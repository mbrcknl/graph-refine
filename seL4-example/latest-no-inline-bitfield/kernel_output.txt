
---------------------------------------------------------------------
       HOL-4 [Kananaskis 13 (stdknl, built Tue Jun 16 16:11:50 2020)]

       For introductory HOL help, type: help "hol";
       To exit type <Control>-D
---------------------------------------------------------------------
** Load path (see loadPath variable) now contains 18 entries
** after consulting Holmakefiles

[In non-standard heap: /home/matthewb/verification/bv/HOL4/examples/machine-code/graph/local-hol-heap]
> > 
Resetting specifications database.

Specializing fetch: 4 -> 1(1)
Specializing decode ARM (cond = 14): 95 -> 95(95)
Specializing decode ARM (cond = 15): 5 -> 5(5)
Specializing decode ARM (cond not in {14, 15}): 95 -> 95(95)
Specializing decode ARM (fallback): 1 -> 1(1)
Specializing eval: 374 -> 348(348)
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
val it = (): unit
> ======================================================================
  Base name: /home/matthewb/verification/bv/graph-refine-master/seL4-example/target/RISCV64-O1/kernel
  Poly/ML: 580
  HOL: Kananaskis 13 (stdknl) commit 08998e3c2
======================================================================
  Reading /home/matthewb/verification/bv/graph-refine-master/seL4-example/target/RISCV64-O1/kernel.elf.txt, done.
  Reading /home/matthewb/verification/bv/graph-refine-master/seL4-example/target/RISCV64-O1/kernel.elf.txt, done.
  Reading /home/matthewb/verification/bv/graph-refine-master/seL4-example/target/RISCV64-O1/kernel.sigs, done.
No signature info for section: _start
No signature info for section: avail_p_regs
No signature info for section: ndks_boot
No signature info for section: rootserver
No signature info for section: rootserver_mem
No signature info for section: avail_reg
No signature info for section: res_reg
No signature info for section: trap_entry
No signature info for section: syscall
No signature info for section: exception
No signature info for section: interrupt
No signature info for section: __clzsi2
No signature info for section: __ctzsi2
No signature info for section: __clzdi2
No signature info for section: __ctzdi2
======================================================================
  Total: 432 functions, 14393 RISC-V instructions
  Longest function: decodeRISCVMMUInvocation (769 instructions)
  0 deps: 226 functions (avail_p_regs, ndks_boot, rootserver, ...)
  1 deps: 54 functions (str_to_long, memset, ...)
  2 deps: 30 functions (invokeTCB_NotificationControl, ...)
  3 deps: 26 functions (c_handle_syscall, slowpath, ...)
  4 deps: 25 functions (invokeTCB_ReadRegisters, ...)
  5 deps: 12 functions (decodeSetSchedParams, ...)
  6 deps: 12 functions (decodeSetIPCBuffer, ...)
  7 deps: 9 functions (performPageTableInvocationUnmap, ...)
  8 deps: 6 functions (setMRs_syscall_error, ...)
  9 deps: 3 functions (invokeUntyped_Retype, decodeSetSpace, ...)
  11 deps: 7 functions (handleSyscall, sendFaultIPC, cteDelete, ...)
  12 deps: 3 functions (handleRecv, cancelBadgedSends, cteInsert)
  13 deps: 3 functions (handleInvocation, doNormalTransfer, ...)
  14 deps: 2 functions (decodeUntypedInvocation, sendSignal)
  15 deps: 2 functions (sameRegionAs, setMRs_fault)
  16 deps: 1 functions (decodeTCBInvocation)
  17 deps: 2 functions (finaliseCap, Arch_finaliseCap)
  18 deps: 1 functions (decodeCNodeInvocation)
  19 deps: 1 functions (sendIPC)
  21 deps: 1 functions (maskCapRights)
  23 deps: 2 functions (fastpath_call, receiveIPC)
  25 deps: 2 functions (fastpath_reply_recv, decodeInvocation)
  29 deps: 1 functions (init_kernel)
  44 deps: 1 functions (decodeRISCVMMUInvocation)
======================================================================

Section avail_p_regs (1 of 432)
===============================

Deriving specifications
-----------------------

Section `avail_p_regs` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `avail_p_regs` has 0 nodes.

Section ndks_boot (2 of 432)
============================

Deriving specifications
-----------------------

Section `ndks_boot` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `ndks_boot` has 0 nodes.

Section rootserver (3 of 432)
=============================

Deriving specifications
-----------------------

Section `rootserver` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `rootserver` has 0 nodes.

Section rootserver_mem (4 of 432)
=================================

Deriving specifications
-----------------------

Section `rootserver_mem` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `rootserver_mem` has 0 nodes.

Section avail_reg (5 of 432)
============================

Deriving specifications
-----------------------

Section `avail_reg` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `avail_reg` has 0 nodes.

Section res_reg (6 of 432)
==========================

Deriving specifications
-----------------------

Section `res_reg` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `res_reg` has 0 nodes.

Section __ctzdi2 (7 of 432)
===========================

Deriving specifications
-----------------------

Section `__ctzdi2` consists of 13 instructions.

RVC_TFFFFT___FT___TF..
ANDI..
RVC_TTT___________FT.
RVC_FTF___________FT.
ADDI..
RVC_TFF_FF________FT.
RVC_FFT___________FT.
BNE..
RVC_TFFFFFFFTFFFFFTF.

Stack analysis
---------------

No stack accesses found. Code for `__ctzdi2`:

    0x84017f20     0x0    mv a5,a0
    0x84017f22     0x2    andi a4,a0,1
    0x84017f26     0x6    bnez a4,ffffffff84017f3e <__ctzdi2+0x1e>
    0x84017f28     0x8    li a0,0
    0x84017f2a     0xa    li a3,65
    0x84017f2e     0xe    srli a5,a5,0x1
    0x84017f30    0x10    addiw a0,a0,1
    0x84017f32    0x12    andi a4,a5,1
    0x84017f36    0x16    bnez a4,ffffffff84017f40 <__ctzdi2+0x20>
    0x84017f38    0x18    bne a0,a3,ffffffff84017f2e <__ctzdi2+0xe>
    0x84017f3c    0x1c    ret
    0x84017f3e    0x1e    li a0,0
    0x84017f40    0x20    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `__ctzdi2` has 21 nodes.

Section __clzdi2 (8 of 432)
===========================

Deriving specifications
-----------------------

Section `__clzdi2` consists of 11 instructions.

BLT..
RVC_FFF___________TF.

Stack analysis
---------------

No stack accesses found. Code for `__clzdi2`:

    0x84017f02     0x0    mv a5,a0
    0x84017f04     0x2    bltz a0,ffffffff84017f1c <__clzdi2+0x1a>
    0x84017f08     0x6    li a0,0
    0x84017f0a     0x8    li a4,65
    0x84017f0e     0xc    slli a5,a5,0x1
    0x84017f10     0xe    addiw a0,a0,1
    0x84017f12    0x10    bltz a5,ffffffff84017f1e <__clzdi2+0x1c>
    0x84017f16    0x14    bne a0,a4,ffffffff84017f0e <__clzdi2+0xc>
    0x84017f1a    0x18    ret
    0x84017f1c    0x1a    li a0,0
    0x84017f1e    0x1c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `__clzdi2` has 19 nodes.

Section __ctzsi2 (9 of 432)
===========================

Deriving specifications
-----------------------

Section `__ctzsi2` consists of 13 instructions.

RVC_TFF_TF________FT.
SRLIW..
ADDIW..

Stack analysis
---------------

No stack accesses found. Code for `__ctzsi2`:

    0x84017ee0     0x0    mv a4,a0
    0x84017ee2     0x2    andi a0,a0,1
    0x84017ee4     0x4    bnez a0,ffffffff84017efe <__ctzsi2+0x1e>
    0x84017ee6     0x6    li a3,33
    0x84017eea     0xa    srliw a5,a4,0x1
    0x84017eee     0xe    sext.w a4,a5
    0x84017ef2    0x12    addiw a0,a0,1
    0x84017ef4    0x14    andi a5,a5,1
    0x84017ef6    0x16    bnez a5,ffffffff84017f00 <__ctzsi2+0x20>
    0x84017ef8    0x18    bne a0,a3,ffffffff84017eea <__ctzsi2+0xa>
    0x84017efc    0x1c    ret
    0x84017efe    0x1e    li a0,0
    0x84017f00    0x20    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `__ctzsi2` has 21 nodes.

Section __clzsi2 (10 of 432)
============================

Deriving specifications
-----------------------

Section `__clzsi2` consists of 13 instructions.

SLLIW..
SLLI..

Stack analysis
---------------

No stack accesses found. Code for `__clzsi2`:

    0x84017eb8     0x0    mv a4,a0
    0x84017eba     0x2    bltz a0,ffffffff84017edc <__clzsi2+0x24>
    0x84017ebe     0x6    li a0,0
    0x84017ec0     0x8    li a3,34
    0x84017ec4     0xc    slliw a5,a4,0x1
    0x84017ec8    0x10    sext.w a4,a5
    0x84017ecc    0x14    addiw a0,a0,1
    0x84017ece    0x16    slli a2,a5,0x20
    0x84017ed2    0x1a    bltz a2,ffffffff84017ede <__clzsi2+0x26>
    0x84017ed6    0x1e    bne a0,a3,ffffffff84017ec4 <__clzsi2+0xc>
    0x84017eda    0x22    ret
    0x84017edc    0x24    li a0,0
    0x84017ede    0x26    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `__clzsi2` has 21 nodes.

Section char_to_long (11 of 432)
================================

Deriving specifications
-----------------------

Section `char_to_long` consists of 20 instructions.

BGEU..
BLTU..

Stack analysis
---------------

No stack accesses found. Code for `char_to_long`:

    0x84017e04     0x0    addiw a5,a0,-48
    0x84017e08     0x4    andi a5,a5,255
    0x84017e0c     0x8    li a4,9
    0x84017e0e     0xa    bgeu a4,a5,ffffffff84017e34 <char_to_long+0x30>
    0x84017e12     0xe    addiw a5,a0,-65
    0x84017e16    0x12    andi a5,a5,255
    0x84017e1a    0x16    li a4,5
    0x84017e1c    0x18    bgeu a4,a5,ffffffff84017e3a <char_to_long+0x36>
    0x84017e20    0x1c    addiw a5,a0,-97
    0x84017e24    0x20    andi a5,a5,255
    0x84017e28    0x24    li a4,5
    0x84017e2a    0x26    bltu a4,a5,ffffffff84017e40 <char_to_long+0x3c>
    0x84017e2e    0x2a    addiw a0,a0,-87
    0x84017e32    0x2e    ret
    0x84017e34    0x30    addiw a0,a0,-48
    0x84017e38    0x34    ret
    0x84017e3a    0x36    addiw a0,a0,-55
    0x84017e3e    0x3a    ret
    0x84017e40    0x3c    li a0,-1
    0x84017e42    0x3e    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `char_to_long` has 30 nodes.

Section strncmp (12 of 432)
===========================

Deriving specifications
-----------------------

Section `strncmp` consists of 14 instructions.

RVC_TTF___________FT.
RVC_TFFTFT___FT___TF..
LBU..
SUBW.....
RVC_FFFFFT________FT.

Stack analysis
---------------

No stack accesses found. Code for `strncmp`:

    0x84017de0     0x0    beqz a2,ffffffff84017e00 <strncmp+0x20>
    0x84017de2     0x2    mv a5,a0
    0x84017de4     0x4    add a2,a2,a0
    0x84017de6     0x6    lbu a4,0(a5)
    0x84017dea     0xa    lbu a0,0(a1)
    0x84017dee     0xe    subw a0,a4,a0
    0x84017df2    0x12    bnez a0,ffffffff84017e02 <strncmp+0x22>
    0x84017df4    0x14    beqz a4,ffffffff84017e02 <strncmp+0x22>
    0x84017df6    0x16    addi a5,a5,1
    0x84017df8    0x18    addi a1,a1,1
    0x84017dfa    0x1a    bne a5,a2,ffffffff84017de6 <strncmp+0x6>
    0x84017dfe    0x1e    ret
    0x84017e00    0x20    li a0,0
    0x84017e02    0x22    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `strncmp` has 26 nodes.

Section memcpy (13 of 432)
==========================

Deriving specifications
-----------------------

Section `memcpy` consists of 9 instructions.

SB..

Stack analysis
---------------

No stack accesses found. Code for `memcpy`:

    0x84017dc8     0x0    beqz a2,ffffffff84017dde <memcpy+0x16>
    0x84017dca     0x2    add a2,a2,a0
    0x84017dcc     0x4    mv a5,a0
    0x84017dce     0x6    lbu a4,0(a1) # 1000 <KERNEL_OFFSET-0xfffffffefffff000>
    0x84017dd2     0xa    sb a4,0(a5)
    0x84017dd6     0xe    addi a5,a5,1
    0x84017dd8    0x10    addi a1,a1,1
    0x84017dda    0x12    bne a2,a5,ffffffff84017dce <memcpy+0x6>
    0x84017dde    0x16    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `memcpy` has 16 nodes.

Section memzero (14 of 432)
===========================

Deriving specifications
-----------------------

Section `memzero` consists of 7 instructions.

SD..

Stack analysis
---------------

No stack accesses found. Code for `memzero`:

    0x840164dc     0x0    beqz a1,ffffffff840164ec <memzero+0x10>
    0x840164de     0x2    mv a5,a0
    0x840164e0     0x4    add a1,a1,a0
    0x840164e2     0x6    sd zero,0(a5)
    0x840164e6     0xa    addi a5,a5,8
    0x840164e8     0xc    bne a5,a1,ffffffff840164e2 <memzero+0x6>
    0x840164ec    0x10    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `memzero` has 13 nodes.

Section strlcat (15 of 432)
===========================

Deriving specifications
-----------------------

Section `strlcat` consists of 31 instructions.

ADD.....
RVC_TFT___________FT.
SUB.....
RVC_TFFFFT___T____TF.

Stack analysis
---------------

No stack accesses found. Code for `strlcat`:

    0x84016482     0x0    mv a3,a0
    0x84016484     0x2    li a0,0
    0x84016486     0x4    beqz a2,ffffffff8401649a <strlcat+0x18>
    0x84016488     0x6    add a5,a3,a0
    0x8401648c     0xa    lbu a5,0(a5)
    0x84016490     0xe    beqz a5,ffffffff8401649e <strlcat+0x1c>
    0x84016492    0x10    addi a0,a0,1
    0x84016494    0x12    bne a2,a0,ffffffff84016488 <strlcat+0x6>
    0x84016498    0x16    j ffffffff840164d6 <strlcat+0x54>
    0x8401649a    0x18    mv a0,a2
    0x8401649c    0x1a    ret
    0x8401649e    0x1c    bgeu a0,a2,ffffffff840164d6 <strlcat+0x54>
    0x840164a2    0x20    addi a5,a0,1
    0x840164a6    0x24    bgeu a5,a2,ffffffff840164d0 <strlcat+0x4e>
    0x840164aa    0x28    addi a6,a5,-1
    0x840164ae    0x2c    sub a4,a5,a0
    0x840164b2    0x30    add a4,a4,a1
    0x840164b4    0x32    lbu a4,-1(a4)
    0x840164b8    0x36    beqz a4,ffffffff840164ce <strlcat+0x4c>
    0x840164ba    0x38    add a6,a3,a5
    0x840164be    0x3c    sb a4,-1(a6)
    0x840164c2    0x40    addi a4,a5,1
    0x840164c6    0x44    bgeu a4,a2,ffffffff840164d8 <strlcat+0x56>
    0x840164ca    0x48    mv a5,a4
    0x840164cc    0x4a    j ffffffff840164aa <strlcat+0x28>
    0x840164ce    0x4c    mv a0,a6
    0x840164d0    0x4e    add a3,a3,a0
    0x840164d2    0x50    sb zero,0(a3)
    0x840164d6    0x54    ret
    0x840164d8    0x56    mv a0,a5
    0x840164da    0x58    j ffffffff840164d0 <strlcat+0x4e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
31 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `strlcat` has 51 nodes.

Section strlcpy (16 of 432)
===========================

Deriving specifications
-----------------------

Section `strlcpy` consists of 19 instructions.

RVC_FFFT__________FT.

Stack analysis
---------------

No stack accesses found. Code for `strlcpy`:

    0x84016450     0x0    mv a3,a0
    0x84016452     0x2    li a5,1
    0x84016454     0x4    bgeu a5,a2,ffffffff8401647e <strlcpy+0x2e>
    0x84016458     0x8    addi a2,a2,-1
    0x8401645a     0xa    li a5,0
    0x8401645c     0xc    mv a0,a5
    0x8401645e     0xe    addi a5,a5,1
    0x84016460    0x10    add a4,a1,a0
    0x84016464    0x14    lbu a4,0(a4)
    0x84016468    0x18    beqz a4,ffffffff84016476 <strlcpy+0x26>
    0x8401646a    0x1a    add a0,a0,a3
    0x8401646c    0x1c    sb a4,0(a0)
    0x84016470    0x20    bne a5,a2,ffffffff8401645c <strlcpy+0xc>
    0x84016474    0x24    mv a0,a5
    0x84016476    0x26    add a3,a3,a0
    0x84016478    0x28    sb zero,0(a3)
    0x8401647c    0x2c    ret
    0x8401647e    0x2e    li a0,0
    0x84016480    0x30    j ffffffff84016476 <strlcpy+0x26>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
19 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `strlcpy` has 29 nodes.

Section strnlen (17 of 432)
===========================

Deriving specifications
-----------------------

Section `strnlen` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `strnlen`:

    0x84016434     0x0    mv a4,a0
    0x84016436     0x2    li a0,0
    0x84016438     0x4    beqz a1,ffffffff8401644c <strnlen+0x18>
    0x8401643a     0x6    add a5,a4,a0
    0x8401643e     0xa    lbu a5,0(a5)
    0x84016442     0xe    beqz a5,ffffffff8401644a <strnlen+0x16>
    0x84016444    0x10    addi a0,a0,1
    0x84016446    0x12    bne a1,a0,ffffffff8401643a <strnlen+0x6>
    0x8401644a    0x16    ret
    0x8401644c    0x18    mv a0,a1
    0x8401644e    0x1a    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `strnlen` has 20 nodes.

Section copyMRs (18 of 432)
===========================

Deriving specifications
-----------------------

Section `copyMRs` consists of 46 instructions.

RVC_FTT___________FF..
RVC_TTT___________FF..
LD..

Stack analysis
---------------

No stack accesses found. Code for `copyMRs`:

    0x84014a0e     0x0    mv a5,a0
    0x84014a10     0x2    mv a0,a4
    0x84014a12     0x4    beqz a4,ffffffff84014a6e <copyMRs+0x60>
    0x84014a14     0x6    ld a4,88(a5)
    0x84014a16     0x8    sd a4,88(a2)
    0x84014a18     0xa    li a4,1
    0x84014a1a     0xc    bgeu a4,a0,ffffffff84014a62 <copyMRs+0x54>
    0x84014a1e    0x10    ld a4,96(a5)
    0x84014a20    0x12    sd a4,96(a2)
    0x84014a22    0x14    li a4,2
    0x84014a24    0x16    bgeu a4,a0,ffffffff84014a66 <copyMRs+0x58>
    0x84014a28    0x1a    ld a4,104(a5)
    0x84014a2a    0x1c    sd a4,104(a2)
    0x84014a2c    0x1e    li a4,3
    0x84014a2e    0x20    bgeu a4,a0,ffffffff84014a6a <copyMRs+0x5c>
    0x84014a32    0x24    ld a5,112(a5)
    0x84014a34    0x26    sd a5,112(a2)
    0x84014a36    0x28    li a5,4
    0x84014a38    0x2a    beqz a3,ffffffff84014a72 <copyMRs+0x64>
    0x84014a3a    0x2c    beqz a1,ffffffff84014a76 <copyMRs+0x68>
    0x84014a3c    0x2e    bgeu a5,a0,ffffffff84014a7a <copyMRs+0x6c>
    0x84014a40    0x32    addi a5,a5,1
    0x84014a42    0x34    slli a5,a5,0x3
    0x84014a44    0x36    addi a4,a0,1
    0x84014a48    0x3a    slli a4,a4,0x3
    0x84014a4a    0x3c    add a2,a1,a5
    0x84014a4e    0x40    ld a6,0(a2)
    0x84014a52    0x44    add a2,a3,a5
    0x84014a56    0x48    sd a6,0(a2)
    0x84014a5a    0x4c    addi a5,a5,8
    0x84014a5c    0x4e    bne a5,a4,ffffffff84014a4a <copyMRs+0x3c>
    0x84014a60    0x52    ret
    0x84014a62    0x54    li a5,1
    0x84014a64    0x56    j ffffffff84014a38 <copyMRs+0x2a>
    0x84014a66    0x58    li a5,2
    0x84014a68    0x5a    j ffffffff84014a38 <copyMRs+0x2a>
    0x84014a6a    0x5c    li a5,3
    0x84014a6c    0x5e    j ffffffff84014a38 <copyMRs+0x2a>
    0x84014a6e    0x60    mv a5,a4
    0x84014a70    0x62    j ffffffff84014a38 <copyMRs+0x2a>
    0x84014a72    0x64    mv a0,a5
    0x84014a74    0x66    ret
    0x84014a76    0x68    mv a0,a5
    0x84014a78    0x6a    ret
    0x84014a7a    0x6c    mv a0,a5
    0x84014a7c    0x6e    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
46 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `copyMRs` has 76 nodes.

Section setExtraBadge (19 of 432)
=================================

Deriving specifications
-----------------------

Section `setExtraBadge` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setExtraBadge`:

    0x84014906    0x0    addi a2,a2,122
    0x8401490a    0x4    slli a2,a2,0x3
    0x8401490c    0x6    add a2,a2,a0
    0x8401490e    0x8    sd a1,0(a2)
    0x84014910    0xa    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setExtraBadge` has 7 nodes.

Section getExtraCPtr (20 of 432)
================================

Deriving specifications
-----------------------

Section `getExtraCPtr` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `getExtraCPtr`:

    0x840148fa    0x0    addi a1,a1,122
    0x840148fe    0x4    slli a1,a1,0x3
    0x84014900    0x6    add a1,a1,a0
    0x84014902    0x8    ld a0,0(a1)
    0x84014904    0xa    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getExtraCPtr` has 7 nodes.

Section tcbEPDequeue (21 of 432)
================================

Deriving specifications
-----------------------

Section `tcbEPDequeue` consists of 19 instructions.

RVC_TTT___________TF..
RVC_FTT_FT________TF.
RVC_FTTFFFFTFFFFFTFT.

Stack analysis
---------------

2 stack accesses found. Annotated code for `tcbEPDequeue`:

    0x840138b6     0x0    addi sp,sp,-32
    0x840138b8     0x2    mv a5,a0
    0x840138ba     0x4    sd a1,0(sp)           ; stack access
    0x840138bc     0x6    mv a1,a2
    0x840138be     0x8    ld a4,416(a0)
    0x840138c2     0xc    beqz a4,ffffffff840138e0 <tcbEPDequeue+0x2a>
    0x840138c4     0xe    ld a0,0(sp)           ; stack access
    0x840138c6    0x10    ld a3,408(a5)
    0x840138ca    0x14    sd a3,408(a4)
    0x840138ce    0x18    ld a4,408(a5)
    0x840138d2    0x1c    beqz a4,ffffffff840138e6 <tcbEPDequeue+0x30>
    0x840138d4    0x1e    ld a5,416(a5)
    0x840138d8    0x22    sd a5,416(a4)
    0x840138dc    0x26    addi sp,sp,32
    0x840138de    0x28    ret
    0x840138e0    0x2a    ld a0,408(a0)
    0x840138e4    0x2e    j ffffffff840138ce <tcbEPDequeue+0x18>
    0x840138e6    0x30    ld a1,416(a5)
    0x840138ea    0x34    j ffffffff840138dc <tcbEPDequeue+0x26>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
19 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbEPDequeue` has 34 nodes.

Section tcbEPAppend (22 of 432)
===============================

Deriving specifications
-----------------------

Section `tcbEPAppend` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `tcbEPAppend`:

    0x8401389c     0x0    addi sp,sp,-32
    0x8401389e     0x2    mv a5,a0
    0x840138a0     0x4    beqz a1,ffffffff840138a8 <tcbEPAppend+0xc>
    0x840138a2     0x6    mv a0,a1
    0x840138a4     0x8    sd a5,408(a2)
    0x840138a8     0xc    sd a2,416(a5)
    0x840138ac    0x10    sd zero,408(a5)
    0x840138b0    0x14    mv a1,a5
    0x840138b2    0x16    addi sp,sp,32
    0x840138b4    0x18    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbEPAppend` has 16 nodes.

Section setIRQState (23 of 432)
===============================

Deriving specifications
-----------------------

Section `setIRQState` consists of 35 instructions.

AUIPC.
BEQ..
LUI.
RVC_FTF___________FF..
SLL.....
XORI..
RVC_TFFFTT___TT___FT..
RVC_TTF___________FF..
Skipping 1047b7f3 csrrc a5,sie,a5

Skipping 1047a7f3 csrrs a5,sie,a5

RVC_TFFFTT___TF___FT..

Stack analysis
---------------

No stack accesses found. Code for `setIRQState`:

    0x8401233c     0x0    slli a4,a1,0x3
    0x84012340     0x4    auipc a5,0xc
    0x84012344     0x8    addi a5,a5,-1704 # ffffffff8401dc98 <intStateIRQTable>
    0x84012348     0xc    add a5,a5,a4
    0x8401234a     0xe    sd a0,0(a5)
    0x8401234c    0x10    li a5,54
    0x84012350    0x14    beq a1,a5,ffffffff84012380 <setIRQState+0x44>
    0x84012354    0x18    andi a3,a1,31
    0x84012358    0x1c    srli a1,a1,0x5
    0x8401235a    0x1e    slli a1,a1,0x2
    0x8401235c    0x20    lui a4,0xcc002
    0x84012360    0x24    addi a4,a4,256 # ffffffffcc002100 <ki_end+0x47fd3100>
    0x84012364    0x28    add a1,a1,a4
    0x84012366    0x2a    lw a5,0(a1)
    0x84012368    0x2c    sext.w a4,a5
    0x8401236c    0x30    bnez a0,ffffffff84012396 <setIRQState+0x5a>
    0x8401236e    0x32    li a5,1
    0x84012370    0x34    sll a5,a5,a3
    0x84012374    0x38    not a5,a5
    0x84012378    0x3c    and a5,a5,a4
    0x8401237a    0x3e    sext.w a5,a5
    0x8401237c    0x40    sw a5,0(a1)
    0x8401237e    0x42    ret
    0x84012380    0x44    bnez a0,ffffffff8401238c <setIRQState+0x50>
    0x84012382    0x46    li a5,32
    0x84012386    0x4a    csrrc a5,sie,a5
    0x8401238a    0x4e    ret
    0x8401238c    0x50    li a5,32
    0x84012390    0x54    csrrs a5,sie,a5
    0x84012394    0x58    ret
    0x84012396    0x5a    li a5,1
    0x84012398    0x5c    sll a5,a5,a3
    0x8401239c    0x60    or a5,a5,a4
    0x8401239e    0x62    sext.w a5,a5
    0x840123a0    0x64    j ffffffff8401237c <setIRQState+0x40>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
35 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setIRQState` has 49 nodes.

Section isIRQActive (24 of 432)
===============================

Deriving specifications
-----------------------

Section `isIRQActive` consists of 7 instructions.

SLTU.....

Stack analysis
---------------

No stack accesses found. Code for `isIRQActive`:

    0x84012326     0x0    slli a5,a0,0x3
    0x8401232a     0x4    auipc a0,0xc
    0x8401232e     0x8    addi a0,a0,-1682 # ffffffff8401dc98 <intStateIRQTable>
    0x84012332     0xc    add a0,a0,a5
    0x84012334     0xe    ld a0,0(a0)
    0x84012336    0x10    snez a0,a0
    0x8401233a    0x14    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isIRQActive` has 9 nodes.

Section invokeIRQHandler_AckIRQ (25 of 432)
===========================================

Deriving specifications
-----------------------

Section `invokeIRQHandler_AckIRQ` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `invokeIRQHandler_AckIRQ`:

    0x8401231c    0x0    sext.w a0,a0
    0x8401231e    0x2    lui a5,0xcc202
    0x84012322    0x6    sw a0,4(a5)
    0x84012324    0x8    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeIRQHandler_AckIRQ` has 6 nodes.

Section loadCapTransfer (26 of 432)
===================================

Deriving specifications
-----------------------

Section `loadCapTransfer` consists of 7 instructions.


Stack analysis
---------------

Section `loadCapTransfer` expects pointer to stack in a0.
3 stack accesses found. Annotated code for `loadCapTransfer`:

    0x840122e6     0x0    ld a3,1008(a1)
    0x840122ea     0x4    ld a4,1016(a1)
    0x840122ee     0x8    ld a2,1000(a1)
    0x840122f2     0xc    sd a2,0(a0)           ; stack access
    0x840122f4     0xe    sd a3,8(a0)           ; stack access
    0x840122f6    0x10    sd a4,16(a0)          ; stack access
    0x840122f8    0x12    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `loadCapTransfer` has 14 nodes.

Section preemptionPoint (27 of 432)
===================================

Deriving specifications
-----------------------

Section `preemptionPoint` consists of 17 instructions.

Skipping 14402573 csrr a0,sip


Stack analysis
---------------

No stack accesses found. Code for `preemptionPoint`:

    0x84011e20     0x0    auipc a5,0x1d
    0x84011e24     0x4    ld a5,-1040(a5) # ffffffff8402ea10 <ksWorkUnitsCompleted>
    0x84011e28     0x8    addi a5,a5,1
    0x84011e2a     0xa    li a4,99
    0x84011e2e     0xe    bltu a4,a5,ffffffff84011e3e <preemptionPoint+0x1e>
    0x84011e32    0x12    auipc a4,0x1d
    0x84011e36    0x16    sd a5,-1058(a4) # ffffffff8402ea10 <ksWorkUnitsCompleted>
    0x84011e3a    0x1a    li a0,0
    0x84011e3c    0x1c    ret
    0x84011e3e    0x1e    auipc a5,0x1d
    0x84011e42    0x22    sd zero,-1070(a5) # ffffffff8402ea10 <ksWorkUnitsCompleted>
    0x84011e46    0x26    csrr a0,sip
    0x84011e4a    0x2a    andi a0,a0,544
    0x84011e4e    0x2e    bnez a0,ffffffff84011e52 <preemptionPoint+0x32>
    0x84011e50    0x30    ret
    0x84011e52    0x32    li a0,4
    0x84011e54    0x34    j ffffffff84011e50 <preemptionPoint+0x30>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `preemptionPoint` has 27 nodes.

Section setMCPriority (28 of 432)
=================================

Deriving specifications
-----------------------

Section `setMCPriority` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setMCPriority`:

    0x84011e1a    0x0    sd a1,352(a0)
    0x84011e1e    0x4    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setMCPriority` has 4 nodes.

Section doNBRecvFailedTransfer (29 of 432)
==========================================

Deriving specifications
-----------------------

Section `doNBRecvFailedTransfer` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `doNBRecvFailedTransfer`:

    0x84011df6    0x0    sd zero,72(a0)
    0x84011dfa    0x4    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doNBRecvFailedTransfer` has 4 nodes.

Section Arch_performTransfer (30 of 432)
========================================

Deriving specifications
-----------------------

Section `Arch_performTransfer` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_performTransfer`:

    0x84011a90    0x0    li a0,0
    0x84011a92    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_performTransfer` has 3 nodes.

Section Arch_decodeTransfer (31 of 432)
=======================================

Deriving specifications
-----------------------

Section `Arch_decodeTransfer` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_decodeTransfer`:

    0x84011a8c    0x0    li a0,0
    0x84011a8e    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_decodeTransfer` has 3 nodes.

Section Arch_isFrameType (32 of 432)
====================================

Deriving specifications
-----------------------

Section `Arch_isFrameType` consists of 3 instructions.

SLTIU..

Stack analysis
---------------

No stack accesses found. Code for `Arch_isFrameType`:

    0x84011a84    0x0    addi a0,a0,-5
    0x84011a86    0x2    sltiu a0,a0,3
    0x84011a8a    0x6    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_isFrameType` has 4 nodes.

Section Arch_prepareThreadDelete (33 of 432)
============================================

Deriving specifications
-----------------------

Section `Arch_prepareThreadDelete` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_prepareThreadDelete`:

    0x84011a82    0x0    ret

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_prepareThreadDelete` has 2 nodes.

Section Arch_updateCapData (34 of 432)
======================================

Deriving specifications
-----------------------

Section `Arch_updateCapData` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_updateCapData`:

    0x840116bc    0x0    addi sp,sp,-32
    0x840116be    0x2    mv a0,a2
    0x840116c0    0x4    mv a1,a3
    0x840116c2    0x6    addi sp,sp,32
    0x840116c4    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_updateCapData` has 6 nodes.

Section Arch_checkIRQ (35 of 432)
=================================

Deriving specifications
-----------------------

Section `Arch_checkIRQ` consists of 15 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_checkIRQ`:

    0x84011602     0x0    addi a0,a0,-1
    0x84011604     0x2    li a5,53
    0x84011608     0x6    bltu a5,a0,ffffffff84011610 <Arch_checkIRQ+0xe>
    0x8401160c     0xa    li a0,0
    0x8401160e     0xc    ret
    0x84011610     0xe    auipc a5,0xc
    0x84011614    0x12    addi a5,a5,1592 # ffffffff8401dc48 <current_syscall_error>
    0x84011618    0x16    li a4,4
    0x8401161a    0x18    sd a4,48(a5)
    0x8401161c    0x1a    li a4,1
    0x8401161e    0x1c    sd a4,16(a5)
    0x84011620    0x1e    li a4,54
    0x84011624    0x22    sd a4,24(a5)
    0x84011626    0x24    li a0,3
    0x84011628    0x26    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_checkIRQ` has 22 nodes.

Section plat_cleanInvalidateL2Range (36 of 432)
===============================================

Deriving specifications
-----------------------

Section `plat_cleanInvalidateL2Range` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `plat_cleanInvalidateL2Range`:

    0x84011600    0x0    ret

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `plat_cleanInvalidateL2Range` has 2 nodes.

Section plat_invalidateL2Range (37 of 432)
==========================================

Deriving specifications
-----------------------

Section `plat_invalidateL2Range` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `plat_invalidateL2Range`:

    0x840115fe    0x0    ret

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `plat_invalidateL2Range` has 2 nodes.

Section plat_cleanL2Range (38 of 432)
=====================================

Deriving specifications
-----------------------

Section `plat_cleanL2Range` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `plat_cleanL2Range`:

    0x840115fc    0x0    ret

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `plat_cleanL2Range` has 2 nodes.

Section setIRQTrigger (39 of 432)
=================================

Deriving specifications
-----------------------

Section `setIRQTrigger` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setIRQTrigger`:

    0x840115fa    0x0    ret

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setIRQTrigger` has 2 nodes.

Section setNextPC (40 of 432)
=============================

Deriving specifications
-----------------------

Section `setNextPC` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setNextPC`:

    0x840115f4    0x0    sd a1,272(a0)
    0x840115f8    0x4    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setNextPC` has 4 nodes.

Section getRestartPC (41 of 432)
================================

Deriving specifications
-----------------------

Section `getRestartPC` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `getRestartPC`:

    0x840115ee    0x0    ld a0,264(a0)
    0x840115f2    0x4    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getRestartPC` has 4 nodes.

Section performPageInvocationMapPTE (42 of 432)
===============================================

Deriving specifications
-----------------------

Section `performPageInvocationMapPTE` consists of 10 instructions.

Skipping 12000073 sfence.vma

RVC_FFFFFFFT______FT.

Stack analysis
---------------

2 stack accesses found. Annotated code for `performPageInvocationMapPTE`:

    0x84011570     0x0    addi sp,sp,-16
    0x84011572     0x2    sd a0,0(sp)           ; stack access
    0x84011574     0x4    sd a1,8(sp)           ; stack access
    0x84011576     0x6    sd a0,0(a2)
    0x84011578     0x8    sd a1,8(a2)
    0x8401157a     0xa    sd a3,0(a4)
    0x8401157c     0xc    sfence.vma
    0x84011580    0x10    li a0,0
    0x84011582    0x12    addi sp,sp,16
    0x84011584    0x14    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performPageInvocationMapPTE` has 17 nodes.

Section performPageTableInvocationMap (43 of 432)
=================================================

Deriving specifications
-----------------------

Section `performPageTableInvocationMap` consists of 10 instructions.

Skipping 12000073 sfence.vma


Stack analysis
---------------

2 stack accesses found. Annotated code for `performPageTableInvocationMap`:

    0x8401155a     0x0    addi sp,sp,-16
    0x8401155c     0x2    sd a0,0(sp)           ; stack access
    0x8401155e     0x4    sd a1,8(sp)           ; stack access
    0x84011560     0x6    sd a0,0(a2)
    0x84011562     0x8    sd a1,8(a2)
    0x84011564     0xa    sd a3,0(a4)
    0x84011566     0xc    sfence.vma
    0x8401156a    0x10    li a0,0
    0x8401156c    0x12    addi sp,sp,16
    0x8401156e    0x14    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performPageTableInvocationMap` has 17 nodes.

Section copyGlobalMappings (44 of 432)
======================================

Deriving specifications
-----------------------

Section `copyGlobalMappings` consists of 13 instructions.

RVC_FTTFFT___FFFFTFT.

Stack analysis
---------------

No stack accesses found. Code for `copyGlobalMappings`:

    0x84010ee8     0x0    auipc a5,0xb
    0x84010eec     0x4    addi a5,a5,-1768 # ffffffff8401b800 <kernel_root_pageTable+0x800>
    0x84010ef0     0x8    lui a4,0x1
    0x84010ef2     0xa    addi a4,a4,-2048 # 800 <KERNEL_OFFSET-0xfffffffefffff800>
    0x84010ef6     0xe    add a4,a4,a0
    0x84010ef8    0x10    auipc a2,0xb
    0x84010efc    0x14    addi a2,a2,264 # ffffffff8401c000 <kernel_root_pageTable+0x1000>
    0x84010f00    0x18    ld a3,0(a5)
    0x84010f02    0x1a    sd a3,0(a4)
    0x84010f04    0x1c    addi a5,a5,8
    0x84010f06    0x1e    addi a4,a4,8
    0x84010f08    0x20    bne a5,a2,ffffffff84010f00 <copyGlobalMappings+0x18>
    0x84010f0c    0x24    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `copyGlobalMappings` has 18 nodes.

Section Arch_postModifyRegisters (45 of 432)
============================================

Deriving specifications
-----------------------

Section `Arch_postModifyRegisters` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_postModifyRegisters`:

    0x84010ee6    0x0    ret

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_postModifyRegisters` has 2 nodes.

Section Arch_activateIdleThread (46 of 432)
===========================================

Deriving specifications
-----------------------

Section `Arch_activateIdleThread` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_activateIdleThread`:

    0x84010ee4    0x0    ret

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_activateIdleThread` has 2 nodes.

Section halt (47 of 432)
========================

Deriving specifications
-----------------------

Section `halt` consists of 5 instructions.

Skipping 00000073 ecall


Stack analysis
---------------

No stack accesses found. Code for `halt`:

    0x84010cec    0x0    li a0,0
    0x84010cee    0x2    li a1,0
    0x84010cf0    0x4    li a2,0
    0x84010cf2    0x6    li a7,8
    0x84010cf4    0x8    ecall

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `halt` has 6 nodes.

Section restore_user_context (48 of 432)
========================================

Deriving specifications
-----------------------

Section `restore_user_context` consists of 41 instructions.

RVC_TFFFFFT__FT___TF.
Skipping 14131073 csrw sepc,t1

Skipping 14029073 csrw sscratch,t0

Skipping 10031073 csrw sstatus,t1

Skipping 10200073 sret


Stack analysis
---------------

No stack accesses found. Code for `restore_user_context`:

    0x84010c4a     0x0    auipc a5,0x1e
    0x84010c4e     0x4    ld a5,-434(a5) # ffffffff8402ea98 <ksCurThread>
    0x84010c52     0x8    mv t0,a5
    0x84010c54     0xa    ld ra,0(t0)
    0x84010c58     0xe    ld sp,8(t0)
    0x84010c5c    0x12    ld gp,16(t0)
    0x84010c60    0x16    ld t2,48(t0)
    0x84010c64    0x1a    ld s0,56(t0)
    0x84010c68    0x1e    ld s1,64(t0)
    0x84010c6c    0x22    ld a0,72(t0)
    0x84010c70    0x26    ld a1,80(t0)
    0x84010c74    0x2a    ld a2,88(t0)
    0x84010c78    0x2e    ld a3,96(t0)
    0x84010c7c    0x32    ld a4,104(t0)
    0x84010c80    0x36    ld a5,112(t0)
    0x84010c84    0x3a    ld a6,120(t0)
    0x84010c88    0x3e    ld a7,128(t0)
    0x84010c8c    0x42    ld s2,136(t0)
    0x84010c90    0x46    ld s3,144(t0)
    0x84010c94    0x4a    ld s4,152(t0)
    0x84010c98    0x4e    ld s5,160(t0)
    0x84010c9c    0x52    ld s6,168(t0)
    0x84010ca0    0x56    ld s7,176(t0)
    0x84010ca4    0x5a    ld s8,184(t0)
    0x84010ca8    0x5e    ld s9,192(t0)
    0x84010cac    0x62    ld s10,200(t0)
    0x84010cb0    0x66    ld s11,208(t0)
    0x84010cb4    0x6a    ld t3,216(t0)
    0x84010cb8    0x6e    ld t4,224(t0)
    0x84010cbc    0x72    ld t5,232(t0)
    0x84010cc0    0x76    ld t6,240(t0)
    0x84010cc4    0x7a    ld t1,24(t0)
    0x84010cc8    0x7e    add tp,t1,zero
    0x84010ccc    0x82    ld t1,272(t0)
    0x84010cd0    0x86    csrw sepc,t1
    0x84010cd4    0x8a    csrw sscratch,t0
    0x84010cd8    0x8e    ld t1,256(t0)
    0x84010cdc    0x92    csrw sstatus,t1
    0x84010ce0    0x96    ld t1,40(t0)
    0x84010ce4    0x9a    ld t0,32(t0)
    0x84010ce8    0x9e    sret

Proving inst theorems
---------------------

41 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `restore_user_context` has 79 nodes.

Section notification_ptr_get_ntfnQueue_tail (49 of 432)
=======================================================

Deriving specifications
-----------------------

Section `notification_ptr_get_ntfnQueue_tail` consists of 7 instructions.

SRLI..
BGE..

Stack analysis
---------------

No stack accesses found. Code for `notification_ptr_get_ntfnQueue_tail`:

    0x84010b56     0x0    ld a5,0(a0)
    0x84010b58     0x2    srli a0,a5,0x19
    0x84010b5c     0x6    bgez a5,ffffffff84010b66 <notification_ptr_get_ntfnQueue_tail+0x10>
    0x84010b60     0xa    li a5,-1
    0x84010b62     0xc    slli a5,a5,0x27
    0x84010b64     0xe    or a0,a0,a5
    0x84010b66    0x10    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `notification_ptr_get_ntfnQueue_tail` has 11 nodes.

Section notification_ptr_get_ntfnQueue_head (50 of 432)
=======================================================

Deriving specifications
-----------------------

Section `notification_ptr_get_ntfnQueue_head` consists of 9 instructions.


Stack analysis
---------------

No stack accesses found. Code for `notification_ptr_get_ntfnQueue_head`:

    0x84010b3e     0x0    ld a5,8(a0)
    0x84010b40     0x2    slli a0,a5,0x19
    0x84010b44     0x6    srli a0,a0,0x19
    0x84010b46     0x8    slli a4,a5,0x19
    0x84010b4a     0xc    bgez a4,ffffffff84010b54 <notification_ptr_get_ntfnQueue_head+0x16>
    0x84010b4e    0x10    li a5,-1
    0x84010b50    0x12    slli a5,a5,0x27
    0x84010b52    0x14    or a0,a0,a5
    0x84010b54    0x16    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `notification_ptr_get_ntfnQueue_head` has 13 nodes.

Section thread_state_ptr_get_blockingObject (51 of 432)
=======================================================

Deriving specifications
-----------------------

Section `thread_state_ptr_get_blockingObject` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `thread_state_ptr_get_blockingObject`:

    0x84010b24     0x0    ld a5,0(a0)
    0x84010b26     0x2    lui a0,0xe0000
    0x84010b2a     0x6    srli a0,a0,0x19
    0x84010b2c     0x8    and a0,a0,a5
    0x84010b2e     0xa    slli a4,a5,0x19
    0x84010b32     0xe    bgez a4,ffffffff84010b3c <thread_state_ptr_get_blockingObject+0x18>
    0x84010b36    0x12    li a5,-1
    0x84010b38    0x14    slli a5,a5,0x27
    0x84010b3a    0x16    or a0,a0,a5
    0x84010b3c    0x18    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `thread_state_ptr_get_blockingObject` has 14 nodes.

Section mdb_node_get_mdbNext (52 of 432)
========================================

Deriving specifications
-----------------------

Section `mdb_node_get_mdbNext` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `mdb_node_get_mdbNext`:

    0x84010b08     0x0    addi sp,sp,-16
    0x84010b0a     0x2    lui a0,0xf8000
    0x84010b0e     0x6    srli a0,a0,0x19
    0x84010b10     0x8    and a0,a0,a1
    0x84010b12     0xa    slli a5,a1,0x19
    0x84010b16     0xe    bgez a5,ffffffff84010b20 <mdb_node_get_mdbNext+0x18>
    0x84010b1a    0x12    li a5,-1
    0x84010b1c    0x14    slli a5,a5,0x27
    0x84010b1e    0x16    or a0,a0,a5
    0x84010b20    0x18    addi sp,sp,16
    0x84010b22    0x1a    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `mdb_node_get_mdbNext` has 14 nodes.

Section endpoint_ptr_get_epQueue_tail (53 of 432)
=================================================

Deriving specifications
-----------------------

Section `endpoint_ptr_get_epQueue_tail` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `endpoint_ptr_get_epQueue_tail`:

    0x84010aee     0x0    ld a5,0(a0)
    0x84010af0     0x2    lui a0,0xf8000
    0x84010af4     0x6    srli a0,a0,0x19
    0x84010af6     0x8    and a0,a0,a5
    0x84010af8     0xa    slli a4,a5,0x19
    0x84010afc     0xe    bgez a4,ffffffff84010b06 <endpoint_ptr_get_epQueue_tail+0x18>
    0x84010b00    0x12    li a5,-1
    0x84010b02    0x14    slli a5,a5,0x27
    0x84010b04    0x16    or a0,a0,a5
    0x84010b06    0x18    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `endpoint_ptr_get_epQueue_tail` has 14 nodes.

Section cap_frame_cap_get_capFMappedAddress (54 of 432)
=======================================================

Deriving specifications
-----------------------

Section `cap_frame_cap_get_capFMappedAddress` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_frame_cap_get_capFMappedAddress`:

    0x84010ad0     0x0    addi sp,sp,-16
    0x84010ad2     0x2    mv a4,a0
    0x84010ad4     0x4    slli a5,a0,0x19
    0x84010ad8     0x8    srli a0,a5,0x19
    0x84010adc     0xc    slli a5,a4,0x19
    0x84010ae0    0x10    bgez a5,ffffffff84010aea <cap_frame_cap_get_capFMappedAddress+0x1a>
    0x84010ae4    0x14    li a5,-1
    0x84010ae6    0x16    slli a5,a5,0x27
    0x84010ae8    0x18    or a0,a0,a5
    0x84010aea    0x1a    addi sp,sp,16
    0x84010aec    0x1c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_frame_cap_get_capFMappedAddress` has 14 nodes.

Section cap_page_table_cap_get_capPTMappedAddress (55 of 432)
=============================================================

Deriving specifications
-----------------------

Section `cap_page_table_cap_get_capPTMappedAddress` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_page_table_cap_get_capPTMappedAddress`:

    0x84010ab2     0x0    addi sp,sp,-16
    0x84010ab4     0x2    mv a4,a0
    0x84010ab6     0x4    slli a5,a0,0x19
    0x84010aba     0x8    srli a0,a5,0x19
    0x84010abe     0xc    slli a5,a4,0x19
    0x84010ac2    0x10    bgez a5,ffffffff84010acc <cap_page_table_cap_get_capPTMappedAddress+0x1a>
    0x84010ac6    0x14    li a5,-1
    0x84010ac8    0x16    slli a5,a5,0x27
    0x84010aca    0x18    or a0,a0,a5
    0x84010acc    0x1a    addi sp,sp,16
    0x84010ace    0x1c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_page_table_cap_get_capPTMappedAddress` has 14 nodes.

Section cap_asid_pool_cap_get_capASIDPool (56 of 432)
=====================================================

Deriving specifications
-----------------------

Section `cap_asid_pool_cap_get_capASIDPool` consists of 12 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_asid_pool_cap_get_capASIDPool`:

    0x84010a92     0x0    addi sp,sp,-16
    0x84010a94     0x2    slli a5,a0,0x2
    0x84010a98     0x6    lui a0,0xf8000
    0x84010a9c     0xa    srli a0,a0,0x19
    0x84010a9e     0xc    and a0,a0,a5
    0x84010aa0     0xe    slli a4,a5,0x19
    0x84010aa4    0x12    bgez a4,ffffffff84010aae <cap_asid_pool_cap_get_capASIDPool+0x1c>
    0x84010aa8    0x16    li a5,-1
    0x84010aaa    0x18    slli a5,a5,0x27
    0x84010aac    0x1a    or a0,a0,a5
    0x84010aae    0x1c    addi sp,sp,16
    0x84010ab0    0x1e    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_asid_pool_cap_get_capASIDPool` has 15 nodes.

Section cap_page_table_cap_get_capPTBasePtr (57 of 432)
=======================================================

Deriving specifications
-----------------------

Section `cap_page_table_cap_get_capPTBasePtr` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_page_table_cap_get_capPTBasePtr`:

    0x84010a76     0x0    addi sp,sp,-16
    0x84010a78     0x2    srli a1,a1,0x9
    0x84010a7a     0x4    slli a0,a1,0x19
    0x84010a7e     0x8    srli a0,a0,0x19
    0x84010a80     0xa    slli a5,a1,0x19
    0x84010a84     0xe    bgez a5,ffffffff84010a8e <cap_page_table_cap_get_capPTBasePtr+0x18>
    0x84010a88    0x12    li a5,-1
    0x84010a8a    0x14    slli a5,a5,0x27
    0x84010a8c    0x16    or a0,a0,a5
    0x84010a8e    0x18    addi sp,sp,16
    0x84010a90    0x1a    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_page_table_cap_get_capPTBasePtr` has 14 nodes.

Section cap_frame_cap_get_capFBasePtr (58 of 432)
=================================================

Deriving specifications
-----------------------

Section `cap_frame_cap_get_capFBasePtr` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_frame_cap_get_capFBasePtr`:

    0x84010a5a     0x0    addi sp,sp,-16
    0x84010a5c     0x2    srli a1,a1,0x9
    0x84010a5e     0x4    slli a0,a1,0x19
    0x84010a62     0x8    srli a0,a0,0x19
    0x84010a64     0xa    slli a5,a1,0x19
    0x84010a68     0xe    bgez a5,ffffffff84010a72 <cap_frame_cap_get_capFBasePtr+0x18>
    0x84010a6c    0x12    li a5,-1
    0x84010a6e    0x14    slli a5,a5,0x27
    0x84010a70    0x16    or a0,a0,a5
    0x84010a72    0x18    addi sp,sp,16
    0x84010a74    0x1a    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_frame_cap_get_capFBasePtr` has 14 nodes.

Section cap_thread_cap_get_capTCBPtr (59 of 432)
================================================

Deriving specifications
-----------------------

Section `cap_thread_cap_get_capTCBPtr` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_thread_cap_get_capTCBPtr`:

    0x84010a3c     0x0    addi sp,sp,-16
    0x84010a3e     0x2    mv a4,a0
    0x84010a40     0x4    slli a5,a0,0x19
    0x84010a44     0x8    srli a0,a5,0x19
    0x84010a48     0xc    slli a5,a4,0x19
    0x84010a4c    0x10    bgez a5,ffffffff84010a56 <cap_thread_cap_get_capTCBPtr+0x1a>
    0x84010a50    0x14    li a5,-1
    0x84010a52    0x16    slli a5,a5,0x27
    0x84010a54    0x18    or a0,a0,a5
    0x84010a56    0x1a    addi sp,sp,16
    0x84010a58    0x1c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_thread_cap_get_capTCBPtr` has 14 nodes.

Section cap_cnode_cap_get_capCNodePtr (60 of 432)
=================================================

Deriving specifications
-----------------------

Section `cap_cnode_cap_get_capCNodePtr` consists of 12 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_cnode_cap_get_capCNodePtr`:

    0x84010a1c     0x0    addi sp,sp,-16
    0x84010a1e     0x2    slli a5,a0,0x1
    0x84010a22     0x6    lui a0,0xfc000
    0x84010a26     0xa    srli a0,a0,0x19
    0x84010a28     0xc    and a0,a0,a5
    0x84010a2a     0xe    slli a4,a5,0x19
    0x84010a2e    0x12    bgez a4,ffffffff84010a38 <cap_cnode_cap_get_capCNodePtr+0x1c>
    0x84010a32    0x16    li a5,-1
    0x84010a34    0x18    slli a5,a5,0x27
    0x84010a36    0x1a    or a0,a0,a5
    0x84010a38    0x1c    addi sp,sp,16
    0x84010a3a    0x1e    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_cnode_cap_get_capCNodePtr` has 15 nodes.

Section cap_endpoint_cap_get_capEPPtr (61 of 432)
=================================================

Deriving specifications
-----------------------

Section `cap_endpoint_cap_get_capEPPtr` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_endpoint_cap_get_capEPPtr`:

    0x840109fe     0x0    addi sp,sp,-16
    0x84010a00     0x2    mv a4,a0
    0x84010a02     0x4    slli a5,a0,0x19
    0x84010a06     0x8    srli a0,a5,0x19
    0x84010a0a     0xc    slli a5,a4,0x19
    0x84010a0e    0x10    bgez a5,ffffffff84010a18 <cap_endpoint_cap_get_capEPPtr+0x1a>
    0x84010a12    0x14    li a5,-1
    0x84010a14    0x16    slli a5,a5,0x27
    0x84010a16    0x18    or a0,a0,a5
    0x84010a18    0x1a    addi sp,sp,16
    0x84010a1a    0x1c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_endpoint_cap_get_capEPPtr` has 14 nodes.

Section cap_untyped_cap_get_capPtr (62 of 432)
==============================================

Deriving specifications
-----------------------

Section `cap_untyped_cap_get_capPtr` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_untyped_cap_get_capPtr`:

    0x840109e0     0x0    addi sp,sp,-16
    0x840109e2     0x2    mv a4,a0
    0x840109e4     0x4    slli a5,a0,0x19
    0x840109e8     0x8    srli a0,a5,0x19
    0x840109ec     0xc    slli a5,a4,0x19
    0x840109f0    0x10    bgez a5,ffffffff840109fa <cap_untyped_cap_get_capPtr+0x1a>
    0x840109f4    0x14    li a5,-1
    0x840109f6    0x16    slli a5,a5,0x27
    0x840109f8    0x18    or a0,a0,a5
    0x840109fa    0x1a    addi sp,sp,16
    0x840109fc    0x1c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_untyped_cap_get_capPtr` has 14 nodes.

Section notification_ptr_get_ntfnBoundTCB (63 of 432)
=====================================================

Deriving specifications
-----------------------

Section `notification_ptr_get_ntfnBoundTCB` consists of 9 instructions.


Stack analysis
---------------

No stack accesses found. Code for `notification_ptr_get_ntfnBoundTCB`:

    0x840109c8     0x0    ld a5,24(a0)
    0x840109ca     0x2    slli a0,a5,0x19
    0x840109ce     0x6    srli a0,a0,0x19
    0x840109d0     0x8    slli a4,a5,0x19
    0x840109d4     0xc    bgez a4,ffffffff840109de <notification_ptr_get_ntfnBoundTCB+0x16>
    0x840109d8    0x10    li a5,-1
    0x840109da    0x12    slli a5,a5,0x27
    0x840109dc    0x14    or a0,a0,a5
    0x840109de    0x16    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `notification_ptr_get_ntfnBoundTCB` has 13 nodes.

Section cap_notification_cap_get_capNtfnPtr (64 of 432)
=======================================================

Deriving specifications
-----------------------

Section `cap_notification_cap_get_capNtfnPtr` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_notification_cap_get_capNtfnPtr`:

    0x840109aa     0x0    addi sp,sp,-16
    0x840109ac     0x2    mv a4,a0
    0x840109ae     0x4    slli a5,a0,0x19
    0x840109b2     0x8    srli a0,a5,0x19
    0x840109b6     0xc    slli a5,a4,0x19
    0x840109ba    0x10    bgez a5,ffffffff840109c4 <cap_notification_cap_get_capNtfnPtr+0x1a>
    0x840109be    0x14    li a5,-1
    0x840109c0    0x16    slli a5,a5,0x27
    0x840109c2    0x18    or a0,a0,a5
    0x840109c4    0x1a    addi sp,sp,16
    0x840109c6    0x1c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_notification_cap_get_capNtfnPtr` has 14 nodes.

Section getNewActiveIRQ (65 of 432)
===================================

Deriving specifications
-----------------------

Section `getNewActiveIRQ` consists of 13 instructions.

Skipping 14402573 csrr a0,sip


Stack analysis
---------------

No stack accesses found. Code for `getNewActiveIRQ`:

    0x84010986     0x0    csrr a0,sip
    0x8401098a     0x4    andi a5,a0,512
    0x8401098e     0x8    bnez a5,ffffffff84010998 <getNewActiveIRQ+0x12>
    0x84010990     0xa    andi a0,a0,32
    0x84010994     0xe    bnez a0,ffffffff840109a4 <getNewActiveIRQ+0x1e>
    0x84010996    0x10    ret
    0x84010998    0x12    lui a5,0xcc202
    0x8401099c    0x16    lw a0,4(a5)
    0x8401099e    0x18    slli a0,a0,0x20
    0x840109a0    0x1a    srli a0,a0,0x20
    0x840109a2    0x1c    ret
    0x840109a4    0x1e    li a0,54
    0x840109a8    0x22    j ffffffff84010996 <getNewActiveIRQ+0x10>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getNewActiveIRQ` has 21 nodes.

Section idle_thread (66 of 432)
===============================

Deriving specifications
-----------------------

Section `idle_thread` consists of 2 instructions.

Skipping 10500073 wfi


Stack analysis
---------------

No stack accesses found. Code for `idle_thread`:

    0x840108f6    0x0    wfi
    0x840108fa    0x4    j ffffffff840108f6 <idle_thread>

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `idle_thread` has 3 nodes.

Section seL4_Fault_VMFault_get_instructionFault (67 of 432)
===========================================================

Deriving specifications
-----------------------

Section `seL4_Fault_VMFault_get_instructionFault` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_Fault_VMFault_get_instructionFault`:

    0x840108ec    0x0    addi sp,sp,-16
    0x840108ee    0x2    srli a0,a0,0x13
    0x840108f0    0x4    andi a0,a0,1
    0x840108f2    0x6    addi sp,sp,16
    0x840108f4    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_Fault_VMFault_get_instructionFault` has 6 nodes.

Section seL4_Fault_VMFault_get_FSR (68 of 432)
==============================================

Deriving specifications
-----------------------

Section `seL4_Fault_VMFault_get_FSR` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_Fault_VMFault_get_FSR`:

    0x840108e2    0x0    addi sp,sp,-16
    0x840108e4    0x2    srliw a0,a0,0x1b
    0x840108e8    0x6    addi sp,sp,16
    0x840108ea    0x8    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_Fault_VMFault_get_FSR` has 5 nodes.

Section seL4_Fault_VMFault_get_address (69 of 432)
==================================================

Deriving specifications
-----------------------

Section `seL4_Fault_VMFault_get_address` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_Fault_VMFault_get_address`:

    0x840108da    0x0    addi sp,sp,-16
    0x840108dc    0x2    mv a0,a1
    0x840108de    0x4    addi sp,sp,16
    0x840108e0    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_Fault_VMFault_get_address` has 5 nodes.

Section seL4_Fault_VMFault_new (70 of 432)
==========================================

Deriving specifications
-----------------------

Section `seL4_Fault_VMFault_new` consists of 14 instructions.

ORI..

Stack analysis
---------------

No stack accesses found. Code for `seL4_Fault_VMFault_new`:

    0x840108ba     0x0    addi sp,sp,-16
    0x840108bc     0x2    mv a5,a0
    0x840108be     0x4    slli a1,a1,0x1b
    0x840108c0     0x6    li a0,-1
    0x840108c2     0x8    srli a0,a0,0x20
    0x840108c4     0xa    and a1,a1,a0
    0x840108c6     0xc    slli a2,a2,0x13
    0x840108c8     0xe    lui a0,0x80
    0x840108cc    0x12    and a2,a2,a0
    0x840108ce    0x14    or a1,a1,a2
    0x840108d0    0x16    ori a0,a1,5
    0x840108d4    0x1a    mv a1,a5
    0x840108d6    0x1c    addi sp,sp,16
    0x840108d8    0x1e    ret

Proving inst theorems
---------------------

14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_Fault_VMFault_new` has 15 nodes.

Section seL4_Fault_UserException_get_code (71 of 432)
=====================================================

Deriving specifications
-----------------------

Section `seL4_Fault_UserException_get_code` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_Fault_UserException_get_code`:

    0x840108b0    0x0    addi sp,sp,-16
    0x840108b2    0x2    srliw a0,a0,0x4
    0x840108b6    0x6    addi sp,sp,16
    0x840108b8    0x8    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_Fault_UserException_get_code` has 5 nodes.

Section seL4_Fault_UserException_get_number (72 of 432)
=======================================================

Deriving specifications
-----------------------

Section `seL4_Fault_UserException_get_number` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_Fault_UserException_get_number`:

    0x840108a8    0x0    addi sp,sp,-16
    0x840108aa    0x2    srli a0,a0,0x20
    0x840108ac    0x4    addi sp,sp,16
    0x840108ae    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_Fault_UserException_get_number` has 5 nodes.

Section seL4_Fault_UserException_new (73 of 432)
================================================

Deriving specifications
-----------------------

Section `seL4_Fault_UserException_new` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_Fault_UserException_new`:

    0x84010890     0x0    addi sp,sp,-16
    0x84010892     0x2    slli a1,a1,0x4
    0x84010894     0x4    li a5,-1
    0x84010896     0x6    srli a5,a5,0x20
    0x84010898     0x8    and a1,a1,a5
    0x8401089a     0xa    slli a0,a0,0x20
    0x8401089c     0xc    or a0,a0,a1
    0x8401089e     0xe    ori a0,a0,3
    0x840108a2    0x12    li a1,0
    0x840108a4    0x14    addi sp,sp,16
    0x840108a6    0x16    ret

Proving inst theorems
---------------------

11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_Fault_UserException_new` has 12 nodes.

Section seL4_Fault_UnknownSyscall_get_syscallNumber (74 of 432)
===============================================================

Deriving specifications
-----------------------

Section `seL4_Fault_UnknownSyscall_get_syscallNumber` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_Fault_UnknownSyscall_get_syscallNumber`:

    0x84010888    0x0    addi sp,sp,-16
    0x8401088a    0x2    mv a0,a1
    0x8401088c    0x4    addi sp,sp,16
    0x8401088e    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_Fault_UnknownSyscall_get_syscallNumber` has 5 nodes.

Section seL4_Fault_UnknownSyscall_new (75 of 432)
=================================================

Deriving specifications
-----------------------

Section `seL4_Fault_UnknownSyscall_new` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_Fault_UnknownSyscall_new`:

    0x8401087e    0x0    addi sp,sp,-16
    0x84010880    0x2    mv a1,a0
    0x84010882    0x4    li a0,2
    0x84010884    0x6    addi sp,sp,16
    0x84010886    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_Fault_UnknownSyscall_new` has 6 nodes.

Section seL4_Fault_CapFault_get_inReceivePhase (76 of 432)
==========================================================

Deriving specifications
-----------------------

Section `seL4_Fault_CapFault_get_inReceivePhase` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_Fault_CapFault_get_inReceivePhase`:

    0x84010876    0x0    addi sp,sp,-16
    0x84010878    0x2    srli a0,a0,0x3f
    0x8401087a    0x4    addi sp,sp,16
    0x8401087c    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_Fault_CapFault_get_inReceivePhase` has 5 nodes.

Section seL4_Fault_CapFault_get_address (77 of 432)
===================================================

Deriving specifications
-----------------------

Section `seL4_Fault_CapFault_get_address` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_Fault_CapFault_get_address`:

    0x8401086e    0x0    addi sp,sp,-16
    0x84010870    0x2    mv a0,a1
    0x84010872    0x4    addi sp,sp,16
    0x84010874    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_Fault_CapFault_get_address` has 5 nodes.

Section seL4_Fault_CapFault_new (78 of 432)
===========================================

Deriving specifications
-----------------------

Section `seL4_Fault_CapFault_new` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_Fault_CapFault_new`:

    0x8401085c     0x0    addi sp,sp,-16
    0x8401085e     0x2    mv a5,a0
    0x84010860     0x4    slli a0,a1,0x3f
    0x84010864     0x8    ori a0,a0,1
    0x84010868     0xc    mv a1,a5
    0x8401086a     0xe    addi sp,sp,16
    0x8401086c    0x10    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_Fault_CapFault_new` has 8 nodes.

Section seL4_Fault_NullFault_new (79 of 432)
============================================

Deriving specifications
-----------------------

Section `seL4_Fault_NullFault_new` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_Fault_NullFault_new`:

    0x84010852    0x0    addi sp,sp,-16
    0x84010854    0x2    li a0,0
    0x84010856    0x4    li a1,0
    0x84010858    0x6    addi sp,sp,16
    0x8401085a    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_Fault_NullFault_new` has 6 nodes.

Section seL4_Fault_get_seL4_FaultType (80 of 432)
=================================================

Deriving specifications
-----------------------

Section `seL4_Fault_get_seL4_FaultType` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_Fault_get_seL4_FaultType`:

    0x8401084a    0x0    addi sp,sp,-16
    0x8401084c    0x2    andi a0,a0,15
    0x8401084e    0x4    addi sp,sp,16
    0x84010850    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_Fault_get_seL4_FaultType` has 5 nodes.

Section lookup_fault_guard_mismatch_get_bitsFound (81 of 432)
=============================================================

Deriving specifications
-----------------------

Section `lookup_fault_guard_mismatch_get_bitsFound` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `lookup_fault_guard_mismatch_get_bitsFound`:

    0x8401083e    0x0    addi sp,sp,-16
    0x84010840    0x2    srli a0,a0,0x2
    0x84010842    0x4    andi a0,a0,127
    0x84010846    0x8    addi sp,sp,16
    0x84010848    0xa    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookup_fault_guard_mismatch_get_bitsFound` has 6 nodes.

Section lookup_fault_guard_mismatch_get_bitsLeft (82 of 432)
============================================================

Deriving specifications
-----------------------

Section `lookup_fault_guard_mismatch_get_bitsLeft` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `lookup_fault_guard_mismatch_get_bitsLeft`:

    0x84010832    0x0    addi sp,sp,-16
    0x84010834    0x2    srli a0,a0,0x9
    0x84010836    0x4    andi a0,a0,127
    0x8401083a    0x8    addi sp,sp,16
    0x8401083c    0xa    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookup_fault_guard_mismatch_get_bitsLeft` has 6 nodes.

Section lookup_fault_guard_mismatch_get_guardFound (83 of 432)
==============================================================

Deriving specifications
-----------------------

Section `lookup_fault_guard_mismatch_get_guardFound` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `lookup_fault_guard_mismatch_get_guardFound`:

    0x8401082a    0x0    addi sp,sp,-16
    0x8401082c    0x2    mv a0,a1
    0x8401082e    0x4    addi sp,sp,16
    0x84010830    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookup_fault_guard_mismatch_get_guardFound` has 5 nodes.

Section lookup_fault_guard_mismatch_new (84 of 432)
===================================================

Deriving specifications
-----------------------

Section `lookup_fault_guard_mismatch_new` consists of 13 instructions.

RVC_FTTFFT___T____FT.

Stack analysis
---------------

No stack accesses found. Code for `lookup_fault_guard_mismatch_new`:

    0x8401080c     0x0    addi sp,sp,-16
    0x8401080e     0x2    mv a5,a0
    0x84010810     0x4    slli a1,a1,0x9
    0x84010812     0x6    lui a0,0x10
    0x84010814     0x8    addi a0,a0,-1
    0x84010816     0xa    and a1,a1,a0
    0x84010818     0xc    slli a2,a2,0x2
    0x8401081a     0xe    andi a2,a2,508
    0x8401081e    0x12    or a1,a1,a2
    0x84010820    0x14    ori a0,a1,3
    0x84010824    0x18    mv a1,a5
    0x84010826    0x1a    addi sp,sp,16
    0x84010828    0x1c    ret

Proving inst theorems
---------------------

13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookup_fault_guard_mismatch_new` has 14 nodes.

Section lookup_fault_depth_mismatch_get_bitsLeft (85 of 432)
============================================================

Deriving specifications
-----------------------

Section `lookup_fault_depth_mismatch_get_bitsLeft` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `lookup_fault_depth_mismatch_get_bitsLeft`:

    0x84010800    0x0    addi sp,sp,-16
    0x84010802    0x2    srli a0,a0,0x2
    0x84010804    0x4    andi a0,a0,127
    0x84010808    0x8    addi sp,sp,16
    0x8401080a    0xa    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookup_fault_depth_mismatch_get_bitsLeft` has 6 nodes.

Section lookup_fault_depth_mismatch_get_bitsFound (86 of 432)
=============================================================

Deriving specifications
-----------------------

Section `lookup_fault_depth_mismatch_get_bitsFound` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `lookup_fault_depth_mismatch_get_bitsFound`:

    0x840107f4    0x0    addi sp,sp,-16
    0x840107f6    0x2    srli a0,a0,0x9
    0x840107f8    0x4    andi a0,a0,127
    0x840107fc    0x8    addi sp,sp,16
    0x840107fe    0xa    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookup_fault_depth_mismatch_get_bitsFound` has 6 nodes.

Section lookup_fault_depth_mismatch_new (87 of 432)
===================================================

Deriving specifications
-----------------------

Section `lookup_fault_depth_mismatch_new` consists of 12 instructions.


Stack analysis
---------------

No stack accesses found. Code for `lookup_fault_depth_mismatch_new`:

    0x840107d8     0x0    addi sp,sp,-16
    0x840107da     0x2    slli a0,a0,0x9
    0x840107dc     0x4    lui a5,0x10
    0x840107de     0x6    addi a5,a5,-1
    0x840107e0     0x8    and a0,a0,a5
    0x840107e2     0xa    slli a1,a1,0x2
    0x840107e4     0xc    andi a1,a1,508
    0x840107e8    0x10    or a0,a0,a1
    0x840107ea    0x12    ori a0,a0,2
    0x840107ee    0x16    li a1,0
    0x840107f0    0x18    addi sp,sp,16
    0x840107f2    0x1a    ret

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookup_fault_depth_mismatch_new` has 13 nodes.

Section lookup_fault_missing_capability_get_bitsLeft (88 of 432)
================================================================

Deriving specifications
-----------------------

Section `lookup_fault_missing_capability_get_bitsLeft` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `lookup_fault_missing_capability_get_bitsLeft`:

    0x840107cc    0x0    addi sp,sp,-16
    0x840107ce    0x2    srli a0,a0,0x2
    0x840107d0    0x4    andi a0,a0,127
    0x840107d4    0x8    addi sp,sp,16
    0x840107d6    0xa    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookup_fault_missing_capability_get_bitsLeft` has 6 nodes.

Section lookup_fault_missing_capability_new (89 of 432)
=======================================================

Deriving specifications
-----------------------

Section `lookup_fault_missing_capability_new` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `lookup_fault_missing_capability_new`:

    0x840107ba     0x0    addi sp,sp,-16
    0x840107bc     0x2    slli a0,a0,0x2
    0x840107be     0x4    andi a0,a0,508
    0x840107c2     0x8    ori a0,a0,1
    0x840107c6     0xc    li a1,0
    0x840107c8     0xe    addi sp,sp,16
    0x840107ca    0x10    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookup_fault_missing_capability_new` has 8 nodes.

Section lookup_fault_invalid_root_new (90 of 432)
=================================================

Deriving specifications
-----------------------

Section `lookup_fault_invalid_root_new` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `lookup_fault_invalid_root_new`:

    0x840107b0    0x0    addi sp,sp,-16
    0x840107b2    0x2    li a0,0
    0x840107b4    0x4    li a1,0
    0x840107b6    0x6    addi sp,sp,16
    0x840107b8    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookup_fault_invalid_root_new` has 6 nodes.

Section lookup_fault_get_lufType (91 of 432)
============================================

Deriving specifications
-----------------------

Section `lookup_fault_get_lufType` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `lookup_fault_get_lufType`:

    0x840107a8    0x0    addi sp,sp,-16
    0x840107aa    0x2    andi a0,a0,3
    0x840107ac    0x4    addi sp,sp,16
    0x840107ae    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookup_fault_get_lufType` has 5 nodes.

Section cap_asid_pool_cap_get_capASIDBase (92 of 432)
=====================================================

Deriving specifications
-----------------------

Section `cap_asid_pool_cap_get_capASIDBase` consists of 6 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_asid_pool_cap_get_capASIDBase`:

    0x8401079c    0x0    addi sp,sp,-16
    0x8401079e    0x2    srli a0,a0,0x2b
    0x840107a0    0x4    slli a0,a0,0x30
    0x840107a2    0x6    srli a0,a0,0x30
    0x840107a4    0x8    addi sp,sp,16
    0x840107a6    0xa    ret

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_asid_pool_cap_get_capASIDBase` has 7 nodes.

Section cap_asid_pool_cap_new (93 of 432)
=========================================

Deriving specifications
-----------------------

Section `cap_asid_pool_cap_new` consists of 14 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_asid_pool_cap_new`:

    0x8401077e     0x0    addi sp,sp,-16
    0x84010780     0x2    slli a0,a0,0x2b
    0x84010782     0x4    lui a5,0xffff
    0x84010786     0x8    slli a5,a5,0x1f
    0x84010788     0xa    and a0,a0,a5
    0x8401078a     0xc    slli a1,a1,0x19
    0x8401078c     0xe    srli a1,a1,0x1b
    0x8401078e    0x10    or a0,a0,a1
    0x84010790    0x12    li a5,13
    0x84010792    0x14    slli a5,a5,0x3b
    0x84010794    0x16    or a0,a0,a5
    0x84010796    0x18    li a1,0
    0x84010798    0x1a    addi sp,sp,16
    0x8401079a    0x1c    ret

Proving inst theorems
---------------------

14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_asid_pool_cap_new` has 15 nodes.

Section cap_asid_control_cap_new (94 of 432)
============================================

Deriving specifications
-----------------------

Section `cap_asid_control_cap_new` consists of 6 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_asid_control_cap_new`:

    0x84010772    0x0    addi sp,sp,-16
    0x84010774    0x2    li a0,11
    0x84010776    0x4    slli a0,a0,0x3b
    0x84010778    0x6    li a1,0
    0x8401077a    0x8    addi sp,sp,16
    0x8401077c    0xa    ret

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_asid_control_cap_new` has 7 nodes.

Section cap_page_table_cap_set_capPTMappedAddress (95 of 432)
=============================================================

Deriving specifications
-----------------------

Section `cap_page_table_cap_set_capPTMappedAddress` consists of 9 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_page_table_cap_set_capPTMappedAddress`:

    0x8401075e     0x0    addi sp,sp,-32
    0x84010760     0x2    li a5,-1
    0x84010762     0x4    slli a4,a5,0x27
    0x84010766     0x8    and a0,a0,a4
    0x84010768     0xa    srli a5,a5,0x19
    0x8401076a     0xc    and a5,a5,a2
    0x8401076c     0xe    or a0,a0,a5
    0x8401076e    0x10    addi sp,sp,32
    0x84010770    0x12    ret

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_page_table_cap_set_capPTMappedAddress` has 10 nodes.

Section cap_page_table_cap_ptr_set_capPTIsMapped (96 of 432)
============================================================

Deriving specifications
-----------------------

Section `cap_page_table_cap_ptr_set_capPTIsMapped` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_page_table_cap_ptr_set_capPTIsMapped`:

    0x8401074a     0x0    ld a5,0(a0)
    0x8401074c     0x2    li a4,-1
    0x8401074e     0x4    slli a4,a4,0x27
    0x84010750     0x6    addi a4,a4,-1
    0x84010752     0x8    and a5,a5,a4
    0x84010754     0xa    andi a1,a1,1
    0x84010756     0xc    slli a1,a1,0x27
    0x84010758     0xe    or a5,a5,a1
    0x8401075a    0x10    sd a5,0(a0)
    0x8401075c    0x12    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_page_table_cap_ptr_set_capPTIsMapped` has 13 nodes.

Section cap_page_table_cap_set_capPTIsMapped (97 of 432)
========================================================

Deriving specifications
-----------------------

Section `cap_page_table_cap_set_capPTIsMapped` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_page_table_cap_set_capPTIsMapped`:

    0x84010736     0x0    addi sp,sp,-32
    0x84010738     0x2    li a5,-1
    0x8401073a     0x4    slli a5,a5,0x27
    0x8401073c     0x6    addi a5,a5,-1
    0x8401073e     0x8    and a0,a0,a5
    0x84010740     0xa    andi a2,a2,1
    0x84010742     0xc    slli a2,a2,0x27
    0x84010744     0xe    or a0,a0,a2
    0x84010746    0x10    addi sp,sp,32
    0x84010748    0x12    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_page_table_cap_set_capPTIsMapped` has 11 nodes.

Section cap_page_table_cap_get_capPTIsMapped (98 of 432)
========================================================

Deriving specifications
-----------------------

Section `cap_page_table_cap_get_capPTIsMapped` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_page_table_cap_get_capPTIsMapped`:

    0x8401072c    0x0    addi sp,sp,-16
    0x8401072e    0x2    srli a0,a0,0x27
    0x84010730    0x4    andi a0,a0,1
    0x84010732    0x6    addi sp,sp,16
    0x84010734    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_page_table_cap_get_capPTIsMapped` has 6 nodes.

Section cap_page_table_cap_set_capPTMappedASID (99 of 432)
==========================================================

Deriving specifications
-----------------------

Section `cap_page_table_cap_set_capPTMappedASID` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_page_table_cap_set_capPTMappedASID`:

    0x8401071e    0x0    addi sp,sp,-32
    0x84010720    0x2    slli a1,a1,0x10
    0x84010722    0x4    srli a1,a1,0x10
    0x84010724    0x6    slli a2,a2,0x30
    0x84010726    0x8    or a1,a1,a2
    0x84010728    0xa    addi sp,sp,32
    0x8401072a    0xc    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_page_table_cap_set_capPTMappedASID` has 8 nodes.

Section cap_page_table_cap_get_capPTMappedASID (100 of 432)
===========================================================

Deriving specifications
-----------------------

Section `cap_page_table_cap_get_capPTMappedASID` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_page_table_cap_get_capPTMappedASID`:

    0x84010714    0x0    addi sp,sp,-16
    0x84010716    0x2    srli a0,a1,0x30
    0x8401071a    0x6    addi sp,sp,16
    0x8401071c    0x8    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_page_table_cap_get_capPTMappedASID` has 5 nodes.

Section cap_page_table_cap_new (101 of 432)
===========================================

Deriving specifications
-----------------------

Section `cap_page_table_cap_new` consists of 17 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_page_table_cap_new`:

    0x840106ee     0x0    addi sp,sp,-16
    0x840106f0     0x2    andi a2,a2,1
    0x840106f2     0x4    slli a2,a2,0x27
    0x840106f4     0x6    slli a3,a3,0x19
    0x840106f6     0x8    srli a3,a3,0x19
    0x840106f8     0xa    or a2,a2,a3
    0x840106fa     0xc    slli a1,a1,0x9
    0x840106fc     0xe    lui a5,0xfe000
    0x84010700    0x12    srli a5,a5,0x10
    0x84010702    0x14    and a1,a1,a5
    0x84010704    0x16    slli a5,a0,0x30
    0x84010708    0x1a    li a0,3
    0x8401070a    0x1c    slli a0,a0,0x3b
    0x8401070c    0x1e    or a0,a0,a2
    0x8401070e    0x20    or a1,a1,a5
    0x84010710    0x22    addi sp,sp,16
    0x84010712    0x24    ret

Proving inst theorems
---------------------

17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_page_table_cap_new` has 18 nodes.

Section cap_frame_cap_set_capFMappedAddress (102 of 432)
========================================================

Deriving specifications
-----------------------

Section `cap_frame_cap_set_capFMappedAddress` consists of 9 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_frame_cap_set_capFMappedAddress`:

    0x840106da     0x0    addi sp,sp,-32
    0x840106dc     0x2    li a5,-1
    0x840106de     0x4    slli a4,a5,0x27
    0x840106e2     0x8    and a0,a0,a4
    0x840106e4     0xa    srli a5,a5,0x19
    0x840106e6     0xc    and a5,a5,a2
    0x840106e8     0xe    or a0,a0,a5
    0x840106ea    0x10    addi sp,sp,32
    0x840106ec    0x12    ret

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_frame_cap_set_capFMappedAddress` has 10 nodes.

Section cap_frame_cap_get_capFIsDevice (103 of 432)
===================================================

Deriving specifications
-----------------------

Section `cap_frame_cap_get_capFIsDevice` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_frame_cap_get_capFIsDevice`:

    0x840106d0    0x0    addi sp,sp,-16
    0x840106d2    0x2    srli a0,a0,0x36
    0x840106d4    0x4    andi a0,a0,1
    0x840106d6    0x6    addi sp,sp,16
    0x840106d8    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_frame_cap_get_capFIsDevice` has 6 nodes.

Section cap_frame_cap_set_capFVMRights (104 of 432)
===================================================

Deriving specifications
-----------------------

Section `cap_frame_cap_set_capFVMRights` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_frame_cap_set_capFVMRights`:

    0x840106bc     0x0    addi sp,sp,-32
    0x840106be     0x2    li a5,-3
    0x840106c0     0x4    slli a5,a5,0x37
    0x840106c2     0x6    addi a5,a5,-1
    0x840106c4     0x8    and a0,a0,a5
    0x840106c6     0xa    andi a2,a2,3
    0x840106c8     0xc    slli a2,a2,0x37
    0x840106ca     0xe    or a0,a0,a2
    0x840106cc    0x10    addi sp,sp,32
    0x840106ce    0x12    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_frame_cap_set_capFVMRights` has 11 nodes.

Section cap_frame_cap_get_capFVMRights (105 of 432)
===================================================

Deriving specifications
-----------------------

Section `cap_frame_cap_get_capFVMRights` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_frame_cap_get_capFVMRights`:

    0x840106b2    0x0    addi sp,sp,-16
    0x840106b4    0x2    srli a0,a0,0x37
    0x840106b6    0x4    andi a0,a0,3
    0x840106b8    0x6    addi sp,sp,16
    0x840106ba    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_frame_cap_get_capFVMRights` has 6 nodes.

Section cap_frame_cap_get_capFSize (106 of 432)
===============================================

Deriving specifications
-----------------------

Section `cap_frame_cap_get_capFSize` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_frame_cap_get_capFSize`:

    0x840106a8    0x0    addi sp,sp,-16
    0x840106aa    0x2    srli a0,a0,0x39
    0x840106ac    0x4    andi a0,a0,3
    0x840106ae    0x6    addi sp,sp,16
    0x840106b0    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_frame_cap_get_capFSize` has 6 nodes.

Section cap_frame_cap_set_capFMappedASID (107 of 432)
=====================================================

Deriving specifications
-----------------------

Section `cap_frame_cap_set_capFMappedASID` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_frame_cap_set_capFMappedASID`:

    0x8401069a    0x0    addi sp,sp,-32
    0x8401069c    0x2    slli a1,a1,0x10
    0x8401069e    0x4    srli a1,a1,0x10
    0x840106a0    0x6    slli a2,a2,0x30
    0x840106a2    0x8    or a1,a1,a2
    0x840106a4    0xa    addi sp,sp,32
    0x840106a6    0xc    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_frame_cap_set_capFMappedASID` has 8 nodes.

Section cap_frame_cap_get_capFMappedASID (108 of 432)
=====================================================

Deriving specifications
-----------------------

Section `cap_frame_cap_get_capFMappedASID` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_frame_cap_get_capFMappedASID`:

    0x84010690    0x0    addi sp,sp,-16
    0x84010692    0x2    srli a0,a1,0x30
    0x84010696    0x6    addi sp,sp,16
    0x84010698    0x8    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_frame_cap_get_capFMappedASID` has 5 nodes.

Section cap_frame_cap_new (109 of 432)
======================================

Deriving specifications
-----------------------

Section `cap_frame_cap_new` consists of 24 instructions.

AND.....
OR.....

Stack analysis
---------------

No stack accesses found. Code for `cap_frame_cap_new`:

    0x84010654     0x0    addi sp,sp,-16
    0x84010656     0x2    li a6,3
    0x84010658     0x4    and a2,a6,a2
    0x8401065c     0x8    slli a2,a2,0x39
    0x8401065e     0xa    slli a5,a5,0x19
    0x84010660     0xc    srli a5,a5,0x19
    0x84010662     0xe    or a2,a2,a5
    0x84010664    0x10    li a5,1
    0x84010666    0x12    and a4,a4,a5
    0x84010668    0x14    slli a4,a4,0x36
    0x8401066a    0x16    or a2,a2,a4
    0x8401066c    0x18    and a6,a6,a3
    0x84010670    0x1c    slli a6,a6,0x37
    0x84010672    0x1e    or a2,a2,a6
    0x84010676    0x22    slli a5,a5,0x3b
    0x84010678    0x24    slli a1,a1,0x9
    0x8401067a    0x26    lui a4,0xfe000
    0x8401067e    0x2a    srli a4,a4,0x10
    0x84010680    0x2c    and a1,a1,a4
    0x84010682    0x2e    slli a4,a0,0x30
    0x84010686    0x32    or a0,a2,a5
    0x8401068a    0x36    or a1,a1,a4
    0x8401068c    0x38    addi sp,sp,16
    0x8401068e    0x3a    ret

Proving inst theorems
---------------------

24 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_frame_cap_new` has 25 nodes.

Section cap_domain_cap_new (110 of 432)
=======================================

Deriving specifications
-----------------------

Section `cap_domain_cap_new` consists of 6 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_domain_cap_new`:

    0x84010648    0x0    addi sp,sp,-16
    0x8401064a    0x2    li a0,-3
    0x8401064c    0x4    slli a0,a0,0x3d
    0x8401064e    0x6    li a1,0
    0x84010650    0x8    addi sp,sp,16
    0x84010652    0xa    ret

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_domain_cap_new` has 7 nodes.

Section cap_zombie_cap_get_capZombieType (111 of 432)
=====================================================

Deriving specifications
-----------------------

Section `cap_zombie_cap_get_capZombieType` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_zombie_cap_get_capZombieType`:

    0x8401063e    0x0    addi sp,sp,-16
    0x84010640    0x2    andi a0,a0,127
    0x84010644    0x6    addi sp,sp,16
    0x84010646    0x8    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_zombie_cap_get_capZombieType` has 5 nodes.

Section cap_zombie_cap_set_capZombieID (112 of 432)
===================================================

Deriving specifications
-----------------------

Section `cap_zombie_cap_set_capZombieID` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_zombie_cap_set_capZombieID`:

    0x84010636    0x0    addi sp,sp,-32
    0x84010638    0x2    mv a1,a2
    0x8401063a    0x4    addi sp,sp,32
    0x8401063c    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_zombie_cap_set_capZombieID` has 5 nodes.

Section cap_zombie_cap_get_capZombieID (113 of 432)
===================================================

Deriving specifications
-----------------------

Section `cap_zombie_cap_get_capZombieID` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_zombie_cap_get_capZombieID`:

    0x8401062e    0x0    addi sp,sp,-16
    0x84010630    0x2    mv a0,a1
    0x84010632    0x4    addi sp,sp,16
    0x84010634    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_zombie_cap_get_capZombieID` has 5 nodes.

Section cap_zombie_cap_new (114 of 432)
=======================================

Deriving specifications
-----------------------

Section `cap_zombie_cap_new` consists of 9 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_zombie_cap_new`:

    0x8401061a     0x0    addi sp,sp,-16
    0x8401061c     0x2    mv a4,a0
    0x8401061e     0x4    andi a0,a1,127
    0x84010622     0x8    li a5,-7
    0x84010624     0xa    slli a5,a5,0x3c
    0x84010626     0xc    or a0,a0,a5
    0x84010628     0xe    mv a1,a4
    0x8401062a    0x10    addi sp,sp,16
    0x8401062c    0x12    ret

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_zombie_cap_new` has 10 nodes.

Section cap_irq_handler_cap_get_capIRQ (115 of 432)
===================================================

Deriving specifications
-----------------------

Section `cap_irq_handler_cap_get_capIRQ` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_irq_handler_cap_get_capIRQ`:

    0x8401060e    0x0    addi sp,sp,-16
    0x84010610    0x2    slli a0,a1,0x34
    0x84010614    0x6    srli a0,a0,0x34
    0x84010616    0x8    addi sp,sp,16
    0x84010618    0xa    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_irq_handler_cap_get_capIRQ` has 6 nodes.

Section cap_irq_handler_cap_new (116 of 432)
============================================

Deriving specifications
-----------------------

Section `cap_irq_handler_cap_new` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_irq_handler_cap_new`:

    0x840105fe    0x0    addi sp,sp,-16
    0x84010600    0x2    slli a1,a0,0x34
    0x84010604    0x6    li a0,-1
    0x84010606    0x8    slli a0,a0,0x3f
    0x84010608    0xa    srli a1,a1,0x34
    0x8401060a    0xc    addi sp,sp,16
    0x8401060c    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_irq_handler_cap_new` has 8 nodes.

Section cap_irq_control_cap_new (117 of 432)
============================================

Deriving specifications
-----------------------

Section `cap_irq_control_cap_new` consists of 6 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_irq_control_cap_new`:

    0x840105f2    0x0    addi sp,sp,-16
    0x840105f4    0x2    li a0,7
    0x840105f6    0x4    slli a0,a0,0x3c
    0x840105f8    0x6    li a1,0
    0x840105fa    0x8    addi sp,sp,16
    0x840105fc    0xa    ret

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_irq_control_cap_new` has 7 nodes.

Section cap_thread_cap_new (118 of 432)
=======================================

Deriving specifications
-----------------------

Section `cap_thread_cap_new` consists of 9 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_thread_cap_new`:

    0x840105de     0x0    addi sp,sp,-16
    0x840105e0     0x2    slli a5,a0,0x19
    0x840105e4     0x6    srli a5,a5,0x19
    0x840105e6     0x8    li a0,3
    0x840105e8     0xa    slli a0,a0,0x3d
    0x840105ea     0xc    or a0,a0,a5
    0x840105ec     0xe    li a1,0
    0x840105ee    0x10    addi sp,sp,16
    0x840105f0    0x12    ret

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_thread_cap_new` has 10 nodes.

Section cap_cnode_cap_get_capCNodeRadix (119 of 432)
====================================================

Deriving specifications
-----------------------

Section `cap_cnode_cap_get_capCNodeRadix` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_cnode_cap_get_capCNodeRadix`:

    0x840105d2    0x0    addi sp,sp,-16
    0x840105d4    0x2    srli a0,a0,0x2f
    0x840105d6    0x4    andi a0,a0,63
    0x840105da    0x8    addi sp,sp,16
    0x840105dc    0xa    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_cnode_cap_get_capCNodeRadix` has 6 nodes.

Section cap_cnode_cap_set_capCNodeGuardSize (120 of 432)
========================================================

Deriving specifications
-----------------------

Section `cap_cnode_cap_set_capCNodeGuardSize` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_cnode_cap_set_capCNodeGuardSize`:

    0x840105ba     0x0    addi sp,sp,-32
    0x840105bc     0x2    li a5,-63
    0x840105c0     0x6    slli a5,a5,0x35
    0x840105c2     0x8    addi a5,a5,-1
    0x840105c4     0xa    and a0,a0,a5
    0x840105c6     0xc    andi a2,a2,63
    0x840105ca    0x10    slli a2,a2,0x35
    0x840105cc    0x12    or a0,a0,a2
    0x840105ce    0x14    addi sp,sp,32
    0x840105d0    0x16    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_cnode_cap_set_capCNodeGuardSize` has 11 nodes.

Section cap_cnode_cap_get_capCNodeGuardSize (121 of 432)
========================================================

Deriving specifications
-----------------------

Section `cap_cnode_cap_get_capCNodeGuardSize` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_cnode_cap_get_capCNodeGuardSize`:

    0x840105ae    0x0    addi sp,sp,-16
    0x840105b0    0x2    srli a0,a0,0x35
    0x840105b2    0x4    andi a0,a0,63
    0x840105b6    0x8    addi sp,sp,16
    0x840105b8    0xa    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_cnode_cap_get_capCNodeGuardSize` has 6 nodes.

Section cap_cnode_cap_set_capCNodeGuard (122 of 432)
====================================================

Deriving specifications
-----------------------

Section `cap_cnode_cap_set_capCNodeGuard` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_cnode_cap_set_capCNodeGuard`:

    0x840105a6    0x0    addi sp,sp,-32
    0x840105a8    0x2    mv a1,a2
    0x840105aa    0x4    addi sp,sp,32
    0x840105ac    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_cnode_cap_set_capCNodeGuard` has 5 nodes.

Section cap_cnode_cap_get_capCNodeGuard (123 of 432)
====================================================

Deriving specifications
-----------------------

Section `cap_cnode_cap_get_capCNodeGuard` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_cnode_cap_get_capCNodeGuard`:

    0x8401059e    0x0    addi sp,sp,-16
    0x840105a0    0x2    mv a0,a1
    0x840105a2    0x4    addi sp,sp,16
    0x840105a4    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_cnode_cap_get_capCNodeGuard` has 5 nodes.

Section cap_cnode_cap_new (124 of 432)
======================================

Deriving specifications
-----------------------

Section `cap_cnode_cap_new` consists of 16 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_cnode_cap_new`:

    0x8401057c     0x0    addi sp,sp,-16
    0x8401057e     0x2    li a5,63
    0x84010582     0x6    and a0,a0,a5
    0x84010584     0x8    slli a0,a0,0x2f
    0x84010586     0xa    slli a3,a3,0x19
    0x84010588     0xc    srli a3,a3,0x1a
    0x8401058a     0xe    or a0,a0,a3
    0x8401058c    0x10    and a5,a5,a1
    0x8401058e    0x12    slli a5,a5,0x35
    0x84010590    0x14    or a0,a0,a5
    0x84010592    0x16    li a5,5
    0x84010594    0x18    slli a5,a5,0x3c
    0x84010596    0x1a    or a0,a0,a5
    0x84010598    0x1c    mv a1,a2
    0x8401059a    0x1e    addi sp,sp,16
    0x8401059c    0x20    ret

Proving inst theorems
---------------------

16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_cnode_cap_new` has 17 nodes.

Section cap_reply_cap_get_capReplyMaster (125 of 432)
=====================================================

Deriving specifications
-----------------------

Section `cap_reply_cap_get_capReplyMaster` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_reply_cap_get_capReplyMaster`:

    0x84010574    0x0    addi sp,sp,-16
    0x84010576    0x2    andi a0,a0,1
    0x84010578    0x4    addi sp,sp,16
    0x8401057a    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_reply_cap_get_capReplyMaster` has 5 nodes.

Section cap_reply_cap_set_capReplyCanGrant (126 of 432)
=======================================================

Deriving specifications
-----------------------

Section `cap_reply_cap_set_capReplyCanGrant` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_reply_cap_set_capReplyCanGrant`:

    0x84010566    0x0    addi sp,sp,-32
    0x84010568    0x2    andi a0,a0,-3
    0x8401056a    0x4    slli a2,a2,0x1
    0x8401056c    0x6    andi a2,a2,2
    0x8401056e    0x8    or a0,a0,a2
    0x84010570    0xa    addi sp,sp,32
    0x84010572    0xc    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_reply_cap_set_capReplyCanGrant` has 8 nodes.

Section cap_reply_cap_get_capReplyCanGrant (127 of 432)
=======================================================

Deriving specifications
-----------------------

Section `cap_reply_cap_get_capReplyCanGrant` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_reply_cap_get_capReplyCanGrant`:

    0x8401055c    0x0    addi sp,sp,-16
    0x8401055e    0x2    srli a0,a0,0x1
    0x84010560    0x4    andi a0,a0,1
    0x84010562    0x6    addi sp,sp,16
    0x84010564    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_reply_cap_get_capReplyCanGrant` has 6 nodes.

Section cap_reply_cap_get_capTCBPtr (128 of 432)
================================================

Deriving specifications
-----------------------

Section `cap_reply_cap_get_capTCBPtr` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_reply_cap_get_capTCBPtr`:

    0x84010554    0x0    addi sp,sp,-16
    0x84010556    0x2    mv a0,a1
    0x84010558    0x4    addi sp,sp,16
    0x8401055a    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_reply_cap_get_capTCBPtr` has 5 nodes.

Section cap_reply_cap_new (129 of 432)
======================================

Deriving specifications
-----------------------

Section `cap_reply_cap_new` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_reply_cap_new`:

    0x8401053c     0x0    addi sp,sp,-16
    0x8401053e     0x2    slli a0,a0,0x1
    0x84010540     0x4    andi a0,a0,2
    0x84010542     0x6    andi a5,a1,1
    0x84010546     0xa    or a0,a0,a5
    0x84010548     0xc    li a5,1
    0x8401054a     0xe    slli a5,a5,0x3e
    0x8401054c    0x10    or a0,a0,a5
    0x8401054e    0x12    mv a1,a2
    0x84010550    0x14    addi sp,sp,16
    0x84010552    0x16    ret

Proving inst theorems
---------------------

11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_reply_cap_new` has 12 nodes.

Section cap_notification_cap_set_capNtfnCanSend (130 of 432)
============================================================

Deriving specifications
-----------------------

Section `cap_notification_cap_set_capNtfnCanSend` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_notification_cap_set_capNtfnCanSend`:

    0x84010528     0x0    addi sp,sp,-32
    0x8401052a     0x2    li a5,-1
    0x8401052c     0x4    slli a5,a5,0x39
    0x8401052e     0x6    addi a5,a5,-1
    0x84010530     0x8    and a0,a0,a5
    0x84010532     0xa    andi a2,a2,1
    0x84010534     0xc    slli a2,a2,0x39
    0x84010536     0xe    or a0,a0,a2
    0x84010538    0x10    addi sp,sp,32
    0x8401053a    0x12    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_notification_cap_set_capNtfnCanSend` has 11 nodes.

Section cap_notification_cap_get_capNtfnCanSend (131 of 432)
============================================================

Deriving specifications
-----------------------

Section `cap_notification_cap_get_capNtfnCanSend` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_notification_cap_get_capNtfnCanSend`:

    0x8401051e    0x0    addi sp,sp,-16
    0x84010520    0x2    srli a0,a0,0x39
    0x84010522    0x4    andi a0,a0,1
    0x84010524    0x6    addi sp,sp,16
    0x84010526    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_notification_cap_get_capNtfnCanSend` has 6 nodes.

Section cap_notification_cap_set_capNtfnCanReceive (132 of 432)
===============================================================

Deriving specifications
-----------------------

Section `cap_notification_cap_set_capNtfnCanReceive` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_notification_cap_set_capNtfnCanReceive`:

    0x8401050a     0x0    addi sp,sp,-32
    0x8401050c     0x2    li a5,-1
    0x8401050e     0x4    slli a5,a5,0x3a
    0x84010510     0x6    addi a5,a5,-1
    0x84010512     0x8    and a0,a0,a5
    0x84010514     0xa    andi a2,a2,1
    0x84010516     0xc    slli a2,a2,0x3a
    0x84010518     0xe    or a0,a0,a2
    0x8401051a    0x10    addi sp,sp,32
    0x8401051c    0x12    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_notification_cap_set_capNtfnCanReceive` has 11 nodes.

Section cap_notification_cap_get_capNtfnCanReceive (133 of 432)
===============================================================

Deriving specifications
-----------------------

Section `cap_notification_cap_get_capNtfnCanReceive` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_notification_cap_get_capNtfnCanReceive`:

    0x84010500    0x0    addi sp,sp,-16
    0x84010502    0x2    srli a0,a0,0x3a
    0x84010504    0x4    andi a0,a0,1
    0x84010506    0x6    addi sp,sp,16
    0x84010508    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_notification_cap_get_capNtfnCanReceive` has 6 nodes.

Section cap_notification_cap_set_capNtfnBadge (134 of 432)
==========================================================

Deriving specifications
-----------------------

Section `cap_notification_cap_set_capNtfnBadge` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_notification_cap_set_capNtfnBadge`:

    0x840104f8    0x0    addi sp,sp,-32
    0x840104fa    0x2    mv a1,a2
    0x840104fc    0x4    addi sp,sp,32
    0x840104fe    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_notification_cap_set_capNtfnBadge` has 5 nodes.

Section cap_notification_cap_get_capNtfnBadge (135 of 432)
==========================================================

Deriving specifications
-----------------------

Section `cap_notification_cap_get_capNtfnBadge` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_notification_cap_get_capNtfnBadge`:

    0x840104f0    0x0    addi sp,sp,-16
    0x840104f2    0x2    mv a0,a1
    0x840104f4    0x4    addi sp,sp,16
    0x840104f6    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_notification_cap_get_capNtfnBadge` has 5 nodes.

Section cap_notification_cap_new (136 of 432)
=============================================

Deriving specifications
-----------------------

Section `cap_notification_cap_new` consists of 17 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_notification_cap_new`:

    0x840104ce     0x0    addi sp,sp,-16
    0x840104d0     0x2    mv a4,a0
    0x840104d2     0x4    li a5,1
    0x840104d4     0x6    and a1,a1,a5
    0x840104d6     0x8    slli a1,a1,0x3a
    0x840104d8     0xa    slli a3,a3,0x19
    0x840104da     0xc    srli a3,a3,0x19
    0x840104dc     0xe    or a1,a1,a3
    0x840104de    0x10    and a5,a5,a2
    0x840104e0    0x12    slli a5,a5,0x39
    0x840104e2    0x14    or a1,a1,a5
    0x840104e4    0x16    li a0,3
    0x840104e6    0x18    slli a0,a0,0x3c
    0x840104e8    0x1a    or a0,a0,a1
    0x840104ea    0x1c    mv a1,a4
    0x840104ec    0x1e    addi sp,sp,16
    0x840104ee    0x20    ret

Proving inst theorems
---------------------

17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_notification_cap_new` has 18 nodes.

Section cap_endpoint_cap_set_capCanSend (137 of 432)
====================================================

Deriving specifications
-----------------------

Section `cap_endpoint_cap_set_capCanSend` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_endpoint_cap_set_capCanSend`:

    0x840104ba     0x0    addi sp,sp,-32
    0x840104bc     0x2    li a5,-1
    0x840104be     0x4    slli a5,a5,0x37
    0x840104c0     0x6    addi a5,a5,-1
    0x840104c2     0x8    and a0,a0,a5
    0x840104c4     0xa    andi a2,a2,1
    0x840104c6     0xc    slli a2,a2,0x37
    0x840104c8     0xe    or a0,a0,a2
    0x840104ca    0x10    addi sp,sp,32
    0x840104cc    0x12    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_endpoint_cap_set_capCanSend` has 11 nodes.

Section cap_endpoint_cap_get_capCanSend (138 of 432)
====================================================

Deriving specifications
-----------------------

Section `cap_endpoint_cap_get_capCanSend` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_endpoint_cap_get_capCanSend`:

    0x840104b0    0x0    addi sp,sp,-16
    0x840104b2    0x2    srli a0,a0,0x37
    0x840104b4    0x4    andi a0,a0,1
    0x840104b6    0x6    addi sp,sp,16
    0x840104b8    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_endpoint_cap_get_capCanSend` has 6 nodes.

Section cap_endpoint_cap_set_capCanReceive (139 of 432)
=======================================================

Deriving specifications
-----------------------

Section `cap_endpoint_cap_set_capCanReceive` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_endpoint_cap_set_capCanReceive`:

    0x8401049c     0x0    addi sp,sp,-32
    0x8401049e     0x2    li a5,-1
    0x840104a0     0x4    slli a5,a5,0x38
    0x840104a2     0x6    addi a5,a5,-1
    0x840104a4     0x8    and a0,a0,a5
    0x840104a6     0xa    andi a2,a2,1
    0x840104a8     0xc    slli a2,a2,0x38
    0x840104aa     0xe    or a0,a0,a2
    0x840104ac    0x10    addi sp,sp,32
    0x840104ae    0x12    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_endpoint_cap_set_capCanReceive` has 11 nodes.

Section cap_endpoint_cap_get_capCanReceive (140 of 432)
=======================================================

Deriving specifications
-----------------------

Section `cap_endpoint_cap_get_capCanReceive` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_endpoint_cap_get_capCanReceive`:

    0x84010492    0x0    addi sp,sp,-16
    0x84010494    0x2    srli a0,a0,0x38
    0x84010496    0x4    andi a0,a0,1
    0x84010498    0x6    addi sp,sp,16
    0x8401049a    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_endpoint_cap_get_capCanReceive` has 6 nodes.

Section cap_endpoint_cap_set_capCanGrant (141 of 432)
=====================================================

Deriving specifications
-----------------------

Section `cap_endpoint_cap_set_capCanGrant` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_endpoint_cap_set_capCanGrant`:

    0x8401047e     0x0    addi sp,sp,-32
    0x84010480     0x2    li a5,-1
    0x84010482     0x4    slli a5,a5,0x39
    0x84010484     0x6    addi a5,a5,-1
    0x84010486     0x8    and a0,a0,a5
    0x84010488     0xa    andi a2,a2,1
    0x8401048a     0xc    slli a2,a2,0x39
    0x8401048c     0xe    or a0,a0,a2
    0x8401048e    0x10    addi sp,sp,32
    0x84010490    0x12    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_endpoint_cap_set_capCanGrant` has 11 nodes.

Section cap_endpoint_cap_get_capCanGrant (142 of 432)
=====================================================

Deriving specifications
-----------------------

Section `cap_endpoint_cap_get_capCanGrant` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_endpoint_cap_get_capCanGrant`:

    0x84010474    0x0    addi sp,sp,-16
    0x84010476    0x2    srli a0,a0,0x39
    0x84010478    0x4    andi a0,a0,1
    0x8401047a    0x6    addi sp,sp,16
    0x8401047c    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_endpoint_cap_get_capCanGrant` has 6 nodes.

Section cap_endpoint_cap_set_capCanGrantReply (143 of 432)
==========================================================

Deriving specifications
-----------------------

Section `cap_endpoint_cap_set_capCanGrantReply` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_endpoint_cap_set_capCanGrantReply`:

    0x84010460     0x0    addi sp,sp,-32
    0x84010462     0x2    li a5,-1
    0x84010464     0x4    slli a5,a5,0x3a
    0x84010466     0x6    addi a5,a5,-1
    0x84010468     0x8    and a0,a0,a5
    0x8401046a     0xa    andi a2,a2,1
    0x8401046c     0xc    slli a2,a2,0x3a
    0x8401046e     0xe    or a0,a0,a2
    0x84010470    0x10    addi sp,sp,32
    0x84010472    0x12    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_endpoint_cap_set_capCanGrantReply` has 11 nodes.

Section cap_endpoint_cap_get_capCanGrantReply (144 of 432)
==========================================================

Deriving specifications
-----------------------

Section `cap_endpoint_cap_get_capCanGrantReply` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_endpoint_cap_get_capCanGrantReply`:

    0x84010456    0x0    addi sp,sp,-16
    0x84010458    0x2    srli a0,a0,0x3a
    0x8401045a    0x4    andi a0,a0,1
    0x8401045c    0x6    addi sp,sp,16
    0x8401045e    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_endpoint_cap_get_capCanGrantReply` has 6 nodes.

Section cap_endpoint_cap_set_capEPBadge (145 of 432)
====================================================

Deriving specifications
-----------------------

Section `cap_endpoint_cap_set_capEPBadge` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_endpoint_cap_set_capEPBadge`:

    0x8401044e    0x0    addi sp,sp,-32
    0x84010450    0x2    mv a1,a2
    0x84010452    0x4    addi sp,sp,32
    0x84010454    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_endpoint_cap_set_capEPBadge` has 5 nodes.

Section cap_endpoint_cap_get_capEPBadge (146 of 432)
====================================================

Deriving specifications
-----------------------

Section `cap_endpoint_cap_get_capEPBadge` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_endpoint_cap_get_capEPBadge`:

    0x84010446    0x0    addi sp,sp,-16
    0x84010448    0x2    mv a0,a1
    0x8401044a    0x4    addi sp,sp,16
    0x8401044c    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_endpoint_cap_get_capEPBadge` has 5 nodes.

Section cap_endpoint_cap_new (147 of 432)
=========================================

Deriving specifications
-----------------------

Section `cap_endpoint_cap_new` consists of 22 instructions.

RVC_TFFFT____FT___TF.

Stack analysis
---------------

No stack accesses found. Code for `cap_endpoint_cap_new`:

    0x8401041a     0x0    addi sp,sp,-16
    0x8401041c     0x2    mv a6,a0
    0x8401041e     0x4    li a0,1
    0x84010420     0x6    and a1,a1,a0
    0x84010422     0x8    slli a1,a1,0x3a
    0x84010424     0xa    slli a5,a5,0x19
    0x84010426     0xc    srli a5,a5,0x19
    0x84010428     0xe    or a1,a1,a5
    0x8401042a    0x10    and a4,a4,a0
    0x8401042c    0x12    slli a4,a4,0x38
    0x8401042e    0x14    or a1,a1,a4
    0x84010430    0x16    and a3,a3,a0
    0x84010432    0x18    slli a3,a3,0x37
    0x84010434    0x1a    or a1,a1,a3
    0x84010436    0x1c    and a2,a2,a0
    0x84010438    0x1e    slli a2,a2,0x39
    0x8401043a    0x20    or a1,a1,a2
    0x8401043c    0x22    slli a0,a0,0x3d
    0x8401043e    0x24    or a0,a0,a1
    0x84010440    0x26    mv a1,a6
    0x84010442    0x28    addi sp,sp,16
    0x84010444    0x2a    ret

Proving inst theorems
---------------------

22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_endpoint_cap_new` has 23 nodes.

Section cap_untyped_cap_get_capBlockSize (148 of 432)
=====================================================

Deriving specifications
-----------------------

Section `cap_untyped_cap_get_capBlockSize` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_untyped_cap_get_capBlockSize`:

    0x84010410    0x0    addi sp,sp,-16
    0x84010412    0x2    andi a0,a1,63
    0x84010416    0x6    addi sp,sp,16
    0x84010418    0x8    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_untyped_cap_get_capBlockSize` has 5 nodes.

Section cap_untyped_cap_get_capIsDevice (149 of 432)
====================================================

Deriving specifications
-----------------------

Section `cap_untyped_cap_get_capIsDevice` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_untyped_cap_get_capIsDevice`:

    0x84010404    0x0    addi sp,sp,-16
    0x84010406    0x2    srli a0,a1,0x6
    0x8401040a    0x6    andi a0,a0,1
    0x8401040c    0x8    addi sp,sp,16
    0x8401040e    0xa    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_untyped_cap_get_capIsDevice` has 6 nodes.

Section cap_untyped_cap_ptr_set_capFreeIndex (150 of 432)
=========================================================

Deriving specifications
-----------------------

Section `cap_untyped_cap_ptr_set_capFreeIndex` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_untyped_cap_ptr_set_capFreeIndex`:

    0x840103f6    0x0    ld a5,8(a0)
    0x840103f8    0x2    slli a5,a5,0x27
    0x840103fa    0x4    srli a5,a5,0x27
    0x840103fc    0x6    slli a1,a1,0x19
    0x840103fe    0x8    or a5,a5,a1
    0x84010400    0xa    sd a5,8(a0)
    0x84010402    0xc    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_untyped_cap_ptr_set_capFreeIndex` has 10 nodes.

Section cap_untyped_cap_set_capFreeIndex (151 of 432)
=====================================================

Deriving specifications
-----------------------

Section `cap_untyped_cap_set_capFreeIndex` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_untyped_cap_set_capFreeIndex`:

    0x840103e8    0x0    addi sp,sp,-32
    0x840103ea    0x2    slli a1,a1,0x27
    0x840103ec    0x4    srli a1,a1,0x27
    0x840103ee    0x6    slli a2,a2,0x19
    0x840103f0    0x8    or a1,a1,a2
    0x840103f2    0xa    addi sp,sp,32
    0x840103f4    0xc    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_untyped_cap_set_capFreeIndex` has 8 nodes.

Section cap_untyped_cap_get_capFreeIndex (152 of 432)
=====================================================

Deriving specifications
-----------------------

Section `cap_untyped_cap_get_capFreeIndex` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_untyped_cap_get_capFreeIndex`:

    0x840103de    0x0    addi sp,sp,-16
    0x840103e0    0x2    srli a0,a1,0x19
    0x840103e4    0x6    addi sp,sp,16
    0x840103e6    0x8    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_untyped_cap_get_capFreeIndex` has 5 nodes.

Section cap_untyped_cap_new (153 of 432)
========================================

Deriving specifications
-----------------------

Section `cap_untyped_cap_new` consists of 14 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_untyped_cap_new`:

    0x840103be     0x0    addi sp,sp,-16
    0x840103c0     0x2    slli a3,a3,0x19
    0x840103c2     0x4    srli a3,a3,0x19
    0x840103c4     0x6    slli a1,a1,0x6
    0x840103c6     0x8    andi a1,a1,64
    0x840103ca     0xc    slli a0,a0,0x19
    0x840103cc     0xe    or a1,a1,a0
    0x840103ce    0x10    andi a2,a2,63
    0x840103d2    0x14    li a0,1
    0x840103d4    0x16    slli a0,a0,0x3c
    0x840103d6    0x18    or a0,a0,a3
    0x840103d8    0x1a    or a1,a1,a2
    0x840103da    0x1c    addi sp,sp,16
    0x840103dc    0x1e    ret

Proving inst theorems
---------------------

14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_untyped_cap_new` has 15 nodes.

Section cap_null_cap_new (154 of 432)
=====================================

Deriving specifications
-----------------------

Section `cap_null_cap_new` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_null_cap_new`:

    0x840103b4    0x0    addi sp,sp,-16
    0x840103b6    0x2    li a0,0
    0x840103b8    0x4    li a1,0
    0x840103ba    0x6    addi sp,sp,16
    0x840103bc    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_null_cap_new` has 6 nodes.

Section cap_capType_equals (155 of 432)
=======================================

Deriving specifications
-----------------------

Section `cap_capType_equals` consists of 6 instructions.

RVC_TFFFTT___FF___FT..

Stack analysis
---------------

No stack accesses found. Code for `cap_capType_equals`:

    0x840103a6    0x0    addi sp,sp,-16
    0x840103a8    0x2    srli a0,a0,0x3b
    0x840103aa    0x4    sub a0,a0,a2
    0x840103ac    0x6    seqz a0,a0
    0x840103b0    0xa    addi sp,sp,16
    0x840103b2    0xc    ret

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_capType_equals` has 7 nodes.

Section cap_get_capType (156 of 432)
====================================

Deriving specifications
-----------------------

Section `cap_get_capType` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_get_capType`:

    0x8401039e    0x0    addi sp,sp,-16
    0x840103a0    0x2    srli a0,a0,0x3b
    0x840103a2    0x4    addi sp,sp,16
    0x840103a4    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_get_capType` has 5 nodes.

Section vm_attributes_get_riscvExecuteNever (157 of 432)
========================================================

Deriving specifications
-----------------------

Section `vm_attributes_get_riscvExecuteNever` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `vm_attributes_get_riscvExecuteNever`:

    0x8401039a    0x0    andi a0,a0,1
    0x8401039c    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `vm_attributes_get_riscvExecuteNever` has 3 nodes.

Section thread_state_ptr_set_tsType (158 of 432)
================================================

Deriving specifications
-----------------------

Section `thread_state_ptr_set_tsType` consists of 6 instructions.


Stack analysis
---------------

No stack accesses found. Code for `thread_state_ptr_set_tsType`:

    0x8401038e    0x0    ld a5,0(a0)
    0x84010390    0x2    andi a5,a5,-16
    0x84010392    0x4    andi a1,a1,15
    0x84010394    0x6    or a5,a5,a1
    0x84010396    0x8    sd a5,0(a0)
    0x84010398    0xa    ret

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `thread_state_ptr_set_tsType` has 9 nodes.

Section thread_state_ptr_get_tsType (159 of 432)
================================================

Deriving specifications
-----------------------

Section `thread_state_ptr_get_tsType` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `thread_state_ptr_get_tsType`:

    0x84010388    0x0    ld a0,0(a0)
    0x8401038a    0x2    andi a0,a0,15
    0x8401038c    0x4    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `thread_state_ptr_get_tsType` has 5 nodes.

Section thread_state_get_tsType (160 of 432)
============================================

Deriving specifications
-----------------------

Section `thread_state_get_tsType` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `thread_state_get_tsType`:

    0x84010382    0x0    ld a0,0(a0)
    0x84010384    0x2    andi a0,a0,15
    0x84010386    0x4    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `thread_state_get_tsType` has 5 nodes.

Section thread_state_ptr_set_blockingObject (161 of 432)
========================================================

Deriving specifications
-----------------------

Section `thread_state_ptr_set_blockingObject` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `thread_state_ptr_set_blockingObject`:

    0x8401036a     0x0    ld a5,0(a0)
    0x8401036c     0x2    li a4,-1
    0x8401036e     0x4    slli a4,a4,0x27
    0x84010370     0x6    addi a4,a4,15
    0x84010372     0x8    and a5,a5,a4
    0x84010374     0xa    lui a4,0xe0000
    0x84010378     0xe    srli a4,a4,0x19
    0x8401037a    0x10    and a1,a1,a4
    0x8401037c    0x12    or a5,a5,a1
    0x8401037e    0x14    sd a5,0(a0)
    0x84010380    0x16    ret

Proving inst theorems
---------------------

11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `thread_state_ptr_set_blockingObject` has 14 nodes.

Section thread_state_ptr_set_tcbQueued (162 of 432)
===================================================

Deriving specifications
-----------------------

Section `thread_state_ptr_set_tcbQueued` consists of 6 instructions.


Stack analysis
---------------

No stack accesses found. Code for `thread_state_ptr_set_tcbQueued`:

    0x8401035e    0x0    ld a5,8(a0)
    0x84010360    0x2    andi a5,a5,-2
    0x84010362    0x4    andi a1,a1,1
    0x84010364    0x6    or a5,a5,a1
    0x84010366    0x8    sd a5,8(a0)
    0x84010368    0xa    ret

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `thread_state_ptr_set_tcbQueued` has 9 nodes.

Section thread_state_get_tcbQueued (163 of 432)
===============================================

Deriving specifications
-----------------------

Section `thread_state_get_tcbQueued` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `thread_state_get_tcbQueued`:

    0x84010358    0x0    ld a0,8(a0)
    0x8401035a    0x2    andi a0,a0,1
    0x8401035c    0x4    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `thread_state_get_tcbQueued` has 5 nodes.

Section thread_state_ptr_set_blockingIPCIsCall (164 of 432)
===========================================================

Deriving specifications
-----------------------

Section `thread_state_ptr_set_blockingIPCIsCall` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `thread_state_ptr_set_blockingIPCIsCall`:

    0x8401034a    0x0    ld a5,8(a0)
    0x8401034c    0x2    andi a5,a5,-3
    0x8401034e    0x4    slli a1,a1,0x1
    0x84010350    0x6    andi a1,a1,2
    0x84010352    0x8    or a5,a5,a1
    0x84010354    0xa    sd a5,8(a0)
    0x84010356    0xc    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `thread_state_ptr_set_blockingIPCIsCall` has 10 nodes.

Section thread_state_ptr_get_blockingIPCIsCall (165 of 432)
===========================================================

Deriving specifications
-----------------------

Section `thread_state_ptr_get_blockingIPCIsCall` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `thread_state_ptr_get_blockingIPCIsCall`:

    0x84010342    0x0    ld a0,8(a0)
    0x84010344    0x2    srli a0,a0,0x1
    0x84010346    0x4    andi a0,a0,1
    0x84010348    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `thread_state_ptr_get_blockingIPCIsCall` has 6 nodes.

Section thread_state_ptr_set_blockingIPCCanGrantReply (166 of 432)
==================================================================

Deriving specifications
-----------------------

Section `thread_state_ptr_set_blockingIPCCanGrantReply` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `thread_state_ptr_set_blockingIPCCanGrantReply`:

    0x84010334    0x0    ld a5,8(a0)
    0x84010336    0x2    andi a5,a5,-5
    0x84010338    0x4    slli a1,a1,0x2
    0x8401033a    0x6    andi a1,a1,4
    0x8401033c    0x8    or a5,a5,a1
    0x8401033e    0xa    sd a5,8(a0)
    0x84010340    0xc    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `thread_state_ptr_set_blockingIPCCanGrantReply` has 10 nodes.

Section thread_state_ptr_get_blockingIPCCanGrantReply (167 of 432)
==================================================================

Deriving specifications
-----------------------

Section `thread_state_ptr_get_blockingIPCCanGrantReply` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `thread_state_ptr_get_blockingIPCCanGrantReply`:

    0x8401032c    0x0    ld a0,8(a0)
    0x8401032e    0x2    srli a0,a0,0x2
    0x84010330    0x4    andi a0,a0,1
    0x84010332    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `thread_state_ptr_get_blockingIPCCanGrantReply` has 6 nodes.

Section thread_state_ptr_set_blockingIPCCanGrant (168 of 432)
=============================================================

Deriving specifications
-----------------------

Section `thread_state_ptr_set_blockingIPCCanGrant` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `thread_state_ptr_set_blockingIPCCanGrant`:

    0x8401031e    0x0    ld a5,8(a0)
    0x84010320    0x2    andi a5,a5,-9
    0x84010322    0x4    slli a1,a1,0x3
    0x84010324    0x6    andi a1,a1,8
    0x84010326    0x8    or a5,a5,a1
    0x84010328    0xa    sd a5,8(a0)
    0x8401032a    0xc    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `thread_state_ptr_set_blockingIPCCanGrant` has 10 nodes.

Section thread_state_ptr_get_blockingIPCCanGrant (169 of 432)
=============================================================

Deriving specifications
-----------------------

Section `thread_state_ptr_get_blockingIPCCanGrant` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `thread_state_ptr_get_blockingIPCCanGrant`:

    0x84010316    0x0    ld a0,8(a0)
    0x84010318    0x2    srli a0,a0,0x3
    0x8401031a    0x4    andi a0,a0,1
    0x8401031c    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `thread_state_ptr_get_blockingIPCCanGrant` has 6 nodes.

Section thread_state_ptr_set_blockingIPCBadge (170 of 432)
==========================================================

Deriving specifications
-----------------------

Section `thread_state_ptr_set_blockingIPCBadge` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `thread_state_ptr_set_blockingIPCBadge`:

    0x84010312    0x0    sd a1,16(a0)
    0x84010314    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `thread_state_ptr_set_blockingIPCBadge` has 4 nodes.

Section thread_state_ptr_get_blockingIPCBadge (171 of 432)
==========================================================

Deriving specifications
-----------------------

Section `thread_state_ptr_get_blockingIPCBadge` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `thread_state_ptr_get_blockingIPCBadge`:

    0x8401030e    0x0    ld a0,16(a0)
    0x84010310    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `thread_state_ptr_get_blockingIPCBadge` has 4 nodes.

Section satp_new (172 of 432)
=============================

Deriving specifications
-----------------------

Section `satp_new` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `satp_new`:

    0x840102f6     0x0    slli a1,a1,0x2c
    0x840102f8     0x2    lui a5,0xffff
    0x840102fc     0x6    slli a5,a5,0x20
    0x840102fe     0x8    and a1,a1,a5
    0x84010300     0xa    slli a0,a0,0x3c
    0x84010302     0xc    or a1,a1,a0
    0x84010304     0xe    slli a2,a2,0x14
    0x84010306    0x10    srli a0,a2,0x14
    0x8401030a    0x14    or a0,a0,a1
    0x8401030c    0x16    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `satp_new` has 11 nodes.

Section pte_ptr_get_valid (173 of 432)
======================================

Deriving specifications
-----------------------

Section `pte_ptr_get_valid` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `pte_ptr_get_valid`:

    0x840102f0    0x0    ld a0,0(a0)
    0x840102f2    0x2    andi a0,a0,1
    0x840102f4    0x4    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `pte_ptr_get_valid` has 5 nodes.

Section pte_ptr_get_read (174 of 432)
=====================================

Deriving specifications
-----------------------

Section `pte_ptr_get_read` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `pte_ptr_get_read`:

    0x840102e8    0x0    ld a0,0(a0)
    0x840102ea    0x2    srli a0,a0,0x1
    0x840102ec    0x4    andi a0,a0,1
    0x840102ee    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `pte_ptr_get_read` has 6 nodes.

Section pte_ptr_get_write (175 of 432)
======================================

Deriving specifications
-----------------------

Section `pte_ptr_get_write` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `pte_ptr_get_write`:

    0x840102e0    0x0    ld a0,0(a0)
    0x840102e2    0x2    srli a0,a0,0x2
    0x840102e4    0x4    andi a0,a0,1
    0x840102e6    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `pte_ptr_get_write` has 6 nodes.

Section pte_ptr_get_execute (176 of 432)
========================================

Deriving specifications
-----------------------

Section `pte_ptr_get_execute` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `pte_ptr_get_execute`:

    0x840102d8    0x0    ld a0,0(a0)
    0x840102da    0x2    srli a0,a0,0x3
    0x840102dc    0x4    andi a0,a0,1
    0x840102de    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `pte_ptr_get_execute` has 6 nodes.

Section pte_ptr_get_ppn (177 of 432)
====================================

Deriving specifications
-----------------------

Section `pte_ptr_get_ppn` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `pte_ptr_get_ppn`:

    0x840102d0    0x0    ld a0,0(a0)
    0x840102d2    0x2    slli a0,a0,0xa
    0x840102d4    0x4    srli a0,a0,0x14
    0x840102d6    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `pte_ptr_get_ppn` has 6 nodes.

Section pte_new (178 of 432)
============================

Deriving specifications
-----------------------

Section `pte_new` consists of 33 instructions.

RVC_FTT_FFT_______TF.
RVC_FTT_T_________TF.

Stack analysis
---------------

2 stack accesses found. Annotated code for `pte_new`:

    0x8401026a     0x0    ld t1,0(sp)           ; stack access
    0x8401026c     0x2    slli t1,t1,0x1
    0x8401026e     0x4    andi t1,t1,2
    0x84010272     0x8    ld t3,8(sp)           ; stack access
    0x84010274     0xa    andi t3,t3,1
    0x84010278     0xe    or t1,t1,t3
    0x8401027c    0x12    slli a7,a7,0x2
    0x8401027e    0x14    andi a7,a7,4
    0x84010282    0x18    or t1,t1,a7
    0x84010286    0x1c    slli a6,a6,0x3
    0x84010288    0x1e    andi a6,a6,8
    0x8401028c    0x22    or t1,t1,a6
    0x84010290    0x26    slli a5,a5,0x4
    0x84010292    0x28    andi a5,a5,16
    0x84010294    0x2a    or t1,t1,a5
    0x84010298    0x2e    slli a4,a4,0x5
    0x8401029a    0x30    andi a4,a4,32
    0x8401029e    0x34    or t1,t1,a4
    0x840102a2    0x38    slli a3,a3,0x6
    0x840102a4    0x3a    andi a3,a3,64
    0x840102a8    0x3e    or t1,t1,a3
    0x840102ac    0x42    slli a2,a2,0x7
    0x840102ae    0x44    andi a2,a2,255
    0x840102b2    0x48    or t1,t1,a2
    0x840102b6    0x4c    slli a1,a1,0x8
    0x840102b8    0x4e    andi a1,a1,768
    0x840102bc    0x52    or t1,t1,a1
    0x840102c0    0x56    slli a0,a0,0xa
    0x840102c2    0x58    lui a5,0xfff00
    0x840102c6    0x5c    srli a5,a5,0xa
    0x840102c8    0x5e    and a0,a0,a5
    0x840102ca    0x60    or a0,t1,a0
    0x840102ce    0x64    ret

Proving inst theorems
---------------------

33 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `pte_new` has 36 nodes.

Section notification_ptr_set_state (179 of 432)
===============================================

Deriving specifications
-----------------------

Section `notification_ptr_set_state` consists of 6 instructions.


Stack analysis
---------------

No stack accesses found. Code for `notification_ptr_set_state`:

    0x8401025e    0x0    ld a5,0(a0)
    0x84010260    0x2    andi a5,a5,-4
    0x84010262    0x4    andi a1,a1,3
    0x84010264    0x6    or a5,a5,a1
    0x84010266    0x8    sd a5,0(a0)
    0x84010268    0xa    ret

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `notification_ptr_set_state` has 9 nodes.

Section notification_ptr_get_state (180 of 432)
===============================================

Deriving specifications
-----------------------

Section `notification_ptr_get_state` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `notification_ptr_get_state`:

    0x84010258    0x0    ld a0,0(a0)
    0x8401025a    0x2    andi a0,a0,3
    0x8401025c    0x4    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `notification_ptr_get_state` has 5 nodes.

Section notification_ptr_set_ntfnQueue_tail (181 of 432)
========================================================

Deriving specifications
-----------------------

Section `notification_ptr_set_ntfnQueue_tail` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `notification_ptr_set_ntfnQueue_tail`:

    0x8401024a    0x0    ld a5,0(a0)
    0x8401024c    0x2    slli a5,a5,0x27
    0x8401024e    0x4    srli a5,a5,0x27
    0x84010250    0x6    slli a1,a1,0x19
    0x84010252    0x8    or a5,a5,a1
    0x84010254    0xa    sd a5,0(a0)
    0x84010256    0xc    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `notification_ptr_set_ntfnQueue_tail` has 10 nodes.

Section notification_ptr_set_ntfnQueue_head (182 of 432)
========================================================

Deriving specifications
-----------------------

Section `notification_ptr_set_ntfnQueue_head` consists of 9 instructions.


Stack analysis
---------------

No stack accesses found. Code for `notification_ptr_set_ntfnQueue_head`:

    0x84010236     0x0    ld a5,8(a0)
    0x84010238     0x2    li a4,-1
    0x8401023a     0x4    slli a3,a4,0x27
    0x8401023e     0x8    and a5,a5,a3
    0x84010240     0xa    srli a4,a4,0x19
    0x84010242     0xc    and a4,a4,a1
    0x84010244     0xe    or a5,a5,a4
    0x84010246    0x10    sd a5,8(a0)
    0x84010248    0x12    ret

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `notification_ptr_set_ntfnQueue_head` has 12 nodes.

Section notification_ptr_set_ntfnMsgIdentifier (183 of 432)
===========================================================

Deriving specifications
-----------------------

Section `notification_ptr_set_ntfnMsgIdentifier` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `notification_ptr_set_ntfnMsgIdentifier`:

    0x84010232    0x0    sd a1,16(a0)
    0x84010234    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `notification_ptr_set_ntfnMsgIdentifier` has 4 nodes.

Section notification_ptr_get_ntfnMsgIdentifier (184 of 432)
===========================================================

Deriving specifications
-----------------------

Section `notification_ptr_get_ntfnMsgIdentifier` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `notification_ptr_get_ntfnMsgIdentifier`:

    0x8401022e    0x0    ld a0,16(a0)
    0x84010230    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `notification_ptr_get_ntfnMsgIdentifier` has 4 nodes.

Section notification_ptr_set_ntfnBoundTCB (185 of 432)
======================================================

Deriving specifications
-----------------------

Section `notification_ptr_set_ntfnBoundTCB` consists of 9 instructions.


Stack analysis
---------------

No stack accesses found. Code for `notification_ptr_set_ntfnBoundTCB`:

    0x8401021a     0x0    ld a5,24(a0)
    0x8401021c     0x2    li a4,-1
    0x8401021e     0x4    slli a3,a4,0x27
    0x84010222     0x8    and a5,a5,a3
    0x84010224     0xa    srli a4,a4,0x19
    0x84010226     0xc    and a4,a4,a1
    0x84010228     0xe    or a5,a5,a4
    0x8401022a    0x10    sd a5,24(a0)
    0x8401022c    0x12    ret

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `notification_ptr_set_ntfnBoundTCB` has 12 nodes.

Section mdb_node_ptr_set_mdbPrev (186 of 432)
=============================================

Deriving specifications
-----------------------

Section `mdb_node_ptr_set_mdbPrev` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `mdb_node_ptr_set_mdbPrev`:

    0x84010216    0x0    sd a1,0(a0)
    0x84010218    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `mdb_node_ptr_set_mdbPrev` has 4 nodes.

Section mdb_node_set_mdbPrev (187 of 432)
=========================================

Deriving specifications
-----------------------

Section `mdb_node_set_mdbPrev` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `mdb_node_set_mdbPrev`:

    0x8401020e    0x0    addi sp,sp,-32
    0x84010210    0x2    mv a0,a2
    0x84010212    0x4    addi sp,sp,32
    0x84010214    0x6    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `mdb_node_set_mdbPrev` has 5 nodes.

Section mdb_node_get_mdbPrev (188 of 432)
=========================================

Deriving specifications
-----------------------

Section `mdb_node_get_mdbPrev` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `mdb_node_get_mdbPrev`:

    0x84010208    0x0    addi sp,sp,-16
    0x8401020a    0x2    addi sp,sp,16
    0x8401020c    0x4    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `mdb_node_get_mdbPrev` has 4 nodes.

Section mdb_node_ptr_set_mdbFirstBadged (189 of 432)
====================================================

Deriving specifications
-----------------------

Section `mdb_node_ptr_set_mdbFirstBadged` consists of 6 instructions.


Stack analysis
---------------

No stack accesses found. Code for `mdb_node_ptr_set_mdbFirstBadged`:

    0x840101fc    0x0    ld a5,8(a0)
    0x840101fe    0x2    andi a5,a5,-2
    0x84010200    0x4    andi a1,a1,1
    0x84010202    0x6    or a5,a5,a1
    0x84010204    0x8    sd a5,8(a0)
    0x84010206    0xa    ret

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `mdb_node_ptr_set_mdbFirstBadged` has 9 nodes.

Section mdb_node_set_mdbFirstBadged (190 of 432)
================================================

Deriving specifications
-----------------------

Section `mdb_node_set_mdbFirstBadged` consists of 6 instructions.


Stack analysis
---------------

No stack accesses found. Code for `mdb_node_set_mdbFirstBadged`:

    0x840101f0    0x0    addi sp,sp,-32
    0x840101f2    0x2    andi a1,a1,-2
    0x840101f4    0x4    andi a2,a2,1
    0x840101f6    0x6    or a1,a1,a2
    0x840101f8    0x8    addi sp,sp,32
    0x840101fa    0xa    ret

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `mdb_node_set_mdbFirstBadged` has 7 nodes.

Section mdb_node_get_mdbFirstBadged (191 of 432)
================================================

Deriving specifications
-----------------------

Section `mdb_node_get_mdbFirstBadged` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `mdb_node_get_mdbFirstBadged`:

    0x840101e6    0x0    addi sp,sp,-16
    0x840101e8    0x2    andi a0,a1,1
    0x840101ec    0x6    addi sp,sp,16
    0x840101ee    0x8    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `mdb_node_get_mdbFirstBadged` has 5 nodes.

Section mdb_node_ptr_set_mdbRevocable (192 of 432)
==================================================

Deriving specifications
-----------------------

Section `mdb_node_ptr_set_mdbRevocable` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `mdb_node_ptr_set_mdbRevocable`:

    0x840101d8    0x0    ld a5,8(a0)
    0x840101da    0x2    andi a5,a5,-3
    0x840101dc    0x4    slli a1,a1,0x1
    0x840101de    0x6    andi a1,a1,2
    0x840101e0    0x8    or a5,a5,a1
    0x840101e2    0xa    sd a5,8(a0)
    0x840101e4    0xc    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `mdb_node_ptr_set_mdbRevocable` has 10 nodes.

Section mdb_node_set_mdbRevocable (193 of 432)
==============================================

Deriving specifications
-----------------------

Section `mdb_node_set_mdbRevocable` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `mdb_node_set_mdbRevocable`:

    0x840101ca    0x0    addi sp,sp,-32
    0x840101cc    0x2    andi a1,a1,-3
    0x840101ce    0x4    slli a2,a2,0x1
    0x840101d0    0x6    andi a2,a2,2
    0x840101d2    0x8    or a1,a1,a2
    0x840101d4    0xa    addi sp,sp,32
    0x840101d6    0xc    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `mdb_node_set_mdbRevocable` has 8 nodes.

Section mdb_node_get_mdbRevocable (194 of 432)
==============================================

Deriving specifications
-----------------------

Section `mdb_node_get_mdbRevocable` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `mdb_node_get_mdbRevocable`:

    0x840101be    0x0    addi sp,sp,-16
    0x840101c0    0x2    srli a0,a1,0x1
    0x840101c4    0x6    andi a0,a0,1
    0x840101c6    0x8    addi sp,sp,16
    0x840101c8    0xa    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `mdb_node_get_mdbRevocable` has 6 nodes.

Section mdb_node_ptr_set_mdbNext (195 of 432)
=============================================

Deriving specifications
-----------------------

Section `mdb_node_ptr_set_mdbNext` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `mdb_node_ptr_set_mdbNext`:

    0x840101a6     0x0    ld a5,8(a0)
    0x840101a8     0x2    li a4,-1
    0x840101aa     0x4    slli a4,a4,0x27
    0x840101ac     0x6    addi a4,a4,3
    0x840101ae     0x8    and a5,a5,a4
    0x840101b0     0xa    lui a4,0xf8000
    0x840101b4     0xe    srli a4,a4,0x19
    0x840101b6    0x10    and a1,a1,a4
    0x840101b8    0x12    or a5,a5,a1
    0x840101ba    0x14    sd a5,8(a0)
    0x840101bc    0x16    ret

Proving inst theorems
---------------------

11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `mdb_node_ptr_set_mdbNext` has 14 nodes.

Section mdb_node_new (196 of 432)
=================================

Deriving specifications
-----------------------

Section `mdb_node_new` consists of 12 instructions.


Stack analysis
---------------

No stack accesses found. Code for `mdb_node_new`:

    0x8401018a     0x0    addi sp,sp,-16
    0x8401018c     0x2    slli a1,a1,0x1
    0x8401018e     0x4    andi a1,a1,2
    0x84010190     0x6    lui a4,0xf8000
    0x84010194     0xa    srli a4,a4,0x19
    0x84010196     0xc    and a5,a0,a4
    0x8401019a    0x10    or a1,a1,a5
    0x8401019c    0x12    andi a2,a2,1
    0x8401019e    0x14    mv a0,a3
    0x840101a0    0x16    or a1,a1,a2
    0x840101a2    0x18    addi sp,sp,16
    0x840101a4    0x1a    ret

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `mdb_node_new` has 13 nodes.

Section endpoint_ptr_set_state (197 of 432)
===========================================

Deriving specifications
-----------------------

Section `endpoint_ptr_set_state` consists of 6 instructions.


Stack analysis
---------------

No stack accesses found. Code for `endpoint_ptr_set_state`:

    0x8401017e    0x0    ld a5,0(a0)
    0x84010180    0x2    andi a5,a5,-4
    0x84010182    0x4    andi a1,a1,3
    0x84010184    0x6    or a5,a5,a1
    0x84010186    0x8    sd a5,0(a0)
    0x84010188    0xa    ret

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `endpoint_ptr_set_state` has 9 nodes.

Section endpoint_ptr_get_state (198 of 432)
===========================================

Deriving specifications
-----------------------

Section `endpoint_ptr_get_state` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `endpoint_ptr_get_state`:

    0x84010178    0x0    ld a0,0(a0)
    0x8401017a    0x2    andi a0,a0,3
    0x8401017c    0x4    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `endpoint_ptr_get_state` has 5 nodes.

Section endpoint_ptr_set_epQueue_tail (199 of 432)
==================================================

Deriving specifications
-----------------------

Section `endpoint_ptr_set_epQueue_tail` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `endpoint_ptr_set_epQueue_tail`:

    0x84010160     0x0    ld a5,0(a0)
    0x84010162     0x2    li a4,-1
    0x84010164     0x4    slli a4,a4,0x27
    0x84010166     0x6    addi a4,a4,3
    0x84010168     0x8    and a5,a5,a4
    0x8401016a     0xa    lui a4,0xf8000
    0x8401016e     0xe    srli a4,a4,0x19
    0x84010170    0x10    and a1,a1,a4
    0x84010172    0x12    or a5,a5,a1
    0x84010174    0x14    sd a5,0(a0)
    0x84010176    0x16    ret

Proving inst theorems
---------------------

11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `endpoint_ptr_set_epQueue_tail` has 14 nodes.

Section endpoint_ptr_set_epQueue_head (200 of 432)
==================================================

Deriving specifications
-----------------------

Section `endpoint_ptr_set_epQueue_head` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `endpoint_ptr_set_epQueue_head`:

    0x8401015c    0x0    sd a1,8(a0)
    0x8401015e    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `endpoint_ptr_set_epQueue_head` has 4 nodes.

Section endpoint_ptr_get_epQueue_head (201 of 432)
==================================================

Deriving specifications
-----------------------

Section `endpoint_ptr_get_epQueue_head` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `endpoint_ptr_get_epQueue_head`:

    0x84010158    0x0    ld a0,8(a0)
    0x8401015a    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `endpoint_ptr_get_epQueue_head` has 4 nodes.

Section seL4_MessageInfo_set_length (202 of 432)
================================================

Deriving specifications
-----------------------

Section `seL4_MessageInfo_set_length` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_MessageInfo_set_length`:

    0x8401014c    0x0    andi a0,a0,-128
    0x84010150    0x4    andi a1,a1,127
    0x84010154    0x8    or a0,a0,a1
    0x84010156    0xa    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_MessageInfo_set_length` has 5 nodes.

Section seL4_MessageInfo_get_length (203 of 432)
================================================

Deriving specifications
-----------------------

Section `seL4_MessageInfo_get_length` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_MessageInfo_get_length`:

    0x84010146    0x0    andi a0,a0,127
    0x8401014a    0x4    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_MessageInfo_get_length` has 3 nodes.

Section seL4_MessageInfo_set_extraCaps (204 of 432)
===================================================

Deriving specifications
-----------------------

Section `seL4_MessageInfo_set_extraCaps` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_MessageInfo_set_extraCaps`:

    0x84010138    0x0    andi a0,a0,-385
    0x8401013c    0x4    slli a1,a1,0x7
    0x8401013e    0x6    andi a1,a1,384
    0x84010142    0xa    or a0,a0,a1
    0x84010144    0xc    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_MessageInfo_set_extraCaps` has 6 nodes.

Section seL4_MessageInfo_get_extraCaps (205 of 432)
===================================================

Deriving specifications
-----------------------

Section `seL4_MessageInfo_get_extraCaps` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_MessageInfo_get_extraCaps`:

    0x84010132    0x0    srli a0,a0,0x7
    0x84010134    0x2    andi a0,a0,3
    0x84010136    0x4    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_MessageInfo_get_extraCaps` has 4 nodes.

Section seL4_MessageInfo_set_capsUnwrapped (206 of 432)
=======================================================

Deriving specifications
-----------------------

Section `seL4_MessageInfo_set_capsUnwrapped` consists of 9 instructions.

RVC_FTTTFT________FT.

Stack analysis
---------------

No stack accesses found. Code for `seL4_MessageInfo_set_capsUnwrapped`:

    0x8401011c     0x0    lui a5,0xfffff
    0x8401011e     0x2    addi a5,a5,511 # fffffffffffff1ff <ki_end+0x7bfd01ff>
    0x84010122     0x6    and a0,a0,a5
    0x84010124     0x8    slli a1,a1,0x9
    0x84010126     0xa    lui a5,0x1
    0x84010128     0xc    addi a5,a5,-512 # e00 <KERNEL_OFFSET-0xfffffffefffff200>
    0x8401012c    0x10    and a1,a1,a5
    0x8401012e    0x12    or a0,a0,a1
    0x84010130    0x14    ret

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_MessageInfo_set_capsUnwrapped` has 10 nodes.

Section seL4_MessageInfo_get_capsUnwrapped (207 of 432)
=======================================================

Deriving specifications
-----------------------

Section `seL4_MessageInfo_get_capsUnwrapped` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_MessageInfo_get_capsUnwrapped`:

    0x84010116    0x0    srli a0,a0,0x9
    0x84010118    0x2    andi a0,a0,7
    0x8401011a    0x4    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_MessageInfo_get_capsUnwrapped` has 4 nodes.

Section seL4_MessageInfo_get_label (208 of 432)
===============================================

Deriving specifications
-----------------------

Section `seL4_MessageInfo_get_label` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_MessageInfo_get_label`:

    0x84010112    0x0    srli a0,a0,0xc
    0x84010114    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_MessageInfo_get_label` has 3 nodes.

Section seL4_MessageInfo_new (209 of 432)
=========================================

Deriving specifications
-----------------------

Section `seL4_MessageInfo_new` consists of 12 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_MessageInfo_new`:

    0x840100f4     0x0    slli a2,a2,0x7
    0x840100f6     0x2    andi a2,a2,384
    0x840100fa     0x6    andi a3,a3,127
    0x840100fe     0xa    or a2,a2,a3
    0x84010100     0xc    slli a0,a0,0xc
    0x84010102     0xe    or a2,a2,a0
    0x84010104    0x10    slli a1,a1,0x9
    0x84010106    0x12    lui a0,0x1
    0x84010108    0x14    addi a0,a0,-512 # e00 <KERNEL_OFFSET-0xfffffffefffff200>
    0x8401010c    0x18    and a0,a0,a1
    0x8401010e    0x1a    or a0,a0,a2
    0x84010110    0x1c    ret

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_MessageInfo_new` has 13 nodes.

Section seL4_CapRights_get_capAllowWrite (210 of 432)
=====================================================

Deriving specifications
-----------------------

Section `seL4_CapRights_get_capAllowWrite` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_CapRights_get_capAllowWrite`:

    0x840100f0    0x0    andi a0,a0,1
    0x840100f2    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_CapRights_get_capAllowWrite` has 3 nodes.

Section seL4_CapRights_get_capAllowRead (211 of 432)
====================================================

Deriving specifications
-----------------------

Section `seL4_CapRights_get_capAllowRead` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_CapRights_get_capAllowRead`:

    0x840100ea    0x0    srli a0,a0,0x1
    0x840100ec    0x2    andi a0,a0,1
    0x840100ee    0x4    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_CapRights_get_capAllowRead` has 4 nodes.

Section seL4_CapRights_get_capAllowGrant (212 of 432)
=====================================================

Deriving specifications
-----------------------

Section `seL4_CapRights_get_capAllowGrant` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_CapRights_get_capAllowGrant`:

    0x840100e4    0x0    srli a0,a0,0x2
    0x840100e6    0x2    andi a0,a0,1
    0x840100e8    0x4    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_CapRights_get_capAllowGrant` has 4 nodes.

Section seL4_CapRights_get_capAllowGrantReply (213 of 432)
==========================================================

Deriving specifications
-----------------------

Section `seL4_CapRights_get_capAllowGrantReply` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_CapRights_get_capAllowGrantReply`:

    0x840100de    0x0    srli a0,a0,0x3
    0x840100e0    0x2    andi a0,a0,1
    0x840100e2    0x4    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_CapRights_get_capAllowGrantReply` has 4 nodes.

Section seL4_CNode_CapData_get_guardSize (214 of 432)
=====================================================

Deriving specifications
-----------------------

Section `seL4_CNode_CapData_get_guardSize` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_CNode_CapData_get_guardSize`:

    0x840100d8    0x0    andi a0,a0,63
    0x840100dc    0x4    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_CNode_CapData_get_guardSize` has 3 nodes.

Section seL4_CNode_CapData_get_guard (215 of 432)
=================================================

Deriving specifications
-----------------------

Section `seL4_CNode_CapData_get_guard` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `seL4_CNode_CapData_get_guard`:

    0x840100d4    0x0    srli a0,a0,0x6
    0x840100d6    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `seL4_CNode_CapData_get_guard` has 3 nodes.

Section bi_finalise (216 of 432)
================================

Deriving specifications
-----------------------

Section `bi_finalise` consists of 8 instructions.


Stack analysis
---------------

No stack accesses found. Code for `bi_finalise`:

    0x84000b70     0x0    auipc a5,0x1
    0x84000b74     0x4    addi a5,a5,-1632 # ffffffff84001510 <ndks_boot>
    0x84000b78     0x8    ld a3,592(a5)
    0x84000b7c     0xc    ld a4,600(a5)
    0x84000b80    0x10    ld a5,584(a5)
    0x84000b84    0x14    sd a3,40(a5)
    0x84000b86    0x16    sd a4,48(a5)
    0x84000b88    0x18    ret

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `bi_finalise` has 14 nodes.

Section init_core_state (217 of 432)
====================================

Deriving specifications
-----------------------

Section `init_core_state` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `init_core_state`:

    0x84000962     0x0    auipc a5,0x1d
    0x84000966     0x4    sd a0,734(a5) # ffffffff8401dc40 <ksSchedulerAction>
    0x8400096a     0x8    auipc a5,0x1d
    0x8400096e     0xc    ld a5,702(a5) # ffffffff8401dc28 <ksIdleThread>
    0x84000972    0x10    auipc a4,0x2e
    0x84000976    0x14    sd a5,294(a4) # ffffffff8402ea98 <ksCurThread>
    0x8400097a    0x18    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `init_core_state` has 11 nodes.

Section initIRQController (218 of 432)
======================================

Deriving specifications
-----------------------

Section `initIRQController` consists of 30 instructions.

SRL.....

Stack analysis
---------------

No stack accesses found. Code for `initIRQController`:

    0x84000334     0x0    li a4,1
    0x84000336     0x2    lui a1,0xcc001
    0x8400033a     0x6    lui a3,0xcc202
    0x8400033e     0xa    li a2,54
    0x84000342     0xe    j ffffffff8400034a <initIRQController+0x16>
    0x84000344    0x10    addi a4,a4,1
    0x84000346    0x12    beq a4,a2,ffffffff8400036e <initIRQController+0x3a>
    0x8400034a    0x16    sext.w a0,a4
    0x8400034e    0x1a    srli a5,a4,0x5
    0x84000352    0x1e    slli a5,a5,0x2
    0x84000354    0x20    add a5,a5,a1
    0x84000356    0x22    lw a5,0(a5)
    0x84000358    0x24    slli a5,a5,0x20
    0x8400035a    0x26    srli a5,a5,0x20
    0x8400035c    0x28    andi a6,a4,31
    0x84000360    0x2c    srl a5,a5,a6
    0x84000364    0x30    andi a5,a5,1
    0x84000366    0x32    beqz a5,ffffffff84000344 <initIRQController+0x10>
    0x84000368    0x34    lw a5,4(a3)
    0x8400036a    0x36    sw a0,4(a3)
    0x8400036c    0x38    j ffffffff84000344 <initIRQController+0x10>
    0x8400036e    0x3a    lui a5,0xcc000
    0x84000372    0x3e    addi a5,a5,4
    0x84000374    0x40    li a3,2
    0x84000376    0x42    lui a4,0xcc000
    0x8400037a    0x46    addi a4,a4,220 # ffffffffcc0000dc <ki_end+0x47fd10dc>
    0x8400037e    0x4a    sw a3,0(a5)
    0x84000380    0x4c    addi a5,a5,4
    0x84000382    0x4e    bne a5,a4,ffffffff8400037e <initIRQController+0x4a>
    0x84000386    0x52    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
30 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `initIRQController` has 41 nodes.

Section initLocalIRQController (219 of 432)
===========================================

Deriving specifications
-----------------------

Section `initLocalIRQController` consists of 22 instructions.

SW..
Skipping 1047a7f3 csrrs a5,sie,a5


Stack analysis
---------------

No stack accesses found. Code for `initLocalIRQController`:

    0x840002f0     0x0    li a3,1
    0x840002f2     0x2    lui a1,0xcc002
    0x840002f6     0x6    addi a1,a1,256 # ffffffffcc002100 <ki_end+0x47fd3100>
    0x840002fa     0xa    li a6,1
    0x840002fc     0xc    li a0,54
    0x84000300    0x10    srli a4,a3,0x5
    0x84000304    0x14    slli a4,a4,0x2
    0x84000306    0x16    add a4,a4,a1
    0x84000308    0x18    lw a2,0(a4)
    0x8400030a    0x1a    andi a5,a3,31
    0x8400030e    0x1e    sll a5,a6,a5
    0x84000312    0x22    not a5,a5
    0x84000316    0x26    and a5,a5,a2
    0x84000318    0x28    sext.w a5,a5
    0x8400031a    0x2a    sw a5,0(a4)
    0x8400031c    0x2c    addi a3,a3,1
    0x8400031e    0x2e    bne a3,a0,ffffffff84000300 <initLocalIRQController+0x10>
    0x84000322    0x32    lui a5,0xcc202
    0x84000326    0x36    sw zero,0(a5) # ffffffffcc202000 <ki_end+0x481d3000>
    0x8400032a    0x3a    li a5,544
    0x8400032e    0x3e    csrrs a5,sie,a5
    0x84000332    0x42    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `initLocalIRQController` has 29 nodes.

Section initL2Cache (220 of 432)
================================

Deriving specifications
-----------------------

Section `initL2Cache` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `initL2Cache`:

    0x840002ee    0x0    ret

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `initL2Cache` has 2 nodes.

Section initTimer (221 of 432)
==============================

Deriving specifications
-----------------------

Section `initTimer` consists of 7 instructions.

Skipping c0102573 rdtime a0

Skipping 00000073 ecall


Stack analysis
---------------

No stack accesses found. Code for `initTimer`:

    0x840002da     0x0    rdtime a0
    0x840002de     0x4    addi a0,a0,2000
    0x840002e2     0x8    li a1,0
    0x840002e4     0xa    li a2,0
    0x840002e6     0xc    li a7,0
    0x840002e8     0xe    ecall
    0x840002ec    0x12    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `initTimer` has 10 nodes.

Section get_avail_p_regs (222 of 432)
=====================================

Deriving specifications
-----------------------

Section `get_avail_p_regs` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `get_avail_p_regs`:

    0x840002d0    0x0    auipc a0,0x1
    0x840002d4    0x4    addi a0,a0,560 # ffffffff84001500 <avail_p_regs>
    0x840002d8    0x8    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `get_avail_p_regs` has 4 nodes.

Section get_num_avail_p_regs (223 of 432)
=========================================

Deriving specifications
-----------------------

Section `get_num_avail_p_regs` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `get_num_avail_p_regs`:

    0x840002cc    0x0    li a0,1
    0x840002ce    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `get_num_avail_p_regs` has 3 nodes.

Section arch_get_n_paging (224 of 432)
======================================

Deriving specifications
-----------------------

Section `arch_get_n_paging` consists of 19 instructions.


Stack analysis
---------------

No stack accesses found. Code for `arch_get_n_paging`:

    0x8400010c     0x0    addi sp,sp,-16
    0x8400010e     0x2    addi a1,a1,-1
    0x84000110     0x4    srli a4,a1,0x15
    0x84000114     0x8    addi a4,a4,1
    0x84000116     0xa    slli a4,a4,0x15
    0x84000118     0xc    lui a5,0xffe00
    0x8400011c    0x10    and a5,a5,a0
    0x8400011e    0x12    sub a4,a4,a5
    0x84000120    0x14    srli a4,a4,0x15
    0x84000122    0x16    srli a5,a1,0x1e
    0x84000126    0x1a    addi a5,a5,1
    0x84000128    0x1c    slli a5,a5,0x1e
    0x8400012a    0x1e    lui a3,0xc0000
    0x8400012e    0x22    and a0,a0,a3
    0x84000130    0x24    sub a5,a5,a0
    0x84000132    0x26    srli a5,a5,0x1e
    0x84000134    0x28    add a0,a4,a5
    0x84000138    0x2c    addi sp,sp,16
    0x8400013a    0x2e    ret

Proving inst theorems
---------------------

19 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arch_get_n_paging` has 20 nodes.

Section Arch_configureIdleThread (225 of 432)
=============================================

Deriving specifications
-----------------------

Section `Arch_configureIdleThread` consists of 9 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_configureIdleThread`:

    0x840000a4     0x0    auipc a5,0x11
    0x840000a8     0x4    addi a5,a5,-1966 # ffffffff840108f6 <idle_thread>
    0x840000ac     0x8    sd a5,272(a0)
    0x840000b0     0xc    li a5,288
    0x840000b4    0x10    sd a5,256(a0)
    0x840000b8    0x14    auipc a5,0x1e
    0x840000bc    0x18    addi a5,a5,-1168 # ffffffff8401dc28 <ksIdleThread>
    0x840000c0    0x1c    sd a5,8(a0)
    0x840000c2    0x1e    ret

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_configureIdleThread` has 13 nodes.

Section merge_regions (226 of 432)
==================================

Deriving specifications
-----------------------

Section `merge_regions` consists of 43 instructions.

RVC_TFFTFT___T____TF.

Stack analysis
---------------

No stack accesses found. Code for `merge_regions`:

    0x84000026     0x0    auipc a1,0x1
    0x8400002a     0x4    ld a1,1578(a1) # ffffffff84001650 <ndks_boot+0x140>
    0x8400002e     0x8    li a5,1
    0x84000030     0xa    bgeu a5,a1,ffffffff840000a2 <merge_regions+0x7c>
    0x84000034     0xe    li a4,1
    0x84000036    0x10    auipc a2,0x1
    0x8400003a    0x14    addi a2,a2,1242 # ffffffff84001510 <ndks_boot>
    0x8400003e    0x18    auipc a6,0x1
    0x84000042    0x1c    addi a6,a6,1218 # ffffffff84001500 <avail_p_regs>
    0x84000046    0x20    j ffffffff84000086 <merge_regions+0x60>
    0x84000048    0x22    slli a5,a4,0x4
    0x8400004c    0x26    add a5,a5,a2
    0x8400004e    0x28    ld a5,8(a5)
    0x84000050    0x2a    slli a0,a0,0x4
    0x84000052    0x2c    add a0,a0,a2
    0x84000054    0x2e    sd a5,8(a0)
    0x84000056    0x30    addi a5,a4,1
    0x8400005a    0x34    bgeu a5,a1,ffffffff84000078 <merge_regions+0x52>
    0x8400005e    0x38    slli a5,a4,0x4
    0x84000062    0x3c    add a5,a5,a2
    0x84000064    0x3e    slli a0,a1,0x4
    0x84000068    0x42    add a0,a0,a6
    0x8400006a    0x44    ld a3,16(a5)
    0x8400006c    0x46    sd a3,0(a5)
    0x8400006e    0x48    ld a3,24(a5)
    0x84000070    0x4a    sd a3,8(a5)
    0x84000072    0x4c    addi a5,a5,16
    0x84000074    0x4e    bne a5,a0,ffffffff8400006a <merge_regions+0x44>
    0x84000078    0x52    addi a1,a1,-1
    0x8400007a    0x54    sd a1,320(a2)
    0x8400007e    0x58    ld a1,320(a2)
    0x84000082    0x5c    bgeu a4,a1,ffffffff840000a2 <merge_regions+0x7c>
    0x84000086    0x60    addi a0,a4,-1
    0x8400008a    0x64    slli a3,a0,0x4
    0x8400008e    0x68    add a3,a3,a2
    0x84000090    0x6a    slli a5,a4,0x4
    0x84000094    0x6e    add a5,a5,a2
    0x84000096    0x70    ld a3,8(a3)
    0x84000098    0x72    ld a5,0(a5)
    0x8400009a    0x74    beq a3,a5,ffffffff84000048 <merge_regions+0x22>
    0x8400009e    0x78    addi a4,a4,1
    0x840000a0    0x7a    j ffffffff8400007e <merge_regions+0x58>
    0x840000a2    0x7c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
43 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `merge_regions` has 65 nodes.

Section str_to_long (227 of 432)
================================

Deriving specifications
-----------------------

Section `str_to_long` consists of 44 instructions.

RVC_FTTTFFFTF_____FT.
JAL.
MUL.....
RVC_FTT_FFFFT_____TF.
RVC_FTTFFFFTFT____FT.

Stack analysis
---------------

10 stack accesses found. Annotated code for `str_to_long`:

    0x84017e44     0x0    addi sp,sp,-48
    0x84017e46     0x2    sd ra,40(sp)          ; stack access
    0x84017e48     0x4    sd s0,32(sp)          ; stack access
    0x84017e4a     0x6    sd s1,24(sp)          ; stack access
    0x84017e4c     0x8    sd s2,16(sp)          ; stack access
    0x84017e4e     0xa    sd s3,8(sp)           ; stack access
    0x84017e50     0xc    mv s1,a0
    0x84017e52     0xe    lbu a0,0(a0)
    0x84017e56    0x12    li a5,48
    0x84017e5a    0x16    li s2,10
    0x84017e5c    0x18    beq a0,a5,ffffffff84017e8e <str_to_long+0x4a>
    0x84017e60    0x1c    lbu a0,0(s1)
    0x84017e64    0x20    beqz a0,ffffffff84017ea4 <str_to_long+0x60>
    0x84017e66    0x22    li s0,0
    0x84017e68    0x24    li s3,-1
    0x84017e6a    0x26    slli s2,s2,0x20
    0x84017e6c    0x28    srli s2,s2,0x20
    0x84017e70    0x2c    jal ra,ffffffff84017e04 <char_to_long>
    0x84017e74    0x30    beq a0,s3,ffffffff84017eaa <str_to_long+0x66>
    0x84017e78    0x34    bge a0,s2,ffffffff84017ea8 <str_to_long+0x64>
    0x84017e7c    0x38    mul s0,s2,s0
    0x84017e80    0x3c    add s0,s0,a0
    0x84017e82    0x3e    addi s1,s1,1
    0x84017e84    0x40    lbu a0,0(s1)
    0x84017e88    0x44    bnez a0,ffffffff84017e70 <str_to_long+0x2c>
    0x84017e8a    0x46    mv a0,s0
    0x84017e8c    0x48    j ffffffff84017eaa <str_to_long+0x66>
    0x84017e8e    0x4a    lbu a5,1(s1)
    0x84017e92    0x4e    andi a5,a5,223
    0x84017e96    0x52    li a4,88
    0x84017e9a    0x56    bne a5,a4,ffffffff84017e66 <str_to_long+0x22>
    0x84017e9e    0x5a    addi s1,s1,2
    0x84017ea0    0x5c    li s2,16
    0x84017ea2    0x5e    j ffffffff84017e60 <str_to_long+0x1c>
    0x84017ea4    0x60    li a0,-1
    0x84017ea6    0x62    j ffffffff84017eaa <str_to_long+0x66>
    0x84017ea8    0x64    li a0,-1
    0x84017eaa    0x66    ld ra,40(sp)          ; stack access
    0x84017eac    0x68    ld s0,32(sp)          ; stack access
    0x84017eae    0x6a    ld s1,24(sp)          ; stack access
    0x84017eb0    0x6c    ld s2,16(sp)          ; stack access
    0x84017eb2    0x6e    ld s3,8(sp)           ; stack access
    0x84017eb4    0x70    addi sp,sp,48
    0x84017eb6    0x72    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
44 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `str_to_long` has 72 nodes.

Section memset (228 of 432)
===========================

Deriving specifications
-----------------------

Section `memset` consists of 23 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `memset`:

    0x84017d90     0x0    addi sp,sp,-16
    0x84017d92     0x2    sd ra,8(sp)           ; stack access
    0x84017d94     0x4    sd s0,0(sp)           ; stack access
    0x84017d96     0x6    mv s0,a0
    0x84017d98     0x8    mv a4,a1
    0x84017d9a     0xa    mv a1,a2
    0x84017d9c     0xc    or a5,a0,a2
    0x84017da0    0x10    andi a5,a5,7
    0x84017da2    0x12    or a5,a5,a4
    0x84017da4    0x14    bnez a5,ffffffff84017db4 <memset+0x24>
    0x84017da6    0x16    jal ra,ffffffff840164dc <memzero>
    0x84017daa    0x1a    mv a0,s0
    0x84017dac    0x1c    ld ra,8(sp)           ; stack access
    0x84017dae    0x1e    ld s0,0(sp)           ; stack access
    0x84017db0    0x20    addi sp,sp,16
    0x84017db2    0x22    ret
    0x84017db4    0x24    add a3,a0,a2
    0x84017db8    0x28    mv a5,a0
    0x84017dba    0x2a    beqz a2,ffffffff84017daa <memset+0x1a>
    0x84017dbc    0x2c    sb a4,0(a5)
    0x84017dc0    0x30    addi a5,a5,1
    0x84017dc2    0x32    bne a3,a5,ffffffff84017dbc <memset+0x2c>
    0x84017dc6    0x36    j ffffffff84017daa <memset+0x1a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `memset` has 36 nodes.

Section Arch_decodeInvocation (229 of 432)
==========================================

Deriving specifications
-----------------------

Section `Arch_decodeInvocation` consists of 7 instructions.

RVC_TFFFT____T____TF..

Stack analysis
---------------

2 stack accesses found. Annotated code for `Arch_decodeInvocation`:

    0x84016dbe    0x0    addi sp,sp,-32
    0x84016dc0    0x2    sd ra,24(sp)          ; stack access
    0x84016dc2    0x4    mv a6,a7
    0x84016dc4    0x6    jal ra,ffffffff8401654a <decodeRISCVMMUInvocation>
    0x84016dc8    0xa    ld ra,24(sp)          ; stack access
    0x84016dca    0xc    addi sp,sp,32
    0x84016dcc    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_decodeInvocation` has 11 nodes.

Section invokeTCB_Resume (230 of 432)
=====================================

Deriving specifications
-----------------------

Section `invokeTCB_Resume` consists of 7 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeTCB_Resume`:

    0x84015456    0x0    addi sp,sp,-16
    0x84015458    0x2    sd ra,8(sp)           ; stack access
    0x8401545a    0x4    jal ra,ffffffff84014644 <restart>
    0x8401545e    0x8    li a0,0
    0x84015460    0xa    ld ra,8(sp)           ; stack access
    0x84015462    0xc    addi sp,sp,16
    0x84015464    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_Resume` has 11 nodes.

Section invokeTCB_Suspend (231 of 432)
======================================

Deriving specifications
-----------------------

Section `invokeTCB_Suspend` consists of 7 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeTCB_Suspend`:

    0x84015446    0x0    addi sp,sp,-16
    0x84015448    0x2    sd ra,8(sp)           ; stack access
    0x8401544a    0x4    jal ra,ffffffff84013afe <suspend>
    0x8401544e    0x8    li a0,0
    0x84015450    0xa    ld ra,8(sp)           ; stack access
    0x84015452    0xc    addi sp,sp,16
    0x84015454    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_Suspend` has 11 nodes.

Section performInvocation_Endpoint (232 of 432)
===============================================

Deriving specifications
-----------------------

Section `performInvocation_Endpoint` consists of 16 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `performInvocation_Endpoint`:

    0x8401509e     0x0    addi sp,sp,-16
    0x840150a0     0x2    sd ra,8(sp)           ; stack access
    0x840150a2     0x4    mv a6,a0
    0x840150a4     0x6    mv a7,a1
    0x840150a6     0x8    mv a0,a4
    0x840150a8     0xa    mv a1,a5
    0x840150aa     0xc    auipc a5,0x1a
    0x840150ae    0x10    ld a5,-1554(a5) # ffffffff8402ea98 <ksCurThread>
    0x840150b2    0x14    mv a4,a3
    0x840150b4    0x16    mv a3,a2
    0x840150b6    0x18    mv a2,a7
    0x840150b8    0x1a    jal ra,ffffffff84014d68 <sendIPC>
    0x840150bc    0x1e    li a0,0
    0x840150be    0x20    ld ra,8(sp)           ; stack access
    0x840150c0    0x22    addi sp,sp,16
    0x840150c2    0x24    ret

Proving inst theorems
---------------------

16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performInvocation_Endpoint` has 21 nodes.

Section performInvocation_Reply (233 of 432)
============================================

Deriving specifications
-----------------------

Section `performInvocation_Reply` consists of 12 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `performInvocation_Reply`:

    0x84014d4a     0x0    addi sp,sp,-16
    0x84014d4c     0x2    sd ra,8(sp)           ; stack access
    0x84014d4e     0x4    mv a3,a2
    0x84014d50     0x6    mv a2,a1
    0x84014d52     0x8    mv a1,a0
    0x84014d54     0xa    auipc a0,0x1a
    0x84014d58     0xe    ld a0,-700(a0) # ffffffff8402ea98 <ksCurThread>
    0x84014d5c    0x12    jal ra,ffffffff84014c5a <doReplyTransfer>
    0x84014d60    0x16    li a0,0
    0x84014d62    0x18    ld ra,8(sp)           ; stack access
    0x84014d64    0x1a    addi sp,sp,16
    0x84014d66    0x1c    ret

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performInvocation_Reply` has 17 nodes.

Section deleteCallerCap (234 of 432)
====================================

Deriving specifications
-----------------------

Section `deleteCallerCap` consists of 8 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `deleteCallerCap`:

    0x84014952     0x0    addi sp,sp,-16
    0x84014954     0x2    sd ra,8(sp)           ; stack access
    0x84014956     0x4    andi a0,a0,-1024
    0x8401495a     0x8    addi a0,a0,96
    0x8401495e     0xc    jal ra,ffffffff840144d0 <cteDeleteOne>
    0x84014962    0x10    ld ra,8(sp)           ; stack access
    0x84014964    0x12    addi sp,sp,16
    0x84014966    0x14    ret

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deleteCallerCap` has 12 nodes.

Section performInvocation_Notification (235 of 432)
===================================================

Deriving specifications
-----------------------

Section `performInvocation_Notification` consists of 7 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `performInvocation_Notification`:

    0x840148ea    0x0    addi sp,sp,-16
    0x840148ec    0x2    sd ra,8(sp)           ; stack access
    0x840148ee    0x4    jal ra,ffffffff84014696 <sendSignal>
    0x840148f2    0x8    li a0,0
    0x840148f4    0xa    ld ra,8(sp)           ; stack access
    0x840148f6    0xc    addi sp,sp,16
    0x840148f8    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performInvocation_Notification` has 11 nodes.

Section deletingIRQHandler (236 of 432)
=======================================

Deriving specifications
-----------------------

Section `deletingIRQHandler` consists of 10 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `deletingIRQHandler`:

    0x8401462a     0x0    addi sp,sp,-16
    0x8401462c     0x2    sd ra,8(sp)           ; stack access
    0x8401462e     0x4    slli a0,a0,0x5
    0x84014630     0x6    auipc a5,0x1a
    0x84014634     0xa    addi a5,a5,-1584 # ffffffff8402e000 <intStateIRQNode>
    0x84014638     0xe    add a0,a0,a5
    0x8401463a    0x10    jal ra,ffffffff840144d0 <cteDeleteOne>
    0x8401463e    0x14    ld ra,8(sp)           ; stack access
    0x84014640    0x16    addi sp,sp,16
    0x84014642    0x18    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deletingIRQHandler` has 14 nodes.

Section invokeIRQHandler_ClearIRQHandler (237 of 432)
=====================================================

Deriving specifications
-----------------------

Section `invokeIRQHandler_ClearIRQHandler` consists of 10 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeIRQHandler_ClearIRQHandler`:

    0x84014544     0x0    addi sp,sp,-16
    0x84014546     0x2    sd ra,8(sp)           ; stack access
    0x84014548     0x4    slli a0,a0,0x5
    0x8401454a     0x6    auipc a5,0x1a
    0x8401454e     0xa    addi a5,a5,-1354 # ffffffff8402e000 <intStateIRQNode>
    0x84014552     0xe    add a0,a0,a5
    0x84014554    0x10    jal ra,ffffffff840144d0 <cteDeleteOne>
    0x84014558    0x14    ld ra,8(sp)           ; stack access
    0x8401455a    0x16    addi sp,sp,16
    0x8401455c    0x18    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeIRQHandler_ClearIRQHandler` has 14 nodes.

Section invokeCNodeRevoke (238 of 432)
======================================

Deriving specifications
-----------------------

Section `invokeCNodeRevoke` consists of 6 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeCNodeRevoke`:

    0x84014036    0x0    addi sp,sp,-16
    0x84014038    0x2    sd ra,8(sp)           ; stack access
    0x8401403a    0x4    jal ra,ffffffff84013ff0 <cteRevoke>
    0x8401403e    0x8    ld ra,8(sp)           ; stack access
    0x84014040    0xa    addi sp,sp,16
    0x84014042    0xc    ret

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeRevoke` has 10 nodes.

Section invokeCNodeDelete (239 of 432)
======================================

Deriving specifications
-----------------------

Section `invokeCNodeDelete` consists of 7 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeCNodeDelete`:

    0x84013fe0    0x0    addi sp,sp,-16
    0x84013fe2    0x2    sd ra,8(sp)           ; stack access
    0x84013fe4    0x4    li a1,1
    0x84013fe6    0x6    jal ra,ffffffff84013d20 <cteDelete>
    0x84013fea    0xa    ld ra,8(sp)           ; stack access
    0x84013fec    0xc    addi sp,sp,16
    0x84013fee    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeDelete` has 11 nodes.

Section scheduleChooseNewThread (240 of 432)
============================================

Deriving specifications
-----------------------

Section `scheduleChooseNewThread` consists of 34 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `scheduleChooseNewThread`:

    0x84013642     0x0    addi sp,sp,-16
    0x84013644     0x2    sd ra,8(sp)           ; stack access
    0x84013646     0x4    auipc a5,0x1b
    0x8401364a     0x8    ld a5,-2030(a5) # ffffffff8402de58 <ksDomainTime>
    0x8401364e     0xc    beqz a5,ffffffff8401365a <scheduleChooseNewThread+0x18>
    0x84013650     0xe    jal ra,ffffffff840135c6 <chooseThread>
    0x84013654    0x12    ld ra,8(sp)           ; stack access
    0x84013656    0x14    addi sp,sp,16
    0x84013658    0x16    ret
    0x8401365a    0x18    auipc a5,0x1b
    0x8401365e    0x1c    ld a5,1094(a5) # ffffffff8402eaa0 <ksDomScheduleIdx>
    0x84013662    0x20    addi a5,a5,1
    0x84013664    0x22    li a4,2
    0x84013666    0x24    bltu a4,a5,ffffffff840136a6 <scheduleChooseNewThread+0x64>
    0x8401366a    0x28    auipc a4,0x1b
    0x8401366e    0x2c    sd a5,1078(a4) # ffffffff8402eaa0 <ksDomScheduleIdx>
    0x84013672    0x30    auipc a5,0x1b
    0x84013676    0x34    sd zero,926(a5) # ffffffff8402ea10 <ksWorkUnitsCompleted>
    0x8401367a    0x38    auipc a5,0x1b
    0x8401367e    0x3c    ld a5,1062(a5) # ffffffff8402eaa0 <ksDomScheduleIdx>
    0x84013682    0x40    slli a4,a5,0x4
    0x84013686    0x44    auipc a5,0x5
    0x8401368a    0x48    addi a5,a5,-950 # ffffffff840182d0 <fault_messages>
    0x8401368e    0x4c    add a5,a5,a4
    0x84013690    0x4e    ld a4,192(a5)
    0x84013692    0x50    auipc a3,0x1b
    0x84013696    0x54    sd a4,366(a3) # ffffffff8402e800 <ksCurDomain>
    0x8401369a    0x58    ld a5,200(a5)
    0x8401369c    0x5a    auipc a4,0x1a
    0x840136a0    0x5e    sd a5,1980(a4) # ffffffff8402de58 <ksDomainTime>
    0x840136a4    0x62    j ffffffff84013650 <scheduleChooseNewThread+0xe>
    0x840136a6    0x64    auipc a5,0x1b
    0x840136aa    0x68    sd zero,1018(a5) # ffffffff8402eaa0 <ksDomScheduleIdx>
    0x840136ae    0x6c    j ffffffff84013672 <scheduleChooseNewThread+0x30>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
34 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `scheduleChooseNewThread` has 52 nodes.

Section handleDoubleFault (241 of 432)
======================================

Deriving specifications
-----------------------

Section `handleDoubleFault` consists of 7 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleDoubleFault`:

    0x84013102    0x0    addi sp,sp,-32
    0x84013104    0x2    sd ra,24(sp)          ; stack access
    0x84013106    0x4    li a1,0
    0x84013108    0x6    jal ra,ffffffff84013020 <setThreadState>
    0x8401310c    0xa    ld ra,24(sp)          ; stack access
    0x8401310e    0xc    addi sp,sp,32
    0x84013110    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleDoubleFault` has 11 nodes.

Section rescheduleRequired (242 of 432)
=======================================

Deriving specifications
-----------------------

Section `rescheduleRequired` consists of 17 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `rescheduleRequired`:

    0x84012fa8     0x0    auipc a0,0xb
    0x84012fac     0x4    ld a0,-872(a0) # ffffffff8401dc40 <ksSchedulerAction>
    0x84012fb0     0x8    li a5,1
    0x84012fb2     0xa    bltu a5,a0,ffffffff84012fc2 <rescheduleRequired+0x1a>
    0x84012fb6     0xe    li a5,1
    0x84012fb8    0x10    auipc a4,0xb
    0x84012fbc    0x14    sd a5,-888(a4) # ffffffff8401dc40 <ksSchedulerAction>
    0x84012fc0    0x18    ret
    0x84012fc2    0x1a    addi sp,sp,-16
    0x84012fc4    0x1c    sd ra,8(sp)           ; stack access
    0x84012fc6    0x1e    jal ra,ffffffff84012efc <tcbSchedEnqueue>
    0x84012fca    0x22    li a5,1
    0x84012fcc    0x24    auipc a4,0xb
    0x84012fd0    0x28    sd a5,-908(a4) # ffffffff8401dc40 <ksSchedulerAction>
    0x84012fd4    0x2c    ld ra,8(sp)           ; stack access
    0x84012fd6    0x2e    addi sp,sp,16
    0x84012fd8    0x30    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `rescheduleRequired` has 27 nodes.

Section bindNotification (243 of 432)
=====================================

Deriving specifications
-----------------------

Section `bindNotification` consists of 15 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `bindNotification`:

    0x84012526     0x0    addi sp,sp,-32
    0x84012528     0x2    sd ra,24(sp)          ; stack access
    0x8401252a     0x4    sd s0,16(sp)          ; stack access
    0x8401252c     0x6    sd s1,8(sp)           ; stack access
    0x8401252e     0x8    mv s0,a0
    0x84012530     0xa    mv s1,a1
    0x84012532     0xc    mv a1,a0
    0x84012534     0xe    mv a0,s1
    0x84012536    0x10    jal ra,ffffffff8401021a <notification_ptr_set_ntfnBoundTCB>
    0x8401253a    0x14    sd s1,304(s0)
    0x8401253e    0x18    ld ra,24(sp)          ; stack access
    0x84012540    0x1a    ld s0,16(sp)          ; stack access
    0x84012542    0x1c    ld s1,8(sp)           ; stack access
    0x84012544    0x1e    addi sp,sp,32
    0x84012546    0x20    ret

Proving inst theorems
---------------------

15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `bindNotification` has 24 nodes.

Section unbindNotification (244 of 432)
=======================================

Deriving specifications
-----------------------

Section `unbindNotification` consists of 13 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `unbindNotification`:

    0x84012506     0x0    addi sp,sp,-16
    0x84012508     0x2    sd ra,8(sp)           ; stack access
    0x8401250a     0x4    sd s0,0(sp)           ; stack access
    0x8401250c     0x6    mv s0,a0
    0x8401250e     0x8    ld a0,304(a0)
    0x84012512     0xc    beqz a0,ffffffff8401251e <unbindNotification+0x18>
    0x84012514     0xe    li a1,0
    0x84012516    0x10    jal ra,ffffffff8401021a <notification_ptr_set_ntfnBoundTCB>
    0x8401251a    0x14    sd zero,304(s0)
    0x8401251e    0x18    ld ra,8(sp)           ; stack access
    0x84012520    0x1a    ld s0,0(sp)           ; stack access
    0x84012522    0x1c    addi sp,sp,16
    0x84012524    0x1e    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `unbindNotification` has 23 nodes.

Section deletedIRQHandler (245 of 432)
======================================

Deriving specifications
-----------------------

Section `deletedIRQHandler` consists of 8 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `deletedIRQHandler`:

    0x840123d6     0x0    addi sp,sp,-16
    0x840123d8     0x2    sd ra,8(sp)           ; stack access
    0x840123da     0x4    mv a1,a0
    0x840123dc     0x6    li a0,0
    0x840123de     0x8    jal ra,ffffffff8401233c <setIRQState>
    0x840123e2     0xc    ld ra,8(sp)           ; stack access
    0x840123e4     0xe    addi sp,sp,16
    0x840123e6    0x10    ret

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deletedIRQHandler` has 12 nodes.

Section replyFromKernel_success_empty (246 of 432)
==================================================

Deriving specifications
-----------------------

Section `replyFromKernel_success_empty` consists of 15 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `replyFromKernel_success_empty`:

    0x840122fa     0x0    addi sp,sp,-16
    0x840122fc     0x2    sd ra,8(sp)           ; stack access
    0x840122fe     0x4    sd s0,0(sp)           ; stack access
    0x84012300     0x6    mv s0,a0
    0x84012302     0x8    sd zero,72(a0)
    0x84012306     0xc    li a3,0
    0x84012308     0xe    li a2,0
    0x8401230a    0x10    li a1,0
    0x8401230c    0x12    li a0,0
    0x8401230e    0x14    jal ra,ffffffff840100f4 <seL4_MessageInfo_new>
    0x84012312    0x18    sd a0,80(s0)
    0x84012314    0x1a    ld ra,8(sp)           ; stack access
    0x84012316    0x1c    ld s0,0(sp)           ; stack access
    0x84012318    0x1e    addi sp,sp,16
    0x8401231a    0x20    ret

Proving inst theorems
---------------------

15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `replyFromKernel_success_empty` has 23 nodes.

Section ensureEmptySlot (247 of 432)
====================================

Deriving specifications
-----------------------

Section `ensureEmptySlot` consists of 15 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `ensureEmptySlot`:

    0x8401225c     0x0    addi sp,sp,-16
    0x8401225e     0x2    sd ra,8(sp)           ; stack access
    0x84012260     0x4    mv a5,a0
    0x84012262     0x6    ld a0,0(a0)
    0x84012264     0x8    ld a1,8(a5)
    0x84012266     0xa    jal ra,ffffffff8401039e <cap_get_capType>
    0x8401226a     0xe    bnez a0,ffffffff84012272 <ensureEmptySlot+0x16>
    0x8401226c    0x10    ld ra,8(sp)           ; stack access
    0x8401226e    0x12    addi sp,sp,16
    0x84012270    0x14    ret
    0x84012272    0x16    li a5,8
    0x84012274    0x18    auipc a4,0xc
    0x84012278    0x1c    sd a5,-1532(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x8401227c    0x20    li a0,3
    0x8401227e    0x22    j ffffffff8401226c <ensureEmptySlot+0x10>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `ensureEmptySlot` has 24 nodes.

Section capSwapForDelete (248 of 432)
=====================================

Deriving specifications
-----------------------

Section `capSwapForDelete` consists of 14 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `capSwapForDelete`:

    0x84012176     0x0    beq a0,a1,ffffffff84012194 <capSwapForDelete+0x1e>
    0x8401217a     0x4    addi sp,sp,-48
    0x8401217c     0x6    sd ra,40(sp)          ; stack access
    0x8401217e     0x8    mv a2,a0
    0x84012180     0xa    mv a5,a1
    0x84012182     0xc    ld a3,0(a1)
    0x84012184     0xe    ld a4,8(a1)
    0x84012186    0x10    ld a0,0(a0)
    0x84012188    0x12    ld a1,8(a2)
    0x8401218a    0x14    jal ra,ffffffff840120ac <cteSwap>
    0x8401218e    0x18    ld ra,40(sp)          ; stack access
    0x84012190    0x1a    addi sp,sp,48
    0x84012192    0x1c    ret
    0x84012194    0x1e    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `capSwapForDelete` has 25 nodes.

Section invokeCNodeMove (249 of 432)
====================================

Deriving specifications
-----------------------

Section `invokeCNodeMove` consists of 7 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeCNodeMove`:

    0x84012046    0x0    addi sp,sp,-32
    0x84012048    0x2    sd ra,24(sp)          ; stack access
    0x8401204a    0x4    jal ra,ffffffff84011fd0 <cteMove>
    0x8401204e    0x8    li a0,0
    0x84012050    0xa    ld ra,24(sp)          ; stack access
    0x84012052    0xc    addi sp,sp,32
    0x84012054    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeMove` has 11 nodes.

Section invokeCNodeInsert (250 of 432)
======================================

Deriving specifications
-----------------------

Section `invokeCNodeInsert` consists of 7 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeCNodeInsert`:

    0x84011fc0    0x0    addi sp,sp,-32
    0x84011fc2    0x2    sd ra,24(sp)          ; stack access
    0x84011fc4    0x4    jal ra,ffffffff84011e56 <cteInsert>
    0x84011fc8    0x8    li a0,0
    0x84011fca    0xa    ld ra,24(sp)          ; stack access
    0x84011fcc    0xc    addi sp,sp,32
    0x84011fce    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeInsert` has 11 nodes.

Section switchToIdleThread (251 of 432)
=======================================

Deriving specifications
-----------------------

Section `switchToIdleThread` consists of 10 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `switchToIdleThread`:

    0x84011dfc     0x0    addi sp,sp,-16
    0x84011dfe     0x2    sd ra,8(sp)           ; stack access
    0x84011e00     0x4    jal ra,ffffffff840113ee <Arch_switchToIdleThread>
    0x84011e04     0x8    auipc a5,0xc
    0x84011e08     0xc    ld a5,-476(a5) # ffffffff8401dc28 <ksIdleThread>
    0x84011e0c    0x10    auipc a4,0x1d
    0x84011e10    0x14    sd a5,-884(a4) # ffffffff8402ea98 <ksCurThread>
    0x84011e14    0x18    ld ra,8(sp)           ; stack access
    0x84011e16    0x1a    addi sp,sp,16
    0x84011e18    0x1c    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `switchToIdleThread` has 16 nodes.

Section lookupPivotSlot (252 of 432)
====================================

Deriving specifications
-----------------------

Section `lookupPivotSlot` consists of 12 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `lookupPivotSlot`:

    0x84011d94     0x0    addi sp,sp,-48
    0x84011d96     0x2    sd ra,40(sp)          ; stack access
    0x84011d98     0x4    mv a5,a1
    0x84011d9a     0x6    mv a4,a3
    0x84011d9c     0x8    mv a3,a2
    0x84011d9e     0xa    mv a1,a0
    0x84011da0     0xc    mv a2,a5
    0x84011da2     0xe    li a0,1
    0x84011da4    0x10    jal ra,ffffffff84011c7e <lookupSlotForCNodeOp>
    0x84011da8    0x14    ld ra,40(sp)          ; stack access
    0x84011daa    0x16    addi sp,sp,48
    0x84011dac    0x18    ret

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupPivotSlot` has 16 nodes.

Section lookupTargetSlot (253 of 432)
=====================================

Deriving specifications
-----------------------

Section `lookupTargetSlot` consists of 12 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `lookupTargetSlot`:

    0x84011d7a     0x0    addi sp,sp,-48
    0x84011d7c     0x2    sd ra,40(sp)          ; stack access
    0x84011d7e     0x4    mv a5,a1
    0x84011d80     0x6    mv a4,a3
    0x84011d82     0x8    mv a3,a2
    0x84011d84     0xa    mv a1,a0
    0x84011d86     0xc    mv a2,a5
    0x84011d88     0xe    li a0,0
    0x84011d8a    0x10    jal ra,ffffffff84011c7e <lookupSlotForCNodeOp>
    0x84011d8e    0x14    ld ra,40(sp)          ; stack access
    0x84011d90    0x16    addi sp,sp,48
    0x84011d92    0x18    ret

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupTargetSlot` has 16 nodes.

Section lookupSourceSlot (254 of 432)
=====================================

Deriving specifications
-----------------------

Section `lookupSourceSlot` consists of 12 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `lookupSourceSlot`:

    0x84011d60     0x0    addi sp,sp,-48
    0x84011d62     0x2    sd ra,40(sp)          ; stack access
    0x84011d64     0x4    mv a5,a1
    0x84011d66     0x6    mv a4,a3
    0x84011d68     0x8    mv a3,a2
    0x84011d6a     0xa    mv a1,a0
    0x84011d6c     0xc    mv a2,a5
    0x84011d6e     0xe    li a0,1
    0x84011d70    0x10    jal ra,ffffffff84011c7e <lookupSlotForCNodeOp>
    0x84011d74    0x14    ld ra,40(sp)          ; stack access
    0x84011d76    0x16    addi sp,sp,48
    0x84011d78    0x18    ret

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupSourceSlot` has 16 nodes.

Section lookupSlot (255 of 432)
===============================

Deriving specifications
-----------------------

Section `lookupSlot` consists of 14 instructions.

RVC_FFFFFFFFFFT___FF.

Stack analysis
---------------

4 stack accesses found. Annotated code for `lookupSlot`:

    0x84011bd8     0x0    addi sp,sp,-80
    0x84011bda     0x2    sd ra,72(sp)          ; stack access
    0x84011bdc     0x4    mv a3,a1
    0x84011bde     0x6    andi a0,a0,-1024
    0x84011be2     0xa    li a4,64
    0x84011be6     0xe    ld a1,0(a0)
    0x84011be8    0x10    ld a2,8(a0)
    0x84011bea    0x12    addi a0,sp,8
    0x84011bec    0x14    jal ra,ffffffff84011a94 <resolveAddressBits>
    0x84011bf0    0x18    ld a0,8(sp)           ; stack access
    0x84011bf2    0x1a    ld a1,16(sp)          ; stack access
    0x84011bf4    0x1c    ld ra,72(sp)          ; stack access
    0x84011bf6    0x1e    addi sp,sp,80
    0x84011bf8    0x20    ret

Proving inst theorems
---------------------

14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupSlot` has 22 nodes.

Section Arch_getObjectSize (256 of 432)
=======================================

Deriving specifications
-----------------------

Section `Arch_getObjectSize` consists of 19 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `Arch_getObjectSize`:

    0x840119dc     0x0    li a4,7
    0x840119de     0x2    beq a0,a4,ffffffff84011a0a <Arch_getObjectSize+0x2e>
    0x840119e2     0x6    mv a5,a0
    0x840119e4     0x8    bltu a4,a0,ffffffff840119fa <Arch_getObjectSize+0x1e>
    0x840119e8     0xc    li a4,5
    0x840119ea     0xe    li a0,30
    0x840119ec    0x10    beq a5,a4,ffffffff840119f8 <Arch_getObjectSize+0x1c>
    0x840119f0    0x14    li a4,6
    0x840119f2    0x16    li a0,12
    0x840119f4    0x18    bne a5,a4,ffffffff84011a02 <Arch_getObjectSize+0x26>
    0x840119f8    0x1c    ret
    0x840119fa    0x1e    li a4,8
    0x840119fc    0x20    li a0,12
    0x840119fe    0x22    beq a5,a4,ffffffff840119f8 <Arch_getObjectSize+0x1c>
    0x84011a02    0x26    addi sp,sp,-16
    0x84011a04    0x28    sd ra,8(sp)           ; stack access
    0x84011a06    0x2a    jal ra,ffffffff84010cec <halt>
    0x84011a0a    0x2e    li a0,21
    0x84011a0c    0x30    j ffffffff840119f8 <Arch_getObjectSize+0x1c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
19 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_getObjectSize` has 32 nodes.

Section deleteASID (257 of 432)
===============================

Deriving specifications
-----------------------

Section `deleteASID` consists of 23 instructions.

Skipping 12a00073 sfence.vma zero,a0


Stack analysis
---------------

2 stack accesses found. Annotated code for `deleteASID`:

    0x84011442     0x0    srli a5,a0,0x9
    0x84011446     0x4    slli a4,a5,0x3
    0x8401144a     0x8    auipc a5,0xb
    0x8401144e     0xc    addi a5,a5,990 # ffffffff8401c828 <riscvKSASIDTable>
    0x84011452    0x10    add a5,a5,a4
    0x84011454    0x12    ld a5,0(a5)
    0x84011456    0x14    beqz a5,ffffffff84011466 <deleteASID+0x24>
    0x84011458    0x16    andi a4,a0,511
    0x8401145c    0x1a    slli a4,a4,0x3
    0x8401145e    0x1c    add a5,a5,a4
    0x84011460    0x1e    ld a4,0(a5)
    0x84011462    0x20    beq a4,a1,ffffffff84011468 <deleteASID+0x26>
    0x84011466    0x24    ret
    0x84011468    0x26    addi sp,sp,-16
    0x8401146a    0x28    sd ra,8(sp)           ; stack access
    0x8401146c    0x2a    sfence.vma zero,a0
    0x84011470    0x2e    sd zero,0(a5)
    0x84011474    0x32    auipc a0,0x1d
    0x84011478    0x36    ld a0,1572(a0) # ffffffff8402ea98 <ksCurThread>
    0x8401147c    0x3a    jal ra,ffffffff84011336 <setVMRoot>
    0x84011480    0x3e    ld ra,8(sp)           ; stack access
    0x84011482    0x40    addi sp,sp,16
    0x84011484    0x42    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deleteASID` has 37 nodes.

Section deleteASIDPool (258 of 432)
===================================

Deriving specifications
-----------------------

Section `deleteASIDPool` consists of 20 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `deleteASIDPool`:

    0x84011404     0x0    srli a0,a0,0x9
    0x84011406     0x2    slli a4,a0,0x3
    0x8401140a     0x6    auipc a5,0xb
    0x8401140e     0xa    addi a5,a5,1054 # ffffffff8401c828 <riscvKSASIDTable>
    0x84011412     0xe    add a5,a5,a4
    0x84011414    0x10    ld a5,0(a5)
    0x84011416    0x12    beq a5,a1,ffffffff8401141c <deleteASIDPool+0x18>
    0x8401141a    0x16    ret
    0x8401141c    0x18    addi sp,sp,-16
    0x8401141e    0x1a    sd ra,8(sp)           ; stack access
    0x84011420    0x1c    auipc a5,0xb
    0x84011424    0x20    addi a5,a5,1032 # ffffffff8401c828 <riscvKSASIDTable>
    0x84011428    0x24    add a0,a5,a4
    0x8401142c    0x28    sd zero,0(a0)
    0x84011430    0x2c    auipc a0,0x1d
    0x84011434    0x30    ld a0,1640(a0) # ffffffff8402ea98 <ksCurThread>
    0x84011438    0x34    jal ra,ffffffff84011336 <setVMRoot>
    0x8401143c    0x38    ld ra,8(sp)           ; stack access
    0x8401143e    0x3a    addi sp,sp,16
    0x84011440    0x3c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deleteASIDPool` has 30 nodes.

Section Arch_switchToIdleThread (259 of 432)
============================================

Deriving specifications
-----------------------

Section `Arch_switchToIdleThread` consists of 8 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `Arch_switchToIdleThread`:

    0x840113ee     0x0    addi sp,sp,-16
    0x840113f0     0x2    sd ra,8(sp)           ; stack access
    0x840113f2     0x4    auipc a0,0xd
    0x840113f6     0x8    ld a0,-1994(a0) # ffffffff8401dc28 <ksIdleThread>
    0x840113fa     0xc    jal ra,ffffffff84011336 <setVMRoot>
    0x840113fe    0x10    ld ra,8(sp)           ; stack access
    0x84011400    0x12    addi sp,sp,16
    0x84011402    0x14    ret

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_switchToIdleThread` has 13 nodes.

Section Arch_switchToThread (260 of 432)
========================================

Deriving specifications
-----------------------

Section `Arch_switchToThread` consists of 6 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `Arch_switchToThread`:

    0x840113e0    0x0    addi sp,sp,-16
    0x840113e2    0x2    sd ra,8(sp)           ; stack access
    0x840113e4    0x4    jal ra,ffffffff84011336 <setVMRoot>
    0x840113e8    0x8    ld ra,8(sp)           ; stack access
    0x840113ea    0xa    addi sp,sp,16
    0x840113ec    0xc    ret

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_switchToThread` has 10 nodes.

Section Arch_handleFaultReply (261 of 432)
==========================================

Deriving specifications
-----------------------

Section `Arch_handleFaultReply` consists of 7 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `Arch_handleFaultReply`:

    0x84010cf8    0x0    li a5,5
    0x84010cfa    0x2    bne a2,a5,ffffffff84010d02 <Arch_handleFaultReply+0xa>
    0x84010cfe    0x6    li a0,1
    0x84010d00    0x8    ret
    0x84010d02    0xa    addi sp,sp,-16
    0x84010d04    0xc    sd ra,8(sp)           ; stack access
    0x84010d06    0xe    jal ra,ffffffff84010cec <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_handleFaultReply` has 12 nodes.

Section findVSpaceForASID (262 of 432)
======================================

Deriving specifications
-----------------------

Section `findVSpaceForASID` consists of 39 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `findVSpaceForASID`:

    0x84010922     0x0    addi sp,sp,-32
    0x84010924     0x2    sd ra,24(sp)          ; stack access
    0x84010926     0x4    srli a5,a0,0x9
    0x8401092a     0x8    slli a4,a5,0x3
    0x8401092e     0xc    auipc a5,0xc
    0x84010932    0x10    addi a5,a5,-262 # ffffffff8401c828 <riscvKSASIDTable>
    0x84010936    0x14    add a5,a5,a4
    0x84010938    0x16    ld a5,0(a5)
    0x8401093a    0x18    beqz a5,ffffffff84010956 <findVSpaceForASID+0x34>
    0x8401093c    0x1a    andi a0,a0,511
    0x84010940    0x1e    slli a0,a0,0x3
    0x84010942    0x20    add a0,a0,a5
    0x84010944    0x22    ld a5,0(a0)
    0x84010946    0x24    beqz a5,ffffffff8401096e <findVSpaceForASID+0x4c>
    0x84010948    0x26    sd zero,0(sp)         ; stack access
    0x8401094a    0x28    sd a5,8(sp)           ; stack access
    0x8401094c    0x2a    ld a0,0(sp)           ; stack access
    0x8401094e    0x2c    ld a1,8(sp)           ; stack access
    0x84010950    0x2e    ld ra,24(sp)          ; stack access
    0x84010952    0x30    addi sp,sp,32
    0x84010954    0x32    ret
    0x84010956    0x34    jal ra,ffffffff840107b0 <lookup_fault_invalid_root_new>
    0x8401095a    0x38    auipc a5,0xd
    0x8401095e    0x3c    addi a5,a5,726 # ffffffff8401dc30 <current_lookup_fault>
    0x84010962    0x40    sd a0,0(a5)
    0x84010964    0x42    sd a1,8(a5)
    0x84010966    0x44    li a5,2
    0x84010968    0x46    sd a5,0(sp)           ; stack access
    0x8401096a    0x48    sd zero,8(sp)         ; stack access
    0x8401096c    0x4a    j ffffffff8401094c <findVSpaceForASID+0x2a>
    0x8401096e    0x4c    jal ra,ffffffff840107b0 <lookup_fault_invalid_root_new>
    0x84010972    0x50    auipc a5,0xd
    0x84010976    0x54    addi a5,a5,702 # ffffffff8401dc30 <current_lookup_fault>
    0x8401097a    0x58    sd a0,0(a5)
    0x8401097c    0x5a    sd a1,8(a5)
    0x8401097e    0x5c    li a5,2
    0x84010980    0x5e    sd a5,0(sp)           ; stack access
    0x84010982    0x60    sd zero,8(sp)         ; stack access
    0x84010984    0x62    j ffffffff8401094c <findVSpaceForASID+0x2a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
39 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `findVSpaceForASID` has 62 nodes.

Section pte_next (263 of 432)
=============================

Deriving specifications
-----------------------

Section `pte_next` consists of 17 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `pte_next`:

    0x840108fc     0x0    addi sp,sp,-32
    0x840108fe     0x2    sd ra,24(sp)          ; stack access
    0x84010900     0x4    snez a6,a1
    0x84010904     0x8    li a5,1
    0x84010906     0xa    sd a5,8(sp)           ; stack access
    0x84010908     0xc    sd a6,0(sp)           ; stack access
    0x8401090a     0xe    mv a7,a6
    0x8401090c    0x10    li a5,0
    0x8401090e    0x12    li a4,1
    0x84010910    0x14    li a3,1
    0x84010912    0x16    li a2,1
    0x84010914    0x18    li a1,0
    0x84010916    0x1a    srli a0,a0,0xc
    0x84010918    0x1c    jal ra,ffffffff8401026a <pte_new>
    0x8401091c    0x20    ld ra,24(sp)          ; stack access
    0x8401091e    0x22    addi sp,sp,32
    0x84010920    0x24    ret

Proving inst theorems
---------------------

17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `pte_next` has 23 nodes.

Section interrupt (264 of 432)
==============================

Deriving specifications
-----------------------

Section `interrupt` consists of 2 instructions.

JAL_NOP.

Stack analysis
---------------

No stack accesses found. Code for `interrupt`:

    0x840100cc    0x0    sd ra,272(t0)
    0x840100d0    0x4    j ffffffff840148de <c_handle_interrupt>

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `interrupt` has 4 nodes.

Section exception (265 of 432)
==============================

Deriving specifications
-----------------------

Section `exception` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `exception`:

    0x840100c4    0x0    sd ra,272(t0)
    0x840100c8    0x4    j ffffffff8401506c <c_handle_exception>

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `exception` has 4 nodes.

Section syscall (266 of 432)
============================

Deriving specifications
-----------------------

Section `syscall` consists of 3 instructions.

RVC_FFFFFFFFT_____FT.

Stack analysis
---------------

No stack accesses found. Code for `syscall`:

    0x840100ba    0x0    addi ra,ra,4
    0x840100bc    0x2    sd ra,272(t0)
    0x840100c0    0x6    j ffffffff84017d72 <c_handle_syscall>

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `syscall` has 5 nodes.

Section maybe_alloc_extra_bi (267 of 432)
=========================================

Deriving specifications
-----------------------

Section `maybe_alloc_extra_bi` consists of 16 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `maybe_alloc_extra_bi`:

    0x84000e38     0x0    bltu a1,a0,ffffffff84000e48 <maybe_alloc_extra_bi+0x10>
    0x84000e3c     0x4    mv a5,a1
    0x84000e3e     0x6    auipc a4,0x1
    0x84000e42     0xa    ld a4,-1702(a4) # ffffffff84001798 <rootserver+0x28>
    0x84000e46     0xe    beqz a4,ffffffff84000e4a <maybe_alloc_extra_bi+0x12>
    0x84000e48    0x10    ret
    0x84000e4a    0x12    addi sp,sp,-16
    0x84000e4c    0x14    sd ra,8(sp)           ; stack access
    0x84000e4e    0x16    li a1,1
    0x84000e50    0x18    mv a0,a5
    0x84000e52    0x1a    jal ra,ffffffff84000e0a <alloc_rootserver_obj>
    0x84000e56    0x1e    auipc a5,0x1
    0x84000e5a    0x22    sd a0,-1726(a5) # ffffffff84001798 <rootserver+0x28>
    0x84000e5e    0x26    ld ra,8(sp)           ; stack access
    0x84000e60    0x28    addi sp,sp,16
    0x84000e62    0x2a    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `maybe_alloc_extra_bi` has 27 nodes.

Section alloc_rootserver_obj (268 of 432)
=========================================

Deriving specifications
-----------------------

Section `alloc_rootserver_obj` consists of 16 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `alloc_rootserver_obj`:

    0x84000e0a     0x0    addi sp,sp,-16
    0x84000e0c     0x2    sd ra,8(sp)           ; stack access
    0x84000e0e     0x4    sd s0,0(sp)           ; stack access
    0x84000e10     0x6    auipc a5,0x0
    0x84000e14     0xa    addi a5,a5,1792 # ffffffff84001510 <ndks_boot>
    0x84000e18     0xe    ld s0,680(a5)
    0x84000e1c    0x12    sll a1,a1,a0
    0x84000e20    0x16    add a4,a1,s0
    0x84000e24    0x1a    sd a4,680(a5)
    0x84000e28    0x1e    mv a0,s0
    0x84000e2a    0x20    jal ra,ffffffff840164dc <memzero>
    0x84000e2e    0x24    mv a0,s0
    0x84000e30    0x26    ld ra,8(sp)           ; stack access
    0x84000e32    0x28    ld s0,0(sp)           ; stack access
    0x84000e34    0x2a    addi sp,sp,16
    0x84000e36    0x2c    ret

Proving inst theorems
---------------------

16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `alloc_rootserver_obj` has 24 nodes.

Section create_idle_thread (269 of 432)
=======================================

Deriving specifications
-----------------------

Section `create_idle_thread` consists of 11 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `create_idle_thread`:

    0x84000ce8     0x0    addi sp,sp,-16
    0x84000cea     0x2    sd ra,8(sp)           ; stack access
    0x84000cec     0x4    auipc a0,0x18
    0x84000cf0     0x8    addi a0,a0,-1260 # ffffffff84018800 <__global_pointer$+0xbe>
    0x84000cf4     0xc    auipc a5,0x1d
    0x84000cf8    0x10    sd a0,-204(a5) # ffffffff8401dc28 <ksIdleThread>
    0x84000cfc    0x14    jal ra,ffffffff84000cba <configureIdleThread>
    0x84000d00    0x18    li a0,1
    0x84000d02    0x1a    ld ra,8(sp)           ; stack access
    0x84000d04    0x1c    addi sp,sp,16
    0x84000d06    0x1e    ret

Proving inst theorems
---------------------

11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_idle_thread` has 16 nodes.

Section configureIdleThread (270 of 432)
========================================

Deriving specifications
-----------------------

Section `configureIdleThread` consists of 15 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `configureIdleThread`:

    0x84000cba     0x0    addi sp,sp,-16
    0x84000cbc     0x2    sd ra,8(sp)           ; stack access
    0x84000cbe     0x4    auipc a4,0x10
    0x84000cc2     0x8    addi a4,a4,-968 # ffffffff840108f6 <idle_thread>
    0x84000cc6     0xc    sd a4,272(a0)
    0x84000cca    0x10    li a4,288
    0x84000cce    0x14    sd a4,256(a0)
    0x84000cd2    0x18    auipc a4,0x1d
    0x84000cd6    0x1c    addi a4,a4,-170 # ffffffff8401dc28 <ksIdleThread>
    0x84000cda    0x20    sd a4,8(a0)
    0x84000cdc    0x22    li a1,7
    0x84000cde    0x24    jal ra,ffffffff84013020 <setThreadState>
    0x84000ce2    0x28    ld ra,8(sp)           ; stack access
    0x84000ce4    0x2a    addi sp,sp,16
    0x84000ce6    0x2c    ret

Proving inst theorems
---------------------

15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `configureIdleThread` has 22 nodes.

Section create_kernel_untypeds (271 of 432)
===========================================

Deriving specifications
-----------------------

Section `create_kernel_untypeds` consists of 38 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `create_kernel_untypeds`:

    0x84000b12     0x0    addi sp,sp,-80
    0x84000b14     0x2    sd ra,72(sp)          ; stack access
    0x84000b16     0x4    sd s0,64(sp)          ; stack access
    0x84000b18     0x6    sd s1,56(sp)          ; stack access
    0x84000b1a     0x8    sd s2,48(sp)          ; stack access
    0x84000b1c     0xa    sd a0,16(sp)          ; stack access
    0x84000b1e     0xc    sd a1,24(sp)          ; stack access
    0x84000b20     0xe    mv a6,a3
    0x84000b22    0x10    mv s1,a4
    0x84000b24    0x12    mv a5,a4
    0x84000b26    0x14    mv a3,a2
    0x84000b28    0x16    mv a4,a6
    0x84000b2a    0x18    li a2,0
    0x84000b2c    0x1a    jal ra,ffffffff8400097c <create_untypeds_for_region>
    0x84000b30    0x1e    beqz a0,ffffffff84000b64 <create_kernel_untypeds+0x52>
    0x84000b32    0x20    auipc s0,0x1
    0x84000b36    0x24    addi s0,s0,-1242 # ffffffff84001658 <ndks_boot+0x148>
    0x84000b3a    0x28    auipc s2,0x1
    0x84000b3e    0x2c    addi s2,s2,-994 # ffffffff84001758 <ndks_boot+0x248>
    0x84000b42    0x30    ld a3,0(s0)
    0x84000b44    0x32    ld a4,8(s0)
    0x84000b46    0x34    sd zero,0(s0)
    0x84000b4a    0x38    sd zero,8(s0)
    0x84000b4e    0x3c    mv a5,s1
    0x84000b50    0x3e    li a2,0
    0x84000b52    0x40    ld a0,16(sp)          ; stack access
    0x84000b54    0x42    ld a1,24(sp)          ; stack access
    0x84000b56    0x44    jal ra,ffffffff8400097c <create_untypeds_for_region>
    0x84000b5a    0x48    beqz a0,ffffffff84000b64 <create_kernel_untypeds+0x52>
    0x84000b5c    0x4a    addi s0,s0,16
    0x84000b5e    0x4c    bne s0,s2,ffffffff84000b42 <create_kernel_untypeds+0x30>
    0x84000b62    0x50    li a0,1
    0x84000b64    0x52    ld ra,72(sp)          ; stack access
    0x84000b66    0x54    ld s0,64(sp)          ; stack access
    0x84000b68    0x56    ld s1,56(sp)          ; stack access
    0x84000b6a    0x58    ld s2,48(sp)          ; stack access
    0x84000b6c    0x5a    addi sp,sp,80
    0x84000b6e    0x5c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
38 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_kernel_untypeds` has 63 nodes.

Section create_device_untypeds (272 of 432)
===========================================

Deriving specifications
-----------------------

Section `create_device_untypeds` consists of 64 instructions.

RVC_FTTFFFFTFFT___FT.

Stack analysis
---------------

20 stack accesses found. Annotated code for `create_device_untypeds`:

    0x84000a78     0x0    addi sp,sp,-96
    0x84000a7a     0x2    sd ra,88(sp)          ; stack access
    0x84000a7c     0x4    sd s0,80(sp)          ; stack access
    0x84000a7e     0x6    sd s1,72(sp)          ; stack access
    0x84000a80     0x8    sd s2,64(sp)          ; stack access
    0x84000a82     0xa    sd s3,56(sp)          ; stack access
    0x84000a84     0xc    sd s4,48(sp)          ; stack access
    0x84000a86     0xe    sd s5,40(sp)          ; stack access
    0x84000a88    0x10    sd a0,0(sp)           ; stack access
    0x84000a8a    0x12    sd a1,8(sp)           ; stack access
    0x84000a8c    0x14    mv s5,a2
    0x84000a8e    0x16    auipc a3,0x1
    0x84000a92    0x1a    ld a3,-1086(a3) # ffffffff84001650 <ndks_boot+0x140>
    0x84000a96    0x1e    beqz a3,ffffffff84000af6 <create_device_untypeds+0x7e>
    0x84000a98    0x20    auipc s0,0x1
    0x84000a9c    0x24    addi s0,s0,-1416 # ffffffff84001510 <ndks_boot>
    0x84000aa0    0x28    li s1,0
    0x84000aa2    0x2a    li a3,0
    0x84000aa4    0x2c    li s4,-1
    0x84000aa6    0x2e    slli s4,s4,0x26
    0x84000aa8    0x30    mv s3,s0
    0x84000aaa    0x32    j ffffffff84000abc <create_device_untypeds+0x44>
    0x84000aac    0x34    ld a3,8(s2)
    0x84000ab0    0x38    addi s1,s1,1
    0x84000ab2    0x3a    addi s0,s0,16
    0x84000ab4    0x3c    ld a5,320(s3) # 1140 <KERNEL_OFFSET-0xfffffffeffffeec0>
    0x84000ab8    0x40    bgeu s1,a5,ffffffff84000ad8 <create_device_untypeds+0x60>
    0x84000abc    0x44    mv s2,s0
    0x84000abe    0x46    ld a4,0(s0)
    0x84000ac0    0x48    bgeu a3,a4,ffffffff84000aac <create_device_untypeds+0x34>
    0x84000ac4    0x4c    mv a5,s5
    0x84000ac6    0x4e    add a3,a3,s4
    0x84000ac8    0x50    add a4,a4,s4
    0x84000aca    0x52    li a2,1
    0x84000acc    0x54    ld a0,0(sp)           ; stack access
    0x84000ace    0x56    ld a1,8(sp)           ; stack access
    0x84000ad0    0x58    jal ra,ffffffff8400097c <create_untypeds_for_region>
    0x84000ad4    0x5c    bnez a0,ffffffff84000aac <create_device_untypeds+0x34>
    0x84000ad6    0x5e    j ffffffff84000ae4 <create_device_untypeds+0x6c>
    0x84000ad8    0x60    lui a5,0xfc000
    0x84000adc    0x64    srli a5,a5,0x19
    0x84000ade    0x66    li a0,1
    0x84000ae0    0x68    bgeu a5,a3,ffffffff84000af6 <create_device_untypeds+0x7e>
    0x84000ae4    0x6c    ld ra,88(sp)          ; stack access
    0x84000ae6    0x6e    ld s0,80(sp)          ; stack access
    0x84000ae8    0x70    ld s1,72(sp)          ; stack access
    0x84000aea    0x72    ld s2,64(sp)          ; stack access
    0x84000aec    0x74    ld s3,56(sp)          ; stack access
    0x84000aee    0x76    ld s4,48(sp)          ; stack access
    0x84000af0    0x78    ld s5,40(sp)          ; stack access
    0x84000af2    0x7a    addi sp,sp,96
    0x84000af4    0x7c    ret
    0x84000af6    0x7e    li a4,-1
    0x84000af8    0x80    slli a2,a4,0x26
    0x84000afc    0x84    mv a5,s5
    0x84000afe    0x86    add a3,a3,a2
    0x84000b00    0x88    srli a4,a4,0x1a
    0x84000b02    0x8a    li a2,1
    0x84000b04    0x8c    ld a0,0(sp)           ; stack access
    0x84000b06    0x8e    ld a1,8(sp)           ; stack access
    0x84000b08    0x90    jal ra,ffffffff8400097c <create_untypeds_for_region>
    0x84000b0c    0x94    beqz a0,ffffffff84000ae4 <create_device_untypeds+0x6c>
    0x84000b0e    0x96    li a0,1
    0x84000b10    0x98    j ffffffff84000ae4 <create_device_untypeds+0x6c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
64 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_device_untypeds` has 103 nodes.

Section calculate_extra_bi_size_bits (273 of 432)
=================================================

Deriving specifications
-----------------------

Section `calculate_extra_bi_size_bits` consists of 22 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `calculate_extra_bi_size_bits`:

    0x840006b6     0x0    addi sp,sp,-16
    0x840006b8     0x2    sd ra,8(sp)           ; stack access
    0x840006ba     0x4    sd s0,0(sp)           ; stack access
    0x840006bc     0x6    mv s0,a0
    0x840006be     0x8    beqz a0,ffffffff840006e6 <calculate_extra_bi_size_bits+0x30>
    0x840006c0     0xa    addi a0,a0,-1
    0x840006c2     0xc    srli a0,a0,0xc
    0x840006c4     0xe    addi a0,a0,1
    0x840006c6    0x10    slli a0,a0,0xc
    0x840006c8    0x12    jal ra,ffffffff84017f02 <__clzdi2>
    0x840006cc    0x16    sext.w a5,a0
    0x840006d0    0x1a    li a0,63
    0x840006d4    0x1e    sub a0,a0,a5
    0x840006d6    0x20    li a4,1
    0x840006d8    0x22    sll a4,a4,a0
    0x840006dc    0x26    bgeu a4,s0,ffffffff840006e6 <calculate_extra_bi_size_bits+0x30>
    0x840006e0    0x2a    li a0,64
    0x840006e4    0x2e    sub a0,a0,a5
    0x840006e6    0x30    ld ra,8(sp)           ; stack access
    0x840006e8    0x32    ld s0,0(sp)           ; stack access
    0x840006ea    0x34    addi sp,sp,16
    0x840006ec    0x36    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `calculate_extra_bi_size_bits` has 32 nodes.

Section insert_region (274 of 432)
==================================

Deriving specifications
-----------------------

Section `insert_region` consists of 39 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `insert_region`:

    0x8400055e     0x0    addi sp,sp,-48
    0x84000560     0x2    sd ra,40(sp)          ; stack access
    0x84000562     0x4    sd s0,32(sp)          ; stack access
    0x84000564     0x6    sd a0,0(sp)           ; stack access
    0x84000566     0x8    sd a1,8(sp)           ; stack access
    0x84000568     0xa    beq a0,a1,ffffffff840005b8 <insert_region+0x5a>
    0x8400056c     0xe    auipc a5,0x1
    0x84000570    0x12    addi a5,a5,236 # ffffffff84001658 <ndks_boot+0x148>
    0x84000574    0x16    li s0,0
    0x84000576    0x18    li a2,16
    0x84000578    0x1a    ld a3,0(a5)
    0x8400057a    0x1c    ld a4,8(a5)
    0x8400057c    0x1e    beq a3,a4,ffffffff84000592 <insert_region+0x34>
    0x84000580    0x22    addi s0,s0,1
    0x84000582    0x24    addi a5,a5,16
    0x84000584    0x26    bne s0,a2,ffffffff84000578 <insert_region+0x1a>
    0x84000588    0x2a    li a0,0
    0x8400058a    0x2c    ld ra,40(sp)          ; stack access
    0x8400058c    0x2e    ld s0,32(sp)          ; stack access
    0x8400058e    0x30    addi sp,sp,48
    0x84000590    0x32    ret
    0x84000592    0x34    li a5,1
    0x84000594    0x36    slli a5,a5,0x26
    0x84000596    0x38    add a0,a0,a5
    0x84000598    0x3a    add a1,a1,a5
    0x8400059a    0x3c    jal ra,ffffffff84000388 <reserve_region>
    0x8400059e    0x40    addi s0,s0,20
    0x840005a0    0x42    slli s0,s0,0x4
    0x840005a2    0x44    auipc a5,0x1
    0x840005a6    0x48    addi a5,a5,-146 # ffffffff84001510 <ndks_boot>
    0x840005aa    0x4c    add s0,s0,a5
    0x840005ac    0x4e    ld a5,0(sp)           ; stack access
    0x840005ae    0x50    sd a5,8(s0)
    0x840005b0    0x52    ld a5,8(sp)           ; stack access
    0x840005b2    0x54    sd a5,16(s0)
    0x840005b4    0x56    li a0,1
    0x840005b6    0x58    j ffffffff8400058a <insert_region+0x2c>
    0x840005b8    0x5a    li a0,1
    0x840005ba    0x5c    j ffffffff8400058a <insert_region+0x2c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
39 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `insert_region` has 59 nodes.

Section reserve_region (275 of 432)
===================================

Deriving specifications
-----------------------

Section `reserve_region` consists of 81 instructions.

RVC_TFFFFT___FFT__TF.
RVC_TFFTT____FT___TF.
RVC_TFFTFFT__FT___TF.

Stack analysis
---------------

2 stack accesses found. Annotated code for `reserve_region`:

    0x84000388     0x0    beq a0,a1,ffffffff84000478 <reserve_region+0xf0>
    0x8400038c     0x4    addi sp,sp,-32
    0x8400038e     0x6    sd ra,24(sp)          ; stack access
    0x84000390     0x8    mv a7,a0
    0x84000392     0xa    auipc a6,0x1
    0x84000396     0xe    ld a6,702(a6) # ffffffff84001650 <ndks_boot+0x140>
    0x8400039a    0x12    beqz a6,ffffffff840003ca <reserve_region+0x42>
    0x8400039e    0x16    auipc t1,0x1
    0x840003a2    0x1a    addi t1,t1,370 # ffffffff84001510 <ndks_boot>
    0x840003a6    0x1e    mv a5,t1
    0x840003a8    0x20    li a4,0
    0x840003aa    0x22    ld a3,0(a5)
    0x840003ac    0x24    beq a3,a1,ffffffff840003ec <reserve_region+0x64>
    0x840003b0    0x28    ld a2,8(a5)
    0x840003b2    0x2a    beq a2,a7,ffffffff84000408 <reserve_region+0x80>
    0x840003b6    0x2e    bltu a1,a3,ffffffff8400041e <reserve_region+0x96>
    0x840003ba    0x32    addi a4,a4,1
    0x840003bc    0x34    addi a5,a5,16
    0x840003be    0x36    bne a4,a6,ffffffff840003aa <reserve_region+0x22>
    0x840003c2    0x3a    li a5,19
    0x840003c4    0x3c    li a0,0
    0x840003c6    0x3e    beq a6,a5,ffffffff84000402 <reserve_region+0x7a>
    0x840003ca    0x42    auipc a5,0x1
    0x840003ce    0x46    addi a5,a5,326 # ffffffff84001510 <ndks_boot>
    0x840003d2    0x4a    slli a6,a6,0x4
    0x840003d4    0x4c    add a6,a6,a5
    0x840003d6    0x4e    sd a7,0(a6)
    0x840003da    0x52    sd a1,8(a6)
    0x840003de    0x56    ld a4,320(a5)
    0x840003e2    0x5a    addi a4,a4,1
    0x840003e4    0x5c    sd a4,320(a5)
    0x840003e8    0x60    li a0,1
    0x840003ea    0x62    j ffffffff84000402 <reserve_region+0x7a>
    0x840003ec    0x64    slli a4,a4,0x4
    0x840003ee    0x66    auipc a5,0x1
    0x840003f2    0x6a    addi a5,a5,290 # ffffffff84001510 <ndks_boot>
    0x840003f6    0x6e    add a4,a4,a5
    0x840003f8    0x70    sd a7,0(a4)
    0x840003fc    0x74    jal ra,ffffffff84000026 <merge_regions>
    0x84000400    0x78    li a0,1
    0x84000402    0x7a    ld ra,24(sp)          ; stack access
    0x84000404    0x7c    addi sp,sp,32
    0x84000406    0x7e    ret
    0x84000408    0x80    slli a4,a4,0x4
    0x8400040a    0x82    auipc a5,0x1
    0x8400040e    0x86    addi a5,a5,262 # ffffffff84001510 <ndks_boot>
    0x84000412    0x8a    add a4,a4,a5
    0x84000414    0x8c    sd a1,8(a4)
    0x84000416    0x8e    jal ra,ffffffff84000026 <merge_regions>
    0x8400041a    0x92    li a0,1
    0x8400041c    0x94    j ffffffff84000402 <reserve_region+0x7a>
    0x8400041e    0x96    addi a5,a6,1
    0x84000422    0x9a    li a3,19
    0x84000424    0x9c    li a0,0
    0x84000426    0x9e    bltu a3,a5,ffffffff84000402 <reserve_region+0x7a>
    0x8400042a    0xa2    bgeu a4,a6,ffffffff84000456 <reserve_region+0xce>
    0x8400042e    0xa6    slli a6,a6,0x4
    0x84000430    0xa8    auipc a5,0x1
    0x84000434    0xac    addi a5,a5,224 # ffffffff84001510 <ndks_boot>
    0x84000438    0xb0    add a6,a6,a5
    0x8400043a    0xb2    slli a5,a4,0x4
    0x8400043e    0xb6    add t1,t1,a5
    0x84000440    0xb8    ld a5,-16(a6)
    0x84000444    0xbc    sd a5,0(a6)
    0x84000448    0xc0    ld a5,-8(a6)
    0x8400044c    0xc4    sd a5,8(a6)
    0x84000450    0xc8    addi a6,a6,-16
    0x84000452    0xca    bne a6,t1,ffffffff84000440 <reserve_region+0xb8>
    0x84000456    0xce    auipc a3,0x1
    0x8400045a    0xd2    addi a3,a3,186 # ffffffff84001510 <ndks_boot>
    0x8400045e    0xd6    slli a5,a4,0x4
    0x84000462    0xda    add a5,a5,a3
    0x84000464    0xdc    sd a7,0(a5)
    0x84000468    0xe0    sd a1,8(a5)
    0x8400046a    0xe2    ld a5,320(a3)
    0x8400046e    0xe6    addi a5,a5,1
    0x84000470    0xe8    sd a5,320(a3)
    0x84000474    0xec    li a0,1
    0x84000476    0xee    j ffffffff84000402 <reserve_region+0x7a>
    0x84000478    0xf0    li a0,1
    0x8400047a    0xf2    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
81 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `reserve_region` has 124 nodes.

Section write_it_asid_pool (276 of 432)
=======================================

Deriving specifications
-----------------------

Section `write_it_asid_pool` consists of 21 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `write_it_asid_pool`:

    0x84000166     0x0    addi sp,sp,-64
    0x84000168     0x2    sd ra,56(sp)          ; stack access
    0x8400016a     0x4    sd s0,48(sp)          ; stack access
    0x8400016c     0x6    sd s1,40(sp)          ; stack access
    0x8400016e     0x8    sd s2,32(sp)          ; stack access
    0x84000170     0xa    mv s2,a2
    0x84000172     0xc    mv s1,a3
    0x84000174     0xe    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x84000178    0x12    mv s0,a0
    0x8400017a    0x14    mv a0,s2
    0x8400017c    0x16    mv a1,s1
    0x8400017e    0x18    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x84000182    0x1c    sd a0,8(s0)
    0x84000184    0x1e    auipc a5,0x1c
    0x84000188    0x22    sd s0,1700(a5) # ffffffff8401c828 <riscvKSASIDTable>
    0x8400018c    0x26    ld ra,56(sp)          ; stack access
    0x8400018e    0x28    ld s0,48(sp)          ; stack access
    0x84000190    0x2a    ld s1,40(sp)          ; stack access
    0x84000192    0x2c    ld s2,32(sp)          ; stack access
    0x84000194    0x2e    addi sp,sp,64
    0x84000196    0x30    ret

Proving inst theorems
---------------------

21 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `write_it_asid_pool` has 34 nodes.

Section activate_kernel_vspace (277 of 432)
===========================================

Deriving specifications
-----------------------

Section `activate_kernel_vspace` consists of 16 instructions.

Skipping 18051073 csrw satp,a0

Skipping 12000073 sfence.vma


Stack analysis
---------------

2 stack accesses found. Annotated code for `activate_kernel_vspace`:

    0x8400013c     0x0    addi sp,sp,-16
    0x8400013e     0x2    sd ra,8(sp)           ; stack access
    0x84000140     0x4    auipc a2,0x1b
    0x84000144     0x8    addi a2,a2,-320 # ffffffff8401b000 <kernel_root_pageTable>
    0x84000148     0xc    li a5,1
    0x8400014a     0xe    slli a5,a5,0x20
    0x8400014c    0x10    add a2,a2,a5
    0x8400014e    0x12    srli a2,a2,0xc
    0x84000150    0x14    li a1,0
    0x84000152    0x16    li a0,8
    0x84000154    0x18    jal ra,ffffffff840102f6 <satp_new>
    0x84000158    0x1c    csrw satp,a0
    0x8400015c    0x20    sfence.vma
    0x84000160    0x24    ld ra,8(sp)           ; stack access
    0x84000162    0x26    addi sp,sp,16
    0x84000164    0x28    ret

Proving inst theorems
---------------------

16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `activate_kernel_vspace` has 22 nodes.

Section create_unmapped_it_frame_cap (278 of 432)
=================================================

Deriving specifications
-----------------------

Section `create_unmapped_it_frame_cap` consists of 12 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `create_unmapped_it_frame_cap`:

    0x840000f2     0x0    addi sp,sp,-48
    0x840000f4     0x2    sd ra,40(sp)          ; stack access
    0x840000f6     0x4    mv a1,a0
    0x840000f8     0x6    li a5,0
    0x840000fa     0x8    li a4,0
    0x840000fc     0xa    li a3,0
    0x840000fe     0xc    li a2,0
    0x84000100     0xe    li a0,0
    0x84000102    0x10    jal ra,ffffffff84010654 <cap_frame_cap_new>
    0x84000106    0x14    ld ra,40(sp)          ; stack access
    0x84000108    0x16    addi sp,sp,48
    0x8400010a    0x18    ret

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_unmapped_it_frame_cap` has 16 nodes.

Section map_kernel_frame (279 of 432)
=====================================

Deriving specifications
-----------------------

Section `map_kernel_frame` consists of 18 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `map_kernel_frame`:

    0x840000c4     0x0    addi sp,sp,-16
    0x840000c6     0x2    sd ra,8(sp)           ; stack access
    0x840000c8     0x4    sd s0,0(sp)           ; stack access
    0x840000ca     0x6    srli a1,a1,0x1e
    0x840000cc     0x8    andi a1,a1,511
    0x840000d0     0xc    slli a1,a1,0x3
    0x840000d2     0xe    auipc s0,0x1b
    0x840000d6    0x12    addi s0,s0,-210 # ffffffff8401b000 <kernel_root_pageTable>
    0x840000da    0x16    add s0,s0,a1
    0x840000dc    0x18    li a1,1
    0x840000de    0x1a    lui a5,0xc0000
    0x840000e2    0x1e    and a0,a0,a5
    0x840000e4    0x20    jal ra,ffffffff840108fc <pte_next>
    0x840000e8    0x24    sd a0,0(s0)
    0x840000ea    0x26    ld ra,8(sp)           ; stack access
    0x840000ec    0x28    ld s0,0(sp)           ; stack access
    0x840000ee    0x2a    addi sp,sp,16
    0x840000f0    0x2c    ret

Proving inst theorems
---------------------

18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `map_kernel_frame` has 25 nodes.

Section _start (280 of 432)
===========================

Deriving specifications
-----------------------

Section `_start` consists of 10 instructions.

Skipping 0000100f fence.i

Skipping 14001073 csrw sscratch,zero


Stack analysis
---------------

No stack accesses found. Code for `_start`:

    0x84000000     0x0    fence.i
    0x84000004     0x4    auipc gp,0x18
    0x84000008     0x8    addi gp,gp,1854 # ffffffff84018742 <__global_pointer$>
    0x8400000c     0xc    auipc sp,0x1e
    0x84000010    0x10    addi sp,sp,-996 # ffffffff8401dc28 <ksIdleThread>
    0x84000014    0x14    csrw sscratch,zero
    0x84000018    0x18    jal ra,ffffffff840012a6 <init_kernel>
    0x8400001c    0x1c    auipc ra,0x11
    0x84000020    0x20    addi ra,ra,-978 # ffffffff84010c4a <restore_user_context>
    0x84000024    0x24    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `_start` has 14 nodes.

Section invokeTCB_NotificationControl (281 of 432)
==================================================

Deriving specifications
-----------------------

Section `invokeTCB_NotificationControl` consists of 10 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeTCB_NotificationControl`:

    0x84016082     0x0    addi sp,sp,-16
    0x84016084     0x2    sd ra,8(sp)           ; stack access
    0x84016086     0x4    beqz a1,ffffffff84016094 <invokeTCB_NotificationControl+0x12>
    0x84016088     0x6    jal ra,ffffffff84012526 <bindNotification>
    0x8401608c     0xa    li a0,0
    0x8401608e     0xc    ld ra,8(sp)           ; stack access
    0x84016090     0xe    addi sp,sp,16
    0x84016092    0x10    ret
    0x84016094    0x12    jal ra,ffffffff84012506 <unbindNotification>
    0x84016098    0x16    j ffffffff8401608c <invokeTCB_NotificationControl+0xa>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_NotificationControl` has 17 nodes.

Section invokeTCB_WriteRegisters (282 of 432)
=============================================

Deriving specifications
-----------------------

Section `invokeTCB_WriteRegisters` consists of 79 instructions.

RVC_TFFTFFT__T____TF.
RVC_TFFTT____FFT__TF.

Stack analysis
---------------

4 stack accesses found. Annotated code for `invokeTCB_WriteRegisters`:

    0x84015f0c     0x0    addi sp,sp,-16
    0x84015f0e     0x2    sd ra,8(sp)           ; stack access
    0x84015f10     0x4    sd s0,0(sp)           ; stack access
    0x84015f12     0x6    mv s0,a0
    0x84015f14     0x8    mv a7,a2
    0x84015f16     0xa    li a5,32
    0x84015f1a     0xe    bgeu a5,a2,ffffffff84015f22 <invokeTCB_WriteRegisters+0x16>
    0x84015f1e    0x12    li a7,32
    0x84015f22    0x16    beqz a2,ffffffff84015fc4 <invokeTCB_WriteRegisters+0xb8>
    0x84015f24    0x18    auipc a0,0x2
    0x84015f28    0x1c    addi a0,a0,1180 # ffffffff840183c0 <frameRegisters>
    0x84015f2c    0x20    li a5,2
    0x84015f2e    0x22    li t3,3
    0x84015f30    0x24    li t4,17
    0x84015f32    0x26    auipc t6,0x19
    0x84015f36    0x2a    addi t6,t6,-1178 # ffffffff8402ea98 <ksCurThread>
    0x84015f3a    0x2e    auipc t5,0x2
    0x84015f3e    0x32    addi t5,t5,1078 # ffffffff84018370 <msgRegisters>
    0x84015f42    0x36    j ffffffff84015f70 <invokeTCB_WriteRegisters+0x64>
    0x84015f44    0x38    ld a6,0(t6)
    0x84015f48    0x3c    slli t1,a5,0x3
    0x84015f4c    0x40    add t1,t1,t5
    0x84015f4e    0x42    ld t1,0(t1)
    0x84015f52    0x46    slli t1,t1,0x3
    0x84015f54    0x48    add a6,a6,t1
    0x84015f56    0x4a    ld a6,0(a6)
    0x84015f5a    0x4e    slli a3,a3,0x3
    0x84015f5c    0x50    add a3,a3,s0
    0x84015f5e    0x52    sd a6,0(a3)
    0x84015f62    0x56    addi a0,a0,8
    0x84015f64    0x58    addi a3,a5,1
    0x84015f68    0x5c    addi a5,a5,-1
    0x84015f6a    0x5e    bgeu a5,a7,ffffffff84015f8c <invokeTCB_WriteRegisters+0x80>
    0x84015f6e    0x62    mv a5,a3
    0x84015f70    0x64    ld a3,0(a0)
    0x84015f72    0x66    bgeu t3,a5,ffffffff84015f44 <invokeTCB_WriteRegisters+0x38>
    0x84015f76    0x6a    slli a6,a5,0x3
    0x84015f7a    0x6e    add a6,a6,a4
    0x84015f7c    0x70    ld a6,8(a6)
    0x84015f80    0x74    slli a3,a3,0x3
    0x84015f82    0x76    add a3,a3,s0
    0x84015f84    0x78    sd a6,0(a3)
    0x84015f88    0x7c    bne a5,t4,ffffffff84015f62 <invokeTCB_WriteRegisters+0x56>
    0x84015f8c    0x80    li a5,16
    0x84015f8e    0x82    bgeu a5,a2,ffffffff84015fc4 <invokeTCB_WriteRegisters+0xb8>
    0x84015f92    0x86    addi a4,a4,152
    0x84015f96    0x8a    auipc a3,0x2
    0x84015f9a    0x8e    addi a3,a3,1202 # ffffffff84018448 <gpRegisters+0x8>
    0x84015f9e    0x92    auipc a6,0x2
    0x84015fa2    0x96    addi a6,a6,1314 # ffffffff840184c0 <gpRegisters+0x80>
    0x84015fa6    0x9a    li a2,17
    0x84015fa8    0x9c    li a5,9
    0x84015faa    0x9e    j ffffffff84015fb2 <invokeTCB_WriteRegisters+0xa6>
    0x84015fac    0xa0    ld a5,0(a3)
    0x84015fae    0xa2    addi a3,a3,8
    0x84015fb0    0xa4    addi a2,a2,1
    0x84015fb2    0xa6    ld a0,0(a4)
    0x84015fb4    0xa8    slli a5,a5,0x3
    0x84015fb6    0xaa    add a5,a5,s0
    0x84015fb8    0xac    sd a0,0(a5)
    0x84015fba    0xae    beq a3,a6,ffffffff84015fc4 <invokeTCB_WriteRegisters+0xb8>
    0x84015fbe    0xb2    addi a4,a4,8
    0x84015fc0    0xb4    bltu a2,a7,ffffffff84015fac <invokeTCB_WriteRegisters+0xa0>
    0x84015fc4    0xb8    ld a5,264(s0)
    0x84015fc8    0xbc    sd a5,272(s0)
    0x84015fcc    0xc0    bnez a1,ffffffff84015fe4 <invokeTCB_WriteRegisters+0xd8>
    0x84015fce    0xc2    auipc a5,0x19
    0x84015fd2    0xc6    ld a5,-1334(a5) # ffffffff8402ea98 <ksCurThread>
    0x84015fd6    0xca    beq a5,s0,ffffffff84015fec <invokeTCB_WriteRegisters+0xe0>
    0x84015fda    0xce    li a0,0
    0x84015fdc    0xd0    ld ra,8(sp)           ; stack access
    0x84015fde    0xd2    ld s0,0(sp)           ; stack access
    0x84015fe0    0xd4    addi sp,sp,16
    0x84015fe2    0xd6    ret
    0x84015fe4    0xd8    mv a0,s0
    0x84015fe6    0xda    jal ra,ffffffff84014644 <restart>
    0x84015fea    0xde    j ffffffff84015fce <invokeTCB_WriteRegisters+0xc2>
    0x84015fec    0xe0    jal ra,ffffffff84012fa8 <rescheduleRequired>
    0x84015ff0    0xe4    j ffffffff84015fda <invokeTCB_WriteRegisters+0xce>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
79 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_WriteRegisters` has 119 nodes.

Section handleFault (283 of 432)
================================

Deriving specifications
-----------------------

Section `handleFault` consists of 14 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `handleFault`:

    0x84014fba     0x0    addi sp,sp,-16
    0x84014fbc     0x2    sd ra,8(sp)           ; stack access
    0x84014fbe     0x4    sd s0,0(sp)           ; stack access
    0x84014fc0     0x6    mv s0,a0
    0x84014fc2     0x8    jal ra,ffffffff84014eae <sendFaultIPC>
    0x84014fc6     0xc    bnez a0,ffffffff84014fd0 <handleFault+0x16>
    0x84014fc8     0xe    ld ra,8(sp)           ; stack access
    0x84014fca    0x10    ld s0,0(sp)           ; stack access
    0x84014fcc    0x12    addi sp,sp,16
    0x84014fce    0x14    ret
    0x84014fd0    0x16    li a1,0
    0x84014fd2    0x18    mv a0,s0
    0x84014fd4    0x1a    jal ra,ffffffff84013020 <setThreadState>
    0x84014fd8    0x1e    j ffffffff84014fc8 <handleFault+0xe>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleFault` has 23 nodes.

Section c_handle_interrupt (284 of 432)
=======================================

Deriving specifications
-----------------------

Section `c_handle_interrupt` consists of 4 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_interrupt`:

    0x840148de    0x0    addi sp,sp,-16
    0x840148e0    0x2    sd ra,8(sp)           ; stack access
    0x840148e2    0x4    jal ra,ffffffff84014890 <handleInterruptEntry>
    0x840148e6    0x8    jal ra,ffffffff84010c4a <restore_user_context>

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_interrupt` has 7 nodes.

Section invokeIRQHandler_SetIRQHandler (285 of 432)
===================================================

Deriving specifications
-----------------------

Section `invokeIRQHandler_SetIRQHandler` consists of 23 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `invokeIRQHandler_SetIRQHandler`:

    0x8401450e     0x0    addi sp,sp,-48
    0x84014510     0x2    sd ra,40(sp)          ; stack access
    0x84014512     0x4    sd s0,32(sp)          ; stack access
    0x84014514     0x6    sd s1,24(sp)          ; stack access
    0x84014516     0x8    sd a1,0(sp)           ; stack access
    0x84014518     0xa    sd a2,8(sp)           ; stack access
    0x8401451a     0xc    mv s1,a3
    0x8401451c     0xe    slli a0,a0,0x5
    0x8401451e    0x10    auipc s0,0x1a
    0x84014522    0x14    addi s0,s0,-1310 # ffffffff8402e000 <intStateIRQNode>
    0x84014526    0x18    add s0,s0,a0
    0x84014528    0x1a    mv a0,s0
    0x8401452a    0x1c    jal ra,ffffffff840144d0 <cteDeleteOne>
    0x8401452e    0x20    mv a3,s0
    0x84014530    0x22    mv a2,s1
    0x84014532    0x24    ld a0,0(sp)           ; stack access
    0x84014534    0x26    ld a1,8(sp)           ; stack access
    0x84014536    0x28    jal ra,ffffffff84011e56 <cteInsert>
    0x8401453a    0x2c    ld ra,40(sp)          ; stack access
    0x8401453c    0x2e    ld s0,32(sp)          ; stack access
    0x8401453e    0x30    ld s1,24(sp)          ; stack access
    0x84014540    0x32    addi sp,sp,48
    0x84014542    0x34    ret

Proving inst theorems
---------------------

23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeIRQHandler_SetIRQHandler` has 36 nodes.

Section switchToThread (286 of 432)
===================================

Deriving specifications
-----------------------

Section `switchToThread` consists of 13 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `switchToThread`:

    0x840135a4     0x0    addi sp,sp,-16
    0x840135a6     0x2    sd ra,8(sp)           ; stack access
    0x840135a8     0x4    sd s0,0(sp)           ; stack access
    0x840135aa     0x6    mv s0,a0
    0x840135ac     0x8    jal ra,ffffffff84011336 <setVMRoot>
    0x840135b0     0xc    mv a0,s0
    0x840135b2     0xe    jal ra,ffffffff840134d2 <tcbSchedDequeue>
    0x840135b6    0x12    auipc a5,0x1b
    0x840135ba    0x16    sd s0,1250(a5) # ffffffff8402ea98 <ksCurThread>
    0x840135be    0x1a    ld ra,8(sp)           ; stack access
    0x840135c0    0x1c    ld s0,0(sp)           ; stack access
    0x840135c2    0x1e    addi sp,sp,16
    0x840135c4    0x20    ret

Proving inst theorems
---------------------

13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `switchToThread` has 21 nodes.

Section tcbSchedDequeue (287 of 432)
====================================

Deriving specifications
-----------------------

Section `tcbSchedDequeue` consists of 73 instructions.

RVC_TFFFFT___FFFT_TF.

Stack analysis
---------------

7 stack accesses found. Annotated code for `tcbSchedDequeue`:

    0x840134d2     0x0    addi sp,sp,-48
    0x840134d4     0x2    sd ra,40(sp)          ; stack access
    0x840134d6     0x4    sd s0,32(sp)          ; stack access
    0x840134d8     0x6    mv s0,a0
    0x840134da     0x8    ld a5,280(a0)
    0x840134de     0xc    sd a5,0(sp)           ; stack access
    0x840134e0     0xe    ld a5,288(a0)
    0x840134e4    0x12    sd a5,8(sp)           ; stack access
    0x840134e6    0x14    ld a5,296(a0)
    0x840134ea    0x18    sd a5,16(sp)          ; stack access
    0x840134ec    0x1a    mv a0,sp
    0x840134ee    0x1c    jal ra,ffffffff84010358 <thread_state_get_tcbQueued>
    0x840134f2    0x20    beqz a0,ffffffff8401353c <tcbSchedDequeue+0x6a>
    0x840134f4    0x22    ld a2,344(s0)
    0x840134f8    0x26    ld a3,360(s0)
    0x840134fc    0x2a    slli a5,a2,0x8
    0x84013500    0x2e    add a5,a5,a3
    0x84013502    0x30    slli a5,a5,0x4
    0x84013504    0x32    auipc a4,0xb
    0x84013508    0x36    addi a4,a4,-1708 # ffffffff8401de58 <ksReadyQueues>
    0x8401350c    0x3a    add a5,a5,a4
    0x8401350e    0x3c    ld a0,8(a5)
    0x84013510    0x3e    ld a4,400(s0)
    0x84013514    0x42    beqz a4,ffffffff84013544 <tcbSchedDequeue+0x72>
    0x84013516    0x44    ld a1,0(a5)
    0x84013518    0x46    ld a3,392(s0)
    0x8401351c    0x4a    sd a3,392(a4)
    0x84013520    0x4e    ld a4,392(s0)
    0x84013524    0x52    beqz a4,ffffffff8401359e <tcbSchedDequeue+0xcc>
    0x84013526    0x54    ld a3,400(s0)
    0x8401352a    0x58    sd a3,400(a4)
    0x8401352e    0x5c    sd a1,0(a5)
    0x84013530    0x5e    sd a0,8(a5)
    0x84013532    0x60    li a1,0
    0x84013534    0x62    addi a0,s0,280
    0x84013538    0x66    jal ra,ffffffff8401035e <thread_state_ptr_set_tcbQueued>
    0x8401353c    0x6a    ld ra,40(sp)          ; stack access
    0x8401353e    0x6c    ld s0,32(sp)          ; stack access
    0x84013540    0x6e    addi sp,sp,48
    0x84013542    0x70    ret
    0x84013544    0x72    ld a1,392(s0)
    0x84013548    0x76    bnez a1,ffffffff8401359a <tcbSchedDequeue+0xc8>
    0x8401354a    0x78    srli a7,a3,0x6
    0x8401354e    0x7c    li a4,3
    0x84013550    0x7e    sub a6,a4,a7
    0x84013554    0x82    li a4,1
    0x84013556    0x84    sll a3,a4,a3
    0x8401355a    0x88    not a3,a3
    0x8401355e    0x8c    slli a4,a2,0x2
    0x84013562    0x90    add a4,a4,a6
    0x84013564    0x92    slli a4,a4,0x3
    0x84013566    0x94    auipc a6,0x1b
    0x8401356a    0x98    addi a6,a6,682 # ffffffff8402e810 <ksReadyQueuesL2Bitmap>
    0x8401356e    0x9c    add a4,a4,a6
    0x84013570    0x9e    ld a6,0(a4)
    0x84013574    0xa2    and a3,a3,a6
    0x84013578    0xa6    sd a3,0(a4)
    0x8401357a    0xa8    bnez a3,ffffffff84013520 <tcbSchedDequeue+0x4e>
    0x8401357c    0xaa    slli a2,a2,0x3
    0x8401357e    0xac    auipc a4,0x1b
    0x84013582    0xb0    addi a4,a4,1178 # ffffffff8402ea18 <ksReadyQueuesL1Bitmap>
    0x84013586    0xb4    add a2,a2,a4
    0x84013588    0xb6    li a4,1
    0x8401358a    0xb8    sll a4,a4,a7
    0x8401358e    0xbc    not a4,a4
    0x84013592    0xc0    ld a3,0(a2)
    0x84013594    0xc2    and a4,a4,a3
    0x84013596    0xc4    sd a4,0(a2)
    0x84013598    0xc6    j ffffffff84013520 <tcbSchedDequeue+0x4e>
    0x8401359a    0xc8    mv a4,a1
    0x8401359c    0xca    j ffffffff84013526 <tcbSchedDequeue+0x54>
    0x8401359e    0xcc    ld a0,400(s0)
    0x840135a2    0xd0    j ffffffff8401352e <tcbSchedDequeue+0x5c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
73 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbSchedDequeue` has 114 nodes.

Section tcbSchedAppend (288 of 432)
===================================

Deriving specifications
-----------------------

Section `tcbSchedAppend` consists of 60 instructions.


Stack analysis
---------------

7 stack accesses found. Annotated code for `tcbSchedAppend`:

    0x840133ba     0x0    addi sp,sp,-48
    0x840133bc     0x2    sd ra,40(sp)          ; stack access
    0x840133be     0x4    sd s0,32(sp)          ; stack access
    0x840133c0     0x6    mv s0,a0
    0x840133c2     0x8    ld a5,280(a0)
    0x840133c6     0xc    sd a5,0(sp)           ; stack access
    0x840133c8     0xe    ld a5,288(a0)
    0x840133cc    0x12    sd a5,8(sp)           ; stack access
    0x840133ce    0x14    ld a5,296(a0)
    0x840133d2    0x18    sd a5,16(sp)          ; stack access
    0x840133d4    0x1a    mv a0,sp
    0x840133d6    0x1c    jal ra,ffffffff84010358 <thread_state_get_tcbQueued>
    0x840133da    0x20    bnez a0,ffffffff84013416 <tcbSchedAppend+0x5c>
    0x840133dc    0x22    ld a4,344(s0)
    0x840133e0    0x26    ld a1,360(s0)
    0x840133e4    0x2a    slli a5,a4,0x8
    0x840133e8    0x2e    add a5,a5,a1
    0x840133ea    0x30    slli a5,a5,0x4
    0x840133ec    0x32    auipc a3,0xb
    0x840133f0    0x36    addi a3,a3,-1428 # ffffffff8401de58 <ksReadyQueues>
    0x840133f4    0x3a    add a5,a5,a3
    0x840133f6    0x3c    ld a3,0(a5)
    0x840133f8    0x3e    ld a2,8(a5)
    0x840133fa    0x40    beqz a3,ffffffff8401341e <tcbSchedAppend+0x64>
    0x840133fc    0x42    sd s0,392(a2)
    0x84013400    0x46    sd a2,400(s0)
    0x84013404    0x4a    sd zero,392(s0)
    0x84013408    0x4e    sd a3,0(a5)
    0x8401340a    0x50    sd s0,8(a5)
    0x8401340c    0x52    li a1,1
    0x8401340e    0x54    addi a0,s0,280
    0x84013412    0x58    jal ra,ffffffff8401035e <thread_state_ptr_set_tcbQueued>
    0x84013416    0x5c    ld ra,40(sp)          ; stack access
    0x84013418    0x5e    ld s0,32(sp)          ; stack access
    0x8401341a    0x60    addi sp,sp,48
    0x8401341c    0x62    ret
    0x8401341e    0x64    srli a6,a1,0x6
    0x84013422    0x68    li a7,3
    0x84013424    0x6a    sub a7,a7,a6
    0x84013428    0x6e    slli a3,a4,0x3
    0x8401342c    0x72    auipc a0,0x1b
    0x84013430    0x76    addi a0,a0,1516 # ffffffff8402ea18 <ksReadyQueuesL1Bitmap>
    0x84013434    0x7a    add a0,a0,a3
    0x84013436    0x7c    li a3,1
    0x84013438    0x7e    sll a6,a3,a6
    0x8401343c    0x82    ld t1,0(a0)
    0x84013440    0x86    or a6,t1,a6
    0x84013444    0x8a    sd a6,0(a0)
    0x84013448    0x8e    slli a4,a4,0x2
    0x8401344a    0x90    add a4,a4,a7
    0x8401344c    0x92    slli a4,a4,0x3
    0x8401344e    0x94    auipc a0,0x1b
    0x84013452    0x98    addi a0,a0,962 # ffffffff8402e810 <ksReadyQueuesL2Bitmap>
    0x84013456    0x9c    add a4,a4,a0
    0x84013458    0x9e    sll a1,a3,a1
    0x8401345c    0xa2    ld a3,0(a4)
    0x8401345e    0xa4    or a1,a1,a3
    0x84013460    0xa6    sd a1,0(a4)
    0x84013462    0xa8    mv a3,s0
    0x84013464    0xaa    j ffffffff84013400 <tcbSchedAppend+0x46>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
60 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbSchedAppend` has 90 nodes.

Section possibleSwitchTo (289 of 432)
=====================================

Deriving specifications
-----------------------

Section `possibleSwitchTo` consists of 23 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `possibleSwitchTo`:

    0x840132c6     0x0    addi sp,sp,-16
    0x840132c8     0x2    sd ra,8(sp)           ; stack access
    0x840132ca     0x4    sd s0,0(sp)           ; stack access
    0x840132cc     0x6    mv s0,a0
    0x840132ce     0x8    ld a4,344(a0)
    0x840132d2     0xc    auipc a5,0x1b
    0x840132d6    0x10    ld a5,1326(a5) # ffffffff8402e800 <ksCurDomain>
    0x840132da    0x14    bne a4,a5,ffffffff840132f4 <possibleSwitchTo+0x2e>
    0x840132de    0x18    auipc a5,0xb
    0x840132e2    0x1c    ld a5,-1694(a5) # ffffffff8401dc40 <ksSchedulerAction>
    0x840132e6    0x20    beqz a5,ffffffff84013300 <possibleSwitchTo+0x3a>
    0x840132e8    0x22    jal ra,ffffffff84012fa8 <rescheduleRequired>
    0x840132ec    0x26    mv a0,s0
    0x840132ee    0x28    jal ra,ffffffff84012efc <tcbSchedEnqueue>
    0x840132f2    0x2c    j ffffffff840132f8 <possibleSwitchTo+0x32>
    0x840132f4    0x2e    jal ra,ffffffff84012efc <tcbSchedEnqueue>
    0x840132f8    0x32    ld ra,8(sp)           ; stack access
    0x840132fa    0x34    ld s0,0(sp)           ; stack access
    0x840132fc    0x36    addi sp,sp,16
    0x840132fe    0x38    ret
    0x84013300    0x3a    auipc a5,0xb
    0x84013304    0x3e    sd a0,-1728(a5) # ffffffff8401dc40 <ksSchedulerAction>
    0x84013308    0x42    j ffffffff840132f8 <possibleSwitchTo+0x32>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `possibleSwitchTo` has 39 nodes.

Section setThreadState (290 of 432)
===================================

Deriving specifications
-----------------------

Section `setThreadState` consists of 12 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `setThreadState`:

    0x84013020     0x0    addi sp,sp,-16
    0x84013022     0x2    sd ra,8(sp)           ; stack access
    0x84013024     0x4    sd s0,0(sp)           ; stack access
    0x84013026     0x6    mv s0,a0
    0x84013028     0x8    addi a0,a0,280
    0x8401302c     0xc    jal ra,ffffffff8401038e <thread_state_ptr_set_tsType>
    0x84013030    0x10    mv a0,s0
    0x84013032    0x12    jal ra,ffffffff84012fda <scheduleTCB>
    0x84013036    0x16    ld ra,8(sp)           ; stack access
    0x84013038    0x18    ld s0,0(sp)           ; stack access
    0x8401303a    0x1a    addi sp,sp,16
    0x8401303c    0x1c    ret

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setThreadState` has 19 nodes.

Section scheduleTCB (291 of 432)
================================

Deriving specifications
-----------------------

Section `scheduleTCB` consists of 24 instructions.


Stack analysis
---------------

5 stack accesses found. Annotated code for `scheduleTCB`:

    0x84012fda     0x0    auipc a5,0x1c
    0x84012fde     0x4    ld a5,-1346(a5) # ffffffff8402ea98 <ksCurThread>
    0x84012fe2     0x8    beq a5,a0,ffffffff84012fe8 <scheduleTCB+0xe>
    0x84012fe6     0xc    ret
    0x84012fe8     0xe    auipc a5,0xb
    0x84012fec    0x12    ld a5,-936(a5) # ffffffff8401dc40 <ksSchedulerAction>
    0x84012ff0    0x16    bnez a5,ffffffff84012fe6 <scheduleTCB+0xc>
    0x84012ff2    0x18    addi sp,sp,-48
    0x84012ff4    0x1a    sd ra,40(sp)          ; stack access
    0x84012ff6    0x1c    ld a5,280(a0)
    0x84012ffa    0x20    sd a5,0(sp)           ; stack access
    0x84012ffc    0x22    ld a5,288(a0)
    0x84013000    0x26    sd a5,8(sp)           ; stack access
    0x84013002    0x28    ld a5,296(a0)
    0x84013006    0x2c    sd a5,16(sp)          ; stack access
    0x84013008    0x2e    mv a0,sp
    0x8401300a    0x30    jal ra,ffffffff84010382 <thread_state_get_tsType>
    0x8401300e    0x34    addi a0,a0,-1
    0x84013010    0x36    li a5,1
    0x84013012    0x38    bgeu a5,a0,ffffffff8401301a <scheduleTCB+0x40>
    0x84013016    0x3c    jal ra,ffffffff84012fa8 <rescheduleRequired>
    0x8401301a    0x40    ld ra,40(sp)          ; stack access
    0x8401301c    0x42    addi sp,sp,48
    0x8401301e    0x44    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
24 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `scheduleTCB` has 44 nodes.

Section tcbSchedEnqueue (292 of 432)
====================================

Deriving specifications
-----------------------

Section `tcbSchedEnqueue` consists of 60 instructions.


Stack analysis
---------------

7 stack accesses found. Annotated code for `tcbSchedEnqueue`:

    0x84012efc     0x0    addi sp,sp,-48
    0x84012efe     0x2    sd ra,40(sp)          ; stack access
    0x84012f00     0x4    sd s0,32(sp)          ; stack access
    0x84012f02     0x6    mv s0,a0
    0x84012f04     0x8    ld a5,280(a0)
    0x84012f08     0xc    sd a5,0(sp)           ; stack access
    0x84012f0a     0xe    ld a5,288(a0)
    0x84012f0e    0x12    sd a5,8(sp)           ; stack access
    0x84012f10    0x14    ld a5,296(a0)
    0x84012f14    0x18    sd a5,16(sp)          ; stack access
    0x84012f16    0x1a    mv a0,sp
    0x84012f18    0x1c    jal ra,ffffffff84010358 <thread_state_get_tcbQueued>
    0x84012f1c    0x20    bnez a0,ffffffff84012f58 <tcbSchedEnqueue+0x5c>
    0x84012f1e    0x22    ld a4,344(s0)
    0x84012f22    0x26    ld a1,360(s0)
    0x84012f26    0x2a    slli a5,a4,0x8
    0x84012f2a    0x2e    add a5,a5,a1
    0x84012f2c    0x30    slli a5,a5,0x4
    0x84012f2e    0x32    auipc a3,0xb
    0x84012f32    0x36    addi a3,a3,-214 # ffffffff8401de58 <ksReadyQueues>
    0x84012f36    0x3a    add a5,a5,a3
    0x84012f38    0x3c    ld a2,0(a5)
    0x84012f3a    0x3e    ld a3,8(a5)
    0x84012f3c    0x40    beqz a3,ffffffff84012f60 <tcbSchedEnqueue+0x64>
    0x84012f3e    0x42    sd s0,400(a2)
    0x84012f42    0x46    sd zero,400(s0)
    0x84012f46    0x4a    sd a2,392(s0)
    0x84012f4a    0x4e    sd s0,0(a5)
    0x84012f4c    0x50    sd a3,8(a5)
    0x84012f4e    0x52    li a1,1
    0x84012f50    0x54    addi a0,s0,280
    0x84012f54    0x58    jal ra,ffffffff8401035e <thread_state_ptr_set_tcbQueued>
    0x84012f58    0x5c    ld ra,40(sp)          ; stack access
    0x84012f5a    0x5e    ld s0,32(sp)          ; stack access
    0x84012f5c    0x60    addi sp,sp,48
    0x84012f5e    0x62    ret
    0x84012f60    0x64    srli a6,a1,0x6
    0x84012f64    0x68    li a7,3
    0x84012f66    0x6a    sub a7,a7,a6
    0x84012f6a    0x6e    slli a3,a4,0x3
    0x84012f6e    0x72    auipc a0,0x1c
    0x84012f72    0x76    addi a0,a0,-1366 # ffffffff8402ea18 <ksReadyQueuesL1Bitmap>
    0x84012f76    0x7a    add a0,a0,a3
    0x84012f78    0x7c    li a3,1
    0x84012f7a    0x7e    sll a6,a3,a6
    0x84012f7e    0x82    ld t1,0(a0)
    0x84012f82    0x86    or a6,t1,a6
    0x84012f86    0x8a    sd a6,0(a0)
    0x84012f8a    0x8e    slli a4,a4,0x2
    0x84012f8c    0x90    add a4,a4,a7
    0x84012f8e    0x92    slli a4,a4,0x3
    0x84012f90    0x94    auipc a0,0x1c
    0x84012f94    0x98    addi a0,a0,-1920 # ffffffff8402e810 <ksReadyQueuesL2Bitmap>
    0x84012f98    0x9c    add a4,a4,a0
    0x84012f9a    0x9e    sll a1,a3,a1
    0x84012f9e    0xa2    ld a3,0(a4)
    0x84012fa0    0xa4    or a1,a1,a3
    0x84012fa2    0xa6    sd a1,0(a4)
    0x84012fa4    0xa8    mv a3,s0
    0x84012fa6    0xaa    j ffffffff84012f42 <tcbSchedEnqueue+0x46>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
60 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbSchedEnqueue` has 90 nodes.

Section slotCapLongRunningDelete (293 of 432)
=============================================

Deriving specifications
-----------------------

Section `slotCapLongRunningDelete` consists of 30 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `slotCapLongRunningDelete`:

    0x84012b44     0x0    addi sp,sp,-32
    0x84012b46     0x2    sd ra,24(sp)          ; stack access
    0x84012b48     0x4    sd s0,16(sp)          ; stack access
    0x84012b4a     0x6    sd s1,8(sp)           ; stack access
    0x84012b4c     0x8    mv s1,a0
    0x84012b4e     0xa    ld a0,0(a0)
    0x84012b50     0xc    ld a1,8(s1)
    0x84012b52     0xe    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012b56    0x12    mv s0,a0
    0x84012b58    0x14    beqz a0,ffffffff84012b7e <slotCapLongRunningDelete+0x3a>
    0x84012b5a    0x16    mv a0,s1
    0x84012b5c    0x18    jal ra,ffffffff84012af4 <isFinalCapability>
    0x84012b60    0x1c    beqz a0,ffffffff84012b7c <slotCapLongRunningDelete+0x38>
    0x84012b62    0x1e    addi a0,s0,-10
    0x84012b66    0x22    li a5,8
    0x84012b68    0x24    bltu a5,a0,ffffffff84012b8a <slotCapLongRunningDelete+0x46>
    0x84012b6c    0x28    li s0,1
    0x84012b6e    0x2a    sll s0,s0,a0
    0x84012b72    0x2e    andi s0,s0,261
    0x84012b76    0x32    snez s0,s0
    0x84012b7a    0x36    j ffffffff84012b7e <slotCapLongRunningDelete+0x3a>
    0x84012b7c    0x38    mv s0,a0
    0x84012b7e    0x3a    mv a0,s0
    0x84012b80    0x3c    ld ra,24(sp)          ; stack access
    0x84012b82    0x3e    ld s0,16(sp)          ; stack access
    0x84012b84    0x40    ld s1,8(sp)           ; stack access
    0x84012b86    0x42    addi sp,sp,32
    0x84012b88    0x44    ret
    0x84012b8a    0x46    li s0,0
    0x84012b8c    0x48    j ffffffff84012b7e <slotCapLongRunningDelete+0x3a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
30 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `slotCapLongRunningDelete` has 47 nodes.

Section ensureNoChildren (294 of 432)
=====================================

Deriving specifications
-----------------------

Section `ensureNoChildren` consists of 21 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `ensureNoChildren`:

    0x840129a8     0x0    addi sp,sp,-16
    0x840129aa     0x2    sd ra,8(sp)           ; stack access
    0x840129ac     0x4    sd s0,0(sp)           ; stack access
    0x840129ae     0x6    mv s0,a0
    0x840129b0     0x8    ld a0,16(a0)
    0x840129b2     0xa    ld a1,24(s0)
    0x840129b4     0xc    jal ra,ffffffff84010b08 <mdb_node_get_mdbNext>
    0x840129b8    0x10    beqz a0,ffffffff840129c4 <ensureNoChildren+0x1c>
    0x840129ba    0x12    mv a1,a0
    0x840129bc    0x14    mv a0,s0
    0x840129be    0x16    jal ra,ffffffff84012908 <isMDBParentOf>
    0x840129c2    0x1a    bnez a0,ffffffff840129cc <ensureNoChildren+0x24>
    0x840129c4    0x1c    ld ra,8(sp)           ; stack access
    0x840129c6    0x1e    ld s0,0(sp)           ; stack access
    0x840129c8    0x20    addi sp,sp,16
    0x840129ca    0x22    ret
    0x840129cc    0x24    li a5,9
    0x840129ce    0x26    auipc a4,0xb
    0x840129d2    0x2a    sd a5,682(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840129d6    0x2e    li a0,3
    0x840129d8    0x30    j ffffffff840129c4 <ensureNoChildren+0x1c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
21 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `ensureNoChildren` has 35 nodes.

Section getObjectSize (295 of 432)
==================================

Deriving specifications
-----------------------

Section `getObjectSize` consists of 28 instructions.

RVC_TFFFFT___FFFFFTF.

Stack analysis
---------------

2 stack accesses found. Annotated code for `getObjectSize`:

    0x84012548     0x0    addi sp,sp,-16
    0x8401254a     0x2    sd ra,8(sp)           ; stack access
    0x8401254c     0x4    li a5,4
    0x8401254e     0x6    bltu a5,a0,ffffffff8401256c <getObjectSize+0x24>
    0x84012552     0xa    li a5,4
    0x84012554     0xc    bltu a5,a0,ffffffff84012584 <getObjectSize+0x3c>
    0x84012558    0x10    slli a0,a0,0x2
    0x8401255a    0x12    auipc a4,0x6
    0x8401255e    0x16    addi a4,a4,-1398 # ffffffff84017fe4 <ksDomScheduleLength+0x9c>
    0x84012562    0x1a    add a5,a0,a4
    0x84012566    0x1e    lw a5,0(a5)
    0x84012568    0x20    add a5,a5,a4
    0x8401256a    0x22    jr a5
    0x8401256c    0x24    jal ra,ffffffff840119dc <Arch_getObjectSize>
    0x84012570    0x28    ld ra,8(sp)           ; stack access
    0x84012572    0x2a    addi sp,sp,16
    0x84012574    0x2c    ret
    0x84012576    0x2e    li a0,4
    0x84012578    0x30    j ffffffff84012570 <getObjectSize+0x28>
    0x8401257a    0x32    addi a0,a1,5
    0x8401257e    0x36    j ffffffff84012570 <getObjectSize+0x28>
    0x84012580    0x38    mv a0,a1
    0x84012582    0x3a    j ffffffff84012570 <getObjectSize+0x28>
    0x84012584    0x3c    jal ra,ffffffff84010cec <halt>
    0x84012588    0x40    li a0,10
    0x8401258a    0x42    j ffffffff84012570 <getObjectSize+0x28>
    0x8401258c    0x44    li a0,5
    0x8401258e    0x46    j ffffffff84012570 <getObjectSize+0x28>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
28 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getObjectSize` has 39 nodes.

Section unbindMaybeNotification (296 of 432)
============================================

Deriving specifications
-----------------------

Section `unbindMaybeNotification` consists of 18 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `unbindMaybeNotification`:

    0x840124dc     0x0    addi sp,sp,-32
    0x840124de     0x2    sd ra,24(sp)          ; stack access
    0x840124e0     0x4    sd s0,16(sp)          ; stack access
    0x840124e2     0x6    sd s1,8(sp)           ; stack access
    0x840124e4     0x8    mv s1,a0
    0x840124e6     0xa    jal ra,ffffffff840109c8 <notification_ptr_get_ntfnBoundTCB>
    0x840124ea     0xe    bnez a0,ffffffff840124f6 <unbindMaybeNotification+0x1a>
    0x840124ec    0x10    ld ra,24(sp)          ; stack access
    0x840124ee    0x12    ld s0,16(sp)          ; stack access
    0x840124f0    0x14    ld s1,8(sp)           ; stack access
    0x840124f2    0x16    addi sp,sp,32
    0x840124f4    0x18    ret
    0x840124f6    0x1a    mv s0,a0
    0x840124f8    0x1c    li a1,0
    0x840124fa    0x1e    mv a0,s1
    0x840124fc    0x20    jal ra,ffffffff8401021a <notification_ptr_set_ntfnBoundTCB>
    0x84012500    0x24    sd zero,304(s0)
    0x84012504    0x28    j ffffffff840124ec <unbindMaybeNotification+0x10>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `unbindMaybeNotification` has 30 nodes.

Section invokeCNodeRotate (297 of 432)
======================================

Deriving specifications
-----------------------

Section `invokeCNodeRotate` consists of 32 instructions.


Stack analysis
---------------

15 stack accesses found. Annotated code for `invokeCNodeRotate`:

    0x8401212e     0x0    addi sp,sp,-64
    0x84012130     0x2    sd ra,56(sp)          ; stack access
    0x84012132     0x4    sd s0,48(sp)          ; stack access
    0x84012134     0x6    sd s1,40(sp)          ; stack access
    0x84012136     0x8    sd a0,16(sp)          ; stack access
    0x84012138     0xa    sd a1,24(sp)          ; stack access
    0x8401213a     0xc    sd a2,0(sp)           ; stack access
    0x8401213c     0xe    sd a3,8(sp)           ; stack access
    0x8401213e    0x10    mv s0,a4
    0x84012140    0x12    mv s1,a5
    0x84012142    0x14    beq a4,a6,ffffffff8401216a <invokeCNodeRotate+0x3c>
    0x84012146    0x18    mv a3,a6
    0x84012148    0x1a    mv a2,a5
    0x8401214a    0x1c    ld a0,0(sp)           ; stack access
    0x8401214c    0x1e    ld a1,8(sp)           ; stack access
    0x8401214e    0x20    jal ra,ffffffff84011fd0 <cteMove>
    0x84012152    0x24    mv a3,s1
    0x84012154    0x26    mv a2,s0
    0x84012156    0x28    ld a0,16(sp)          ; stack access
    0x84012158    0x2a    ld a1,24(sp)          ; stack access
    0x8401215a    0x2c    jal ra,ffffffff84011fd0 <cteMove>
    0x8401215e    0x30    li a0,0
    0x84012160    0x32    ld ra,56(sp)          ; stack access
    0x84012162    0x34    ld s0,48(sp)          ; stack access
    0x84012164    0x36    ld s1,40(sp)          ; stack access
    0x84012166    0x38    addi sp,sp,64
    0x84012168    0x3a    ret
    0x8401216a    0x3c    mv a3,a2
    0x8401216c    0x3e    ld a4,8(sp)           ; stack access
    0x8401216e    0x40    mv a2,s0
    0x84012170    0x42    jal ra,ffffffff840120ac <cteSwap>
    0x84012174    0x46    j ffffffff8401215e <invokeCNodeRotate+0x30>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
32 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeRotate` has 53 nodes.

Section lookupCapAndSlot (298 of 432)
=====================================

Deriving specifications
-----------------------

Section `lookupCapAndSlot` consists of 30 instructions.


Stack analysis
---------------

Section `lookupCapAndSlot` expects pointer to stack in a0.
16 stack accesses found. Annotated code for `lookupCapAndSlot`:

    0x84011c3a     0x0    addi sp,sp,-48
    0x84011c3c     0x2    sd ra,40(sp)          ; stack access
    0x84011c3e     0x4    sd s0,32(sp)          ; stack access
    0x84011c40     0x6    sd s1,24(sp)          ; stack access
    0x84011c42     0x8    mv s0,a0
    0x84011c44     0xa    mv a0,a1
    0x84011c46     0xc    mv a1,a2
    0x84011c48     0xe    jal ra,ffffffff84011bd8 <lookupSlot>
    0x84011c4c    0x12    sd a0,0(sp)           ; stack access
    0x84011c4e    0x14    sd a1,8(sp)           ; stack access
    0x84011c50    0x16    bnez a0,ffffffff84011c6c <lookupCapAndSlot+0x32>
    0x84011c52    0x18    ld a5,0(a1)
    0x84011c54    0x1a    sd a5,8(s0)           ; stack access
    0x84011c56    0x1c    ld a5,8(a1)
    0x84011c58    0x1e    sd a5,16(s0)          ; stack access
    0x84011c5a    0x20    sd zero,0(s0)         ; stack access
    0x84011c5e    0x24    sd a1,24(s0)          ; stack access
    0x84011c60    0x26    mv a0,s0
    0x84011c62    0x28    ld ra,40(sp)          ; stack access
    0x84011c64    0x2a    ld s0,32(sp)          ; stack access
    0x84011c66    0x2c    ld s1,24(sp)          ; stack access
    0x84011c68    0x2e    addi sp,sp,48
    0x84011c6a    0x30    ret
    0x84011c6c    0x32    mv s1,a0
    0x84011c6e    0x34    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84011c72    0x38    sd a0,8(s0)           ; stack access
    0x84011c74    0x3a    sd a1,16(s0)          ; stack access
    0x84011c76    0x3c    sd s1,0(s0)           ; stack access
    0x84011c78    0x3e    sd zero,24(s0)        ; stack access
    0x84011c7c    0x42    j ffffffff84011c60 <lookupCapAndSlot+0x26>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
30 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupCapAndSlot` has 53 nodes.

Section lookupCap (299 of 432)
==============================

Deriving specifications
-----------------------

Section `lookupCap` consists of 29 instructions.


Stack analysis
---------------

Section `lookupCap` expects pointer to stack in a0.
15 stack accesses found. Annotated code for `lookupCap`:

    0x84011bfa     0x0    addi sp,sp,-48
    0x84011bfc     0x2    sd ra,40(sp)          ; stack access
    0x84011bfe     0x4    sd s0,32(sp)          ; stack access
    0x84011c00     0x6    sd s1,24(sp)          ; stack access
    0x84011c02     0x8    mv s0,a0
    0x84011c04     0xa    mv a0,a1
    0x84011c06     0xc    mv a1,a2
    0x84011c08     0xe    jal ra,ffffffff84011bd8 <lookupSlot>
    0x84011c0c    0x12    sd a0,0(sp)           ; stack access
    0x84011c0e    0x14    sd a1,8(sp)           ; stack access
    0x84011c10    0x16    bnez a0,ffffffff84011c2c <lookupCap+0x32>
    0x84011c12    0x18    ld a5,8(sp)           ; stack access
    0x84011c14    0x1a    ld a4,0(a5)
    0x84011c16    0x1c    sd a4,8(s0)           ; stack access
    0x84011c18    0x1e    ld a5,8(a5)
    0x84011c1a    0x20    sd a5,16(s0)          ; stack access
    0x84011c1c    0x22    sd zero,0(s0)         ; stack access
    0x84011c20    0x26    mv a0,s0
    0x84011c22    0x28    ld ra,40(sp)          ; stack access
    0x84011c24    0x2a    ld s0,32(sp)          ; stack access
    0x84011c26    0x2c    ld s1,24(sp)          ; stack access
    0x84011c28    0x2e    addi sp,sp,48
    0x84011c2a    0x30    ret
    0x84011c2c    0x32    mv s1,a0
    0x84011c2e    0x34    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84011c32    0x38    sd a0,8(s0)           ; stack access
    0x84011c34    0x3a    sd a1,16(s0)          ; stack access
    0x84011c36    0x3c    sd s1,0(s0)           ; stack access
    0x84011c38    0x3e    j ffffffff84011c20 <lookupCap+0x26>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
29 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupCap` has 51 nodes.

Section maskVMRights (300 of 432)
=================================

Deriving specifications
-----------------------

Section `maskVMRights` consists of 35 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `maskVMRights`:

    0x8401150a     0x0    addi sp,sp,-32
    0x8401150c     0x2    sd ra,24(sp)          ; stack access
    0x8401150e     0x4    sd s0,16(sp)          ; stack access
    0x84011510     0x6    sd s1,8(sp)           ; stack access
    0x84011512     0x8    mv s0,a0
    0x84011514     0xa    mv s1,a1
    0x84011516     0xc    li a5,2
    0x84011518     0xe    beq a0,a5,ffffffff8401152e <maskVMRights+0x24>
    0x8401151c    0x12    li a5,3
    0x8401151e    0x14    li a0,1
    0x84011520    0x16    beq s0,a5,ffffffff8401153e <maskVMRights+0x34>
    0x84011524    0x1a    ld ra,24(sp)          ; stack access
    0x84011526    0x1c    ld s0,16(sp)          ; stack access
    0x84011528    0x1e    ld s1,8(sp)           ; stack access
    0x8401152a    0x20    addi sp,sp,32
    0x8401152c    0x22    ret
    0x8401152e    0x24    mv a0,a1
    0x84011530    0x26    jal ra,ffffffff840100ea <seL4_CapRights_get_capAllowRead>
    0x84011534    0x2a    mv a5,a0
    0x84011536    0x2c    mv a0,s0
    0x84011538    0x2e    bnez a5,ffffffff84011524 <maskVMRights+0x1a>
    0x8401153a    0x30    li a0,1
    0x8401153c    0x32    j ffffffff84011524 <maskVMRights+0x1a>
    0x8401153e    0x34    mv a0,a1
    0x84011540    0x36    jal ra,ffffffff840100ea <seL4_CapRights_get_capAllowRead>
    0x84011544    0x3a    mv a5,a0
    0x84011546    0x3c    li a0,1
    0x84011548    0x3e    beqz a5,ffffffff84011524 <maskVMRights+0x1a>
    0x8401154a    0x40    mv a0,s1
    0x8401154c    0x42    jal ra,ffffffff840100f0 <seL4_CapRights_get_capAllowWrite>
    0x84011550    0x46    mv a5,a0
    0x84011552    0x48    li a0,2
    0x84011554    0x4a    beqz a5,ffffffff84011524 <maskVMRights+0x1a>
    0x84011556    0x4c    mv a0,s0
    0x84011558    0x4e    j ffffffff84011524 <maskVMRights+0x1a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
35 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `maskVMRights` has 55 nodes.

Section checkValidIPCBuffer (301 of 432)
========================================

Deriving specifications
-----------------------

Section `checkValidIPCBuffer` consists of 36 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `checkValidIPCBuffer`:

    0x840114ae     0x0    addi sp,sp,-32
    0x840114b0     0x2    sd ra,24(sp)          ; stack access
    0x840114b2     0x4    sd s0,16(sp)          ; stack access
    0x840114b4     0x6    mv s0,a0
    0x840114b6     0x8    sd a1,0(sp)           ; stack access
    0x840114b8     0xa    sd a2,8(sp)           ; stack access
    0x840114ba     0xc    mv a0,a1
    0x840114bc     0xe    mv a1,a2
    0x840114be    0x10    jal ra,ffffffff8401039e <cap_get_capType>
    0x840114c2    0x14    li a5,1
    0x840114c4    0x16    bne a0,a5,ffffffff840114e0 <checkValidIPCBuffer+0x32>
    0x840114c8    0x1a    ld a0,0(sp)           ; stack access
    0x840114ca    0x1c    ld a1,8(sp)           ; stack access
    0x840114cc    0x1e    jal ra,ffffffff840106d0 <cap_frame_cap_get_capFIsDevice>
    0x840114d0    0x22    bnez a0,ffffffff840114ee <checkValidIPCBuffer+0x40>
    0x840114d2    0x24    andi a0,s0,1023
    0x840114d6    0x28    bnez a0,ffffffff840114fc <checkValidIPCBuffer+0x4e>
    0x840114d8    0x2a    ld ra,24(sp)          ; stack access
    0x840114da    0x2c    ld s0,16(sp)          ; stack access
    0x840114dc    0x2e    addi sp,sp,32
    0x840114de    0x30    ret
    0x840114e0    0x32    li a5,3
    0x840114e2    0x34    auipc a4,0xc
    0x840114e6    0x38    sd a5,1942(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840114ea    0x3c    li a0,3
    0x840114ec    0x3e    j ffffffff840114d8 <checkValidIPCBuffer+0x2a>
    0x840114ee    0x40    li a5,3
    0x840114f0    0x42    auipc a4,0xc
    0x840114f4    0x46    sd a5,1928(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840114f8    0x4a    li a0,3
    0x840114fa    0x4c    j ffffffff840114d8 <checkValidIPCBuffer+0x2a>
    0x840114fc    0x4e    li a5,5
    0x840114fe    0x50    auipc a4,0xc
    0x84011502    0x54    sd a5,1914(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84011506    0x58    li a0,3
    0x84011508    0x5a    j ffffffff840114d8 <checkValidIPCBuffer+0x2a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
36 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `checkValidIPCBuffer` has 56 nodes.

Section isValidVTableRoot (302 of 432)
======================================

Deriving specifications
-----------------------

Section `isValidVTableRoot` consists of 16 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `isValidVTableRoot`:

    0x84011486     0x0    addi sp,sp,-32
    0x84011488     0x2    sd ra,24(sp)          ; stack access
    0x8401148a     0x4    sd a0,0(sp)           ; stack access
    0x8401148c     0x6    sd a1,8(sp)           ; stack access
    0x8401148e     0x8    jal ra,ffffffff8401039e <cap_get_capType>
    0x84011492     0xc    li a5,3
    0x84011494     0xe    beq a0,a5,ffffffff840114a0 <isValidVTableRoot+0x1a>
    0x84011498    0x12    li a0,0
    0x8401149a    0x14    ld ra,24(sp)          ; stack access
    0x8401149c    0x16    addi sp,sp,32
    0x8401149e    0x18    ret
    0x840114a0    0x1a    ld a0,0(sp)           ; stack access
    0x840114a2    0x1c    ld a1,8(sp)           ; stack access
    0x840114a4    0x1e    jal ra,ffffffff8401072c <cap_page_table_cap_get_capPTIsMapped>
    0x840114a8    0x22    snez a0,a0
    0x840114ac    0x26    j ffffffff8401149a <isValidVTableRoot+0x14>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isValidVTableRoot` has 27 nodes.

Section handleVMFault (303 of 432)
==================================

Deriving specifications
-----------------------

Section `handleVMFault` consists of 40 instructions.

Skipping 14302573 csrr a0,stval


Stack analysis
---------------

1 stack accesses found. Annotated code for `handleVMFault`:

    0x84011192     0x0    addi sp,sp,-16
    0x84011194     0x2    sd ra,8(sp)           ; stack access
    0x84011196     0x4    csrr a0,stval
    0x8401119a     0x8    li a5,15
    0x8401119c     0xa    bltu a5,a1,ffffffff840111fa <handleVMFault+0x68>
    0x840111a0     0xe    slli a1,a1,0x2
    0x840111a2    0x10    auipc a4,0x7
    0x840111a6    0x14    addi a4,a4,-510 # ffffffff84017fa4 <ksDomScheduleLength+0x5c>
    0x840111aa    0x18    add a1,a1,a4
    0x840111ac    0x1a    lw a5,0(a1)
    0x840111ae    0x1c    add a5,a5,a4
    0x840111b0    0x1e    jr a5
    0x840111b2    0x20    li a2,0
    0x840111b4    0x22    li a1,5
    0x840111b6    0x24    jal ra,ffffffff840108ba <seL4_Fault_VMFault_new>
    0x840111ba    0x28    auipc a5,0xb
    0x840111be    0x2c    addi a5,a5,1606 # ffffffff8401c800 <current_fault>
    0x840111c2    0x30    sd a0,0(a5)
    0x840111c4    0x32    sd a1,8(a5)
    0x840111c6    0x34    li a0,1
    0x840111c8    0x36    ld ra,8(sp)
    0x840111ca    0x38    addi sp,sp,16
    0x840111cc    0x3a    ret
    0x840111ce    0x3c    li a2,0
    0x840111d0    0x3e    li a1,7
    0x840111d2    0x40    jal ra,ffffffff840108ba <seL4_Fault_VMFault_new>
    0x840111d6    0x44    auipc a5,0xb
    0x840111da    0x48    addi a5,a5,1578 # ffffffff8401c800 <current_fault>
    0x840111de    0x4c    sd a0,0(a5)
    0x840111e0    0x4e    sd a1,8(a5)
    0x840111e2    0x50    j ffffffff840111c6 <handleVMFault+0x34>
    0x840111e4    0x52    li a2,1
    0x840111e6    0x54    li a1,1
    0x840111e8    0x56    jal ra,ffffffff840108ba <seL4_Fault_VMFault_new>
    0x840111ec    0x5a    auipc a5,0xb
    0x840111f0    0x5e    addi a5,a5,1556 # ffffffff8401c800 <current_fault>
    0x840111f4    0x62    sd a0,0(a5)
    0x840111f6    0x64    sd a1,8(a5)
    0x840111f8    0x66    j ffffffff840111c6 <handleVMFault+0x34>
    0x840111fa    0x68    jal ra,ffffffff84010cec <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
40 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleVMFault` has 58 nodes.

Section trap_entry (304 of 432)
===============================

Deriving specifications
-----------------------

Section `trap_entry` consists of 48 instructions.

Skipping 140292f3 csrrw t0,sscratch,t0

Skipping 140020f3 csrr ra,sscratch

Skipping 100020f3 csrr ra,sstatus

Skipping 14202473 csrr s0,scause

Skipping 141020f3 csrr ra,sepc


Stack analysis
---------------

No stack accesses found. Code for `trap_entry`:

    0x84010000     0x0    csrrw t0,sscratch,t0
    0x84010004     0x4    sd ra,0(t0)
    0x84010008     0x8    sd sp,8(t0)
    0x8401000c     0xc    sd gp,16(t0)
    0x84010010    0x10    sd tp,24(t0)
    0x84010014    0x14    sd t1,40(t0)
    0x84010018    0x18    sd t2,48(t0)
    0x8401001c    0x1c    sd s0,56(t0)
    0x84010020    0x20    sd s1,64(t0)
    0x84010024    0x24    sd a0,72(t0)
    0x84010028    0x28    sd a1,80(t0)
    0x8401002c    0x2c    sd a2,88(t0)
    0x84010030    0x30    sd a3,96(t0)
    0x84010034    0x34    sd a4,104(t0)
    0x84010038    0x38    sd a5,112(t0)
    0x8401003c    0x3c    sd a6,120(t0)
    0x84010040    0x40    sd a7,128(t0)
    0x84010044    0x44    sd s2,136(t0)
    0x84010048    0x48    sd s3,144(t0)
    0x8401004c    0x4c    sd s4,152(t0)
    0x84010050    0x50    sd s5,160(t0)
    0x84010054    0x54    sd s6,168(t0)
    0x84010058    0x58    sd s7,176(t0)
    0x8401005c    0x5c    sd s8,184(t0)
    0x84010060    0x60    sd s9,192(t0)
    0x84010064    0x64    sd s10,200(t0)
    0x84010068    0x68    sd s11,208(t0)
    0x8401006c    0x6c    sd t3,216(t0)
    0x84010070    0x70    sd t4,224(t0)
    0x84010074    0x74    sd t5,232(t0)
    0x84010078    0x78    sd t6,240(t0)
    0x8401007c    0x7c    csrr ra,sscratch
    0x84010080    0x80    sd ra,32(t0)
    0x84010084    0x84    csrr ra,sstatus
    0x84010088    0x88    sd ra,256(t0)
    0x8401008c    0x8c    csrr s0,scause
    0x84010090    0x90    sd s0,248(t0)
    0x84010094    0x94    mv gp,gp
    0x84010098    0x98    auipc sp,0xe
    0x8401009c    0x9c    addi sp,sp,-1136 # ffffffff8401dc28 <ksIdleThread>
    0x840100a0    0xa0    csrr ra,sepc
    0x840100a4    0xa4    sd ra,264(t0)
    0x840100a8    0xa8    srli s2,s0,0x3f
    0x840100ac    0xac    li s1,1
    0x840100ae    0xae    beq s2,s1,ffffffff840100cc <interrupt>
    0x840100b2    0xb2    andi s0,s0,15
    0x840100b4    0xb4    li s4,8
    0x840100b6    0xb6    bne s0,s4,ffffffff840100c4 <exception>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
48 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `trap_entry` has 95 nodes.

Section populate_bi_frame (305 of 432)
======================================

Deriving specifications
-----------------------

Section `populate_bi_frame` consists of 55 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `populate_bi_frame`:

    0x84000d6a     0x0    addi sp,sp,-48
    0x84000d6c     0x2    sd ra,40(sp)          ; stack access
    0x84000d6e     0x4    sd s0,32(sp)          ; stack access
    0x84000d70     0x6    sd s1,24(sp)          ; stack access
    0x84000d72     0x8    sd s2,16(sp)          ; stack access
    0x84000d74     0xa    sd s3,8(sp)           ; stack access
    0x84000d76     0xc    mv s3,a0
    0x84000d78     0xe    mv s2,a1
    0x84000d7a    0x10    mv s1,a2
    0x84000d7c    0x12    mv s0,a3
    0x84000d7e    0x14    lui a1,0x1
    0x84000d80    0x16    auipc a0,0x1
    0x84000d84    0x1a    ld a0,-1520(a0) # ffffffff84001790 <rootserver+0x20>
    0x84000d88    0x1e    jal ra,ffffffff840164dc <memzero>
    0x84000d8c    0x22    bnez s0,ffffffff84000df0 <populate_bi_frame+0x86>
    0x84000d8e    0x24    auipc a5,0x0
    0x84000d92    0x28    addi a5,a5,1922 # ffffffff84001510 <ndks_boot>
    0x84000d96    0x2c    ld a4,640(a5)
    0x84000d9a    0x30    sd a4,584(a5)
    0x84000d9e    0x34    li a3,12
    0x84000da0    0x36    sd a3,592(a5)
    0x84000da4    0x3a    sd s3,8(a4)
    0x84000da8    0x3e    ld a4,640(a5)
    0x84000dac    0x42    sd s2,16(a4)
    0x84000db0    0x46    ld a4,640(a5)
    0x84000db4    0x4a    sd zero,24(a4)
    0x84000db8    0x4e    ld a4,640(a5)
    0x84000dbc    0x52    sd s1,32(a4)
    0x84000dbe    0x54    ld a5,640(a5)
    0x84000dc2    0x58    li a4,19
    0x84000dc4    0x5a    sd a4,136(a5)
    0x84000dc6    0x5c    auipc a4,0x2e
    0x84000dca    0x60    ld a4,-806(a4) # ffffffff8402eaa0 <ksDomScheduleIdx>
    0x84000dce    0x64    slli a3,a4,0x4
    0x84000dd2    0x68    auipc a4,0x17
    0x84000dd6    0x6c    addi a4,a4,1278 # ffffffff840182d0 <fault_messages>
    0x84000dda    0x70    add a4,a4,a3
    0x84000ddc    0x72    ld a4,192(a4)
    0x84000dde    0x74    sd a4,144(a5)
    0x84000de0    0x76    sd s0,0(a5)
    0x84000de2    0x78    ld ra,40(sp)          ; stack access
    0x84000de4    0x7a    ld s0,32(sp)          ; stack access
    0x84000de6    0x7c    ld s1,24(sp)          ; stack access
    0x84000de8    0x7e    ld s2,16(sp)          ; stack access
    0x84000dea    0x80    ld s3,8(sp)           ; stack access
    0x84000dec    0x82    addi sp,sp,48
    0x84000dee    0x84    ret
    0x84000df0    0x86    mv a0,s0
    0x84000df2    0x88    jal ra,ffffffff840006b6 <calculate_extra_bi_size_bits>
    0x84000df6    0x8c    li a1,1
    0x84000df8    0x8e    sll a1,a1,a0
    0x84000dfc    0x92    auipc a0,0x1
    0x84000e00    0x96    ld a0,-1636(a0) # ffffffff84001798 <rootserver+0x28>
    0x84000e04    0x9a    jal ra,ffffffff840164dc <memzero>
    0x84000e08    0x9e    j ffffffff84000d8e <populate_bi_frame+0x24>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
55 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `populate_bi_frame` has 89 nodes.

Section provide_cap (306 of 432)
================================

Deriving specifications
-----------------------

Section `provide_cap` consists of 30 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `provide_cap`:

    0x840006ee     0x0    addi sp,sp,-48
    0x840006f0     0x2    sd ra,40(sp)          ; stack access
    0x840006f2     0x4    sd s0,32(sp)          ; stack access
    0x840006f4     0x6    sd a0,16(sp)          ; stack access
    0x840006f6     0x8    sd a1,24(sp)          ; stack access
    0x840006f8     0xa    sd a2,0(sp)           ; stack access
    0x840006fa     0xc    sd a3,8(sp)           ; stack access
    0x840006fc     0xe    auipc a5,0x1
    0x84000700    0x12    addi a5,a5,-492 # ffffffff84001510 <ndks_boot>
    0x84000704    0x16    ld s0,592(a5)
    0x84000708    0x1a    ld a5,600(a5)
    0x8400070c    0x1e    bltu s0,a5,ffffffff8400071a <provide_cap+0x2c>
    0x84000710    0x22    li a0,0
    0x84000712    0x24    ld ra,40(sp)          ; stack access
    0x84000714    0x26    ld s0,32(sp)          ; stack access
    0x84000716    0x28    addi sp,sp,48
    0x84000718    0x2a    ret
    0x8400071a    0x2c    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x8400071e    0x30    slli s0,s0,0x5
    0x84000720    0x32    ld a1,0(sp)           ; stack access
    0x84000722    0x34    ld a2,8(sp)           ; stack access
    0x84000724    0x36    add a0,a0,s0
    0x84000726    0x38    jal ra,ffffffff840005bc <write_slot>
    0x8400072a    0x3c    auipc a4,0x1
    0x8400072e    0x40    addi a4,a4,-538 # ffffffff84001510 <ndks_boot>
    0x84000732    0x44    ld a5,592(a4)
    0x84000736    0x48    addi a5,a5,1
    0x84000738    0x4a    sd a5,592(a4)
    0x8400073c    0x4e    li a0,1
    0x8400073e    0x50    j ffffffff84000712 <provide_cap+0x24>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
30 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `provide_cap` has 49 nodes.

Section create_root_cnode (307 of 432)
======================================

Deriving specifications
-----------------------

Section `create_root_cnode` consists of 25 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `create_root_cnode`:

    0x840005f2     0x0    addi sp,sp,-48
    0x840005f4     0x2    sd ra,40(sp)          ; stack access
    0x840005f6     0x4    sd s0,32(sp)          ; stack access
    0x840005f8     0x6    auipc a5,0x1
    0x840005fc     0xa    addi a5,a5,-232 # ffffffff84001510 <ndks_boot>
    0x84000600     0xe    lui a4,0x80
    0x84000604    0x12    sd a4,600(a5)
    0x84000608    0x16    ld s0,608(a5)
    0x8400060c    0x1a    mv a3,s0
    0x8400060e    0x1c    li a2,0
    0x84000610    0x1e    li a1,45
    0x84000614    0x22    li a0,19
    0x84000616    0x24    jal ra,ffffffff8401057c <cap_cnode_cap_new>
    0x8400061a    0x28    mv a2,a1
    0x8400061c    0x2a    sd a0,0(sp)           ; stack access
    0x8400061e    0x2c    sd a1,8(sp)           ; stack access
    0x84000620    0x2e    mv a1,a0
    0x84000622    0x30    addi a0,s0,64
    0x84000626    0x34    jal ra,ffffffff840005bc <write_slot>
    0x8400062a    0x38    ld a0,0(sp)           ; stack access
    0x8400062c    0x3a    ld a1,8(sp)           ; stack access
    0x8400062e    0x3c    ld ra,40(sp)          ; stack access
    0x84000630    0x3e    ld s0,32(sp)          ; stack access
    0x84000632    0x40    addi sp,sp,48
    0x84000634    0x42    ret

Proving inst theorems
---------------------

25 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_root_cnode` has 38 nodes.

Section map_kernel_window (308 of 432)
======================================

Deriving specifications
-----------------------

Section `map_kernel_window` consists of 69 instructions.

RVC_FFFFT_________FT.

Stack analysis
---------------

16 stack accesses found. Annotated code for `map_kernel_window`:

    0x840004a0     0x0    addi sp,sp,-64
    0x840004a2     0x2    sd ra,56(sp)          ; stack access
    0x840004a4     0x4    sd s0,48(sp)          ; stack access
    0x840004a6     0x6    sd s1,40(sp)          ; stack access
    0x840004a8     0x8    sd s2,32(sp)          ; stack access
    0x840004aa     0xa    sd s3,24(sp)          ; stack access
    0x840004ac     0xc    sd s4,16(sp)          ; stack access
    0x840004ae     0xe    sd s5,8(sp)           ; stack access
    0x840004b0    0x10    sd s6,0(sp)           ; stack access
    0x840004b2    0x12    li s1,-1
    0x840004b4    0x14    slli s1,s1,0x26
    0x840004b6    0x16    auipc s6,0x1b
    0x840004ba    0x1a    addi s6,s6,-1206 # ffffffff8401b000 <kernel_root_pageTable>
    0x840004be    0x1e    li s2,1
    0x840004c0    0x20    slli s5,s2,0x26
    0x840004c4    0x24    lui s4,0x40000
    0x840004c8    0x28    lui s3,0x80000
    0x840004cc    0x2c    srli s0,s1,0x1e
    0x840004d0    0x30    andi s0,s0,511
    0x840004d4    0x34    slli s0,s0,0x3
    0x840004d6    0x36    add s0,s0,s6
    0x840004d8    0x38    mv a1,s2
    0x840004da    0x3a    add a0,s1,s5
    0x840004de    0x3e    jal ra,ffffffff840108fc <pte_next>
    0x840004e2    0x42    sd a0,0(s0)
    0x840004e4    0x44    add s1,s1,s4
    0x840004e6    0x46    bne s1,s3,ffffffff840004cc <map_kernel_window+0x2c>
    0x840004ea    0x4a    li s0,1
    0x840004ec    0x4c    slli a5,s0,0x20
    0x840004f0    0x50    auipc s1,0x1a
    0x840004f4    0x54    addi s1,s1,-1264 # ffffffff8401a000 <kernel_image_level2_pt>
    0x840004f8    0x58    add s1,s1,a5
    0x840004fa    0x5a    auipc s2,0x1c
    0x840004fe    0x5e    addi s2,s2,-1274 # ffffffff8401c000 <kernel_root_pageTable+0x1000>
    0x84000502    0x62    li a1,0
    0x84000504    0x64    mv a0,s1
    0x84000506    0x66    jal ra,ffffffff840108fc <pte_next>
    0x8400050a    0x6a    sd a0,-2032(s2)
    0x8400050e    0x6e    li a1,0
    0x84000510    0x70    mv a0,s1
    0x84000512    0x72    jal ra,ffffffff840108fc <pte_next>
    0x84000516    0x76    sd a0,-16(s2)
    0x8400051a    0x7a    li s2,0
    0x8400051c    0x7c    slli s0,s0,0x1f
    0x8400051e    0x7e    auipc s5,0x1a
    0x84000522    0x82    addi s5,s5,-1310 # ffffffff8401a000 <kernel_image_level2_pt>
    0x84000526    0x86    lui s4,0x200
    0x8400052a    0x8a    li s3,3
    0x8400052c    0x8c    slli s3,s3,0x1e
    0x8400052e    0x8e    slli s1,s2,0x3
    0x84000532    0x92    add s1,s1,s5
    0x84000534    0x94    li a1,1
    0x84000536    0x96    mv a0,s0
    0x84000538    0x98    jal ra,ffffffff840108fc <pte_next>
    0x8400053c    0x9c    sd a0,0(s1)
    0x8400053e    0x9e    addi s2,s2,1
    0x84000540    0xa0    add s0,s0,s4
    0x84000542    0xa2    bne s0,s3,ffffffff8400052e <map_kernel_window+0x8e>
    0x84000546    0xa6    jal ra,ffffffff8400047c <map_kernel_devices>
    0x8400054a    0xaa    ld ra,56(sp)          ; stack access
    0x8400054c    0xac    ld s0,48(sp)          ; stack access
    0x8400054e    0xae    ld s1,40(sp)          ; stack access
    0x84000550    0xb0    ld s2,32(sp)          ; stack access
    0x84000552    0xb2    ld s3,24(sp)          ; stack access
    0x84000554    0xb4    ld s4,16(sp)          ; stack access
    0x84000556    0xb6    ld s5,8(sp)           ; stack access
    0x84000558    0xb8    ld s6,0(sp)           ; stack access
    0x8400055a    0xba    addi sp,sp,64
    0x8400055c    0xbc    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
69 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `map_kernel_window` has 99 nodes.

Section map_kernel_devices (309 of 432)
=======================================

Deriving specifications
-----------------------

Section `map_kernel_devices` consists of 12 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `map_kernel_devices`:

    0x8400047c     0x0    addi sp,sp,-32
    0x8400047e     0x2    sd ra,24(sp)          ; stack access
    0x84000480     0x4    li a2,1
    0x84000482     0x6    lui a1,0xc0000
    0x84000486     0xa    lui a0,0xc000
    0x8400048a     0xe    jal ra,ffffffff840000c4 <map_kernel_frame>
    0x8400048e    0x12    lui a0,0xc000
    0x84000492    0x16    lui a1,0xc001
    0x84000496    0x1a    jal ra,ffffffff84000388 <reserve_region>
    0x8400049a    0x1e    ld ra,24(sp)          ; stack access
    0x8400049c    0x20    addi sp,sp,32
    0x8400049e    0x22    ret

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `map_kernel_devices` has 17 nodes.

Section create_mapped_it_frame_cap (310 of 432)
===============================================

Deriving specifications
-----------------------

Section `create_mapped_it_frame_cap` consists of 28 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `create_mapped_it_frame_cap`:

    0x8400028e     0x0    addi sp,sp,-80
    0x84000290     0x2    sd ra,72(sp)          ; stack access
    0x84000292     0x4    sd s0,64(sp)          ; stack access
    0x84000294     0x6    sd s1,56(sp)          ; stack access
    0x84000296     0x8    mv s1,a0
    0x84000298     0xa    mv s0,a1
    0x8400029a     0xc    mv a1,a2
    0x8400029c     0xe    mv a0,a4
    0x8400029e    0x10    mv a2,a5
    0x840002a0    0x12    mv a5,a3
    0x840002a2    0x14    li a4,0
    0x840002a4    0x16    li a3,3
    0x840002a6    0x18    snez a2,a2
    0x840002aa    0x1c    jal ra,ffffffff84010654 <cap_frame_cap_new>
    0x840002ae    0x20    mv a2,a0
    0x840002b0    0x22    mv a3,a1
    0x840002b2    0x24    sd a0,16(sp)          ; stack access
    0x840002b4    0x26    sd a1,24(sp)          ; stack access
    0x840002b6    0x28    mv a0,s1
    0x840002b8    0x2a    mv a1,s0
    0x840002ba    0x2c    jal ra,ffffffff84000218 <map_it_frame_cap>
    0x840002be    0x30    ld a0,16(sp)          ; stack access
    0x840002c0    0x32    ld a1,24(sp)          ; stack access
    0x840002c2    0x34    ld ra,72(sp)          ; stack access
    0x840002c4    0x36    ld s0,64(sp)          ; stack access
    0x840002c6    0x38    ld s1,56(sp)          ; stack access
    0x840002c8    0x3a    addi sp,sp,80
    0x840002ca    0x3c    ret

Proving inst theorems
---------------------

28 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_mapped_it_frame_cap` has 41 nodes.

Section c_handle_syscall (311 of 432)
=====================================

Deriving specifications
-----------------------

Section `c_handle_syscall` consists of 10 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_syscall`:

    0x84017d72     0x0    addi sp,sp,-16
    0x84017d74     0x2    sd ra,8(sp)           ; stack access
    0x84017d76     0x4    li a5,-1
    0x84017d78     0x6    beq a7,a5,ffffffff84017d88 <c_handle_syscall+0x16>
    0x84017d7c     0xa    li a5,-2
    0x84017d7e     0xc    beq a7,a5,ffffffff84017d8c <c_handle_syscall+0x1a>
    0x84017d82    0x10    mv a0,a7
    0x84017d84    0x12    jal ra,ffffffff84017648 <slowpath>
    0x84017d88    0x16    jal ra,ffffffff84017660 <fastpath_call>
    0x84017d8c    0x1a    jal ra,ffffffff840179b8 <fastpath_reply_recv>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_syscall` has 18 nodes.

Section slowpath (312 of 432)
=============================

Deriving specifications
-----------------------

Section `slowpath` consists of 8 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `slowpath`:

    0x84017648     0x0    addi sp,sp,-16
    0x8401764a     0x2    sd ra,8(sp)           ; stack access
    0x8401764c     0x4    li a5,-9
    0x8401764e     0x6    bgeu a5,a0,ffffffff8401765a <slowpath+0x12>
    0x84017652     0xa    jal ra,ffffffff84017500 <handleSyscall>
    0x84017656     0xe    jal ra,ffffffff84010c4a <restore_user_context>
    0x8401765a    0x12    jal ra,ffffffff84014fda <handleUnknownSyscall>
    0x8401765e    0x16    j ffffffff84017656 <slowpath+0xe>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `slowpath` has 14 nodes.

Section replyFromKernel_error (313 of 432)
==========================================

Deriving specifications
-----------------------

Section `replyFromKernel_error` consists of 22 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `replyFromKernel_error`:

    0x840163fc     0x0    addi sp,sp,-16
    0x840163fe     0x2    sd ra,8(sp)           ; stack access
    0x84016400     0x4    sd s0,0(sp)           ; stack access
    0x84016402     0x6    mv s0,a0
    0x84016404     0x8    mv a1,a0
    0x84016406     0xa    li a0,1
    0x84016408     0xc    jal ra,ffffffff84010f0e <lookupIPCBuffer>
    0x8401640c    0x10    mv a1,a0
    0x8401640e    0x12    sd zero,72(s0)
    0x84016412    0x16    mv a0,s0
    0x84016414    0x18    jal ra,ffffffff840162f0 <setMRs_syscall_error>
    0x84016418    0x1c    mv a3,a0
    0x8401641a    0x1e    li a2,0
    0x8401641c    0x20    li a1,0
    0x8401641e    0x22    auipc a0,0x8
    0x84016422    0x26    ld a0,-1958(a0) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016426    0x2a    jal ra,ffffffff840100f4 <seL4_MessageInfo_new>
    0x8401642a    0x2e    sd a0,80(s0)
    0x8401642c    0x30    ld ra,8(sp)           ; stack access
    0x8401642e    0x32    ld s0,0(sp)           ; stack access
    0x84016430    0x34    addi sp,sp,16
    0x84016432    0x36    ret

Proving inst theorems
---------------------

22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `replyFromKernel_error` has 33 nodes.

Section decodeUnbindNotification (314 of 432)
=============================================

Deriving specifications
-----------------------

Section `decodeUnbindNotification` consists of 25 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `decodeUnbindNotification`:

    0x8401615c     0x0    addi sp,sp,-32
    0x8401615e     0x2    sd ra,24(sp)          ; stack access
    0x84016160     0x4    sd s0,16(sp)          ; stack access
    0x84016162     0x6    sd a0,0(sp)           ; stack access
    0x84016164     0x8    sd a1,8(sp)           ; stack access
    0x84016166     0xa    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x8401616a     0xe    ld a5,304(a0)
    0x8401616e    0x12    beqz a5,ffffffff84016190 <decodeUnbindNotification+0x34>
    0x84016170    0x14    mv s0,a0
    0x84016172    0x16    li a1,2
    0x84016174    0x18    auipc a0,0x19
    0x84016178    0x1c    ld a0,-1756(a0) # ffffffff8402ea98 <ksCurThread>
    0x8401617c    0x20    jal ra,ffffffff84013020 <setThreadState>
    0x84016180    0x24    li a1,0
    0x84016182    0x26    mv a0,s0
    0x84016184    0x28    jal ra,ffffffff84016082 <invokeTCB_NotificationControl>
    0x84016188    0x2c    ld ra,24(sp)          ; stack access
    0x8401618a    0x2e    ld s0,16(sp)          ; stack access
    0x8401618c    0x30    addi sp,sp,32
    0x8401618e    0x32    ret
    0x84016190    0x34    li a5,3
    0x84016192    0x36    auipc a4,0x8
    0x84016196    0x3a    sd a5,-1306(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x8401619a    0x3e    li a0,3
    0x8401619c    0x40    j ffffffff84016188 <decodeUnbindNotification+0x2c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
25 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeUnbindNotification` has 40 nodes.

Section decodeWriteRegisters (315 of 432)
=========================================

Deriving specifications
-----------------------

Section `decodeWriteRegisters` consists of 55 instructions.


Stack analysis
---------------

16 stack accesses found. Annotated code for `decodeWriteRegisters`:

    0x84015ff2     0x0    addi sp,sp,-64
    0x84015ff4     0x2    sd ra,56(sp)          ; stack access
    0x84015ff6     0x4    sd s0,48(sp)          ; stack access
    0x84015ff8     0x6    sd s1,40(sp)          ; stack access
    0x84015ffa     0x8    sd s2,32(sp)          ; stack access
    0x84015ffc     0xa    sd s3,24(sp)          ; stack access
    0x84015ffe     0xc    sd s4,16(sp)          ; stack access
    0x84016000     0xe    sd a0,0(sp)           ; stack access
    0x84016002    0x10    sd a1,8(sp)           ; stack access
    0x84016004    0x12    li a5,1
    0x84016006    0x14    bgeu a5,a2,ffffffff84016058 <decodeWriteRegisters+0x66>
    0x8401600a    0x18    mv s0,a3
    0x8401600c    0x1a    auipc s1,0x19
    0x84016010    0x1e    ld s1,-1396(s1) # ffffffff8402ea98 <ksCurThread>
    0x84016014    0x22    ld s3,96(s1)
    0x84016018    0x26    addi a2,a2,-2
    0x8401601a    0x28    bltu a2,s3,ffffffff84016066 <decodeWriteRegisters+0x74>
    0x8401601e    0x2c    ld a0,0(sp)           ; stack access
    0x84016020    0x2e    ld a1,8(sp)           ; stack access
    0x84016022    0x30    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x84016026    0x34    mv s2,a0
    0x84016028    0x36    beq a0,s1,ffffffff84016074 <decodeWriteRegisters+0x82>
    0x8401602c    0x3a    ld s4,88(s1)
    0x84016030    0x3e    li a1,2
    0x84016032    0x40    mv a0,s1
    0x84016034    0x42    jal ra,ffffffff84013020 <setThreadState>
    0x84016038    0x46    mv a4,s0
    0x8401603a    0x48    li a3,0
    0x8401603c    0x4a    mv a2,s3
    0x8401603e    0x4c    andi a1,s4,1
    0x84016042    0x50    mv a0,s2
    0x84016044    0x52    jal ra,ffffffff84015f0c <invokeTCB_WriteRegisters>
    0x84016048    0x56    ld ra,56(sp)          ; stack access
    0x8401604a    0x58    ld s0,48(sp)          ; stack access
    0x8401604c    0x5a    ld s1,40(sp)          ; stack access
    0x8401604e    0x5c    ld s2,32(sp)          ; stack access
    0x84016050    0x5e    ld s3,24(sp)          ; stack access
    0x84016052    0x60    ld s4,16(sp)          ; stack access
    0x84016054    0x62    addi sp,sp,64
    0x84016056    0x64    ret
    0x84016058    0x66    li a5,7
    0x8401605a    0x68    auipc a4,0x8
    0x8401605e    0x6c    sd a5,-994(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016062    0x70    li a0,3
    0x84016064    0x72    j ffffffff84016048 <decodeWriteRegisters+0x56>
    0x84016066    0x74    li a5,7
    0x84016068    0x76    auipc a4,0x8
    0x8401606c    0x7a    sd a5,-1008(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016070    0x7e    li a0,3
    0x84016072    0x80    j ffffffff84016048 <decodeWriteRegisters+0x56>
    0x84016074    0x82    li a5,3
    0x84016076    0x84    auipc a4,0x8
    0x8401607a    0x88    sd a5,-1022(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x8401607e    0x8c    li a0,3
    0x84016080    0x8e    j ffffffff84016048 <decodeWriteRegisters+0x56>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
55 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeWriteRegisters` has 87 nodes.

Section decodeReadRegisters (316 of 432)
========================================

Deriving specifications
-----------------------

Section `decodeReadRegisters` consists of 60 instructions.


Stack analysis
---------------

16 stack accesses found. Annotated code for `decodeReadRegisters`:

    0x84015e6c     0x0    addi sp,sp,-64
    0x84015e6e     0x2    sd ra,56(sp)          ; stack access
    0x84015e70     0x4    sd s0,48(sp)          ; stack access
    0x84015e72     0x6    sd s1,40(sp)          ; stack access
    0x84015e74     0x8    sd s2,32(sp)          ; stack access
    0x84015e76     0xa    sd s3,24(sp)          ; stack access
    0x84015e78     0xc    sd a0,0(sp)           ; stack access
    0x84015e7a     0xe    sd a1,8(sp)           ; stack access
    0x84015e7c    0x10    li a5,1
    0x84015e7e    0x12    bgeu a5,a2,ffffffff84015ed6 <decodeReadRegisters+0x6a>
    0x84015e82    0x16    mv s0,a3
    0x84015e84    0x18    auipc s1,0x19
    0x84015e88    0x1c    ld s1,-1004(s1) # ffffffff8402ea98 <ksCurThread>
    0x84015e8c    0x20    ld s2,96(s1)
    0x84015e90    0x24    addi a4,s2,-1
    0x84015e94    0x28    li a5,31
    0x84015e96    0x2a    bltu a5,a4,ffffffff84015ee4 <decodeReadRegisters+0x78>
    0x84015e9a    0x2e    ld a0,0(sp)           ; stack access
    0x84015e9c    0x30    ld a1,8(sp)           ; stack access
    0x84015e9e    0x32    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x84015ea2    0x36    beq s1,a0,ffffffff84015efe <decodeReadRegisters+0x92>
    0x84015ea6    0x3a    ld s3,88(s1)
    0x84015eaa    0x3e    li a1,2
    0x84015eac    0x40    mv a0,s1
    0x84015eae    0x42    jal ra,ffffffff84013020 <setThreadState>
    0x84015eb2    0x46    ld a0,0(sp)           ; stack access
    0x84015eb4    0x48    ld a1,8(sp)           ; stack access
    0x84015eb6    0x4a    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x84015eba    0x4e    mv a4,s0
    0x84015ebc    0x50    li a3,0
    0x84015ebe    0x52    mv a2,s2
    0x84015ec0    0x54    andi a1,s3,1
    0x84015ec4    0x58    jal ra,ffffffff84015d56 <invokeTCB_ReadRegisters>
    0x84015ec8    0x5c    ld ra,56(sp)          ; stack access
    0x84015eca    0x5e    ld s0,48(sp)          ; stack access
    0x84015ecc    0x60    ld s1,40(sp)          ; stack access
    0x84015ece    0x62    ld s2,32(sp)          ; stack access
    0x84015ed0    0x64    ld s3,24(sp)          ; stack access
    0x84015ed2    0x66    addi sp,sp,64
    0x84015ed4    0x68    ret
    0x84015ed6    0x6a    li a5,7
    0x84015ed8    0x6c    auipc a4,0x8
    0x84015edc    0x70    sd a5,-608(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84015ee0    0x74    li a0,3
    0x84015ee2    0x76    j ffffffff84015ec8 <decodeReadRegisters+0x5c>
    0x84015ee4    0x78    auipc a5,0x8
    0x84015ee8    0x7c    addi a5,a5,-668 # ffffffff8401dc48 <current_syscall_error>
    0x84015eec    0x80    li a4,4
    0x84015eee    0x82    sd a4,48(a5)
    0x84015ef0    0x84    li a4,1
    0x84015ef2    0x86    sd a4,16(a5)
    0x84015ef4    0x88    li a4,32
    0x84015ef8    0x8c    sd a4,24(a5)
    0x84015efa    0x8e    li a0,3
    0x84015efc    0x90    j ffffffff84015ec8 <decodeReadRegisters+0x5c>
    0x84015efe    0x92    li a5,3
    0x84015f00    0x94    auipc a4,0x8
    0x84015f04    0x98    sd a5,-648(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84015f08    0x9c    li a0,3
    0x84015f0a    0x9e    j ffffffff84015ec8 <decodeReadRegisters+0x5c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
60 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeReadRegisters` has 95 nodes.

Section invokeTCB_CopyRegisters (317 of 432)
============================================

Deriving specifications
-----------------------

Section `invokeTCB_CopyRegisters` consists of 62 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `invokeTCB_CopyRegisters`:

    0x84015c16     0x0    addi sp,sp,-48
    0x84015c18     0x2    sd ra,40(sp)          ; stack access
    0x84015c1a     0x4    sd s0,32(sp)          ; stack access
    0x84015c1c     0x6    sd s1,24(sp)          ; stack access
    0x84015c1e     0x8    sd s2,16(sp)          ; stack access
    0x84015c20     0xa    sd s3,8(sp)           ; stack access
    0x84015c22     0xc    sd s4,0(sp)           ; stack access
    0x84015c24     0xe    mv s0,a0
    0x84015c26    0x10    mv s1,a1
    0x84015c28    0x12    mv s4,a3
    0x84015c2a    0x14    mv s3,a4
    0x84015c2c    0x16    mv s2,a5
    0x84015c2e    0x18    bnez a2,ffffffff84015caa <invokeTCB_CopyRegisters+0x94>
    0x84015c30    0x1a    bnez s4,ffffffff84015cb2 <invokeTCB_CopyRegisters+0x9c>
    0x84015c34    0x1e    beqz s3,ffffffff84015c64 <invokeTCB_CopyRegisters+0x4e>
    0x84015c38    0x22    auipc a3,0x2
    0x84015c3c    0x26    addi a3,a3,1928 # ffffffff840183c0 <frameRegisters>
    0x84015c40    0x2a    auipc a1,0x3
    0x84015c44    0x2e    addi a1,a1,-2048 # ffffffff84018440 <gpRegisters>
    0x84015c48    0x32    ld a4,0(a3)
    0x84015c4a    0x34    slli a4,a4,0x3
    0x84015c4c    0x36    add a2,s1,a4
    0x84015c50    0x3a    ld a2,0(a2)
    0x84015c52    0x3c    add a4,a4,s0
    0x84015c54    0x3e    sd a2,0(a4)
    0x84015c56    0x40    addi a3,a3,8
    0x84015c58    0x42    bne a3,a1,ffffffff84015c48 <invokeTCB_CopyRegisters+0x32>
    0x84015c5c    0x46    ld a5,264(s0)
    0x84015c60    0x4a    sd a5,272(s0)
    0x84015c64    0x4e    beqz s2,ffffffff84015c8c <invokeTCB_CopyRegisters+0x76>
    0x84015c68    0x52    auipc a4,0x2
    0x84015c6c    0x56    addi a4,a4,2008 # ffffffff84018440 <gpRegisters>
    0x84015c70    0x5a    auipc a2,0x3
    0x84015c74    0x5e    addi a2,a2,-1968 # ffffffff840184c0 <gpRegisters+0x80>
    0x84015c78    0x62    ld a5,0(a4)
    0x84015c7a    0x64    slli a5,a5,0x3
    0x84015c7c    0x66    add a3,s1,a5
    0x84015c80    0x6a    ld a3,0(a3)
    0x84015c82    0x6c    add a5,a5,s0
    0x84015c84    0x6e    sd a3,0(a5)
    0x84015c86    0x70    addi a4,a4,8
    0x84015c88    0x72    bne a4,a2,ffffffff84015c78 <invokeTCB_CopyRegisters+0x62>
    0x84015c8c    0x76    auipc a5,0x19
    0x84015c90    0x7a    ld a5,-500(a5) # ffffffff8402ea98 <ksCurThread>
    0x84015c94    0x7e    beq a5,s0,ffffffff84015cba <invokeTCB_CopyRegisters+0xa4>
    0x84015c98    0x82    li a0,0
    0x84015c9a    0x84    ld ra,40(sp)          ; stack access
    0x84015c9c    0x86    ld s0,32(sp)          ; stack access
    0x84015c9e    0x88    ld s1,24(sp)          ; stack access
    0x84015ca0    0x8a    ld s2,16(sp)          ; stack access
    0x84015ca2    0x8c    ld s3,8(sp)           ; stack access
    0x84015ca4    0x8e    ld s4,0(sp)           ; stack access
    0x84015ca6    0x90    addi sp,sp,48
    0x84015ca8    0x92    ret
    0x84015caa    0x94    mv a0,a1
    0x84015cac    0x96    jal ra,ffffffff84013afe <suspend>
    0x84015cb0    0x9a    j ffffffff84015c30 <invokeTCB_CopyRegisters+0x1a>
    0x84015cb2    0x9c    mv a0,s0
    0x84015cb4    0x9e    jal ra,ffffffff84014644 <restart>
    0x84015cb8    0xa2    j ffffffff84015c34 <invokeTCB_CopyRegisters+0x1e>
    0x84015cba    0xa4    jal ra,ffffffff84012fa8 <rescheduleRequired>
    0x84015cbe    0xa8    j ffffffff84015c98 <invokeTCB_CopyRegisters+0x82>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
62 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_CopyRegisters` has 101 nodes.

Section c_handle_exception (318 of 432)
=======================================

Deriving specifications
-----------------------

Section `c_handle_exception` consists of 17 instructions.

Skipping 14202573 csrr a0,scause


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_exception`:

    0x8401506c     0x0    addi sp,sp,-16
    0x8401506e     0x2    sd ra,8(sp)           ; stack access
    0x84015070     0x4    csrr a0,scause
    0x84015074     0x8    li a5,15
    0x84015076     0xa    bltu a5,a0,ffffffff84015096 <c_handle_exception+0x2a>
    0x8401507a     0xe    slli a4,a0,0x2
    0x8401507e    0x12    auipc a3,0x3
    0x84015082    0x16    addi a3,a3,306 # ffffffff840181b0 <ksDomScheduleLength+0x268>
    0x84015086    0x1a    add a4,a4,a3
    0x84015088    0x1c    lw a5,0(a4)
    0x8401508a    0x1e    add a5,a5,a3
    0x8401508c    0x20    jr a5
    0x8401508e    0x22    jal ra,ffffffff8401503a <handleVMFaultEvent>
    0x84015092    0x26    jal ra,ffffffff84010c4a <restore_user_context>
    0x84015096    0x2a    li a1,0
    0x84015098    0x2c    jal ra,ffffffff8401500a <handleUserLevelFault>
    0x8401509c    0x30    j ffffffff84015092 <c_handle_exception+0x26>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_exception` has 26 nodes.

Section lookupExtraCaps (319 of 432)
====================================

Deriving specifications
-----------------------

Section `lookupExtraCaps` consists of 66 instructions.


Stack analysis
---------------

18 stack accesses found. Annotated code for `lookupExtraCaps`:

    0x84014968     0x0    addi sp,sp,-80
    0x8401496a     0x2    sd ra,72(sp)          ; stack access
    0x8401496c     0x4    sd s0,64(sp)          ; stack access
    0x8401496e     0x6    sd s1,56(sp)          ; stack access
    0x84014970     0x8    sd s2,48(sp)          ; stack access
    0x84014972     0xa    sd s3,40(sp)          ; stack access
    0x84014974     0xc    sd s4,32(sp)          ; stack access
    0x84014976     0xe    sd s5,24(sp)          ; stack access
    0x84014978    0x10    sd s6,16(sp)          ; stack access
    0x8401497a    0x12    beqz a1,ffffffff840149d4 <lookupExtraCaps+0x6c>
    0x8401497c    0x14    mv s5,a0
    0x8401497e    0x16    mv s1,a1
    0x84014980    0x18    mv a0,a2
    0x84014982    0x1a    jal ra,ffffffff84010132 <seL4_MessageInfo_get_extraCaps>
    0x84014986    0x1e    mv s6,a0
    0x84014988    0x20    beqz a0,ffffffff84014a0a <lookupExtraCaps+0xa2>
    0x8401498a    0x22    addi s1,s1,976
    0x8401498e    0x26    auipc s3,0x9
    0x84014992    0x2a    addi s3,s3,754 # ffffffff8401dc80 <current_extra_caps>
    0x84014996    0x2e    li s2,0
    0x84014998    0x30    ld s4,0(s1)
    0x8401499c    0x34    mv a1,s4
    0x8401499e    0x36    mv a0,s5
    0x840149a0    0x38    jal ra,ffffffff84011bd8 <lookupSlot>
    0x840149a4    0x3c    sd a1,8(sp)           ; stack access
    0x840149a6    0x3e    mv s0,a0
    0x840149a8    0x40    bnez a0,ffffffff840149e0 <lookupExtraCaps+0x78>
    0x840149aa    0x42    ld a5,8(sp)           ; stack access
    0x840149ac    0x44    sd a5,0(s3)
    0x840149b0    0x48    addi s2,s2,1
    0x840149b2    0x4a    addi s1,s1,8
    0x840149b4    0x4c    addi s3,s3,8
    0x840149b6    0x4e    bne s6,s2,ffffffff84014998 <lookupExtraCaps+0x30>
    0x840149ba    0x52    li a5,2
    0x840149bc    0x54    bltu a5,s2,ffffffff840149f4 <lookupExtraCaps+0x8c>
    0x840149c0    0x58    slli s2,s2,0x3
    0x840149c2    0x5a    auipc a5,0x9
    0x840149c6    0x5e    addi a5,a5,702 # ffffffff8401dc80 <current_extra_caps>
    0x840149ca    0x62    add s2,s2,a5
    0x840149cc    0x64    sd zero,0(s2)
    0x840149d0    0x68    li s0,0
    0x840149d2    0x6a    j ffffffff840149f4 <lookupExtraCaps+0x8c>
    0x840149d4    0x6c    auipc a5,0x9
    0x840149d8    0x70    sd zero,684(a5) # ffffffff8401dc80 <current_extra_caps>
    0x840149dc    0x74    li s0,0
    0x840149de    0x76    j ffffffff840149f4 <lookupExtraCaps+0x8c>
    0x840149e0    0x78    li a1,0
    0x840149e2    0x7a    mv a0,s4
    0x840149e4    0x7c    jal ra,ffffffff8401085c <seL4_Fault_CapFault_new>
    0x840149e8    0x80    auipc a5,0x8
    0x840149ec    0x84    addi a5,a5,-488 # ffffffff8401c800 <current_fault>
    0x840149f0    0x88    sd a0,0(a5)
    0x840149f2    0x8a    sd a1,8(a5)
    0x840149f4    0x8c    mv a0,s0
    0x840149f6    0x8e    ld ra,72(sp)          ; stack access
    0x840149f8    0x90    ld s0,64(sp)          ; stack access
    0x840149fa    0x92    ld s1,56(sp)          ; stack access
    0x840149fc    0x94    ld s2,48(sp)          ; stack access
    0x840149fe    0x96    ld s3,40(sp)          ; stack access
    0x84014a00    0x98    ld s4,32(sp)          ; stack access
    0x84014a02    0x9a    ld s5,24(sp)          ; stack access
    0x84014a04    0x9c    ld s6,16(sp)          ; stack access
    0x84014a06    0x9e    addi sp,sp,80
    0x84014a08    0xa0    ret
    0x84014a0a    0xa2    mv s2,a0
    0x84014a0c    0xa4    j ffffffff840149c0 <lookupExtraCaps+0x58>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
66 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupExtraCaps` has 104 nodes.

Section setupCallerCap (320 of 432)
===================================

Deriving specifications
-----------------------

Section `setupCallerCap` consists of 25 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `setupCallerCap`:

    0x84014912     0x0    addi sp,sp,-48
    0x84014914     0x2    sd ra,40(sp)          ; stack access
    0x84014916     0x4    sd s0,32(sp)          ; stack access
    0x84014918     0x6    sd s1,24(sp)          ; stack access
    0x8401491a     0x8    sd s2,16(sp)          ; stack access
    0x8401491c     0xa    mv s0,a0
    0x8401491e     0xc    mv s1,a1
    0x84014920     0xe    mv s2,a2
    0x84014922    0x10    li a1,5
    0x84014924    0x12    jal ra,ffffffff84013020 <setThreadState>
    0x84014928    0x16    mv a2,s0
    0x8401492a    0x18    li a1,0
    0x8401492c    0x1a    mv a0,s2
    0x8401492e    0x1c    jal ra,ffffffff8401053c <cap_reply_cap_new>
    0x84014932    0x20    andi a3,s1,-1024
    0x84014936    0x24    andi a2,s0,-1024
    0x8401493a    0x28    addi a3,a3,96
    0x8401493e    0x2c    addi a2,a2,64
    0x84014942    0x30    jal ra,ffffffff84011e56 <cteInsert>
    0x84014946    0x34    ld ra,40(sp)          ; stack access
    0x84014948    0x36    ld s0,32(sp)          ; stack access
    0x8401494a    0x38    ld s1,24(sp)          ; stack access
    0x8401494c    0x3a    ld s2,16(sp)          ; stack access
    0x8401494e    0x3c    addi sp,sp,48
    0x84014950    0x3e    ret

Proving inst theorems
---------------------

25 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setupCallerCap` has 37 nodes.

Section invokeCNodeCancelBadgedSends (321 of 432)
=================================================

Deriving specifications
-----------------------

Section `invokeCNodeCancelBadgedSends` consists of 19 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `invokeCNodeCancelBadgedSends`:

    0x840139ba     0x0    addi sp,sp,-32
    0x840139bc     0x2    sd ra,24(sp)          ; stack access
    0x840139be     0x4    sd s0,16(sp)          ; stack access
    0x840139c0     0x6    sd a0,0(sp)           ; stack access
    0x840139c2     0x8    sd a1,8(sp)           ; stack access
    0x840139c4     0xa    jal ra,ffffffff84010446 <cap_endpoint_cap_get_capEPBadge>
    0x840139c8     0xe    bnez a0,ffffffff840139d4 <invokeCNodeCancelBadgedSends+0x1a>
    0x840139ca    0x10    li a0,0
    0x840139cc    0x12    ld ra,24(sp)          ; stack access
    0x840139ce    0x14    ld s0,16(sp)          ; stack access
    0x840139d0    0x16    addi sp,sp,32
    0x840139d2    0x18    ret
    0x840139d4    0x1a    mv s0,a0
    0x840139d6    0x1c    ld a0,0(sp)           ; stack access
    0x840139d8    0x1e    ld a1,8(sp)           ; stack access
    0x840139da    0x20    jal ra,ffffffff840109fe <cap_endpoint_cap_get_capEPPtr>
    0x840139de    0x24    mv a1,s0
    0x840139e0    0x26    jal ra,ffffffff840138ec <cancelBadgedSends>
    0x840139e4    0x2a    j ffffffff840139ca <invokeCNodeCancelBadgedSends+0x10>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
19 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeCancelBadgedSends` has 33 nodes.

Section chooseThread (322 of 432)
=================================

Deriving specifications
-----------------------

Section `chooseThread` consists of 44 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `chooseThread`:

    0x840135c6     0x0    addi sp,sp,-32
    0x840135c8     0x2    sd ra,24(sp)          ; stack access
    0x840135ca     0x4    sd s0,16(sp)          ; stack access
    0x840135cc     0x6    sd s1,8(sp)           ; stack access
    0x840135ce     0x8    auipc s1,0x1b
    0x840135d2     0xc    ld s1,562(s1) # ffffffff8402e800 <ksCurDomain>
    0x840135d6    0x10    slli a4,s1,0x3
    0x840135da    0x14    auipc a5,0x1b
    0x840135de    0x18    addi a5,a5,1086 # ffffffff8402ea18 <ksReadyQueuesL1Bitmap>
    0x840135e2    0x1c    add a5,a5,a4
    0x840135e4    0x1e    ld a0,0(a5)
    0x840135e6    0x20    beqz a0,ffffffff8401363c <chooseThread+0x76>
    0x840135e8    0x22    jal ra,ffffffff84017f02 <__clzdi2>
    0x840135ec    0x26    sext.w s0,a0
    0x840135f0    0x2a    slli a5,s1,0x2
    0x840135f4    0x2e    addi a4,s0,-60
    0x840135f8    0x32    add a5,a5,a4
    0x840135fa    0x34    slli a5,a5,0x3
    0x840135fc    0x36    auipc a4,0x1b
    0x84013600    0x3a    addi a4,a4,532 # ffffffff8402e810 <ksReadyQueuesL2Bitmap>
    0x84013604    0x3e    add a5,a5,a4
    0x84013606    0x40    ld a0,0(a5)
    0x84013608    0x42    jal ra,ffffffff84017f02 <__clzdi2>
    0x8401360c    0x46    sext.w a0,a0
    0x8401360e    0x48    li a5,63
    0x84013612    0x4c    sub s0,a5,s0
    0x84013616    0x50    slli s0,s0,0x6
    0x84013618    0x52    sub a5,a5,a0
    0x8401361a    0x54    or s0,s0,a5
    0x8401361c    0x56    slli s1,s1,0x8
    0x8401361e    0x58    add s0,s0,s1
    0x84013620    0x5a    slli s0,s0,0x4
    0x84013622    0x5c    auipc s1,0xb
    0x84013626    0x60    addi s1,s1,-1994 # ffffffff8401de58 <ksReadyQueues>
    0x8401362a    0x64    add s0,s0,s1
    0x8401362c    0x66    ld a0,0(s0)
    0x8401362e    0x68    jal ra,ffffffff840135a4 <switchToThread>
    0x84013632    0x6c    ld ra,24(sp)          ; stack access
    0x84013634    0x6e    ld s0,16(sp)          ; stack access
    0x84013636    0x70    ld s1,8(sp)           ; stack access
    0x84013638    0x72    addi sp,sp,32
    0x8401363a    0x74    ret
    0x8401363c    0x76    jal ra,ffffffff84011dfc <switchToIdleThread>
    0x84013640    0x7a    j ffffffff84013632 <chooseThread+0x6c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
44 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `chooseThread` has 61 nodes.

Section timerTick (323 of 432)
==============================

Deriving specifications
-----------------------

Section `timerTick` consists of 38 instructions.


Stack analysis
---------------

7 stack accesses found. Annotated code for `timerTick`:

    0x84013466     0x0    addi sp,sp,-48
    0x84013468     0x2    sd ra,40(sp)          ; stack access
    0x8401346a     0x4    sd s0,32(sp)          ; stack access
    0x8401346c     0x6    auipc s0,0x1b
    0x84013470     0xa    ld s0,1580(s0) # ffffffff8402ea98 <ksCurThread>
    0x84013474     0xe    ld a5,280(s0)
    0x84013478    0x12    sd a5,0(sp)           ; stack access
    0x8401347a    0x14    ld a5,288(s0)
    0x8401347e    0x18    sd a5,8(sp)           ; stack access
    0x84013480    0x1a    ld a5,296(s0)
    0x84013484    0x1e    sd a5,16(sp)          ; stack access
    0x84013486    0x20    mv a0,sp
    0x84013488    0x22    jal ra,ffffffff84010382 <thread_state_get_tsType>
    0x8401348c    0x26    li a5,1
    0x8401348e    0x28    bne a0,a5,ffffffff840134a2 <timerTick+0x3c>
    0x84013492    0x2c    ld a5,368(s0)
    0x84013496    0x30    li a4,1
    0x84013498    0x32    bgeu a4,a5,ffffffff840134ba <timerTick+0x54>
    0x8401349c    0x36    addi a5,a5,-1
    0x8401349e    0x38    sd a5,368(s0)
    0x840134a2    0x3c    auipc a4,0x1b
    0x840134a6    0x40    addi a4,a4,-1610 # ffffffff8402de58 <ksDomainTime>
    0x840134aa    0x44    ld a5,0(a4)
    0x840134ac    0x46    addi a5,a5,-1
    0x840134ae    0x48    sd a5,0(a4)
    0x840134b0    0x4a    beqz a5,ffffffff840134cc <timerTick+0x66>
    0x840134b2    0x4c    ld ra,40(sp)          ; stack access
    0x840134b4    0x4e    ld s0,32(sp)          ; stack access
    0x840134b6    0x50    addi sp,sp,48
    0x840134b8    0x52    ret
    0x840134ba    0x54    li a5,5
    0x840134bc    0x56    sd a5,368(s0)
    0x840134c0    0x5a    mv a0,s0
    0x840134c2    0x5c    jal ra,ffffffff840133ba <tcbSchedAppend>
    0x840134c6    0x60    jal ra,ffffffff84012fa8 <rescheduleRequired>
    0x840134ca    0x64    j ffffffff840134a2 <timerTick+0x3c>
    0x840134cc    0x66    jal ra,ffffffff84012fa8 <rescheduleRequired>
    0x840134d0    0x6a    j ffffffff840134b2 <timerTick+0x4c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
38 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `timerTick` has 65 nodes.

Section activateThread (324 of 432)
===================================

Deriving specifications
-----------------------

Section `activateThread` consists of 29 instructions.


Stack analysis
---------------

7 stack accesses found. Annotated code for `activateThread`:

    0x84013112     0x0    addi sp,sp,-48
    0x84013114     0x2    sd ra,40(sp)          ; stack access
    0x84013116     0x4    sd s0,32(sp)          ; stack access
    0x84013118     0x6    auipc s0,0x1c
    0x8401311c     0xa    ld s0,-1664(s0) # ffffffff8402ea98 <ksCurThread>
    0x84013120     0xe    ld a5,280(s0)
    0x84013124    0x12    sd a5,0(sp)           ; stack access
    0x84013126    0x14    ld a5,288(s0)
    0x8401312a    0x18    sd a5,8(sp)           ; stack access
    0x8401312c    0x1a    ld a5,296(s0)
    0x84013130    0x1e    sd a5,16(sp)          ; stack access
    0x84013132    0x20    mv a0,sp
    0x84013134    0x22    jal ra,ffffffff84010382 <thread_state_get_tsType>
    0x84013138    0x26    li a5,2
    0x8401313a    0x28    beq a0,a5,ffffffff8401314e <activateThread+0x3c>
    0x8401313e    0x2c    li a5,7
    0x84013140    0x2e    beq a0,a5,ffffffff8401315e <activateThread+0x4c>
    0x84013144    0x32    li a5,1
    0x84013146    0x34    beq a0,a5,ffffffff8401315e <activateThread+0x4c>
    0x8401314a    0x38    jal ra,ffffffff84010cec <halt>
    0x8401314e    0x3c    ld a5,264(s0)
    0x84013152    0x40    sd a5,272(s0)
    0x84013156    0x44    li a1,1
    0x84013158    0x46    mv a0,s0
    0x8401315a    0x48    jal ra,ffffffff84013020 <setThreadState>
    0x8401315e    0x4c    ld ra,40(sp)          ; stack access
    0x84013160    0x4e    ld s0,32(sp)          ; stack access
    0x84013162    0x50    addi sp,sp,48
    0x84013164    0x52    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
29 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `activateThread` has 52 nodes.

Section createNewObjects (325 of 432)
=====================================

Deriving specifications
-----------------------

Section `createNewObjects` consists of 52 instructions.


Stack analysis
---------------

20 stack accesses found. Annotated code for `createNewObjects`:

    0x84012e84     0x0    addi sp,sp,-96
    0x84012e86     0x2    sd ra,88(sp)          ; stack access
    0x84012e88     0x4    sd s0,80(sp)          ; stack access
    0x84012e8a     0x6    sd s1,72(sp)          ; stack access
    0x84012e8c     0x8    sd s2,64(sp)          ; stack access
    0x84012e8e     0xa    sd s3,56(sp)          ; stack access
    0x84012e90     0xc    sd s4,48(sp)          ; stack access
    0x84012e92     0xe    sd s5,40(sp)          ; stack access
    0x84012e94    0x10    sd s6,32(sp)          ; stack access
    0x84012e96    0x12    sd s7,24(sp)          ; stack access
    0x84012e98    0x14    sd s8,16(sp)          ; stack access
    0x84012e9a    0x16    mv s5,a0
    0x84012e9c    0x18    mv s6,a1
    0x84012e9e    0x1a    mv s1,a2
    0x84012ea0    0x1c    mv s0,a3
    0x84012ea2    0x1e    mv s2,a4
    0x84012ea4    0x20    mv s7,a5
    0x84012ea6    0x22    mv s3,a6
    0x84012ea8    0x24    mv s8,a7
    0x84012eaa    0x26    mv a1,a6
    0x84012eac    0x28    jal ra,ffffffff84012548 <getObjectSize>
    0x84012eb0    0x2c    beqz s2,ffffffff84012ee4 <createNewObjects+0x60>
    0x84012eb4    0x30    sext.w s4,a0
    0x84012eb8    0x34    slli s0,s0,0x5
    0x84012eba    0x36    add s1,s1,s0
    0x84012ebc    0x38    li s0,0
    0x84012ebe    0x3a    sll a1,s0,s4
    0x84012ec2    0x3e    mv a3,s8
    0x84012ec4    0x40    mv a2,s3
    0x84012ec6    0x42    add a1,a1,s7
    0x84012ec8    0x44    mv a0,s5
    0x84012eca    0x46    jal ra,ffffffff84012dd2 <createObject>
    0x84012ece    0x4a    mv a2,a0
    0x84012ed0    0x4c    mv a3,a1
    0x84012ed2    0x4e    mv a1,s1
    0x84012ed4    0x50    mv a0,s6
    0x84012ed6    0x52    jal ra,ffffffff84012196 <insertNewCap>
    0x84012eda    0x56    addi s0,s0,1
    0x84012edc    0x58    addi s1,s1,32
    0x84012ee0    0x5c    bne s2,s0,ffffffff84012ebe <createNewObjects+0x3a>
    0x84012ee4    0x60    ld ra,88(sp)          ; stack access
    0x84012ee6    0x62    ld s0,80(sp)          ; stack access
    0x84012ee8    0x64    ld s1,72(sp)          ; stack access
    0x84012eea    0x66    ld s2,64(sp)          ; stack access
    0x84012eec    0x68    ld s3,56(sp)          ; stack access
    0x84012eee    0x6a    ld s4,48(sp)          ; stack access
    0x84012ef0    0x6c    ld s5,40(sp)          ; stack access
    0x84012ef2    0x6e    ld s6,32(sp)          ; stack access
    0x84012ef4    0x70    ld s7,24(sp)          ; stack access
    0x84012ef6    0x72    ld s8,16(sp)          ; stack access
    0x84012ef8    0x74    addi sp,sp,96
    0x84012efa    0x76    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
52 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `createNewObjects` has 80 nodes.

Section isFinalCapability (326 of 432)
======================================

Deriving specifications
-----------------------

Section `isFinalCapability` consists of 35 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `isFinalCapability`:

    0x84012af4     0x0    addi sp,sp,-32
    0x84012af6     0x2    sd ra,24(sp)          ; stack access
    0x84012af8     0x4    sd s0,16(sp)          ; stack access
    0x84012afa     0x6    mv s0,a0
    0x84012afc     0x8    ld a0,16(a0)
    0x84012afe     0xa    sd a0,0(sp)           ; stack access
    0x84012b00     0xc    ld a1,24(s0)
    0x84012b02     0xe    sd a1,8(sp)           ; stack access
    0x84012b04    0x10    jal ra,ffffffff84010208 <mdb_node_get_mdbPrev>
    0x84012b08    0x14    beqz a0,ffffffff84012b1e <isFinalCapability+0x2a>
    0x84012b0a    0x16    mv a5,a0
    0x84012b0c    0x18    ld a2,0(s0)
    0x84012b0e    0x1a    ld a3,8(s0)
    0x84012b10    0x1c    ld a0,0(a0)
    0x84012b12    0x1e    ld a1,8(a5)
    0x84012b14    0x20    jal ra,ffffffff84012a88 <sameObjectAs>
    0x84012b18    0x24    mv a5,a0
    0x84012b1a    0x26    li a0,0
    0x84012b1c    0x28    bnez a5,ffffffff84012b3c <isFinalCapability+0x48>
    0x84012b1e    0x2a    ld a0,0(sp)           ; stack access
    0x84012b20    0x2c    ld a1,8(sp)           ; stack access
    0x84012b22    0x2e    jal ra,ffffffff84010b08 <mdb_node_get_mdbNext>
    0x84012b26    0x32    mv a5,a0
    0x84012b28    0x34    li a0,1
    0x84012b2a    0x36    beqz a5,ffffffff84012b3c <isFinalCapability+0x48>
    0x84012b2c    0x38    ld a2,0(a5)
    0x84012b2e    0x3a    ld a3,8(a5)
    0x84012b30    0x3c    ld a0,0(s0)
    0x84012b32    0x3e    ld a1,8(s0)
    0x84012b34    0x40    jal ra,ffffffff84012a88 <sameObjectAs>
    0x84012b38    0x44    seqz a0,a0
    0x84012b3c    0x48    ld ra,24(sp)          ; stack access
    0x84012b3e    0x4a    ld s0,16(sp)          ; stack access
    0x84012b40    0x4c    addi sp,sp,32
    0x84012b42    0x4e    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
35 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isFinalCapability` has 64 nodes.

Section sameObjectAs (327 of 432)
=================================

Deriving specifications
-----------------------

Section `sameObjectAs` consists of 45 instructions.


Stack analysis
---------------

20 stack accesses found. Annotated code for `sameObjectAs`:

    0x84012a88     0x0    addi sp,sp,-64
    0x84012a8a     0x2    sd ra,56(sp)          ; stack access
    0x84012a8c     0x4    sd a0,16(sp)          ; stack access
    0x84012a8e     0x6    sd a1,24(sp)          ; stack access
    0x84012a90     0x8    sd a2,0(sp)           ; stack access
    0x84012a92     0xa    sd a3,8(sp)           ; stack access
    0x84012a94     0xc    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012a98    0x10    li a5,2
    0x84012a9a    0x12    beq a0,a5,ffffffff84012af0 <sameObjectAs+0x68>
    0x84012a9e    0x16    li a5,14
    0x84012aa0    0x18    beq a0,a5,ffffffff84012ace <sameObjectAs+0x46>
    0x84012aa4    0x1c    ld a0,16(sp)          ; stack access
    0x84012aa6    0x1e    ld a1,24(sp)          ; stack access
    0x84012aa8    0x20    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012aac    0x24    andi a0,a0,1
    0x84012aae    0x26    beqz a0,ffffffff84012abc <sameObjectAs+0x34>
    0x84012ab0    0x28    ld a0,0(sp)           ; stack access
    0x84012ab2    0x2a    ld a1,8(sp)           ; stack access
    0x84012ab4    0x2c    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012ab8    0x30    andi a0,a0,1
    0x84012aba    0x32    bnez a0,ffffffff84012ae2 <sameObjectAs+0x5a>
    0x84012abc    0x34    ld a2,0(sp)           ; stack access
    0x84012abe    0x36    ld a3,8(sp)           ; stack access
    0x84012ac0    0x38    ld a0,16(sp)          ; stack access
    0x84012ac2    0x3a    ld a1,24(sp)          ; stack access
    0x84012ac4    0x3c    jal ra,ffffffff840125de <sameRegionAs>
    0x84012ac8    0x40    ld ra,56(sp)          ; stack access
    0x84012aca    0x42    addi sp,sp,64
    0x84012acc    0x44    ret
    0x84012ace    0x46    ld a0,0(sp)           ; stack access
    0x84012ad0    0x48    ld a1,8(sp)           ; stack access
    0x84012ad2    0x4a    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012ad6    0x4e    mv a4,a0
    0x84012ad8    0x50    li a5,16
    0x84012ada    0x52    li a0,0
    0x84012adc    0x54    bne a4,a5,ffffffff84012aa4 <sameObjectAs+0x1c>
    0x84012ae0    0x58    j ffffffff84012ac8 <sameObjectAs+0x40>
    0x84012ae2    0x5a    ld a2,0(sp)           ; stack access
    0x84012ae4    0x5c    ld a3,8(sp)           ; stack access
    0x84012ae6    0x5e    ld a0,16(sp)          ; stack access
    0x84012ae8    0x60    ld a1,24(sp)          ; stack access
    0x84012aea    0x62    jal ra,ffffffff8401194c <Arch_sameObjectAs>
    0x84012aee    0x66    j ffffffff84012ac8 <sameObjectAs+0x40>
    0x84012af0    0x68    li a0,0
    0x84012af2    0x6a    j ffffffff84012ac8 <sameObjectAs+0x40>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
45 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sameObjectAs` has 82 nodes.

Section invokeIRQControl (328 of 432)
=====================================

Deriving specifications
-----------------------

Section `invokeIRQControl` consists of 23 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `invokeIRQControl`:

    0x840123a2     0x0    addi sp,sp,-48
    0x840123a4     0x2    sd ra,40(sp)          ; stack access
    0x840123a6     0x4    sd s0,32(sp)          ; stack access
    0x840123a8     0x6    sd s1,24(sp)          ; stack access
    0x840123aa     0x8    sd s2,16(sp)          ; stack access
    0x840123ac     0xa    mv s0,a0
    0x840123ae     0xc    mv s2,a1
    0x840123b0     0xe    mv s1,a2
    0x840123b2    0x10    mv a1,a0
    0x840123b4    0x12    li a0,1
    0x840123b6    0x14    jal ra,ffffffff8401233c <setIRQState>
    0x840123ba    0x18    mv a0,s0
    0x840123bc    0x1a    jal ra,ffffffff840105fe <cap_irq_handler_cap_new>
    0x840123c0    0x1e    mv a3,s2
    0x840123c2    0x20    mv a2,s1
    0x840123c4    0x22    jal ra,ffffffff84011e56 <cteInsert>
    0x840123c8    0x26    li a0,0
    0x840123ca    0x28    ld ra,40(sp)          ; stack access
    0x840123cc    0x2a    ld s0,32(sp)          ; stack access
    0x840123ce    0x2c    ld s1,24(sp)          ; stack access
    0x840123d0    0x2e    ld s2,16(sp)          ; stack access
    0x840123d2    0x30    addi sp,sp,48
    0x840123d4    0x32    ret

Proving inst theorems
---------------------

23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeIRQControl` has 35 nodes.

Section getReceiveSlots (329 of 432)
====================================

Deriving specifications
-----------------------

Section `getReceiveSlots` consists of 43 instructions.

RVC_FFFT__________FF.

Stack analysis
---------------

15 stack accesses found. Annotated code for `getReceiveSlots`:

    0x84012280     0x0    addi sp,sp,-96
    0x84012282     0x2    sd ra,88(sp)          ; stack access
    0x84012284     0x4    sd s0,80(sp)          ; stack access
    0x84012286     0x6    sd s1,72(sp)          ; stack access
    0x84012288     0x8    sd s2,64(sp)          ; stack access
    0x8401228a     0xa    beqz a1,ffffffff840122de <getReceiveSlots+0x5e>
    0x8401228c     0xc    ld s1,1008(a1)
    0x84012290    0x10    ld s2,1016(a1)
    0x84012294    0x14    ld a2,1000(a1)
    0x84012298    0x18    mv a1,a0
    0x8401229a    0x1a    addi a0,sp,40
    0x8401229c    0x1c    jal ra,ffffffff84011bfa <lookupCap>
    0x840122a0    0x20    ld a5,40(sp)          ; stack access
    0x840122a2    0x22    li s0,0
    0x840122a4    0x24    bnez a5,ffffffff840122d0 <getReceiveSlots+0x50>
    0x840122a6    0x26    ld a0,48(sp)          ; stack access
    0x840122a8    0x28    sd a0,8(sp)           ; stack access
    0x840122aa    0x2a    ld a1,56(sp)          ; stack access
    0x840122ac    0x2c    sd a1,16(sp)          ; stack access
    0x840122ae    0x2e    mv a3,s2
    0x840122b0    0x30    mv a2,s1
    0x840122b2    0x32    jal ra,ffffffff84011d7a <lookupTargetSlot>
    0x840122b6    0x36    sd a0,24(sp)          ; stack access
    0x840122b8    0x38    sd a1,32(sp)          ; stack access
    0x840122ba    0x3a    bnez a0,ffffffff840122e2 <getReceiveSlots+0x62>
    0x840122bc    0x3c    mv s0,a1
    0x840122be    0x3e    ld a0,0(a1)
    0x840122c0    0x40    ld a1,8(a1)
    0x840122c2    0x42    jal ra,ffffffff8401039e <cap_get_capType>
    0x840122c6    0x46    seqz a0,a0
    0x840122ca    0x4a    neg a0,a0
    0x840122ce    0x4e    and s0,s0,a0
    0x840122d0    0x50    mv a0,s0
    0x840122d2    0x52    ld ra,88(sp)          ; stack access
    0x840122d4    0x54    ld s0,80(sp)          ; stack access
    0x840122d6    0x56    ld s1,72(sp)          ; stack access
    0x840122d8    0x58    ld s2,64(sp)          ; stack access
    0x840122da    0x5a    addi sp,sp,96
    0x840122dc    0x5c    ret
    0x840122de    0x5e    mv s0,a1
    0x840122e0    0x60    j ffffffff840122d0 <getReceiveSlots+0x50>
    0x840122e2    0x62    li s0,0
    0x840122e4    0x64    j ffffffff840122d0 <getReceiveSlots+0x50>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
43 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getReceiveSlots` has 73 nodes.

Section doFaultTransfer (330 of 432)
====================================

Deriving specifications
-----------------------

Section `doFaultTransfer` consists of 30 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `doFaultTransfer`:

    0x84011dae     0x0    addi sp,sp,-48
    0x84011db0     0x2    sd ra,40(sp)          ; stack access
    0x84011db2     0x4    sd s0,32(sp)          ; stack access
    0x84011db4     0x6    sd s1,24(sp)          ; stack access
    0x84011db6     0x8    sd s2,16(sp)          ; stack access
    0x84011db8     0xa    sd s3,8(sp)           ; stack access
    0x84011dba     0xc    mv s2,a0
    0x84011dbc     0xe    mv s1,a1
    0x84011dbe    0x10    mv s0,a2
    0x84011dc0    0x12    mv a2,a3
    0x84011dc2    0x14    mv a1,s0
    0x84011dc4    0x16    mv a0,s1
    0x84011dc6    0x18    jal ra,ffffffff84010d5c <setMRs_fault>
    0x84011dca    0x1c    mv s3,a0
    0x84011dcc    0x1e    ld a0,312(s1)
    0x84011dd0    0x22    ld a1,320(s1)
    0x84011dd4    0x26    jal ra,ffffffff8401084a <seL4_Fault_get_seL4_FaultType>
    0x84011dd8    0x2a    mv a3,s3
    0x84011dda    0x2c    li a2,0
    0x84011ddc    0x2e    li a1,0
    0x84011dde    0x30    jal ra,ffffffff840100f4 <seL4_MessageInfo_new>
    0x84011de2    0x34    sd a0,80(s0)
    0x84011de4    0x36    sd s2,72(s0)
    0x84011de8    0x3a    ld ra,40(sp)          ; stack access
    0x84011dea    0x3c    ld s0,32(sp)          ; stack access
    0x84011dec    0x3e    ld s1,24(sp)          ; stack access
    0x84011dee    0x40    ld s2,16(sp)          ; stack access
    0x84011df0    0x42    ld s3,8(sp)           ; stack access
    0x84011df2    0x44    addi sp,sp,48
    0x84011df4    0x46    ret

Proving inst theorems
---------------------

30 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doFaultTransfer` has 48 nodes.

Section Arch_createObject (331 of 432)
======================================

Deriving specifications
-----------------------

Section `Arch_createObject` consists of 48 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `Arch_createObject`:

    0x84011a0e     0x0    addi sp,sp,-32
    0x84011a10     0x2    sd ra,24(sp)          ; stack access
    0x84011a12     0x4    mv a4,a3
    0x84011a14     0x6    li a5,7
    0x84011a16     0x8    beq a0,a5,ffffffff84011a5a <Arch_createObject+0x4c>
    0x84011a1a     0xc    bltu a5,a0,ffffffff84011a44 <Arch_createObject+0x36>
    0x84011a1e    0x10    li a5,5
    0x84011a20    0x12    beq a0,a5,ffffffff84011a6c <Arch_createObject+0x5e>
    0x84011a24    0x16    li a5,6
    0x84011a26    0x18    bne a0,a5,ffffffff84011a7e <Arch_createObject+0x70>
    0x84011a2a    0x1c    li a5,0
    0x84011a2c    0x1e    li a3,3
    0x84011a2e    0x20    li a2,0
    0x84011a30    0x22    li a0,0
    0x84011a32    0x24    jal ra,ffffffff84010654 <cap_frame_cap_new>
    0x84011a36    0x28    sd a0,0(sp)           ; stack access
    0x84011a38    0x2a    sd a1,8(sp)           ; stack access
    0x84011a3a    0x2c    ld a0,0(sp)           ; stack access
    0x84011a3c    0x2e    ld a1,8(sp)           ; stack access
    0x84011a3e    0x30    ld ra,24(sp)          ; stack access
    0x84011a40    0x32    addi sp,sp,32
    0x84011a42    0x34    ret
    0x84011a44    0x36    li a5,8
    0x84011a46    0x38    bne a0,a5,ffffffff84011a7e <Arch_createObject+0x70>
    0x84011a4a    0x3c    li a3,0
    0x84011a4c    0x3e    li a2,0
    0x84011a4e    0x40    li a0,0
    0x84011a50    0x42    jal ra,ffffffff840106ee <cap_page_table_cap_new>
    0x84011a54    0x46    sd a0,0(sp)           ; stack access
    0x84011a56    0x48    sd a1,8(sp)           ; stack access
    0x84011a58    0x4a    j ffffffff84011a3a <Arch_createObject+0x2c>
    0x84011a5a    0x4c    li a5,0
    0x84011a5c    0x4e    li a3,3
    0x84011a5e    0x50    li a2,1
    0x84011a60    0x52    li a0,0
    0x84011a62    0x54    jal ra,ffffffff84010654 <cap_frame_cap_new>
    0x84011a66    0x58    sd a0,0(sp)           ; stack access
    0x84011a68    0x5a    sd a1,8(sp)           ; stack access
    0x84011a6a    0x5c    j ffffffff84011a3a <Arch_createObject+0x2c>
    0x84011a6c    0x5e    li a5,0
    0x84011a6e    0x60    li a3,3
    0x84011a70    0x62    li a2,2
    0x84011a72    0x64    li a0,0
    0x84011a74    0x66    jal ra,ffffffff84010654 <cap_frame_cap_new>
    0x84011a78    0x6a    sd a0,0(sp)           ; stack access
    0x84011a7a    0x6c    sd a1,8(sp)           ; stack access
    0x84011a7c    0x6e    j ffffffff84011a3a <Arch_createObject+0x2c>
    0x84011a7e    0x70    jal ra,ffffffff84010cec <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
48 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_createObject` has 76 nodes.

Section create_rootserver_objects (332 of 432)
==============================================

Deriving specifications
-----------------------

Section `create_rootserver_objects` consists of 88 instructions.


Stack analysis
---------------

22 stack accesses found. Annotated code for `create_rootserver_objects`:

    0x84000e64     0x0    addi sp,sp,-80
    0x84000e66     0x2    sd ra,72(sp)          ; stack access
    0x84000e68     0x4    sd s0,64(sp)          ; stack access
    0x84000e6a     0x6    sd s1,56(sp)          ; stack access
    0x84000e6c     0x8    sd s2,48(sp)          ; stack access
    0x84000e6e     0xa    sd s3,40(sp)          ; stack access
    0x84000e70     0xc    sd s4,32(sp)          ; stack access
    0x84000e72     0xe    mv s1,a0
    0x84000e74    0x10    sd a1,0(sp)           ; stack access
    0x84000e76    0x12    sd a2,8(sp)           ; stack access
    0x84000e78    0x14    mv s2,a3
    0x84000e7a    0x16    mv s4,a3
    0x84000e7c    0x18    li a5,24
    0x84000e7e    0x1a    bgeu a3,a5,ffffffff84000e84 <create_rootserver_objects+0x20>
    0x84000e82    0x1e    li s4,24
    0x84000e84    0x20    ld a5,0(sp)           ; stack access
    0x84000e86    0x22    sd a5,16(sp)          ; stack access
    0x84000e88    0x24    ld a5,8(sp)           ; stack access
    0x84000e8a    0x26    sd a5,24(sp)          ; stack access
    0x84000e8c    0x28    mv s3,s2
    0x84000e8e    0x2a    beqz s2,ffffffff84000e98 <create_rootserver_objects+0x34>
    0x84000e92    0x2e    li s3,1
    0x84000e94    0x30    sll s3,s3,s2
    0x84000e98    0x34    ld a0,16(sp)          ; stack access
    0x84000e9a    0x36    ld a1,24(sp)          ; stack access
    0x84000e9c    0x38    jal ra,ffffffff8400010c <arch_get_n_paging>
    0x84000ea0    0x3c    auipc s0,0x0
    0x84000ea4    0x40    addi s0,s0,1648 # ffffffff84001510 <ndks_boot>
    0x84000ea8    0x44    sd s1,680(s0)
    0x84000eac    0x48    lui a5,0x1004
    0x84000eb0    0x4c    addi a5,a5,1024 # 1004400 <KERNEL_OFFSET-0xfffffffefeffbc00>
    0x84000eb4    0x50    add s1,s1,a5
    0x84000eb6    0x52    add s1,s1,s3
    0x84000eb8    0x54    slli a0,a0,0xc
    0x84000eba    0x56    add s1,s1,a0
    0x84000ebc    0x58    sd s1,688(s0)
    0x84000ec0    0x5c    mv a1,s2
    0x84000ec2    0x5e    mv a0,s4
    0x84000ec4    0x60    jal ra,ffffffff84000e38 <maybe_alloc_extra_bi>
    0x84000ec8    0x64    li a1,1
    0x84000eca    0x66    li a0,24
    0x84000ecc    0x68    jal ra,ffffffff84000e0a <alloc_rootserver_obj>
    0x84000ed0    0x6c    sd a0,608(s0)
    0x84000ed4    0x70    mv a1,s2
    0x84000ed6    0x72    li a0,12
    0x84000ed8    0x74    jal ra,ffffffff84000e38 <maybe_alloc_extra_bi>
    0x84000edc    0x78    li a1,1
    0x84000ede    0x7a    li a0,12
    0x84000ee0    0x7c    jal ra,ffffffff84000e0a <alloc_rootserver_obj>
    0x84000ee4    0x80    sd a0,616(s0)
    0x84000ee8    0x84    mv a1,s2
    0x84000eea    0x86    li a0,12
    0x84000eec    0x88    jal ra,ffffffff84000e38 <maybe_alloc_extra_bi>
    0x84000ef0    0x8c    li a1,1
    0x84000ef2    0x8e    li a0,12
    0x84000ef4    0x90    jal ra,ffffffff84000e0a <alloc_rootserver_obj>
    0x84000ef8    0x94    sd a0,624(s0)
    0x84000efc    0x98    li a1,1
    0x84000efe    0x9a    li a0,12
    0x84000f00    0x9c    jal ra,ffffffff84000e0a <alloc_rootserver_obj>
    0x84000f04    0xa0    sd a0,632(s0)
    0x84000f08    0xa4    li a1,1
    0x84000f0a    0xa6    li a0,12
    0x84000f0c    0xa8    jal ra,ffffffff84000e0a <alloc_rootserver_obj>
    0x84000f10    0xac    sd a0,640(s0)
    0x84000f14    0xb0    ld a0,0(sp)           ; stack access
    0x84000f16    0xb2    ld a1,8(sp)           ; stack access
    0x84000f18    0xb4    jal ra,ffffffff8400010c <arch_get_n_paging>
    0x84000f1c    0xb8    mv s1,a0
    0x84000f1e    0xba    mv a1,a0
    0x84000f20    0xbc    li a0,12
    0x84000f22    0xbe    jal ra,ffffffff84000e0a <alloc_rootserver_obj>
    0x84000f26    0xc2    sd a0,664(s0)
    0x84000f2a    0xc6    slli s1,s1,0xc
    0x84000f2c    0xc8    add a0,a0,s1
    0x84000f2e    0xca    sd a0,672(s0)
    0x84000f32    0xce    li a1,1
    0x84000f34    0xd0    li a0,10
    0x84000f36    0xd2    jal ra,ffffffff84000e0a <alloc_rootserver_obj>
    0x84000f3a    0xd6    sd a0,656(s0)
    0x84000f3e    0xda    ld ra,72(sp)          ; stack access
    0x84000f40    0xdc    ld s0,64(sp)          ; stack access
    0x84000f42    0xde    ld s1,56(sp)          ; stack access
    0x84000f44    0xe0    ld s2,48(sp)          ; stack access
    0x84000f46    0xe2    ld s3,40(sp)          ; stack access
    0x84000f48    0xe4    ld s4,32(sp)          ; stack access
    0x84000f4a    0xe6    addi sp,sp,80
    0x84000f4c    0xe8    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
88 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_rootserver_objects` has 137 nodes.

Section create_frames_of_region (333 of 432)
============================================

Deriving specifications
-----------------------

Section `create_frames_of_region` consists of 74 instructions.

RVC_FTTFT____FFFFTFT.

Stack analysis
---------------

Section `create_frames_of_region` expects pointer to stack in a0.
39 stack accesses found. Annotated code for `create_frames_of_region`:

    0x8400083e     0x0    addi sp,sp,-144
    0x84000840     0x2    sd ra,136(sp)         ; stack access
    0x84000842     0x4    sd s0,128(sp)         ; stack access
    0x84000844     0x6    sd s1,120(sp)         ; stack access
    0x84000846     0x8    sd s2,112(sp)         ; stack access
    0x84000848     0xa    sd s3,104(sp)         ; stack access
    0x8400084a     0xc    sd s4,96(sp)          ; stack access
    0x8400084c     0xe    sd s5,88(sp)          ; stack access
    0x8400084e    0x10    sd s6,80(sp)          ; stack access
    0x84000850    0x12    sd s7,72(sp)          ; stack access
    0x84000852    0x14    mv s5,a0
    0x84000854    0x16    sd a1,32(sp)          ; stack access
    0x84000856    0x18    sd a2,40(sp)          ; stack access
    0x84000858    0x1a    sd a3,16(sp)          ; stack access
    0x8400085a    0x1c    sd a4,24(sp)          ; stack access
    0x8400085c    0x1e    auipc s7,0x1
    0x84000860    0x22    ld s7,-252(s7) # ffffffff84001760 <ndks_boot+0x250>
    0x84000864    0x26    bgeu a5,a6,ffffffff840008ca <create_frames_of_region+0x8c>
    0x84000868    0x2a    mv s2,a7
    0x8400086a    0x2c    mv s1,a6
    0x8400086c    0x2e    mv s0,a5
    0x8400086e    0x30    li s4,1
    0x84000870    0x32    slli s6,s4,0x26
    0x84000874    0x36    ld a5,144(sp)         ; stack access
    0x84000876    0x38    sub s6,s6,a5
    0x8400087a    0x3c    lui s3,0x1
    0x8400087c    0x3e    j ffffffff840008aa <create_frames_of_region+0x6c>
    0x8400087e    0x40    mv a6,s4
    0x84000880    0x42    li a5,0
    0x84000882    0x44    mv a4,s4
    0x84000884    0x46    add a3,s6,s0
    0x84000888    0x4a    mv a2,s0
    0x8400088a    0x4c    ld a0,16(sp)          ; stack access
    0x8400088c    0x4e    ld a1,24(sp)          ; stack access
    0x8400088e    0x50    jal ra,ffffffff8400028e <create_mapped_it_frame_cap>
    0x84000892    0x54    sd a0,48(sp)          ; stack access
    0x84000894    0x56    sd a1,56(sp)          ; stack access
    0x84000896    0x58    ld a2,48(sp)          ; stack access
    0x84000898    0x5a    ld a3,56(sp)          ; stack access
    0x8400089a    0x5c    ld a0,32(sp)          ; stack access
    0x8400089c    0x5e    ld a1,40(sp)          ; stack access
    0x8400089e    0x60    jal ra,ffffffff840006ee <provide_cap>
    0x840008a2    0x64    beqz a0,ffffffff840008bc <create_frames_of_region+0x7e>
    0x840008a4    0x66    add s0,s0,s3
    0x840008a6    0x68    bgeu s0,s1,ffffffff840008ca <create_frames_of_region+0x8c>
    0x840008aa    0x6c    bnez s2,ffffffff8400087e <create_frames_of_region+0x40>
    0x840008ae    0x70    li a1,0
    0x840008b0    0x72    mv a0,s0
    0x840008b2    0x74    jal ra,ffffffff840000f2 <create_unmapped_it_frame_cap>
    0x840008b6    0x78    sd a0,48(sp)          ; stack access
    0x840008b8    0x7a    sd a1,56(sp)          ; stack access
    0x840008ba    0x7c    j ffffffff84000896 <create_frames_of_region+0x58>
    0x840008bc    0x7e    sd zero,0(s5) # 1000 <KERNEL_OFFSET-0xfffffffefffff000>  ; stack access
    0x840008c0    0x82    sd zero,8(s5)         ; stack access
    0x840008c4    0x86    sd zero,16(s5)        ; stack access
    0x840008c8    0x8a    j ffffffff840008e0 <create_frames_of_region+0xa2>
    0x840008ca    0x8c    sd s7,0(s5)           ; stack access
    0x840008ce    0x90    auipc a5,0x1
    0x840008d2    0x94    ld a5,-366(a5) # ffffffff84001760 <ndks_boot+0x250>
    0x840008d6    0x98    sd a5,8(s5)           ; stack access
    0x840008da    0x9c    li a5,1
    0x840008dc    0x9e    sd a5,16(s5)          ; stack access
    0x840008e0    0xa2    mv a0,s5
    0x840008e2    0xa4    ld ra,136(sp)         ; stack access
    0x840008e4    0xa6    ld s0,128(sp)         ; stack access
    0x840008e6    0xa8    ld s1,120(sp)         ; stack access
    0x840008e8    0xaa    ld s2,112(sp)         ; stack access
    0x840008ea    0xac    ld s3,104(sp)         ; stack access
    0x840008ec    0xae    ld s4,96(sp)          ; stack access
    0x840008ee    0xb0    ld s5,88(sp)          ; stack access
    0x840008f0    0xb2    ld s6,80(sp)          ; stack access
    0x840008f2    0xb4    ld s7,72(sp)          ; stack access
    0x840008f4    0xb6    addi sp,sp,144
    0x840008f6    0xb8    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
74 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_frames_of_region` has 127 nodes.

Section create_bi_frame_cap (334 of 432)
========================================

Deriving specifications
-----------------------

Section `create_bi_frame_cap` consists of 29 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `create_bi_frame_cap`:

    0x84000670     0x0    addi sp,sp,-80
    0x84000672     0x2    sd ra,72(sp)          ; stack access
    0x84000674     0x4    sd s0,64(sp)          ; stack access
    0x84000676     0x6    sd s1,56(sp)          ; stack access
    0x84000678     0x8    sd a0,16(sp)          ; stack access
    0x8400067a     0xa    sd a1,24(sp)          ; stack access
    0x8400067c     0xc    mv a0,a2
    0x8400067e     0xe    mv a1,a3
    0x84000680    0x10    mv a3,a4
    0x84000682    0x12    li a6,0
    0x84000684    0x14    li a5,0
    0x84000686    0x16    li a4,1
    0x84000688    0x18    auipc a2,0x1
    0x8400068c    0x1c    ld a2,264(a2) # ffffffff84001790 <rootserver+0x20>
    0x84000690    0x20    jal ra,ffffffff8400028e <create_mapped_it_frame_cap>
    0x84000694    0x24    mv s1,a0
    0x84000696    0x26    mv s0,a1
    0x84000698    0x28    ld a0,16(sp)          ; stack access
    0x8400069a    0x2a    ld a1,24(sp)          ; stack access
    0x8400069c    0x2c    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x840006a0    0x30    mv a1,s1
    0x840006a2    0x32    mv a2,s0
    0x840006a4    0x34    addi a0,a0,288
    0x840006a8    0x38    jal ra,ffffffff840005bc <write_slot>
    0x840006ac    0x3c    ld ra,72(sp)          ; stack access
    0x840006ae    0x3e    ld s0,64(sp)          ; stack access
    0x840006b0    0x40    ld s1,56(sp)          ; stack access
    0x840006b2    0x42    addi sp,sp,80
    0x840006b4    0x44    ret

Proving inst theorems
---------------------

29 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_bi_frame_cap` has 44 nodes.

Section create_domain_cap (335 of 432)
======================================

Deriving specifications
-----------------------

Section `create_domain_cap` consists of 25 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `create_domain_cap`:

    0x84000636     0x0    addi sp,sp,-80
    0x84000638     0x2    sd ra,72(sp)          ; stack access
    0x8400063a     0x4    sd s0,64(sp)          ; stack access
    0x8400063c     0x6    sd s1,56(sp)          ; stack access
    0x8400063e     0x8    sd s2,48(sp)          ; stack access
    0x84000640     0xa    sd s3,40(sp)          ; stack access
    0x84000642     0xc    mv s3,a0
    0x84000644     0xe    mv s2,a1
    0x84000646    0x10    jal ra,ffffffff84010648 <cap_domain_cap_new>
    0x8400064a    0x14    mv s1,a0
    0x8400064c    0x16    mv s0,a1
    0x8400064e    0x18    mv a0,s3
    0x84000650    0x1a    mv a1,s2
    0x84000652    0x1c    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x84000656    0x20    mv a1,s1
    0x84000658    0x22    mv a2,s0
    0x8400065a    0x24    addi a0,a0,352 # c000160 <KERNEL_OFFSET-0xfffffffef3fffea0>
    0x8400065e    0x28    jal ra,ffffffff840005bc <write_slot>
    0x84000662    0x2c    ld ra,72(sp)          ; stack access
    0x84000664    0x2e    ld s0,64(sp)          ; stack access
    0x84000666    0x30    ld s1,56(sp)          ; stack access
    0x84000668    0x32    ld s2,48(sp)          ; stack access
    0x8400066a    0x34    ld s3,40(sp)          ; stack access
    0x8400066c    0x36    addi sp,sp,80
    0x8400066e    0x38    ret

Proving inst theorems
---------------------

25 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_domain_cap` has 39 nodes.

Section write_slot (336 of 432)
===============================

Deriving specifications
-----------------------

Section `write_slot` consists of 24 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `write_slot`:

    0x840005bc     0x0    addi sp,sp,-32
    0x840005be     0x2    sd ra,24(sp)          ; stack access
    0x840005c0     0x4    sd s0,16(sp)          ; stack access
    0x840005c2     0x6    mv s0,a0
    0x840005c4     0x8    sd a1,0(a0)
    0x840005c6     0xa    sd a2,8(a0)
    0x840005c8     0xc    li a3,0
    0x840005ca     0xe    li a2,0
    0x840005cc    0x10    li a1,0
    0x840005ce    0x12    li a0,0
    0x840005d0    0x14    jal ra,ffffffff8401018a <mdb_node_new>
    0x840005d4    0x18    sd a0,16(s0)
    0x840005d6    0x1a    sd a1,24(s0)
    0x840005d8    0x1c    addi s0,s0,16
    0x840005da    0x1e    li a1,1
    0x840005dc    0x20    mv a0,s0
    0x840005de    0x22    jal ra,ffffffff840101d8 <mdb_node_ptr_set_mdbRevocable>
    0x840005e2    0x26    li a1,1
    0x840005e4    0x28    mv a0,s0
    0x840005e6    0x2a    jal ra,ffffffff840101fc <mdb_node_ptr_set_mdbFirstBadged>
    0x840005ea    0x2e    ld ra,24(sp)          ; stack access
    0x840005ec    0x30    ld s0,16(sp)          ; stack access
    0x840005ee    0x32    addi sp,sp,32
    0x840005f0    0x34    ret

Proving inst theorems
---------------------

24 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `write_slot` has 36 nodes.

Section invokeTCB_ReadRegisters (337 of 432)
============================================

Deriving specifications
-----------------------

Section `invokeTCB_ReadRegisters` consists of 108 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `invokeTCB_ReadRegisters`:

    0x84015d56      0x0    addi sp,sp,-48
    0x84015d58      0x2    sd ra,40(sp)          ; stack access
    0x84015d5a      0x4    sd s0,32(sp)          ; stack access
    0x84015d5c      0x6    sd s1,24(sp)          ; stack access
    0x84015d5e      0x8    sd s2,16(sp)          ; stack access
    0x84015d60      0xa    sd s3,8(sp)           ; stack access
    0x84015d62      0xc    mv s1,a0
    0x84015d64      0xe    mv s0,a2
    0x84015d66     0x10    mv s3,a4
    0x84015d68     0x12    auipc s2,0x19
    0x84015d6c     0x16    ld s2,-720(s2) # ffffffff8402ea98 <ksCurThread>
    0x84015d70     0x1a    bnez a1,ffffffff84015dec <invokeTCB_ReadRegisters+0x96>
    0x84015d72     0x1c    beqz s3,ffffffff84015e54 <invokeTCB_ReadRegisters+0xfe>
    0x84015d76     0x20    mv a1,s2
    0x84015d78     0x22    li a0,1
    0x84015d7a     0x24    jal ra,ffffffff84010f0e <lookupIPCBuffer>
    0x84015d7e     0x28    sd zero,72(s2)
    0x84015d82     0x2c    beqz s0,ffffffff84015e3e <invokeTCB_ReadRegisters+0xe8>
    0x84015d84     0x2e    ld a5,264(s1)
    0x84015d88     0x32    sd a5,88(s2)
    0x84015d8c     0x36    li a5,1
    0x84015d8e     0x38    bgeu a5,s0,ffffffff84015df2 <invokeTCB_ReadRegisters+0x9c>
    0x84015d92     0x3c    ld a5,0(s1)
    0x84015d94     0x3e    sd a5,96(s2)
    0x84015d98     0x42    li a5,2
    0x84015d9a     0x44    bgeu a5,s0,ffffffff84015e32 <invokeTCB_ReadRegisters+0xdc>
    0x84015d9e     0x48    ld a5,8(s1)
    0x84015da0     0x4a    sd a5,104(s2)
    0x84015da4     0x4e    li a5,3
    0x84015da6     0x50    bgeu a5,s0,ffffffff84015e36 <invokeTCB_ReadRegisters+0xe0>
    0x84015daa     0x54    ld a5,16(s1)
    0x84015dac     0x56    sd a5,112(s2)
    0x84015db0     0x5a    li a5,4
    0x84015db2     0x5c    li a3,4
    0x84015db4     0x5e    bgeu a5,s0,ffffffff84015df4 <invokeTCB_ReadRegisters+0x9e>
    0x84015db8     0x62    li a3,4
    0x84015dba     0x64    beqz a0,ffffffff84015e42 <invokeTCB_ReadRegisters+0xec>
    0x84015dbc     0x66    bgeu a3,s0,ffffffff84015dfa <invokeTCB_ReadRegisters+0xa4>
    0x84015dc0     0x6a    slli a4,a3,0x3
    0x84015dc4     0x6e    auipc a2,0x2
    0x84015dc8     0x72    addi a2,a2,1532 # ffffffff840183c0 <frameRegisters>
    0x84015dcc     0x76    add a2,a2,a4
    0x84015dce     0x78    add a4,a4,a0
    0x84015dd0     0x7a    li a1,16
    0x84015dd2     0x7c    addi a3,a3,1
    0x84015dd4     0x7e    ld a5,0(a2)
    0x84015dd6     0x80    slli a5,a5,0x3
    0x84015dd8     0x82    add a5,a5,s1
    0x84015dda     0x84    ld a5,0(a5)
    0x84015ddc     0x86    sd a5,8(a4)
    0x84015dde     0x88    bgeu a3,s0,ffffffff84015dfa <invokeTCB_ReadRegisters+0xa4>
    0x84015de2     0x8c    addi a2,a2,8
    0x84015de4     0x8e    addi a4,a4,8
    0x84015de6     0x90    bne a3,a1,ffffffff84015dd2 <invokeTCB_ReadRegisters+0x7c>
    0x84015dea     0x94    j ffffffff84015dfa <invokeTCB_ReadRegisters+0xa4>
    0x84015dec     0x96    jal ra,ffffffff84013afe <suspend>
    0x84015df0     0x9a    j ffffffff84015d72 <invokeTCB_ReadRegisters+0x1c>
    0x84015df2     0x9c    li a3,1
    0x84015df4     0x9e    beqz a0,ffffffff84015e42 <invokeTCB_ReadRegisters+0xec>
    0x84015df6     0xa0    bltu a3,s0,ffffffff84015dbc <invokeTCB_ReadRegisters+0x66>
    0x84015dfa     0xa4    li a5,16
    0x84015dfc     0xa6    li a4,0
    0x84015dfe     0xa8    bgeu a5,s0,ffffffff84015e44 <invokeTCB_ReadRegisters+0xee>
    0x84015e02     0xac    ld a5,72(s1)
    0x84015e04     0xae    sd a5,136(a0)
    0x84015e06     0xb0    auipc a1,0x2
    0x84015e0a     0xb4    addi a1,a1,1602 # ffffffff84018448 <gpRegisters+0x8>
    0x84015e0e     0xb8    addi a0,a0,144
    0x84015e12     0xbc    addi s0,s0,-16
    0x84015e14     0xbe    li a4,1
    0x84015e16     0xc0    li a2,16
    0x84015e18     0xc2    beq a4,s0,ffffffff84015e3a <invokeTCB_ReadRegisters+0xe4>
    0x84015e1c     0xc6    ld a5,0(a1)
    0x84015e1e     0xc8    slli a5,a5,0x3
    0x84015e20     0xca    add a5,a5,s1
    0x84015e22     0xcc    ld a5,0(a5)
    0x84015e24     0xce    sd a5,0(a0)
    0x84015e26     0xd0    addi a4,a4,1
    0x84015e28     0xd2    addi a1,a1,8
    0x84015e2a     0xd4    addi a0,a0,8
    0x84015e2c     0xd6    bne a4,a2,ffffffff84015e18 <invokeTCB_ReadRegisters+0xc2>
    0x84015e30     0xda    j ffffffff84015e44 <invokeTCB_ReadRegisters+0xee>
    0x84015e32     0xdc    li a3,2
    0x84015e34     0xde    j ffffffff84015df4 <invokeTCB_ReadRegisters+0x9e>
    0x84015e36     0xe0    li a3,3
    0x84015e38     0xe2    j ffffffff84015df4 <invokeTCB_ReadRegisters+0x9e>
    0x84015e3a     0xe4    mv a4,s0
    0x84015e3c     0xe6    j ffffffff84015e44 <invokeTCB_ReadRegisters+0xee>
    0x84015e3e     0xe8    mv a3,s0
    0x84015e40     0xea    bnez a0,ffffffff84015dfa <invokeTCB_ReadRegisters+0xa4>
    0x84015e42     0xec    li a4,0
    0x84015e44     0xee    add a3,a3,a4
    0x84015e46     0xf0    li a2,0
    0x84015e48     0xf2    li a1,0
    0x84015e4a     0xf4    li a0,0
    0x84015e4c     0xf6    jal ra,ffffffff840100f4 <seL4_MessageInfo_new>
    0x84015e50     0xfa    sd a0,80(s2)
    0x84015e54     0xfe    li a1,1
    0x84015e56    0x100    mv a0,s2
    0x84015e58    0x102    jal ra,ffffffff84013020 <setThreadState>
    0x84015e5c    0x106    li a0,0
    0x84015e5e    0x108    ld ra,40(sp)          ; stack access
    0x84015e60    0x10a    ld s0,32(sp)          ; stack access
    0x84015e62    0x10c    ld s1,24(sp)          ; stack access
    0x84015e64    0x10e    ld s2,16(sp)          ; stack access
    0x84015e66    0x110    ld s3,8(sp)           ; stack access
    0x84015e68    0x112    addi sp,sp,48
    0x84015e6a    0x114    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
108 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_ReadRegisters` has 176 nodes.

Section decodeCopyRegisters (338 of 432)
========================================

Deriving specifications
-----------------------

Section `decodeCopyRegisters` consists of 57 instructions.


Stack analysis
---------------

16 stack accesses found. Annotated code for `decodeCopyRegisters`:

    0x84015cc0     0x0    addi sp,sp,-64
    0x84015cc2     0x2    sd ra,56(sp)          ; stack access
    0x84015cc4     0x4    sd s0,48(sp)          ; stack access
    0x84015cc6     0x6    sd s1,40(sp)          ; stack access
    0x84015cc8     0x8    sd s2,32(sp)          ; stack access
    0x84015cca     0xa    sd a0,0(sp)           ; stack access
    0x84015ccc     0xc    sd a1,8(sp)           ; stack access
    0x84015cce     0xe    beqz a2,ffffffff84015d14 <decodeCopyRegisters+0x54>
    0x84015cd0    0x10    auipc a5,0x8
    0x84015cd4    0x14    ld a5,-80(a5) # ffffffff8401dc80 <current_extra_caps>
    0x84015cd8    0x18    beqz a5,ffffffff84015d14 <decodeCopyRegisters+0x54>
    0x84015cda    0x1a    auipc s1,0x19
    0x84015cde    0x1e    ld s1,-578(s1) # ffffffff8402ea98 <ksCurThread>
    0x84015ce2    0x22    ld s0,88(s1)
    0x84015ce4    0x24    ld a0,0(a5)
    0x84015ce6    0x26    sd a0,16(sp)          ; stack access
    0x84015ce8    0x28    ld a1,8(a5)
    0x84015cea    0x2a    sd a1,24(sp)          ; stack access
    0x84015cec    0x2c    jal ra,ffffffff8401039e <cap_get_capType>
    0x84015cf0    0x30    li a5,12
    0x84015cf2    0x32    beq a0,a5,ffffffff84015d22 <decodeCopyRegisters+0x62>
    0x84015cf6    0x36    auipc a5,0x8
    0x84015cfa    0x3a    addi a5,a5,-174 # ffffffff8401dc48 <current_syscall_error>
    0x84015cfe    0x3e    li a4,2
    0x84015d00    0x40    sd a4,48(a5)
    0x84015d02    0x42    li a4,1
    0x84015d04    0x44    sd a4,8(a5)
    0x84015d06    0x46    li a0,3
    0x84015d08    0x48    ld ra,56(sp)          ; stack access
    0x84015d0a    0x4a    ld s0,48(sp)          ; stack access
    0x84015d0c    0x4c    ld s1,40(sp)          ; stack access
    0x84015d0e    0x4e    ld s2,32(sp)          ; stack access
    0x84015d10    0x50    addi sp,sp,64
    0x84015d12    0x52    ret
    0x84015d14    0x54    li a5,7
    0x84015d16    0x56    auipc a4,0x8
    0x84015d1a    0x5a    sd a5,-158(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84015d1e    0x5e    li a0,3
    0x84015d20    0x60    j ffffffff84015d08 <decodeCopyRegisters+0x48>
    0x84015d22    0x62    ld a0,16(sp)          ; stack access
    0x84015d24    0x64    ld a1,24(sp)          ; stack access
    0x84015d26    0x66    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x84015d2a    0x6a    mv s2,a0
    0x84015d2c    0x6c    li a1,2
    0x84015d2e    0x6e    mv a0,s1
    0x84015d30    0x70    jal ra,ffffffff84013020 <setThreadState>
    0x84015d34    0x74    ld a0,0(sp)           ; stack access
    0x84015d36    0x76    ld a1,8(sp)           ; stack access
    0x84015d38    0x78    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x84015d3c    0x7c    li a6,0
    0x84015d3e    0x7e    andi a5,s0,8
    0x84015d42    0x82    andi a4,s0,4
    0x84015d46    0x86    andi a3,s0,2
    0x84015d4a    0x8a    andi a2,s0,1
    0x84015d4e    0x8e    mv a1,s2
    0x84015d50    0x90    jal ra,ffffffff84015c16 <invokeTCB_CopyRegisters>
    0x84015d54    0x94    j ffffffff84015d08 <decodeCopyRegisters+0x48>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
57 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeCopyRegisters` has 93 nodes.

Section decodeDomainInvocation (339 of 432)
===========================================

Deriving specifications
-----------------------

Section `decodeDomainInvocation` consists of 65 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `decodeDomainInvocation`:

    0x84015398     0x0    li a5,29
    0x8401539a     0x2    bne a0,a5,ffffffff840153f6 <decodeDomainInvocation+0x5e>
    0x8401539e     0x6    beqz a1,ffffffff84015404 <decodeDomainInvocation+0x6c>
    0x840153a0     0x8    addi sp,sp,-48
    0x840153a2     0xa    sd ra,40(sp)          ; stack access
    0x840153a4     0xc    sd s0,32(sp)          ; stack access
    0x840153a6     0xe    sd s1,24(sp)          ; stack access
    0x840153a8    0x10    auipc s1,0x19
    0x840153ac    0x14    ld s1,1776(s1) # ffffffff8402ea98 <ksCurThread>
    0x840153b0    0x18    ld s0,88(s1)
    0x840153b2    0x1a    li a5,15
    0x840153b4    0x1c    bltu a5,s0,ffffffff84015412 <decodeDomainInvocation+0x7a>
    0x840153b8    0x20    auipc a5,0x9
    0x840153bc    0x24    ld a5,-1848(a5) # ffffffff8401dc80 <current_extra_caps>
    0x840153c0    0x28    beqz a5,ffffffff84015426 <decodeDomainInvocation+0x8e>
    0x840153c2    0x2a    ld a0,0(a5)
    0x840153c4    0x2c    sd a0,0(sp)           ; stack access
    0x840153c6    0x2e    ld a1,8(a5)
    0x840153c8    0x30    sd a1,8(sp)           ; stack access
    0x840153ca    0x32    jal ra,ffffffff8401039e <cap_get_capType>
    0x840153ce    0x36    li a5,12
    0x840153d0    0x38    bne a0,a5,ffffffff84015434 <decodeDomainInvocation+0x9c>
    0x840153d4    0x3c    li a1,2
    0x840153d6    0x3e    mv a0,s1
    0x840153d8    0x40    jal ra,ffffffff84013020 <setThreadState>
    0x840153dc    0x44    ld a0,0(sp)           ; stack access
    0x840153de    0x46    ld a1,8(sp)           ; stack access
    0x840153e0    0x48    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x840153e4    0x4c    mv a1,s0
    0x840153e6    0x4e    jal ra,ffffffff840137ec <setDomain>
    0x840153ea    0x52    li a0,0
    0x840153ec    0x54    ld ra,40(sp)          ; stack access
    0x840153ee    0x56    ld s0,32(sp)          ; stack access
    0x840153f0    0x58    ld s1,24(sp)          ; stack access
    0x840153f2    0x5a    addi sp,sp,48
    0x840153f4    0x5c    ret
    0x840153f6    0x5e    li a5,3
    0x840153f8    0x60    auipc a4,0x9
    0x840153fc    0x64    sd a5,-1920(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84015400    0x68    li a0,3
    0x84015402    0x6a    ret
    0x84015404    0x6c    li a5,7
    0x84015406    0x6e    auipc a4,0x9
    0x8401540a    0x72    sd a5,-1934(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x8401540e    0x76    li a0,3
    0x84015410    0x78    ret
    0x84015412    0x7a    auipc a5,0x9
    0x84015416    0x7e    addi a5,a5,-1994 # ffffffff8401dc48 <current_syscall_error>
    0x8401541a    0x82    li a4,1
    0x8401541c    0x84    sd a4,48(a5)
    0x8401541e    0x86    sd zero,0(a5)
    0x84015422    0x8a    li a0,3
    0x84015424    0x8c    j ffffffff840153ec <decodeDomainInvocation+0x54>
    0x84015426    0x8e    li a5,7
    0x84015428    0x90    auipc a4,0x9
    0x8401542c    0x94    sd a5,-1968(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84015430    0x98    li a0,3
    0x84015432    0x9a    j ffffffff840153ec <decodeDomainInvocation+0x54>
    0x84015434    0x9c    auipc a5,0x9
    0x84015438    0xa0    addi a5,a5,-2028 # ffffffff8401dc48 <current_syscall_error>
    0x8401543c    0xa4    li a4,1
    0x8401543e    0xa6    sd a4,48(a5)
    0x84015440    0xa8    sd a4,0(a5)
    0x84015442    0xaa    li a0,3
    0x84015444    0xac    j ffffffff840153ec <decodeDomainInvocation+0x54>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
65 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeDomainInvocation` has 104 nodes.

Section handleVMFaultEvent (340 of 432)
=======================================

Deriving specifications
-----------------------

Section `handleVMFaultEvent` consists of 17 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleVMFaultEvent`:

    0x8401503a     0x0    addi sp,sp,-16
    0x8401503c     0x2    sd ra,8(sp)           ; stack access
    0x8401503e     0x4    mv a1,a0
    0x84015040     0x6    auipc a0,0x1a
    0x84015044     0xa    ld a0,-1448(a0) # ffffffff8402ea98 <ksCurThread>
    0x84015048     0xe    jal ra,ffffffff84011192 <handleVMFault>
    0x8401504c    0x12    bnez a0,ffffffff8401505e <handleVMFaultEvent+0x24>
    0x8401504e    0x14    jal ra,ffffffff840136b0 <schedule>
    0x84015052    0x18    jal ra,ffffffff84013112 <activateThread>
    0x84015056    0x1c    li a0,0
    0x84015058    0x1e    ld ra,8(sp)           ; stack access
    0x8401505a    0x20    addi sp,sp,16
    0x8401505c    0x22    ret
    0x8401505e    0x24    auipc a0,0x1a
    0x84015062    0x28    ld a0,-1478(a0) # ffffffff8402ea98 <ksCurThread>
    0x84015066    0x2c    jal ra,ffffffff84014fba <handleFault>
    0x8401506a    0x30    j ffffffff8401504e <handleVMFaultEvent+0x14>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleVMFaultEvent` has 28 nodes.

Section handleUserLevelFault (341 of 432)
=========================================

Deriving specifications
-----------------------

Section `handleUserLevelFault` consists of 16 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleUserLevelFault`:

    0x8401500a     0x0    addi sp,sp,-16
    0x8401500c     0x2    sd ra,8(sp)           ; stack access
    0x8401500e     0x4    jal ra,ffffffff84010890 <seL4_Fault_UserException_new>
    0x84015012     0x8    auipc a5,0x7
    0x84015016     0xc    addi a5,a5,2030 # ffffffff8401c800 <current_fault>
    0x8401501a    0x10    sd a0,0(a5)
    0x8401501c    0x12    sd a1,8(a5)
    0x8401501e    0x14    auipc a0,0x1a
    0x84015022    0x18    ld a0,-1414(a0) # ffffffff8402ea98 <ksCurThread>
    0x84015026    0x1c    jal ra,ffffffff84014fba <handleFault>
    0x8401502a    0x20    jal ra,ffffffff840136b0 <schedule>
    0x8401502e    0x24    jal ra,ffffffff84013112 <activateThread>
    0x84015032    0x28    li a0,0
    0x84015034    0x2a    ld ra,8(sp)           ; stack access
    0x84015036    0x2c    addi sp,sp,16
    0x84015038    0x2e    ret

Proving inst theorems
---------------------

16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleUserLevelFault` has 26 nodes.

Section handleUnknownSyscall (342 of 432)
=========================================

Deriving specifications
-----------------------

Section `handleUnknownSyscall` consists of 16 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleUnknownSyscall`:

    0x84014fda     0x0    addi sp,sp,-16
    0x84014fdc     0x2    sd ra,8(sp)           ; stack access
    0x84014fde     0x4    jal ra,ffffffff8401087e <seL4_Fault_UnknownSyscall_new>
    0x84014fe2     0x8    auipc a5,0x8
    0x84014fe6     0xc    addi a5,a5,-2018 # ffffffff8401c800 <current_fault>
    0x84014fea    0x10    sd a0,0(a5)
    0x84014fec    0x12    sd a1,8(a5)
    0x84014fee    0x14    auipc a0,0x1a
    0x84014ff2    0x18    ld a0,-1366(a0) # ffffffff8402ea98 <ksCurThread>
    0x84014ff6    0x1c    jal ra,ffffffff84014fba <handleFault>
    0x84014ffa    0x20    jal ra,ffffffff840136b0 <schedule>
    0x84014ffe    0x24    jal ra,ffffffff84013112 <activateThread>
    0x84015002    0x28    li a0,0
    0x84015004    0x2a    ld ra,8(sp)           ; stack access
    0x84015006    0x2c    addi sp,sp,16
    0x84015008    0x2e    ret

Proving inst theorems
---------------------

16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleUnknownSyscall` has 26 nodes.

Section doIPCTransfer (343 of 432)
==================================

Deriving specifications
-----------------------

Section `doIPCTransfer` consists of 46 instructions.


Stack analysis
---------------

14 stack accesses found. Annotated code for `doIPCTransfer`:

    0x84014bf0     0x0    addi sp,sp,-64
    0x84014bf2     0x2    sd ra,56(sp)          ; stack access
    0x84014bf4     0x4    sd s0,48(sp)          ; stack access
    0x84014bf6     0x6    sd s1,40(sp)          ; stack access
    0x84014bf8     0x8    sd s2,32(sp)          ; stack access
    0x84014bfa     0xa    sd s3,24(sp)          ; stack access
    0x84014bfc     0xc    sd s4,16(sp)          ; stack access
    0x84014bfe     0xe    sd s5,8(sp)           ; stack access
    0x84014c00    0x10    mv s0,a0
    0x84014c02    0x12    mv s4,a1
    0x84014c04    0x14    mv s2,a2
    0x84014c06    0x16    mv s5,a3
    0x84014c08    0x18    mv s1,a4
    0x84014c0a    0x1a    mv a1,a4
    0x84014c0c    0x1c    li a0,1
    0x84014c0e    0x1e    jal ra,ffffffff84010f0e <lookupIPCBuffer>
    0x84014c12    0x22    mv s3,a0
    0x84014c14    0x24    ld a0,312(s0)
    0x84014c18    0x28    ld a1,320(s0)
    0x84014c1c    0x2c    jal ra,ffffffff8401084a <seL4_Fault_get_seL4_FaultType>
    0x84014c20    0x30    bnez a0,ffffffff84014c4c <doIPCTransfer+0x5c>
    0x84014c22    0x32    mv a1,s0
    0x84014c24    0x34    jal ra,ffffffff84010f0e <lookupIPCBuffer>
    0x84014c28    0x38    mv a1,a0
    0x84014c2a    0x3a    mv a6,s3
    0x84014c2c    0x3c    mv a5,s1
    0x84014c2e    0x3e    mv a4,s5
    0x84014c30    0x40    mv a3,s2
    0x84014c32    0x42    mv a2,s4
    0x84014c34    0x44    mv a0,s0
    0x84014c36    0x46    jal ra,ffffffff84014a7e <doNormalTransfer>
    0x84014c3a    0x4a    ld ra,56(sp)          ; stack access
    0x84014c3c    0x4c    ld s0,48(sp)          ; stack access
    0x84014c3e    0x4e    ld s1,40(sp)          ; stack access
    0x84014c40    0x50    ld s2,32(sp)          ; stack access
    0x84014c42    0x52    ld s3,24(sp)          ; stack access
    0x84014c44    0x54    ld s4,16(sp)          ; stack access
    0x84014c46    0x56    ld s5,8(sp)           ; stack access
    0x84014c48    0x58    addi sp,sp,64
    0x84014c4a    0x5a    ret
    0x84014c4c    0x5c    mv a3,s3
    0x84014c4e    0x5e    mv a2,s1
    0x84014c50    0x60    mv a1,s0
    0x84014c52    0x62    mv a0,s2
    0x84014c54    0x64    jal ra,ffffffff84011dae <doFaultTransfer>
    0x84014c58    0x68    j ffffffff84014c3a <doIPCTransfer+0x4a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
46 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doIPCTransfer` has 70 nodes.

Section handleInterruptEntry (344 of 432)
=========================================

Deriving specifications
-----------------------

Section `handleInterruptEntry` consists of 24 instructions.

LW..

Stack analysis
---------------

2 stack accesses found. Annotated code for `handleInterruptEntry`:

    0x84014890     0x0    addi sp,sp,-16
    0x84014892     0x2    sd ra,8(sp)           ; stack access
    0x84014894     0x4    auipc a5,0x4
    0x84014898     0x8    lw a5,372(a5) # ffffffff84018a08 <active_irq>
    0x8401489c     0xc    addiw a3,a5,-1
    0x840148a0    0x10    li a4,53
    0x840148a4    0x14    bltu a4,a3,ffffffff840148b4 <handleInterruptEntry+0x24>
    0x840148a8    0x18    slli a0,a5,0x20
    0x840148ac    0x1c    srli a0,a0,0x20
    0x840148ae    0x1e    jal ra,ffffffff84014780 <handleInterrupt>
    0x840148b2    0x22    j ffffffff840148ce <handleInterruptEntry+0x3e>
    0x840148b4    0x24    jal ra,ffffffff84010986 <getNewActiveIRQ>
    0x840148b8    0x28    sext.w a5,a0
    0x840148bc    0x2c    auipc a4,0x4
    0x840148c0    0x30    sw a0,332(a4) # ffffffff84018a08 <active_irq>
    0x840148c4    0x34    addiw a0,a0,-1
    0x840148c6    0x36    li a4,53
    0x840148ca    0x3a    bgeu a4,a0,ffffffff840148a8 <handleInterruptEntry+0x18>
    0x840148ce    0x3e    jal ra,ffffffff840136b0 <schedule>
    0x840148d2    0x42    jal ra,ffffffff84013112 <activateThread>
    0x840148d6    0x46    li a0,0
    0x840148d8    0x48    ld ra,8(sp)           ; stack access
    0x840148da    0x4a    addi sp,sp,16
    0x840148dc    0x4c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
24 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleInterruptEntry` has 37 nodes.

Section cteRevoke (345 of 432)
==============================

Deriving specifications
-----------------------

Section `cteRevoke` consists of 30 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `cteRevoke`:

    0x84013ff0     0x0    addi sp,sp,-32
    0x84013ff2     0x2    sd ra,24(sp)          ; stack access
    0x84013ff4     0x4    sd s0,16(sp)          ; stack access
    0x84013ff6     0x6    sd s1,8(sp)           ; stack access
    0x84013ff8     0x8    mv s0,a0
    0x84013ffa     0xa    ld a0,16(a0)
    0x84013ffc     0xc    ld a1,24(s0)
    0x84013ffe     0xe    jal ra,ffffffff84010b08 <mdb_node_get_mdbNext>
    0x84014002    0x12    mv s1,a0
    0x84014004    0x14    beqz a0,ffffffff8401402c <cteRevoke+0x3c>
    0x84014006    0x16    mv a1,s1
    0x84014008    0x18    mv a0,s0
    0x8401400a    0x1a    jal ra,ffffffff84012908 <isMDBParentOf>
    0x8401400e    0x1e    beqz a0,ffffffff8401402c <cteRevoke+0x3c>
    0x84014010    0x20    li a1,1
    0x84014012    0x22    mv a0,s1
    0x84014014    0x24    jal ra,ffffffff84013d20 <cteDelete>
    0x84014018    0x28    bnez a0,ffffffff8401402c <cteRevoke+0x3c>
    0x8401401a    0x2a    jal ra,ffffffff84011e20 <preemptionPoint>
    0x8401401e    0x2e    bnez a0,ffffffff8401402c <cteRevoke+0x3c>
    0x84014020    0x30    ld a0,16(s0)
    0x84014022    0x32    ld a1,24(s0)
    0x84014024    0x34    jal ra,ffffffff84010b08 <mdb_node_get_mdbNext>
    0x84014028    0x38    mv s1,a0
    0x8401402a    0x3a    bnez a0,ffffffff84014006 <cteRevoke+0x16>
    0x8401402c    0x3c    ld ra,24(sp)          ; stack access
    0x8401402e    0x3e    ld s0,16(sp)          ; stack access
    0x84014030    0x40    ld s1,8(sp)           ; stack access
    0x84014032    0x42    addi sp,sp,32
    0x84014034    0x44    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
30 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteRevoke` has 56 nodes.

Section suspend (346 of 432)
============================

Deriving specifications
-----------------------

Section `suspend` consists of 27 instructions.


Stack analysis
---------------

7 stack accesses found. Annotated code for `suspend`:

    0x84013afe     0x0    addi sp,sp,-48
    0x84013b00     0x2    sd ra,40(sp)          ; stack access
    0x84013b02     0x4    sd s0,32(sp)          ; stack access
    0x84013b04     0x6    mv s0,a0
    0x84013b06     0x8    jal ra,ffffffff84013a46 <cancelIPC>
    0x84013b0a     0xc    ld a5,280(s0)
    0x84013b0e    0x10    sd a5,0(sp)           ; stack access
    0x84013b10    0x12    ld a5,288(s0)
    0x84013b14    0x16    sd a5,8(sp)           ; stack access
    0x84013b16    0x18    ld a5,296(s0)
    0x84013b1a    0x1c    sd a5,16(sp)          ; stack access
    0x84013b1c    0x1e    mv a0,sp
    0x84013b1e    0x20    jal ra,ffffffff84010382 <thread_state_get_tsType>
    0x84013b22    0x24    li a5,1
    0x84013b24    0x26    beq a0,a5,ffffffff84013b3e <suspend+0x40>
    0x84013b28    0x2a    li a1,0
    0x84013b2a    0x2c    mv a0,s0
    0x84013b2c    0x2e    jal ra,ffffffff84013020 <setThreadState>
    0x84013b30    0x32    mv a0,s0
    0x84013b32    0x34    jal ra,ffffffff840134d2 <tcbSchedDequeue>
    0x84013b36    0x38    ld ra,40(sp)          ; stack access
    0x84013b38    0x3a    ld s0,32(sp)          ; stack access
    0x84013b3a    0x3c    addi sp,sp,48
    0x84013b3c    0x3e    ret
    0x84013b3e    0x40    ld a5,272(s0)
    0x84013b42    0x44    sd a5,264(s0)
    0x84013b46    0x48    j ffffffff84013b28 <suspend+0x2a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
27 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `suspend` has 46 nodes.

Section setPriority (347 of 432)
================================

Deriving specifications
-----------------------

Section `setPriority` consists of 32 instructions.


Stack analysis
---------------

9 stack accesses found. Annotated code for `setPriority`:

    0x84013844     0x0    addi sp,sp,-64
    0x84013846     0x2    sd ra,56(sp)          ; stack access
    0x84013848     0x4    sd s0,48(sp)          ; stack access
    0x8401384a     0x6    sd s1,40(sp)          ; stack access
    0x8401384c     0x8    mv s0,a0
    0x8401384e     0xa    mv s1,a1
    0x84013850     0xc    jal ra,ffffffff840134d2 <tcbSchedDequeue>
    0x84013854    0x10    sd s1,360(s0)
    0x84013858    0x14    ld a5,280(s0)
    0x8401385c    0x18    sd a5,0(sp)           ; stack access
    0x8401385e    0x1a    ld a5,288(s0)
    0x84013862    0x1e    sd a5,8(sp)           ; stack access
    0x84013864    0x20    ld a5,296(s0)
    0x84013868    0x24    sd a5,16(sp)          ; stack access
    0x8401386a    0x26    mv a0,sp
    0x8401386c    0x28    jal ra,ffffffff84010382 <thread_state_get_tsType>
    0x84013870    0x2c    addi a0,a0,-1
    0x84013872    0x2e    li a5,1
    0x84013874    0x30    bgeu a5,a0,ffffffff84013882 <setPriority+0x3e>
    0x84013878    0x34    ld ra,56(sp)          ; stack access
    0x8401387a    0x36    ld s0,48(sp)          ; stack access
    0x8401387c    0x38    ld s1,40(sp)          ; stack access
    0x8401387e    0x3a    addi sp,sp,64
    0x84013880    0x3c    ret
    0x84013882    0x3e    auipc a5,0x1b
    0x84013886    0x42    ld a5,534(a5) # ffffffff8402ea98 <ksCurThread>
    0x8401388a    0x46    beq a5,s0,ffffffff84013896 <setPriority+0x52>
    0x8401388e    0x4a    mv a0,s0
    0x84013890    0x4c    jal ra,ffffffff840132c6 <possibleSwitchTo>
    0x84013894    0x50    j ffffffff84013878 <setPriority+0x34>
    0x84013896    0x52    jal ra,ffffffff84012fa8 <rescheduleRequired>
    0x8401389a    0x56    j ffffffff84013878 <setPriority+0x34>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
32 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setPriority` has 55 nodes.

Section setDomain (348 of 432)
==============================

Deriving specifications
-----------------------

Section `setDomain` consists of 32 instructions.


Stack analysis
---------------

9 stack accesses found. Annotated code for `setDomain`:

    0x840137ec     0x0    addi sp,sp,-64
    0x840137ee     0x2    sd ra,56(sp)          ; stack access
    0x840137f0     0x4    sd s0,48(sp)          ; stack access
    0x840137f2     0x6    sd s1,40(sp)          ; stack access
    0x840137f4     0x8    mv s0,a0
    0x840137f6     0xa    mv s1,a1
    0x840137f8     0xc    jal ra,ffffffff840134d2 <tcbSchedDequeue>
    0x840137fc    0x10    sd s1,344(s0)
    0x84013800    0x14    ld a5,280(s0)
    0x84013804    0x18    sd a5,0(sp)           ; stack access
    0x84013806    0x1a    ld a5,288(s0)
    0x8401380a    0x1e    sd a5,8(sp)           ; stack access
    0x8401380c    0x20    ld a5,296(s0)
    0x84013810    0x24    sd a5,16(sp)          ; stack access
    0x84013812    0x26    mv a0,sp
    0x84013814    0x28    jal ra,ffffffff84010382 <thread_state_get_tsType>
    0x84013818    0x2c    addi a0,a0,-1
    0x8401381a    0x2e    li a5,1
    0x8401381c    0x30    bgeu a5,a0,ffffffff84013836 <setDomain+0x4a>
    0x84013820    0x34    auipc a5,0x1b
    0x84013824    0x38    ld a5,632(a5) # ffffffff8402ea98 <ksCurThread>
    0x84013828    0x3c    beq a5,s0,ffffffff8401383e <setDomain+0x52>
    0x8401382c    0x40    ld ra,56(sp)          ; stack access
    0x8401382e    0x42    ld s0,48(sp)          ; stack access
    0x84013830    0x44    ld s1,40(sp)          ; stack access
    0x84013832    0x46    addi sp,sp,64
    0x84013834    0x48    ret
    0x84013836    0x4a    mv a0,s0
    0x84013838    0x4c    jal ra,ffffffff84012efc <tcbSchedEnqueue>
    0x8401383c    0x50    j ffffffff84013820 <setDomain+0x34>
    0x8401383e    0x52    jal ra,ffffffff84012fa8 <rescheduleRequired>
    0x84013842    0x56    j ffffffff8401382c <setDomain+0x40>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
32 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setDomain` has 55 nodes.

Section deriveCap (349 of 432)
==============================

Deriving specifications
-----------------------

Section `deriveCap` consists of 73 instructions.


Stack analysis
---------------

Section `deriveCap` expects pointer to stack in a0.
35 stack accesses found. Annotated code for `deriveCap`:

    0x840129da     0x0    addi sp,sp,-96
    0x840129dc     0x2    sd ra,88(sp)          ; stack access
    0x840129de     0x4    sd s0,80(sp)          ; stack access
    0x840129e0     0x6    sd s1,72(sp)          ; stack access
    0x840129e2     0x8    sd s2,64(sp)          ; stack access
    0x840129e4     0xa    mv s0,a0
    0x840129e6     0xc    mv s2,a1
    0x840129e8     0xe    sd a2,0(sp)           ; stack access
    0x840129ea    0x10    sd a3,8(sp)           ; stack access
    0x840129ec    0x12    mv a0,a2
    0x840129ee    0x14    mv a1,a3
    0x840129f0    0x16    jal ra,ffffffff8401039e <cap_get_capType>
    0x840129f4    0x1a    andi s1,a0,1
    0x840129f8    0x1e    bnez s1,ffffffff84012a22 <deriveCap+0x48>
    0x840129fa    0x20    ld a0,0(sp)           ; stack access
    0x840129fc    0x22    ld a1,8(sp)           ; stack access
    0x840129fe    0x24    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012a02    0x28    li a5,14
    0x84012a04    0x2a    beq a0,a5,ffffffff84012a56 <deriveCap+0x7c>
    0x84012a08    0x2e    bltu a5,a0,ffffffff84012a30 <deriveCap+0x56>
    0x84012a0c    0x32    li a5,2
    0x84012a0e    0x34    beq a0,a5,ffffffff84012a60 <deriveCap+0x86>
    0x84012a12    0x38    li a5,8
    0x84012a14    0x3a    bne a0,a5,ffffffff84012a7e <deriveCap+0xa4>
    0x84012a18    0x3e    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84012a1c    0x42    sd a0,48(sp)          ; stack access
    0x84012a1e    0x44    sd a1,56(sp)          ; stack access
    0x84012a20    0x46    j ffffffff84012a3e <deriveCap+0x64>
    0x84012a22    0x48    ld a2,0(sp)           ; stack access
    0x84012a24    0x4a    ld a3,8(sp)           ; stack access
    0x84012a26    0x4c    mv a1,s2
    0x84012a28    0x4e    mv a0,s0
    0x84012a2a    0x50    jal ra,ffffffff8401162a <Arch_deriveCap>
    0x84012a2e    0x54    j ffffffff84012a48 <deriveCap+0x6e>
    0x84012a30    0x56    li a5,18
    0x84012a32    0x58    bne a0,a5,ffffffff84012a7e <deriveCap+0xa4>
    0x84012a36    0x5c    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84012a3a    0x60    sd a0,48(sp)          ; stack access
    0x84012a3c    0x62    sd a1,56(sp)          ; stack access
    0x84012a3e    0x64    sd s1,0(s0)           ; stack access
    0x84012a40    0x66    ld a5,48(sp)          ; stack access
    0x84012a42    0x68    sd a5,8(s0)           ; stack access
    0x84012a44    0x6a    ld a5,56(sp)          ; stack access
    0x84012a46    0x6c    sd a5,16(s0)          ; stack access
    0x84012a48    0x6e    mv a0,s0
    0x84012a4a    0x70    ld ra,88(sp)          ; stack access
    0x84012a4c    0x72    ld s0,80(sp)          ; stack access
    0x84012a4e    0x74    ld s1,72(sp)          ; stack access
    0x84012a50    0x76    ld s2,64(sp)          ; stack access
    0x84012a52    0x78    addi sp,sp,96
    0x84012a54    0x7a    ret
    0x84012a56    0x7c    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84012a5a    0x80    sd a0,48(sp)          ; stack access
    0x84012a5c    0x82    sd a1,56(sp)          ; stack access
    0x84012a5e    0x84    j ffffffff84012a3e <deriveCap+0x64>
    0x84012a60    0x86    mv a0,s2
    0x84012a62    0x88    jal ra,ffffffff840129a8 <ensureNoChildren>
    0x84012a66    0x8c    mv s1,a0
    0x84012a68    0x8e    beqz a0,ffffffff84012a74 <deriveCap+0x9a>
    0x84012a6a    0x90    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84012a6e    0x94    sd a0,48(sp)          ; stack access
    0x84012a70    0x96    sd a1,56(sp)          ; stack access
    0x84012a72    0x98    j ffffffff84012a3e <deriveCap+0x64>
    0x84012a74    0x9a    ld a5,0(sp)           ; stack access
    0x84012a76    0x9c    sd a5,48(sp)          ; stack access
    0x84012a78    0x9e    ld a5,8(sp)           ; stack access
    0x84012a7a    0xa0    sd a5,56(sp)          ; stack access
    0x84012a7c    0xa2    j ffffffff84012a3e <deriveCap+0x64>
    0x84012a7e    0xa4    ld a5,0(sp)           ; stack access
    0x84012a80    0xa6    sd a5,48(sp)          ; stack access
    0x84012a82    0xa8    ld a5,8(sp)           ; stack access
    0x84012a84    0xaa    sd a5,56(sp)          ; stack access
    0x84012a86    0xac    j ffffffff84012a3e <deriveCap+0x64>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
73 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deriveCap` has 131 nodes.

Section completeSignal (350 of 432)
===================================

Deriving specifications
-----------------------

Section `completeSignal` consists of 22 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `completeSignal`:

    0x840124a6     0x0    addi sp,sp,-32
    0x840124a8     0x2    sd ra,24(sp)          ; stack access
    0x840124aa     0x4    sd s0,16(sp)          ; stack access
    0x840124ac     0x6    sd s1,8(sp)           ; stack access
    0x840124ae     0x8    beqz a1,ffffffff840124d8 <completeSignal+0x32>
    0x840124b0     0xa    mv s0,a0
    0x840124b2     0xc    mv s1,a1
    0x840124b4     0xe    jal ra,ffffffff84010258 <notification_ptr_get_state>
    0x840124b8    0x12    li a5,2
    0x840124ba    0x14    bne a0,a5,ffffffff840124d8 <completeSignal+0x32>
    0x840124be    0x18    mv a0,s0
    0x840124c0    0x1a    jal ra,ffffffff8401022e <notification_ptr_get_ntfnMsgIdentifier>
    0x840124c4    0x1e    sd a0,72(s1)
    0x840124c6    0x20    li a1,0
    0x840124c8    0x22    mv a0,s0
    0x840124ca    0x24    jal ra,ffffffff8401025e <notification_ptr_set_state>
    0x840124ce    0x28    ld ra,24(sp)          ; stack access
    0x840124d0    0x2a    ld s0,16(sp)          ; stack access
    0x840124d2    0x2c    ld s1,8(sp)           ; stack access
    0x840124d4    0x2e    addi sp,sp,32
    0x840124d6    0x30    ret
    0x840124d8    0x32    jal ra,ffffffff84010cec <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `completeSignal` has 38 nodes.

Section insertNewCap (351 of 432)
=================================

Deriving specifications
-----------------------

Section `insertNewCap` consists of 39 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `insertNewCap`:

    0x84012196     0x0    addi sp,sp,-64
    0x84012198     0x2    sd ra,56(sp)          ; stack access
    0x8401219a     0x4    sd s0,48(sp)          ; stack access
    0x8401219c     0x6    sd s1,40(sp)          ; stack access
    0x8401219e     0x8    sd s2,32(sp)          ; stack access
    0x840121a0     0xa    sd s3,24(sp)          ; stack access
    0x840121a2     0xc    sd s4,16(sp)          ; stack access
    0x840121a4     0xe    mv s1,a0
    0x840121a6    0x10    mv s0,a1
    0x840121a8    0x12    mv s4,a2
    0x840121aa    0x14    mv s3,a3
    0x840121ac    0x16    ld a0,16(a0)
    0x840121ae    0x18    ld a1,24(s1)
    0x840121b0    0x1a    jal ra,ffffffff84010b08 <mdb_node_get_mdbNext>
    0x840121b4    0x1e    mv s2,a0
    0x840121b6    0x20    sd s4,0(s0)
    0x840121ba    0x24    sd s3,8(s0)
    0x840121be    0x28    mv a3,s1
    0x840121c0    0x2a    li a2,1
    0x840121c2    0x2c    li a1,1
    0x840121c4    0x2e    jal ra,ffffffff8401018a <mdb_node_new>
    0x840121c8    0x32    sd a0,16(s0)
    0x840121ca    0x34    sd a1,24(s0)
    0x840121cc    0x36    bnez s2,ffffffff840121ea <insertNewCap+0x54>
    0x840121d0    0x3a    mv a1,s0
    0x840121d2    0x3c    addi a0,s1,16
    0x840121d6    0x40    jal ra,ffffffff840101a6 <mdb_node_ptr_set_mdbNext>
    0x840121da    0x44    ld ra,56(sp)          ; stack access
    0x840121dc    0x46    ld s0,48(sp)          ; stack access
    0x840121de    0x48    ld s1,40(sp)          ; stack access
    0x840121e0    0x4a    ld s2,32(sp)          ; stack access
    0x840121e2    0x4c    ld s3,24(sp)          ; stack access
    0x840121e4    0x4e    ld s4,16(sp)          ; stack access
    0x840121e6    0x50    addi sp,sp,64
    0x840121e8    0x52    ret
    0x840121ea    0x54    mv a1,s0
    0x840121ec    0x56    addi a0,s2,16
    0x840121f0    0x5a    jal ra,ffffffff84010216 <mdb_node_ptr_set_mdbPrev>
    0x840121f4    0x5e    j ffffffff840121d0 <insertNewCap+0x3a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
39 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `insertNewCap` has 64 nodes.

Section cteSwap (352 of 432)
============================

Deriving specifications
-----------------------

Section `cteSwap` consists of 57 instructions.


Stack analysis
---------------

16 stack accesses found. Annotated code for `cteSwap`:

    0x840120ac     0x0    addi sp,sp,-96
    0x840120ae     0x2    sd ra,88(sp)          ; stack access
    0x840120b0     0x4    sd s0,80(sp)          ; stack access
    0x840120b2     0x6    sd s1,72(sp)          ; stack access
    0x840120b4     0x8    mv s0,a2
    0x840120b6     0xa    mv s1,a5
    0x840120b8     0xc    sd a3,0(a2)
    0x840120ba     0xe    sd a4,8(a2)
    0x840120bc    0x10    sd a0,0(a5)
    0x840120be    0x12    sd a1,8(a5)
    0x840120c0    0x14    ld a0,16(a2)
    0x840120c2    0x16    sd a0,48(sp)          ; stack access
    0x840120c4    0x18    ld a1,24(a2)
    0x840120c6    0x1a    sd a1,56(sp)          ; stack access
    0x840120c8    0x1c    jal ra,ffffffff84010208 <mdb_node_get_mdbPrev>
    0x840120cc    0x20    bnez a0,ffffffff84012106 <cteSwap+0x5a>
    0x840120ce    0x22    ld a0,48(sp)          ; stack access
    0x840120d0    0x24    ld a1,56(sp)          ; stack access
    0x840120d2    0x26    jal ra,ffffffff84010b08 <mdb_node_get_mdbNext>
    0x840120d6    0x2a    bnez a0,ffffffff84012110 <cteSwap+0x64>
    0x840120d8    0x2c    ld a0,16(s1)
    0x840120da    0x2e    sd a0,32(sp)          ; stack access
    0x840120dc    0x30    ld a1,24(s1)
    0x840120de    0x32    sd a1,40(sp)          ; stack access
    0x840120e0    0x34    sd a0,16(s0)
    0x840120e2    0x36    sd a1,24(s0)
    0x840120e4    0x38    ld a5,48(sp)          ; stack access
    0x840120e6    0x3a    sd a5,16(s1)
    0x840120e8    0x3c    ld a5,56(sp)          ; stack access
    0x840120ea    0x3e    sd a5,24(s1)
    0x840120ec    0x40    jal ra,ffffffff84010208 <mdb_node_get_mdbPrev>
    0x840120f0    0x44    bnez a0,ffffffff8401211a <cteSwap+0x6e>
    0x840120f2    0x46    ld a0,32(sp)          ; stack access
    0x840120f4    0x48    ld a1,40(sp)          ; stack access
    0x840120f6    0x4a    jal ra,ffffffff84010b08 <mdb_node_get_mdbNext>
    0x840120fa    0x4e    bnez a0,ffffffff84012124 <cteSwap+0x78>
    0x840120fc    0x50    ld ra,88(sp)          ; stack access
    0x840120fe    0x52    ld s0,80(sp)          ; stack access
    0x84012100    0x54    ld s1,72(sp)          ; stack access
    0x84012102    0x56    addi sp,sp,96
    0x84012104    0x58    ret
    0x84012106    0x5a    mv a1,s1
    0x84012108    0x5c    addi a0,a0,16
    0x8401210a    0x5e    jal ra,ffffffff840101a6 <mdb_node_ptr_set_mdbNext>
    0x8401210e    0x62    j ffffffff840120ce <cteSwap+0x22>
    0x84012110    0x64    mv a1,s1
    0x84012112    0x66    addi a0,a0,16
    0x84012114    0x68    jal ra,ffffffff84010216 <mdb_node_ptr_set_mdbPrev>
    0x84012118    0x6c    j ffffffff840120d8 <cteSwap+0x2c>
    0x8401211a    0x6e    mv a1,s0
    0x8401211c    0x70    addi a0,a0,16
    0x8401211e    0x72    jal ra,ffffffff840101a6 <mdb_node_ptr_set_mdbNext>
    0x84012122    0x76    j ffffffff840120f2 <cteSwap+0x46>
    0x84012124    0x78    mv a1,s0
    0x84012126    0x7a    addi a0,a0,16
    0x84012128    0x7c    jal ra,ffffffff84010216 <mdb_node_ptr_set_mdbPrev>
    0x8401212c    0x80    j ffffffff840120fc <cteSwap+0x50>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
57 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteSwap` has 102 nodes.

Section invokeCNodeSaveCaller (353 of 432)
==========================================

Deriving specifications
-----------------------

Section `invokeCNodeSaveCaller` consists of 34 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `invokeCNodeSaveCaller`:

    0x84012056     0x0    addi sp,sp,-48
    0x84012058     0x2    sd ra,40(sp)          ; stack access
    0x8401205a     0x4    sd s0,32(sp)          ; stack access
    0x8401205c     0x6    sd s1,24(sp)          ; stack access
    0x8401205e     0x8    mv s0,a0
    0x84012060     0xa    auipc a5,0x1d
    0x84012064     0xe    ld a5,-1480(a5) # ffffffff8402ea98 <ksCurThread>
    0x84012068    0x12    andi a5,a5,-1024
    0x8401206c    0x16    addi s1,a5,96
    0x84012070    0x1a    ld a0,96(a5)
    0x84012072    0x1c    sd a0,0(sp)           ; stack access
    0x84012074    0x1e    ld a1,104(a5)
    0x84012076    0x20    sd a1,8(sp)           ; stack access
    0x84012078    0x22    jal ra,ffffffff8401039e <cap_get_capType>
    0x8401207c    0x26    beqz a0,ffffffff8401208e <invokeCNodeSaveCaller+0x38>
    0x8401207e    0x28    li a5,8
    0x84012080    0x2a    bne a0,a5,ffffffff840120a8 <invokeCNodeSaveCaller+0x52>
    0x84012084    0x2e    ld a0,0(sp)           ; stack access
    0x84012086    0x30    ld a1,8(sp)           ; stack access
    0x84012088    0x32    jal ra,ffffffff84010574 <cap_reply_cap_get_capReplyMaster>
    0x8401208c    0x36    beqz a0,ffffffff8401209a <invokeCNodeSaveCaller+0x44>
    0x8401208e    0x38    li a0,0
    0x84012090    0x3a    ld ra,40(sp)          ; stack access
    0x84012092    0x3c    ld s0,32(sp)          ; stack access
    0x84012094    0x3e    ld s1,24(sp)          ; stack access
    0x84012096    0x40    addi sp,sp,48
    0x84012098    0x42    ret
    0x8401209a    0x44    mv a3,s0
    0x8401209c    0x46    mv a2,s1
    0x8401209e    0x48    ld a0,0(sp)           ; stack access
    0x840120a0    0x4a    ld a1,8(sp)           ; stack access
    0x840120a2    0x4c    jal ra,ffffffff84011fd0 <cteMove>
    0x840120a6    0x50    j ffffffff8401208e <invokeCNodeSaveCaller+0x38>
    0x840120a8    0x52    jal ra,ffffffff84010cec <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
34 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeSaveCaller` has 60 nodes.

Section lookupSlotForCNodeOp (354 of 432)
=========================================

Deriving specifications
-----------------------

Section `lookupSlotForCNodeOp` consists of 89 instructions.

RVC_FFFFT_________FF.

Stack analysis
---------------

27 stack accesses found. Annotated code for `lookupSlotForCNodeOp`:

    0x84011c7e     0x0    addi sp,sp,-96
    0x84011c80     0x2    sd ra,88(sp)          ; stack access
    0x84011c82     0x4    sd s0,80(sp)          ; stack access
    0x84011c84     0x6    sd s1,72(sp)          ; stack access
    0x84011c86     0x8    sd s2,64(sp)          ; stack access
    0x84011c88     0xa    mv s2,a0
    0x84011c8a     0xc    sd a1,0(sp)           ; stack access
    0x84011c8c     0xe    sd a2,8(sp)           ; stack access
    0x84011c8e    0x10    mv s1,a3
    0x84011c90    0x12    mv s0,a4
    0x84011c92    0x14    mv a0,a1
    0x84011c94    0x16    mv a1,a2
    0x84011c96    0x18    jal ra,ffffffff8401039e <cap_get_capType>
    0x84011c9a    0x1c    li a5,10
    0x84011c9c    0x1e    bne a0,a5,ffffffff84011cd8 <lookupSlotForCNodeOp+0x5a>
    0x84011ca0    0x22    addi a5,s0,-1
    0x84011ca4    0x26    li a4,63
    0x84011ca8    0x2a    bltu a4,a5,ffffffff84011d00 <lookupSlotForCNodeOp+0x82>
    0x84011cac    0x2e    mv a4,s0
    0x84011cae    0x30    mv a3,s1
    0x84011cb0    0x32    ld a1,0(sp)           ; stack access
    0x84011cb2    0x34    ld a2,8(sp)           ; stack access
    0x84011cb4    0x36    addi a0,sp,24
    0x84011cb6    0x38    jal ra,ffffffff84011a94 <resolveAddressBits>
    0x84011cba    0x3c    ld a1,40(sp)          ; stack access
    0x84011cbc    0x3e    ld a5,24(sp)          ; stack access
    0x84011cbe    0x40    bnez a5,ffffffff84011d1e <lookupSlotForCNodeOp+0xa0>
    0x84011cc0    0x42    bnez a1,ffffffff84011d36 <lookupSlotForCNodeOp+0xb8>
    0x84011cc2    0x44    sd zero,48(sp)        ; stack access
    0x84011cc4    0x46    ld a5,32(sp)          ; stack access
    0x84011cc6    0x48    sd a5,56(sp)          ; stack access
    0x84011cc8    0x4a    ld a0,48(sp)          ; stack access
    0x84011cca    0x4c    ld a1,56(sp)          ; stack access
    0x84011ccc    0x4e    ld ra,88(sp)          ; stack access
    0x84011cce    0x50    ld s0,80(sp)          ; stack access
    0x84011cd0    0x52    ld s1,72(sp)          ; stack access
    0x84011cd2    0x54    ld s2,64(sp)          ; stack access
    0x84011cd4    0x56    addi sp,sp,96
    0x84011cd6    0x58    ret
    0x84011cd8    0x5a    auipc a5,0xc
    0x84011cdc    0x5e    addi a5,a5,-144 # ffffffff8401dc48 <current_syscall_error>
    0x84011ce0    0x62    li a4,6
    0x84011ce2    0x64    sd a4,48(a5)
    0x84011ce4    0x66    sd s2,40(a5)
    0x84011ce8    0x6a    jal ra,ffffffff840107b0 <lookup_fault_invalid_root_new>
    0x84011cec    0x6e    auipc a5,0xc
    0x84011cf0    0x72    addi a5,a5,-188 # ffffffff8401dc30 <current_lookup_fault>
    0x84011cf4    0x76    sd a0,0(a5)
    0x84011cf6    0x78    sd a1,8(a5)
    0x84011cf8    0x7a    li a5,3
    0x84011cfa    0x7c    sd a5,48(sp)          ; stack access
    0x84011cfc    0x7e    sd zero,56(sp)        ; stack access
    0x84011cfe    0x80    j ffffffff84011cc8 <lookupSlotForCNodeOp+0x4a>
    0x84011d00    0x82    auipc a5,0xc
    0x84011d04    0x86    addi a5,a5,-184 # ffffffff8401dc48 <current_syscall_error>
    0x84011d08    0x8a    li a4,4
    0x84011d0a    0x8c    sd a4,48(a5)
    0x84011d0c    0x8e    li a4,1
    0x84011d0e    0x90    sd a4,16(a5)
    0x84011d10    0x92    li a4,64
    0x84011d14    0x96    sd a4,24(a5)
    0x84011d16    0x98    li a5,3
    0x84011d18    0x9a    sd a5,48(sp)          ; stack access
    0x84011d1a    0x9c    sd zero,56(sp)        ; stack access
    0x84011d1c    0x9e    j ffffffff84011cc8 <lookupSlotForCNodeOp+0x4a>
    0x84011d1e    0xa0    auipc a5,0xc
    0x84011d22    0xa4    addi a5,a5,-214 # ffffffff8401dc48 <current_syscall_error>
    0x84011d26    0xa8    li a4,6
    0x84011d28    0xaa    sd a4,48(a5)
    0x84011d2a    0xac    sd s2,40(a5)
    0x84011d2e    0xb0    li a5,3
    0x84011d30    0xb2    sd a5,48(sp)          ; stack access
    0x84011d32    0xb4    sd zero,56(sp)        ; stack access
    0x84011d34    0xb6    j ffffffff84011cc8 <lookupSlotForCNodeOp+0x4a>
    0x84011d36    0xb8    auipc a5,0xc
    0x84011d3a    0xbc    addi a5,a5,-238 # ffffffff8401dc48 <current_syscall_error>
    0x84011d3e    0xc0    li a4,6
    0x84011d40    0xc2    sd a4,48(a5)
    0x84011d42    0xc4    sd s2,40(a5)
    0x84011d46    0xc8    li a0,0
    0x84011d48    0xca    jal ra,ffffffff840107d8 <lookup_fault_depth_mismatch_new>
    0x84011d4c    0xce    auipc a5,0xc
    0x84011d50    0xd2    addi a5,a5,-284 # ffffffff8401dc30 <current_lookup_fault>
    0x84011d54    0xd6    sd a0,0(a5)
    0x84011d56    0xd8    sd a1,8(a5)
    0x84011d58    0xda    li a5,3
    0x84011d5a    0xdc    sd a5,48(sp)          ; stack access
    0x84011d5c    0xde    sd zero,56(sp)        ; stack access
    0x84011d5e    0xe0    j ffffffff84011cc8 <lookupSlotForCNodeOp+0x4a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
89 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupSlotForCNodeOp` has 142 nodes.

Section Arch_maskCapRights (355 of 432)
=======================================

Deriving specifications
-----------------------

Section `Arch_maskCapRights` consists of 33 instructions.


Stack analysis
---------------

18 stack accesses found. Annotated code for `Arch_maskCapRights`:

    0x840116c6     0x0    addi sp,sp,-48
    0x840116c8     0x2    sd ra,40(sp)          ; stack access
    0x840116ca     0x4    sd s0,32(sp)          ; stack access
    0x840116cc     0x6    mv s0,a0
    0x840116ce     0x8    sd a1,0(sp)           ; stack access
    0x840116d0     0xa    sd a2,8(sp)           ; stack access
    0x840116d2     0xc    mv a0,a1
    0x840116d4     0xe    mv a1,a2
    0x840116d6    0x10    jal ra,ffffffff8401039e <cap_get_capType>
    0x840116da    0x14    li a5,1
    0x840116dc    0x16    beq a0,a5,ffffffff840116f4 <Arch_maskCapRights+0x2e>
    0x840116e0    0x1a    ld a5,0(sp)           ; stack access
    0x840116e2    0x1c    sd a5,16(sp)          ; stack access
    0x840116e4    0x1e    ld a5,8(sp)           ; stack access
    0x840116e6    0x20    sd a5,24(sp)          ; stack access
    0x840116e8    0x22    ld a0,16(sp)          ; stack access
    0x840116ea    0x24    ld a1,24(sp)          ; stack access
    0x840116ec    0x26    ld ra,40(sp)          ; stack access
    0x840116ee    0x28    ld s0,32(sp)          ; stack access
    0x840116f0    0x2a    addi sp,sp,48
    0x840116f2    0x2c    ret
    0x840116f4    0x2e    ld a0,0(sp)           ; stack access
    0x840116f6    0x30    ld a1,8(sp)           ; stack access
    0x840116f8    0x32    jal ra,ffffffff840106b2 <cap_frame_cap_get_capFVMRights>
    0x840116fc    0x36    mv a1,s0
    0x840116fe    0x38    jal ra,ffffffff8401150a <maskVMRights>
    0x84011702    0x3c    mv a2,a0
    0x84011704    0x3e    ld a0,0(sp)           ; stack access
    0x84011706    0x40    ld a1,8(sp)           ; stack access
    0x84011708    0x42    jal ra,ffffffff840106bc <cap_frame_cap_set_capFVMRights>
    0x8401170c    0x46    sd a0,16(sp)          ; stack access
    0x8401170e    0x48    sd a1,24(sp)          ; stack access
    0x84011710    0x4a    j ffffffff840116e8 <Arch_maskCapRights+0x22>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
33 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_maskCapRights` has 58 nodes.

Section Arch_setMRs_fault (356 of 432)
======================================

Deriving specifications
-----------------------

Section `Arch_setMRs_fault` consists of 29 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `Arch_setMRs_fault`:

    0x84010d0a     0x0    addi sp,sp,-32
    0x84010d0c     0x2    sd ra,24(sp)          ; stack access
    0x84010d0e     0x4    sd s0,16(sp)          ; stack access
    0x84010d10     0x6    sd s1,8(sp)           ; stack access
    0x84010d12     0x8    li a5,5
    0x84010d14     0xa    bne a3,a5,ffffffff84010d58 <Arch_setMRs_fault+0x4e>
    0x84010d18     0xe    mv s0,a0
    0x84010d1a    0x10    mv s1,a1
    0x84010d1c    0x12    ld a5,264(a0) # ffffffffe0000108 <ki_end+0x5bfd1108>
    0x84010d20    0x16    sd a5,88(a1)
    0x84010d22    0x18    ld a0,312(a0)
    0x84010d26    0x1c    ld a1,320(s0) # 1140 <KERNEL_OFFSET-0xfffffffeffffeec0>
    0x84010d2a    0x20    jal ra,ffffffff840108da <seL4_Fault_VMFault_get_address>
    0x84010d2e    0x24    sd a0,96(s1)
    0x84010d30    0x26    ld a0,312(s0)
    0x84010d34    0x2a    ld a1,320(s0)
    0x84010d38    0x2e    jal ra,ffffffff840108ec <seL4_Fault_VMFault_get_instructionFault>
    0x84010d3c    0x32    sd a0,104(s1)
    0x84010d3e    0x34    ld a0,312(s0)
    0x84010d42    0x38    ld a1,320(s0)
    0x84010d46    0x3c    jal ra,ffffffff840108e2 <seL4_Fault_VMFault_get_FSR>
    0x84010d4a    0x40    sd a0,112(s1)
    0x84010d4c    0x42    li a0,4
    0x84010d4e    0x44    ld ra,24(sp)          ; stack access
    0x84010d50    0x46    ld s0,16(sp)          ; stack access
    0x84010d52    0x48    ld s1,8(sp)           ; stack access
    0x84010d54    0x4a    addi sp,sp,32
    0x84010d56    0x4c    ret
    0x84010d58    0x4e    jal ra,ffffffff84010cec <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
29 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_setMRs_fault` has 53 nodes.

Section create_ipcbuf_frame_cap (357 of 432)
============================================

Deriving specifications
-----------------------

Section `create_ipcbuf_frame_cap` consists of 40 instructions.


Stack analysis
---------------

18 stack accesses found. Annotated code for `create_ipcbuf_frame_cap`:

    0x84000d08     0x0    addi sp,sp,-96
    0x84000d0a     0x2    sd ra,88(sp)          ; stack access
    0x84000d0c     0x4    sd s0,80(sp)          ; stack access
    0x84000d0e     0x6    sd s1,72(sp)          ; stack access
    0x84000d10     0x8    sd a0,16(sp)          ; stack access
    0x84000d12     0xa    sd a1,24(sp)          ; stack access
    0x84000d14     0xc    sd a2,0(sp)           ; stack access
    0x84000d16     0xe    sd a3,8(sp)           ; stack access
    0x84000d18    0x10    mv s0,a4
    0x84000d1a    0x12    auipc s1,0x0
    0x84000d1e    0x16    addi s1,s1,2038 # ffffffff84001510 <ndks_boot>
    0x84000d22    0x1a    lui a1,0x1
    0x84000d24    0x1c    ld a0,632(s1)
    0x84000d28    0x20    jal ra,ffffffff840164dc <memzero>
    0x84000d2c    0x24    li a6,0
    0x84000d2e    0x26    li a5,0
    0x84000d30    0x28    li a4,1
    0x84000d32    0x2a    mv a3,s0
    0x84000d34    0x2c    ld a2,632(s1)
    0x84000d38    0x30    ld a0,0(sp)           ; stack access
    0x84000d3a    0x32    ld a1,8(sp)           ; stack access
    0x84000d3c    0x34    jal ra,ffffffff8400028e <create_mapped_it_frame_cap>
    0x84000d40    0x38    mv s1,a0
    0x84000d42    0x3a    mv s0,a1
    0x84000d44    0x3c    sd a0,32(sp)          ; stack access
    0x84000d46    0x3e    sd a1,40(sp)          ; stack access
    0x84000d48    0x40    ld a0,16(sp)          ; stack access
    0x84000d4a    0x42    ld a1,24(sp)          ; stack access
    0x84000d4c    0x44    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x84000d50    0x48    mv a1,s1
    0x84000d52    0x4a    mv a2,s0
    0x84000d54    0x4c    addi a0,a0,320
    0x84000d58    0x50    jal ra,ffffffff840005bc <write_slot>
    0x84000d5c    0x54    ld a0,32(sp)          ; stack access
    0x84000d5e    0x56    ld a1,40(sp)          ; stack access
    0x84000d60    0x58    ld ra,88(sp)          ; stack access
    0x84000d62    0x5a    ld s0,80(sp)          ; stack access
    0x84000d64    0x5c    ld s1,72(sp)          ; stack access
    0x84000d66    0x5e    addi sp,sp,96
    0x84000d68    0x60    ret

Proving inst theorems
---------------------

40 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_ipcbuf_frame_cap` has 65 nodes.

Section create_untypeds_for_region (358 of 432)
===============================================

Deriving specifications
-----------------------

Section `create_untypeds_for_region` consists of 96 instructions.


Stack analysis
---------------

36 stack accesses found. Annotated code for `create_untypeds_for_region`:

    0x8400097c     0x0    addi sp,sp,-192
    0x8400097e     0x2    sd ra,184(sp)         ; stack access
    0x84000980     0x4    sd s0,176(sp)         ; stack access
    0x84000982     0x6    sd s1,168(sp)         ; stack access
    0x84000984     0x8    sd s2,160(sp)         ; stack access
    0x84000986     0xa    sd s3,152(sp)         ; stack access
    0x84000988     0xc    sd s4,144(sp)         ; stack access
    0x8400098a     0xe    sd s5,136(sp)         ; stack access
    0x8400098c    0x10    sd s6,128(sp)         ; stack access
    0x8400098e    0x12    sd s7,120(sp)         ; stack access
    0x84000990    0x14    sd s8,112(sp)         ; stack access
    0x84000992    0x16    sd s9,104(sp)         ; stack access
    0x84000994    0x18    sd s10,96(sp)         ; stack access
    0x84000996    0x1a    sd s11,88(sp)         ; stack access
    0x84000998    0x1c    sd a0,32(sp)          ; stack access
    0x8400099a    0x1e    sd a1,40(sp)          ; stack access
    0x8400099c    0x20    beq a4,a3,ffffffff84000a74 <create_untypeds_for_region+0xf8>
    0x840009a0    0x24    mv s11,a2
    0x840009a2    0x26    mv s8,a5
    0x840009a4    0x28    mv s2,a3
    0x840009a6    0x2a    mv s3,a4
    0x840009a8    0x2c    li s6,63
    0x840009ac    0x30    li s4,38
    0x840009b0    0x34    auipc s7,0x1
    0x840009b4    0x38    addi s7,s7,-1184 # ffffffff84001510 <ndks_boot>
    0x840009b8    0x3c    li s10,49
    0x840009bc    0x40    li s5,1
    0x840009be    0x42    slli a5,s5,0x26
    0x840009c2    0x46    sd a5,8(sp)           ; stack access
    0x840009c4    0x48    li s9,3
    0x840009c6    0x4a    j ffffffff840009e8 <create_untypeds_for_region+0x6c>
    0x840009c8    0x4c    mv s0,s4
    0x840009ca    0x4e    ld a5,32(sp)          ; stack access
    0x840009cc    0x50    sd a5,48(sp)          ; stack access
    0x840009ce    0x52    ld a5,40(sp)          ; stack access
    0x840009d0    0x54    sd a5,56(sp)          ; stack access
    0x840009d2    0x56    ld a5,592(s7)
    0x840009d6    0x5a    sub a5,a5,s8
    0x840009da    0x5e    bgeu s10,a5,ffffffff84000a18 <create_untypeds_for_region+0x9c>
    0x840009de    0x62    sll s0,s5,s0
    0x840009e2    0x66    add s2,s2,s0
    0x840009e4    0x68    beq s3,s2,ffffffff84000a54 <create_untypeds_for_region+0xd8>
    0x840009e8    0x6c    sub a0,s3,s2
    0x840009ec    0x70    jal ra,ffffffff84017f02 <__clzdi2>
    0x840009f0    0x74    sext.w s1,a0
    0x840009f4    0x78    sub s1,s6,s1
    0x840009f8    0x7c    mv s0,s1
    0x840009fa    0x7e    beqz s2,ffffffff84000a08 <create_untypeds_for_region+0x8c>
    0x840009fe    0x82    mv a0,s2
    0x84000a00    0x84    jal ra,ffffffff84017f20 <__ctzdi2>
    0x84000a04    0x88    sext.w s0,a0
    0x84000a08    0x8c    bgeu s1,s0,ffffffff84000a0e <create_untypeds_for_region+0x92>
    0x84000a0c    0x90    mv s0,s1
    0x84000a0e    0x92    bltu s4,s0,ffffffff840009c8 <create_untypeds_for_region+0x4c>
    0x84000a12    0x96    bgeu s9,s0,ffffffff840009de <create_untypeds_for_region+0x62>
    0x84000a16    0x9a    j ffffffff840009ca <create_untypeds_for_region+0x4e>
    0x84000a18    0x9c    slli a5,a5,0x4
    0x84000a1a    0x9e    ld a4,584(s7)
    0x84000a1e    0xa2    add a5,a5,a4
    0x84000a20    0xa4    sd zero,176(a5)
    0x84000a24    0xa8    ld a4,8(sp)           ; stack access
    0x84000a26    0xaa    add a4,a4,s2
    0x84000a28    0xac    sd a4,168(a5)
    0x84000a2a    0xae    sb s0,176(a5)
    0x84000a2e    0xb2    sb s11,177(a5)
    0x84000a32    0xb6    addiw a0,s0,-4
    0x84000a36    0xba    mv a3,s2
    0x84000a38    0xbc    mv a2,s0
    0x84000a3a    0xbe    mv a1,s11
    0x84000a3c    0xc0    sll a0,s5,a0
    0x84000a40    0xc4    jal ra,ffffffff840103be <cap_untyped_cap_new>
    0x84000a44    0xc8    mv a2,a0
    0x84000a46    0xca    mv a3,a1
    0x84000a48    0xcc    ld a0,48(sp)          ; stack access
    0x84000a4a    0xce    ld a1,56(sp)          ; stack access
    0x84000a4c    0xd0    jal ra,ffffffff840006ee <provide_cap>
    0x84000a50    0xd4    bnez a0,ffffffff840009de <create_untypeds_for_region+0x62>
    0x84000a52    0xd6    j ffffffff84000a56 <create_untypeds_for_region+0xda>
    0x84000a54    0xd8    li a0,1
    0x84000a56    0xda    ld ra,184(sp)         ; stack access
    0x84000a58    0xdc    ld s0,176(sp)         ; stack access
    0x84000a5a    0xde    ld s1,168(sp)         ; stack access
    0x84000a5c    0xe0    ld s2,160(sp)         ; stack access
    0x84000a5e    0xe2    ld s3,152(sp)         ; stack access
    0x84000a60    0xe4    ld s4,144(sp)         ; stack access
    0x84000a62    0xe6    ld s5,136(sp)         ; stack access
    0x84000a64    0xe8    ld s6,128(sp)         ; stack access
    0x84000a66    0xea    ld s7,120(sp)         ; stack access
    0x84000a68    0xec    ld s8,112(sp)         ; stack access
    0x84000a6a    0xee    ld s9,104(sp)         ; stack access
    0x84000a6c    0xf0    ld s10,96(sp)         ; stack access
    0x84000a6e    0xf2    ld s11,88(sp)         ; stack access
    0x84000a70    0xf4    addi sp,sp,192
    0x84000a72    0xf6    ret
    0x84000a74    0xf8    li a0,1
    0x84000a76    0xfa    j ffffffff84000a56 <create_untypeds_for_region+0xda>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
96 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_untypeds_for_region` has 159 nodes.

Section create_it_asid_pool (359 of 432)
========================================

Deriving specifications
-----------------------

Section `create_it_asid_pool` consists of 43 instructions.


Stack analysis
---------------

18 stack accesses found. Annotated code for `create_it_asid_pool`:

    0x840008f8     0x0    addi sp,sp,-112
    0x840008fa     0x2    sd ra,104(sp)         ; stack access
    0x840008fc     0x4    sd s0,96(sp)          ; stack access
    0x840008fe     0x6    sd s1,88(sp)          ; stack access
    0x84000900     0x8    sd s2,80(sp)          ; stack access
    0x84000902     0xa    sd s3,72(sp)          ; stack access
    0x84000904     0xc    mv s3,a0
    0x84000906     0xe    sd a0,0(sp)           ; stack access
    0x84000908    0x10    mv s2,a1
    0x8400090a    0x12    sd a1,8(sp)           ; stack access
    0x8400090c    0x14    auipc a1,0x1
    0x84000910    0x18    ld a1,-396(a1) # ffffffff84001780 <rootserver+0x10>
    0x84000914    0x1c    li a0,0
    0x84000916    0x1e    jal ra,ffffffff8401077e <cap_asid_pool_cap_new>
    0x8400091a    0x22    mv s1,a0
    0x8400091c    0x24    mv s0,a1
    0x8400091e    0x26    sd a0,16(sp)          ; stack access
    0x84000920    0x28    sd a1,24(sp)          ; stack access
    0x84000922    0x2a    mv a0,s3
    0x84000924    0x2c    mv a1,s2
    0x84000926    0x2e    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x8400092a    0x32    mv a1,s1
    0x8400092c    0x34    mv a2,s0
    0x8400092e    0x36    addi a0,a0,192
    0x84000932    0x3a    jal ra,ffffffff840005bc <write_slot>
    0x84000936    0x3e    ld a0,0(sp)           ; stack access
    0x84000938    0x40    ld a1,8(sp)           ; stack access
    0x8400093a    0x42    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x8400093e    0x46    mv s0,a0
    0x84000940    0x48    jal ra,ffffffff84010772 <cap_asid_control_cap_new>
    0x84000944    0x4c    mv a2,a1
    0x84000946    0x4e    mv a1,a0
    0x84000948    0x50    addi a0,s0,160
    0x8400094c    0x54    jal ra,ffffffff840005bc <write_slot>
    0x84000950    0x58    ld a0,16(sp)          ; stack access
    0x84000952    0x5a    ld a1,24(sp)          ; stack access
    0x84000954    0x5c    ld ra,104(sp)         ; stack access
    0x84000956    0x5e    ld s0,96(sp)          ; stack access
    0x84000958    0x60    ld s1,88(sp)          ; stack access
    0x8400095a    0x62    ld s2,80(sp)          ; stack access
    0x8400095c    0x64    ld s3,72(sp)          ; stack access
    0x8400095e    0x66    addi sp,sp,112
    0x84000960    0x68    ret

Proving inst theorems
---------------------

43 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_it_asid_pool` has 69 nodes.

Section map_it_frame_cap (360 of 432)
=====================================

Deriving specifications
-----------------------

Section `map_it_frame_cap` consists of 52 instructions.

Skipping 12000073 sfence.vma


Stack analysis
---------------

20 stack accesses found. Annotated code for `map_it_frame_cap`:

    0x84000218     0x0    addi sp,sp,-112
    0x8400021a     0x2    sd ra,104(sp)         ; stack access
    0x8400021c     0x4    sd s0,96(sp)          ; stack access
    0x8400021e     0x6    sd s1,88(sp)          ; stack access
    0x84000220     0x8    sd s2,80(sp)          ; stack access
    0x84000222     0xa    sd s3,72(sp)          ; stack access
    0x84000224     0xc    sd s4,64(sp)          ; stack access
    0x84000226     0xe    sd a0,32(sp)          ; stack access
    0x84000228    0x10    sd a1,40(sp)          ; stack access
    0x8400022a    0x12    mv s4,a2
    0x8400022c    0x14    sd a2,16(sp)          ; stack access
    0x8400022e    0x16    mv s0,a3
    0x84000230    0x18    mv s2,a3
    0x84000232    0x1a    sd a3,24(sp)          ; stack access
    0x84000234    0x1c    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x84000238    0x20    mv s1,a0
    0x8400023a    0x22    mv a0,s4
    0x8400023c    0x24    mv a1,s0
    0x8400023e    0x26    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x84000242    0x2a    mv s0,a0
    0x84000244    0x2c    mv a0,s4
    0x84000246    0x2e    mv a1,s2
    0x84000248    0x30    jal ra,ffffffff84010ad0 <cap_frame_cap_get_capFMappedAddress>
    0x8400024c    0x34    mv a1,a0
    0x8400024e    0x36    mv a0,s1
    0x84000250    0x38    jal ra,ffffffff84011116 <lookupPTSlot>
    0x84000254    0x3c    mv s1,a0
    0x84000256    0x3e    sd a0,48(sp)          ; stack access
    0x84000258    0x40    sd a1,56(sp)          ; stack access
    0x8400025a    0x42    li a5,1
    0x8400025c    0x44    slli a0,a5,0x26
    0x84000260    0x48    add a0,a0,s0
    0x84000262    0x4a    sd a5,8(sp)           ; stack access
    0x84000264    0x4c    sd a5,0(sp)           ; stack access
    0x84000266    0x4e    li a7,1
    0x84000268    0x50    li a6,1
    0x8400026a    0x52    li a4,0
    0x8400026c    0x54    li a3,1
    0x8400026e    0x56    li a2,1
    0x84000270    0x58    li a1,0
    0x84000272    0x5a    srli a0,a0,0xc
    0x84000274    0x5c    jal ra,ffffffff8401026a <pte_new>
    0x84000278    0x60    sd a0,0(s1)
    0x8400027a    0x62    sfence.vma
    0x8400027e    0x66    ld ra,104(sp)         ; stack access
    0x84000280    0x68    ld s0,96(sp)          ; stack access
    0x84000282    0x6a    ld s1,88(sp)          ; stack access
    0x84000284    0x6c    ld s2,80(sp)          ; stack access
    0x84000286    0x6e    ld s3,72(sp)          ; stack access
    0x84000288    0x70    ld s4,64(sp)          ; stack access
    0x8400028a    0x72    addi sp,sp,112
    0x8400028c    0x74    ret

Proving inst theorems
---------------------

52 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `map_it_frame_cap` has 80 nodes.

Section map_it_pt_cap (361 of 432)
==================================

Deriving specifications
-----------------------

Section `map_it_pt_cap` consists of 57 instructions.

Skipping 12000073 sfence.vma


Stack analysis
---------------

20 stack accesses found. Annotated code for `map_it_pt_cap`:

    0x84000198     0x0    addi sp,sp,-112
    0x8400019a     0x2    sd ra,104(sp)         ; stack access
    0x8400019c     0x4    sd s0,96(sp)          ; stack access
    0x8400019e     0x6    sd s1,88(sp)          ; stack access
    0x840001a0     0x8    sd s2,80(sp)          ; stack access
    0x840001a2     0xa    sd s3,72(sp)          ; stack access
    0x840001a4     0xc    sd s4,64(sp)          ; stack access
    0x840001a6     0xe    mv s4,a0
    0x840001a8    0x10    sd a0,32(sp)          ; stack access
    0x840001aa    0x12    mv s1,a1
    0x840001ac    0x14    sd a1,40(sp)          ; stack access
    0x840001ae    0x16    mv s3,a2
    0x840001b0    0x18    sd a2,16(sp)          ; stack access
    0x840001b2    0x1a    mv s0,a3
    0x840001b4    0x1c    sd a3,24(sp)          ; stack access
    0x840001b6    0x1e    mv a0,a2
    0x840001b8    0x20    mv a1,a3
    0x840001ba    0x22    jal ra,ffffffff84010ab2 <cap_page_table_cap_get_capPTMappedAddress>
    0x840001be    0x26    mv s2,a0
    0x840001c0    0x28    mv a0,s4
    0x840001c2    0x2a    mv a1,s1
    0x840001c4    0x2c    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x840001c8    0x30    mv s1,a0
    0x840001ca    0x32    mv a0,s3
    0x840001cc    0x34    mv a1,s0
    0x840001ce    0x36    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x840001d2    0x3a    mv s0,a0
    0x840001d4    0x3c    mv a1,s2
    0x840001d6    0x3e    mv a0,s1
    0x840001d8    0x40    jal ra,ffffffff84011116 <lookupPTSlot>
    0x840001dc    0x44    mv s1,a0
    0x840001de    0x46    sd a0,48(sp)          ; stack access
    0x840001e0    0x48    sd a1,56(sp)          ; stack access
    0x840001e2    0x4a    li a5,1
    0x840001e4    0x4c    slli a0,a5,0x26
    0x840001e8    0x50    add a0,a0,s0
    0x840001ea    0x52    sd a5,8(sp)           ; stack access
    0x840001ec    0x54    sd zero,0(sp)         ; stack access
    0x840001ee    0x56    li a7,0
    0x840001f0    0x58    li a6,0
    0x840001f2    0x5a    li a5,0
    0x840001f4    0x5c    li a4,0
    0x840001f6    0x5e    li a3,1
    0x840001f8    0x60    li a2,1
    0x840001fa    0x62    li a1,0
    0x840001fc    0x64    srli a0,a0,0xc
    0x840001fe    0x66    jal ra,ffffffff8401026a <pte_new>
    0x84000202    0x6a    sd a0,0(s1)
    0x84000204    0x6c    sfence.vma
    0x84000208    0x70    ld ra,104(sp)         ; stack access
    0x8400020a    0x72    ld s0,96(sp)          ; stack access
    0x8400020c    0x74    ld s1,88(sp)          ; stack access
    0x8400020e    0x76    ld s2,80(sp)          ; stack access
    0x84000210    0x78    ld s3,72(sp)          ; stack access
    0x84000212    0x7a    ld s4,64(sp)          ; stack access
    0x84000214    0x7c    addi sp,sp,112
    0x84000216    0x7e    ret

Proving inst theorems
---------------------

57 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `map_it_pt_cap` has 85 nodes.

Section decodeSetSchedParams (362 of 432)
=========================================

Deriving specifications
-----------------------

Section `decodeSetSchedParams` consists of 90 instructions.


Stack analysis
---------------

24 stack accesses found. Annotated code for `decodeSetSchedParams`:

    0x840158fe     0x0    addi sp,sp,-144
    0x84015900     0x2    sd ra,136(sp)         ; stack access
    0x84015902     0x4    sd s0,128(sp)         ; stack access
    0x84015904     0x6    sd s1,120(sp)         ; stack access
    0x84015906     0x8    sd s2,112(sp)         ; stack access
    0x84015908     0xa    sd a0,64(sp)          ; stack access
    0x8401590a     0xc    sd a1,72(sp)          ; stack access
    0x8401590c     0xe    li a5,1
    0x8401590e    0x10    bgeu a5,a2,ffffffff8401595a <decodeSetSchedParams+0x5c>
    0x84015912    0x14    auipc a5,0x8
    0x84015916    0x18    ld a5,878(a5) # ffffffff8401dc80 <current_extra_caps>
    0x8401591a    0x1c    beqz a5,ffffffff8401595a <decodeSetSchedParams+0x5c>
    0x8401591c    0x1e    auipc s0,0x19
    0x84015920    0x22    ld s0,380(s0) # ffffffff8402ea98 <ksCurThread>
    0x84015924    0x26    ld s1,88(s0)
    0x84015926    0x28    ld s2,96(s0)
    0x8401592a    0x2c    ld a0,0(a5)
    0x8401592c    0x2e    sd a0,80(sp)          ; stack access
    0x8401592e    0x30    ld a1,8(a5)
    0x84015930    0x32    sd a1,88(sp)          ; stack access
    0x84015932    0x34    jal ra,ffffffff8401039e <cap_get_capType>
    0x84015936    0x38    li a5,12
    0x84015938    0x3a    beq a0,a5,ffffffff84015968 <decodeSetSchedParams+0x6a>
    0x8401593c    0x3e    auipc a5,0x8
    0x84015940    0x42    addi a5,a5,780 # ffffffff8401dc48 <current_syscall_error>
    0x84015944    0x46    li a4,2
    0x84015946    0x48    sd a4,48(a5)
    0x84015948    0x4a    li a4,1
    0x8401594a    0x4c    sd a4,8(a5)
    0x8401594c    0x4e    li a0,3
    0x8401594e    0x50    ld ra,136(sp)         ; stack access
    0x84015950    0x52    ld s0,128(sp)         ; stack access
    0x84015952    0x54    ld s1,120(sp)         ; stack access
    0x84015954    0x56    ld s2,112(sp)         ; stack access
    0x84015956    0x58    addi sp,sp,144
    0x84015958    0x5a    ret
    0x8401595a    0x5c    li a5,7
    0x8401595c    0x5e    auipc a4,0x8
    0x84015960    0x62    sd a5,796(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84015964    0x66    li a0,3
    0x84015966    0x68    j ffffffff8401594e <decodeSetSchedParams+0x50>
    0x84015968    0x6a    ld a0,80(sp)          ; stack access
    0x8401596a    0x6c    ld a1,88(sp)          ; stack access
    0x8401596c    0x6e    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x84015970    0x72    ld a5,352(a0)
    0x84015974    0x76    bltu a5,s1,ffffffff840159ba <decodeSetSchedParams+0xbc>
    0x84015978    0x7a    bltu a5,s2,ffffffff840159d0 <decodeSetSchedParams+0xd2>
    0x8401597c    0x7e    li a1,2
    0x8401597e    0x80    mv a0,s0
    0x84015980    0x82    jal ra,ffffffff84013020 <setThreadState>
    0x84015984    0x86    ld a0,64(sp)          ; stack access
    0x84015986    0x88    ld a1,72(sp)          ; stack access
    0x84015988    0x8a    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x8401598c    0x8e    mv s0,a0
    0x8401598e    0x90    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84015992    0x94    mv a5,a0
    0x84015994    0x96    mv a6,a1
    0x84015996    0x98    li a4,9
    0x84015998    0x9a    sd a4,56(sp)          ; stack access
    0x8401599a    0x9c    sd zero,48(sp)        ; stack access
    0x8401599c    0x9e    sd a0,32(sp)          ; stack access
    0x8401599e    0xa0    sd a1,40(sp)          ; stack access
    0x840159a0    0xa2    sd zero,24(sp)        ; stack access
    0x840159a2    0xa4    sd zero,16(sp)        ; stack access
    0x840159a4    0xa6    sd a0,0(sp)           ; stack access
    0x840159a6    0xa8    sd a1,8(sp)           ; stack access
    0x840159a8    0xaa    li a7,0
    0x840159aa    0xac    mv a4,s2
    0x840159ac    0xae    mv a3,s1
    0x840159ae    0xb0    li a2,0
    0x840159b0    0xb2    li a1,0
    0x840159b2    0xb4    mv a0,s0
    0x840159b4    0xb6    jal ra,ffffffff84015466 <invokeTCB_ThreadControl>
    0x840159b8    0xba    j ffffffff8401594e <decodeSetSchedParams+0x50>
    0x840159ba    0xbc    auipc a4,0x8
    0x840159be    0xc0    addi a4,a4,654 # ffffffff8401dc48 <current_syscall_error>
    0x840159c2    0xc4    li a3,4
    0x840159c4    0xc6    sd a3,48(a4)
    0x840159c6    0xc8    sd zero,16(a4)
    0x840159ca    0xcc    sd a5,24(a4)
    0x840159cc    0xce    li a0,3
    0x840159ce    0xd0    j ffffffff8401594e <decodeSetSchedParams+0x50>
    0x840159d0    0xd2    auipc a4,0x8
    0x840159d4    0xd6    addi a4,a4,632 # ffffffff8401dc48 <current_syscall_error>
    0x840159d8    0xda    li a3,4
    0x840159da    0xdc    sd a3,48(a4)
    0x840159dc    0xde    sd zero,16(a4)
    0x840159e0    0xe2    sd a5,24(a4)
    0x840159e2    0xe4    li a0,3
    0x840159e4    0xe6    j ffffffff8401594e <decodeSetSchedParams+0x50>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
90 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetSchedParams` has 147 nodes.

Section decodeSetMCPriority (363 of 432)
========================================

Deriving specifications
-----------------------

Section `decodeSetMCPriority` consists of 77 instructions.


Stack analysis
---------------

22 stack accesses found. Annotated code for `decodeSetMCPriority`:

    0x8401583c     0x0    addi sp,sp,-144
    0x8401583e     0x2    sd ra,136(sp)         ; stack access
    0x84015840     0x4    sd s0,128(sp)         ; stack access
    0x84015842     0x6    sd s1,120(sp)         ; stack access
    0x84015844     0x8    sd a0,64(sp)          ; stack access
    0x84015846     0xa    sd a1,72(sp)          ; stack access
    0x84015848     0xc    beqz a2,ffffffff8401588c <decodeSetMCPriority+0x50>
    0x8401584a     0xe    auipc a5,0x8
    0x8401584e    0x12    ld a5,1078(a5) # ffffffff8401dc80 <current_extra_caps>
    0x84015852    0x16    beqz a5,ffffffff8401588c <decodeSetMCPriority+0x50>
    0x84015854    0x18    auipc s0,0x19
    0x84015858    0x1c    ld s0,580(s0) # ffffffff8402ea98 <ksCurThread>
    0x8401585c    0x20    ld s1,88(s0)
    0x8401585e    0x22    ld a0,0(a5)
    0x84015860    0x24    sd a0,80(sp)          ; stack access
    0x84015862    0x26    ld a1,8(a5)
    0x84015864    0x28    sd a1,88(sp)          ; stack access
    0x84015866    0x2a    jal ra,ffffffff8401039e <cap_get_capType>
    0x8401586a    0x2e    li a5,12
    0x8401586c    0x30    beq a0,a5,ffffffff8401589a <decodeSetMCPriority+0x5e>
    0x84015870    0x34    auipc a5,0x8
    0x84015874    0x38    addi a5,a5,984 # ffffffff8401dc48 <current_syscall_error>
    0x84015878    0x3c    li a4,2
    0x8401587a    0x3e    sd a4,48(a5)
    0x8401587c    0x40    li a4,1
    0x8401587e    0x42    sd a4,8(a5)
    0x84015880    0x44    li a0,3
    0x84015882    0x46    ld ra,136(sp)         ; stack access
    0x84015884    0x48    ld s0,128(sp)         ; stack access
    0x84015886    0x4a    ld s1,120(sp)         ; stack access
    0x84015888    0x4c    addi sp,sp,144
    0x8401588a    0x4e    ret
    0x8401588c    0x50    li a5,7
    0x8401588e    0x52    auipc a4,0x8
    0x84015892    0x56    sd a5,1002(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84015896    0x5a    li a0,3
    0x84015898    0x5c    j ffffffff84015882 <decodeSetMCPriority+0x46>
    0x8401589a    0x5e    ld a0,80(sp)          ; stack access
    0x8401589c    0x60    ld a1,88(sp)          ; stack access
    0x8401589e    0x62    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x840158a2    0x66    ld a5,352(a0)
    0x840158a6    0x6a    bltu a5,s1,ffffffff840158e8 <decodeSetMCPriority+0xac>
    0x840158aa    0x6e    li a1,2
    0x840158ac    0x70    mv a0,s0
    0x840158ae    0x72    jal ra,ffffffff84013020 <setThreadState>
    0x840158b2    0x76    ld a0,64(sp)          ; stack access
    0x840158b4    0x78    ld a1,72(sp)          ; stack access
    0x840158b6    0x7a    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x840158ba    0x7e    mv s0,a0
    0x840158bc    0x80    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x840158c0    0x84    mv a5,a0
    0x840158c2    0x86    mv a6,a1
    0x840158c4    0x88    li a4,8
    0x840158c6    0x8a    sd a4,56(sp)          ; stack access
    0x840158c8    0x8c    sd zero,48(sp)        ; stack access
    0x840158ca    0x8e    sd a0,32(sp)          ; stack access
    0x840158cc    0x90    sd a1,40(sp)          ; stack access
    0x840158ce    0x92    sd zero,24(sp)        ; stack access
    0x840158d0    0x94    sd zero,16(sp)        ; stack access
    0x840158d2    0x96    sd a0,0(sp)           ; stack access
    0x840158d4    0x98    sd a1,8(sp)           ; stack access
    0x840158d6    0x9a    li a7,0
    0x840158d8    0x9c    li a4,0
    0x840158da    0x9e    mv a3,s1
    0x840158dc    0xa0    li a2,0
    0x840158de    0xa2    li a1,0
    0x840158e0    0xa4    mv a0,s0
    0x840158e2    0xa6    jal ra,ffffffff84015466 <invokeTCB_ThreadControl>
    0x840158e6    0xaa    j ffffffff84015882 <decodeSetMCPriority+0x46>
    0x840158e8    0xac    auipc a4,0x8
    0x840158ec    0xb0    addi a4,a4,864 # ffffffff8401dc48 <current_syscall_error>
    0x840158f0    0xb4    li a3,4
    0x840158f2    0xb6    sd a3,48(a4)
    0x840158f4    0xb8    sd zero,16(a4)
    0x840158f8    0xbc    sd a5,24(a4)
    0x840158fa    0xbe    li a0,3
    0x840158fc    0xc0    j ffffffff84015882 <decodeSetMCPriority+0x46>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
77 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetMCPriority` has 126 nodes.

Section decodeSetPriority (364 of 432)
======================================

Deriving specifications
-----------------------

Section `decodeSetPriority` consists of 77 instructions.


Stack analysis
---------------

22 stack accesses found. Annotated code for `decodeSetPriority`:

    0x8401577a     0x0    addi sp,sp,-144
    0x8401577c     0x2    sd ra,136(sp)         ; stack access
    0x8401577e     0x4    sd s0,128(sp)         ; stack access
    0x84015780     0x6    sd s1,120(sp)         ; stack access
    0x84015782     0x8    sd a0,64(sp)          ; stack access
    0x84015784     0xa    sd a1,72(sp)          ; stack access
    0x84015786     0xc    beqz a2,ffffffff840157ca <decodeSetPriority+0x50>
    0x84015788     0xe    auipc a5,0x8
    0x8401578c    0x12    ld a5,1272(a5) # ffffffff8401dc80 <current_extra_caps>
    0x84015790    0x16    beqz a5,ffffffff840157ca <decodeSetPriority+0x50>
    0x84015792    0x18    auipc s0,0x19
    0x84015796    0x1c    ld s0,774(s0) # ffffffff8402ea98 <ksCurThread>
    0x8401579a    0x20    ld s1,88(s0)
    0x8401579c    0x22    ld a0,0(a5)
    0x8401579e    0x24    sd a0,80(sp)          ; stack access
    0x840157a0    0x26    ld a1,8(a5)
    0x840157a2    0x28    sd a1,88(sp)          ; stack access
    0x840157a4    0x2a    jal ra,ffffffff8401039e <cap_get_capType>
    0x840157a8    0x2e    li a5,12
    0x840157aa    0x30    beq a0,a5,ffffffff840157d8 <decodeSetPriority+0x5e>
    0x840157ae    0x34    auipc a5,0x8
    0x840157b2    0x38    addi a5,a5,1178 # ffffffff8401dc48 <current_syscall_error>
    0x840157b6    0x3c    li a4,2
    0x840157b8    0x3e    sd a4,48(a5)
    0x840157ba    0x40    li a4,1
    0x840157bc    0x42    sd a4,8(a5)
    0x840157be    0x44    li a0,3
    0x840157c0    0x46    ld ra,136(sp)         ; stack access
    0x840157c2    0x48    ld s0,128(sp)         ; stack access
    0x840157c4    0x4a    ld s1,120(sp)         ; stack access
    0x840157c6    0x4c    addi sp,sp,144
    0x840157c8    0x4e    ret
    0x840157ca    0x50    li a5,7
    0x840157cc    0x52    auipc a4,0x8
    0x840157d0    0x56    sd a5,1196(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840157d4    0x5a    li a0,3
    0x840157d6    0x5c    j ffffffff840157c0 <decodeSetPriority+0x46>
    0x840157d8    0x5e    ld a0,80(sp)          ; stack access
    0x840157da    0x60    ld a1,88(sp)          ; stack access
    0x840157dc    0x62    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x840157e0    0x66    ld a5,352(a0)
    0x840157e4    0x6a    bltu a5,s1,ffffffff84015826 <decodeSetPriority+0xac>
    0x840157e8    0x6e    li a1,2
    0x840157ea    0x70    mv a0,s0
    0x840157ec    0x72    jal ra,ffffffff84013020 <setThreadState>
    0x840157f0    0x76    ld a0,64(sp)          ; stack access
    0x840157f2    0x78    ld a1,72(sp)          ; stack access
    0x840157f4    0x7a    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x840157f8    0x7e    mv s0,a0
    0x840157fa    0x80    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x840157fe    0x84    mv a5,a0
    0x84015800    0x86    mv a6,a1
    0x84015802    0x88    li a4,1
    0x84015804    0x8a    sd a4,56(sp)          ; stack access
    0x84015806    0x8c    sd zero,48(sp)        ; stack access
    0x84015808    0x8e    sd a0,32(sp)          ; stack access
    0x8401580a    0x90    sd a1,40(sp)          ; stack access
    0x8401580c    0x92    sd zero,24(sp)        ; stack access
    0x8401580e    0x94    sd zero,16(sp)        ; stack access
    0x84015810    0x96    sd a0,0(sp)           ; stack access
    0x84015812    0x98    sd a1,8(sp)           ; stack access
    0x84015814    0x9a    li a7,0
    0x84015816    0x9c    mv a4,s1
    0x84015818    0x9e    li a3,0
    0x8401581a    0xa0    li a2,0
    0x8401581c    0xa2    li a1,0
    0x8401581e    0xa4    mv a0,s0
    0x84015820    0xa6    jal ra,ffffffff84015466 <invokeTCB_ThreadControl>
    0x84015824    0xaa    j ffffffff840157c0 <decodeSetPriority+0x46>
    0x84015826    0xac    auipc a4,0x8
    0x8401582a    0xb0    addi a4,a4,1058 # ffffffff8401dc48 <current_syscall_error>
    0x8401582e    0xb4    li a3,4
    0x84015830    0xb6    sd a3,48(a4)
    0x84015832    0xb8    sd zero,16(a4)
    0x84015836    0xbc    sd a5,24(a4)
    0x84015838    0xbe    li a0,3
    0x8401583a    0xc0    j ffffffff840157c0 <decodeSetPriority+0x46>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
77 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetPriority` has 126 nodes.

Section decodeIRQHandlerInvocation (365 of 432)
===============================================

Deriving specifications
-----------------------

Section `decodeIRQHandlerInvocation` consists of 74 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `decodeIRQHandlerInvocation`:

    0x8401455e     0x0    addi sp,sp,-48
    0x84014560     0x2    sd ra,40(sp)          ; stack access
    0x84014562     0x4    sd s0,32(sp)          ; stack access
    0x84014564     0x6    sd s1,24(sp)          ; stack access
    0x84014566     0x8    mv s0,a1
    0x84014568     0xa    li a5,27
    0x8401456a     0xc    beq a0,a5,ffffffff840145ac <decodeIRQHandlerInvocation+0x4e>
    0x8401456e    0x10    li a5,28
    0x84014570    0x12    beq a0,a5,ffffffff84014612 <decodeIRQHandlerInvocation+0xb4>
    0x84014574    0x16    li a5,26
    0x84014576    0x18    beq a0,a5,ffffffff84014588 <decodeIRQHandlerInvocation+0x2a>
    0x8401457a    0x1c    li a5,3
    0x8401457c    0x1e    auipc a4,0x9
    0x84014580    0x22    sd a5,1788(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84014584    0x26    li a0,3
    0x84014586    0x28    j ffffffff840145a2 <decodeIRQHandlerInvocation+0x44>
    0x84014588    0x2a    li a1,2
    0x8401458a    0x2c    auipc a0,0x1a
    0x8401458e    0x30    ld a0,1294(a0) # ffffffff8402ea98 <ksCurThread>
    0x84014592    0x34    jal ra,ffffffff84013020 <setThreadState>
    0x84014596    0x38    sext.w a1,s0
    0x8401459a    0x3c    lui a5,0xcc202
    0x8401459e    0x40    sw a1,4(a5)
    0x840145a0    0x42    li a0,0
    0x840145a2    0x44    ld ra,40(sp)          ; stack access
    0x840145a4    0x46    ld s0,32(sp)          ; stack access
    0x840145a6    0x48    ld s1,24(sp)          ; stack access
    0x840145a8    0x4a    addi sp,sp,48
    0x840145aa    0x4c    ret
    0x840145ac    0x4e    auipc s1,0x9
    0x840145b0    0x52    ld s1,1748(s1) # ffffffff8401dc80 <current_extra_caps>
    0x840145b4    0x56    beqz s1,ffffffff840145e6 <decodeIRQHandlerInvocation+0x88>
    0x840145b6    0x58    ld a0,0(s1)
    0x840145b8    0x5a    sd a0,0(sp)           ; stack access
    0x840145ba    0x5c    ld a1,8(s1)
    0x840145bc    0x5e    sd a1,8(sp)           ; stack access
    0x840145be    0x60    jal ra,ffffffff8401039e <cap_get_capType>
    0x840145c2    0x64    li a5,6
    0x840145c4    0x66    bne a0,a5,ffffffff840145d2 <decodeIRQHandlerInvocation+0x74>
    0x840145c8    0x6a    ld a0,0(sp)           ; stack access
    0x840145ca    0x6c    ld a1,8(sp)           ; stack access
    0x840145cc    0x6e    jal ra,ffffffff8401051e <cap_notification_cap_get_capNtfnCanSend>
    0x840145d0    0x72    bnez a0,ffffffff840145f4 <decodeIRQHandlerInvocation+0x96>
    0x840145d2    0x74    auipc a5,0x9
    0x840145d6    0x78    addi a5,a5,1654 # ffffffff8401dc48 <current_syscall_error>
    0x840145da    0x7c    li a4,2
    0x840145dc    0x7e    sd a4,48(a5)
    0x840145de    0x80    sd zero,8(a5)
    0x840145e2    0x84    li a0,3
    0x840145e4    0x86    j ffffffff840145a2 <decodeIRQHandlerInvocation+0x44>
    0x840145e6    0x88    li a5,7
    0x840145e8    0x8a    auipc a4,0x9
    0x840145ec    0x8e    sd a5,1680(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840145f0    0x92    li a0,3
    0x840145f2    0x94    j ffffffff840145a2 <decodeIRQHandlerInvocation+0x44>
    0x840145f4    0x96    li a1,2
    0x840145f6    0x98    auipc a0,0x1a
    0x840145fa    0x9c    ld a0,1186(a0) # ffffffff8402ea98 <ksCurThread>
    0x840145fe    0xa0    jal ra,ffffffff84013020 <setThreadState>
    0x84014602    0xa4    mv a3,s1
    0x84014604    0xa6    ld a1,0(sp)           ; stack access
    0x84014606    0xa8    ld a2,8(sp)           ; stack access
    0x84014608    0xaa    mv a0,s0
    0x8401460a    0xac    jal ra,ffffffff8401450e <invokeIRQHandler_SetIRQHandler>
    0x8401460e    0xb0    li a0,0
    0x84014610    0xb2    j ffffffff840145a2 <decodeIRQHandlerInvocation+0x44>
    0x84014612    0xb4    li a1,2
    0x84014614    0xb6    auipc a0,0x1a
    0x84014618    0xba    ld a0,1156(a0) # ffffffff8402ea98 <ksCurThread>
    0x8401461c    0xbe    jal ra,ffffffff84013020 <setThreadState>
    0x84014620    0xc2    mv a0,s0
    0x84014622    0xc4    jal ra,ffffffff84014544 <invokeIRQHandler_ClearIRQHandler>
    0x84014626    0xc8    li a0,0
    0x84014628    0xca    j ffffffff840145a2 <decodeIRQHandlerInvocation+0x44>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
74 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeIRQHandlerInvocation` has 117 nodes.

Section cteDeleteOne (366 of 432)
=================================

Deriving specifications
-----------------------

Section `cteDeleteOne` consists of 26 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `cteDeleteOne`:

    0x840144d0     0x0    addi sp,sp,-64
    0x840144d2     0x2    sd ra,56(sp)          ; stack access
    0x840144d4     0x4    sd s0,48(sp)          ; stack access
    0x840144d6     0x6    mv s0,a0
    0x840144d8     0x8    ld a0,0(a0)
    0x840144da     0xa    ld a1,8(s0)
    0x840144dc     0xc    jal ra,ffffffff8401039e <cap_get_capType>
    0x840144e0    0x10    bnez a0,ffffffff840144ea <cteDeleteOne+0x1a>
    0x840144e2    0x12    ld ra,56(sp)          ; stack access
    0x840144e4    0x14    ld s0,48(sp)          ; stack access
    0x840144e6    0x16    addi sp,sp,64
    0x840144e8    0x18    ret
    0x840144ea    0x1a    mv a0,s0
    0x840144ec    0x1c    jal ra,ffffffff84012af4 <isFinalCapability>
    0x840144f0    0x20    mv a3,a0
    0x840144f2    0x22    li a4,1
    0x840144f4    0x24    ld a1,0(s0)
    0x840144f6    0x26    ld a2,8(s0)
    0x840144f8    0x28    mv a0,sp
    0x840144fa    0x2a    jal ra,ffffffff84013b48 <finaliseCap>
    0x840144fe    0x2e    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84014502    0x32    mv a2,a1
    0x84014504    0x34    mv a1,a0
    0x84014506    0x36    mv a0,s0
    0x84014508    0x38    jal ra,ffffffff840123e8 <emptySlot>
    0x8401450c    0x3c    j ffffffff840144e2 <cteDeleteOne+0x12>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
26 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteDeleteOne` has 42 nodes.

Section Arch_decodeIRQControlInvocation (367 of 432)
====================================================

Deriving specifications
-----------------------

Section `Arch_decodeIRQControlInvocation` consists of 73 instructions.


Stack analysis
---------------

15 stack accesses found. Annotated code for `Arch_decodeIRQControlInvocation`:

    0x8401303e     0x0    li a5,37
    0x84013042     0x4    bne a0,a5,ffffffff840130f4 <Arch_decodeIRQControlInvocation+0xb6>
    0x84013046     0x8    addi sp,sp,-80
    0x84013048     0xa    sd ra,72(sp)          ; stack access
    0x8401304a     0xc    sd s0,64(sp)          ; stack access
    0x8401304c     0xe    sd s1,56(sp)          ; stack access
    0x8401304e    0x10    sd s2,48(sp)          ; stack access
    0x84013050    0x12    sd s3,40(sp)          ; stack access
    0x84013052    0x14    mv s0,a2
    0x84013054    0x16    li a5,3
    0x84013056    0x18    bgeu a5,a1,ffffffff840130a6 <Arch_decodeIRQControlInvocation+0x68>
    0x8401305a    0x1c    auipc a5,0xb
    0x8401305e    0x20    ld a5,-986(a5) # ffffffff8401dc80 <current_extra_caps>
    0x84013062    0x24    beqz a5,ffffffff840130a6 <Arch_decodeIRQControlInvocation+0x68>
    0x84013064    0x26    auipc a4,0x1c
    0x84013068    0x2a    ld a4,-1484(a4) # ffffffff8402ea98 <ksCurThread>
    0x8401306c    0x2e    ld s1,88(a4)
    0x8401306e    0x30    ld s2,104(a4)
    0x84013072    0x34    ld s3,112(a4)
    0x84013076    0x38    ld a4,0(a5)
    0x84013078    0x3a    sd a4,0(sp)           ; stack access
    0x8401307a    0x3c    ld a5,8(a5)
    0x8401307c    0x3e    sd a5,8(sp)           ; stack access
    0x8401307e    0x40    mv a0,s1
    0x84013080    0x42    jal ra,ffffffff84011602 <Arch_checkIRQ>
    0x84013084    0x46    bnez a0,ffffffff840130b2 <Arch_decodeIRQControlInvocation+0x74>
    0x84013086    0x48    slli a4,s1,0x3
    0x8401308a    0x4c    auipc a5,0xb
    0x8401308e    0x50    addi a5,a5,-1010 # ffffffff8401dc98 <intStateIRQTable>
    0x84013092    0x54    add a5,a5,a4
    0x84013094    0x56    ld a5,0(a5)
    0x84013096    0x58    beqz a5,ffffffff840130c0 <Arch_decodeIRQControlInvocation+0x82>
    0x84013098    0x5a    li a5,9
    0x8401309a    0x5c    auipc a4,0xb
    0x8401309e    0x60    sd a5,-1058(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840130a2    0x64    li a0,3
    0x840130a4    0x66    j ffffffff840130b2 <Arch_decodeIRQControlInvocation+0x74>
    0x840130a6    0x68    li a5,7
    0x840130a8    0x6a    auipc a4,0xb
    0x840130ac    0x6e    sd a5,-1072(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840130b0    0x72    li a0,3
    0x840130b2    0x74    ld ra,72(sp)          ; stack access
    0x840130b4    0x76    ld s0,64(sp)          ; stack access
    0x840130b6    0x78    ld s1,56(sp)          ; stack access
    0x840130b8    0x7a    ld s2,48(sp)          ; stack access
    0x840130ba    0x7c    ld s3,40(sp)          ; stack access
    0x840130bc    0x7e    addi sp,sp,80
    0x840130be    0x80    ret
    0x840130c0    0x82    mv a3,s3
    0x840130c2    0x84    mv a2,s2
    0x840130c4    0x86    ld a0,0(sp)           ; stack access
    0x840130c6    0x88    ld a1,8(sp)           ; stack access
    0x840130c8    0x8a    jal ra,ffffffff84011d7a <lookupTargetSlot>
    0x840130cc    0x8e    sd a1,24(sp)          ; stack access
    0x840130ce    0x90    bnez a0,ffffffff840130b2 <Arch_decodeIRQControlInvocation+0x74>
    0x840130d0    0x92    mv s2,a1
    0x840130d2    0x94    mv a0,a1
    0x840130d4    0x96    jal ra,ffffffff8401225c <ensureEmptySlot>
    0x840130d8    0x9a    bnez a0,ffffffff840130b2 <Arch_decodeIRQControlInvocation+0x74>
    0x840130da    0x9c    li a1,2
    0x840130dc    0x9e    auipc a0,0x1c
    0x840130e0    0xa2    ld a0,-1604(a0) # ffffffff8402ea98 <ksCurThread>
    0x840130e4    0xa6    jal ra,ffffffff84013020 <setThreadState>
    0x840130e8    0xaa    mv a2,s0
    0x840130ea    0xac    mv a1,s2
    0x840130ec    0xae    mv a0,s1
    0x840130ee    0xb0    jal ra,ffffffff840123a2 <invokeIRQControl>
    0x840130f2    0xb4    j ffffffff840130b2 <Arch_decodeIRQControlInvocation+0x74>
    0x840130f4    0xb6    li a5,3
    0x840130f6    0xb8    auipc a4,0xb
    0x840130fa    0xbc    sd a5,-1150(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840130fe    0xc0    li a0,3
    0x84013100    0xc2    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
73 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_decodeIRQControlInvocation` has 121 nodes.

Section hasCancelSendRights (368 of 432)
========================================

Deriving specifications
-----------------------

Section `hasCancelSendRights` consists of 32 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `hasCancelSendRights`:

    0x84012590     0x0    addi sp,sp,-32
    0x84012592     0x2    sd ra,24(sp)          ; stack access
    0x84012594     0x4    sd a0,0(sp)           ; stack access
    0x84012596     0x6    sd a1,8(sp)           ; stack access
    0x84012598     0x8    jal ra,ffffffff8401039e <cap_get_capType>
    0x8401259c     0xc    li a5,4
    0x8401259e     0xe    beq a0,a5,ffffffff840125aa <hasCancelSendRights+0x1a>
    0x840125a2    0x12    li a0,0
    0x840125a4    0x14    ld ra,24(sp)          ; stack access
    0x840125a6    0x16    addi sp,sp,32
    0x840125a8    0x18    ret
    0x840125aa    0x1a    ld a0,0(sp)           ; stack access
    0x840125ac    0x1c    ld a1,8(sp)           ; stack access
    0x840125ae    0x1e    jal ra,ffffffff840104b0 <cap_endpoint_cap_get_capCanSend>
    0x840125b2    0x22    li a5,0
    0x840125b4    0x24    beqz a0,ffffffff840125da <hasCancelSendRights+0x4a>
    0x840125b6    0x26    ld a0,0(sp)           ; stack access
    0x840125b8    0x28    ld a1,8(sp)           ; stack access
    0x840125ba    0x2a    jal ra,ffffffff84010492 <cap_endpoint_cap_get_capCanReceive>
    0x840125be    0x2e    li a5,0
    0x840125c0    0x30    beqz a0,ffffffff840125da <hasCancelSendRights+0x4a>
    0x840125c2    0x32    ld a0,0(sp)           ; stack access
    0x840125c4    0x34    ld a1,8(sp)           ; stack access
    0x840125c6    0x36    jal ra,ffffffff84010456 <cap_endpoint_cap_get_capCanGrantReply>
    0x840125ca    0x3a    li a5,0
    0x840125cc    0x3c    beqz a0,ffffffff840125da <hasCancelSendRights+0x4a>
    0x840125ce    0x3e    ld a0,0(sp)           ; stack access
    0x840125d0    0x40    ld a1,8(sp)           ; stack access
    0x840125d2    0x42    jal ra,ffffffff84010474 <cap_endpoint_cap_get_capCanGrant>
    0x840125d6    0x46    snez a5,a0
    0x840125da    0x4a    mv a0,a5
    0x840125dc    0x4c    j ffffffff840125a4 <hasCancelSendRights+0x14>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
32 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `hasCancelSendRights` has 58 nodes.

Section setupReplyMaster (369 of 432)
=====================================

Deriving specifications
-----------------------

Section `setupReplyMaster` consists of 38 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `setupReplyMaster`:

    0x840121f6     0x0    addi sp,sp,-32
    0x840121f8     0x2    sd ra,24(sp)          ; stack access
    0x840121fa     0x4    sd s0,16(sp)          ; stack access
    0x840121fc     0x6    sd s1,8(sp)           ; stack access
    0x840121fe     0x8    sd s2,0(sp)           ; stack access
    0x84012200     0xa    mv s0,a0
    0x84012202     0xc    andi s2,a0,-1024
    0x84012206    0x10    ld a0,64(s2)
    0x8401220a    0x14    ld a1,72(s2)
    0x8401220e    0x18    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012212    0x1c    beqz a0,ffffffff84012220 <setupReplyMaster+0x2a>
    0x84012214    0x1e    ld ra,24(sp)          ; stack access
    0x84012216    0x20    ld s0,16(sp)          ; stack access
    0x84012218    0x22    ld s1,8(sp)           ; stack access
    0x8401221a    0x24    ld s2,0(sp)           ; stack access
    0x8401221c    0x26    addi sp,sp,32
    0x8401221e    0x28    ret
    0x84012220    0x2a    mv a2,s0
    0x84012222    0x2c    li a1,1
    0x84012224    0x2e    li a0,1
    0x84012226    0x30    jal ra,ffffffff8401053c <cap_reply_cap_new>
    0x8401222a    0x34    sd a0,64(s2)
    0x8401222e    0x38    sd a1,72(s2)
    0x84012232    0x3c    li a3,0
    0x84012234    0x3e    li a2,0
    0x84012236    0x40    li a1,0
    0x84012238    0x42    li a0,0
    0x8401223a    0x44    jal ra,ffffffff8401018a <mdb_node_new>
    0x8401223e    0x48    sd a0,80(s2)
    0x84012242    0x4c    sd a1,88(s2)
    0x84012246    0x50    addi s1,s2,80
    0x8401224a    0x54    li a1,1
    0x8401224c    0x56    mv a0,s1
    0x8401224e    0x58    jal ra,ffffffff840101d8 <mdb_node_ptr_set_mdbRevocable>
    0x84012252    0x5c    li a1,1
    0x84012254    0x5e    mv a0,s1
    0x84012256    0x60    jal ra,ffffffff840101fc <mdb_node_ptr_set_mdbFirstBadged>
    0x8401225a    0x64    j ffffffff84012214 <setupReplyMaster+0x1e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
38 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setupReplyMaster` has 60 nodes.

Section Arch_sameObjectAs (370 of 432)
======================================

Deriving specifications
-----------------------

Section `Arch_sameObjectAs` consists of 56 instructions.


Stack analysis
---------------

26 stack accesses found. Annotated code for `Arch_sameObjectAs`:

    0x8401194c     0x0    addi sp,sp,-48
    0x8401194e     0x2    sd ra,40(sp)          ; stack access
    0x84011950     0x4    sd s0,32(sp)          ; stack access
    0x84011952     0x6    sd a0,16(sp)          ; stack access
    0x84011954     0x8    sd a1,24(sp)          ; stack access
    0x84011956     0xa    sd a2,0(sp)           ; stack access
    0x84011958     0xc    sd a3,8(sp)           ; stack access
    0x8401195a     0xe    jal ra,ffffffff8401039e <cap_get_capType>
    0x8401195e    0x12    li a5,1
    0x84011960    0x14    beq a0,a5,ffffffff84011978 <Arch_sameObjectAs+0x2c>
    0x84011964    0x18    ld a2,0(sp)           ; stack access
    0x84011966    0x1a    ld a3,8(sp)           ; stack access
    0x84011968    0x1c    ld a0,16(sp)          ; stack access
    0x8401196a    0x1e    ld a1,24(sp)          ; stack access
    0x8401196c    0x20    jal ra,ffffffff84011804 <Arch_sameRegionAs>
    0x84011970    0x24    ld ra,40(sp)          ; stack access
    0x84011972    0x26    ld s0,32(sp)          ; stack access
    0x84011974    0x28    addi sp,sp,48
    0x84011976    0x2a    ret
    0x84011978    0x2c    ld a0,0(sp)           ; stack access
    0x8401197a    0x2e    ld a1,8(sp)           ; stack access
    0x8401197c    0x30    jal ra,ffffffff8401039e <cap_get_capType>
    0x84011980    0x34    li a5,1
    0x84011982    0x36    bne a0,a5,ffffffff84011964 <Arch_sameObjectAs+0x18>
    0x84011986    0x3a    ld a0,16(sp)          ; stack access
    0x84011988    0x3c    ld a1,24(sp)          ; stack access
    0x8401198a    0x3e    jal ra,ffffffff84010a5a <cap_frame_cap_get_capFBasePtr>
    0x8401198e    0x42    mv s0,a0
    0x84011990    0x44    ld a0,0(sp)           ; stack access
    0x84011992    0x46    ld a1,8(sp)           ; stack access
    0x84011994    0x48    jal ra,ffffffff84010a5a <cap_frame_cap_get_capFBasePtr>
    0x84011998    0x4c    li a5,0
    0x8401199a    0x4e    beq s0,a0,ffffffff840119a2 <Arch_sameObjectAs+0x56>
    0x8401199e    0x52    mv a0,a5
    0x840119a0    0x54    j ffffffff84011970 <Arch_sameObjectAs+0x24>
    0x840119a2    0x56    ld a0,16(sp)          ; stack access
    0x840119a4    0x58    ld a1,24(sp)          ; stack access
    0x840119a6    0x5a    jal ra,ffffffff840106a8 <cap_frame_cap_get_capFSize>
    0x840119aa    0x5e    mv s0,a0
    0x840119ac    0x60    ld a0,0(sp)           ; stack access
    0x840119ae    0x62    ld a1,8(sp)           ; stack access
    0x840119b0    0x64    jal ra,ffffffff840106a8 <cap_frame_cap_get_capFSize>
    0x840119b4    0x68    li a5,0
    0x840119b6    0x6a    bne s0,a0,ffffffff8401199e <Arch_sameObjectAs+0x52>
    0x840119ba    0x6e    ld a0,16(sp)          ; stack access
    0x840119bc    0x70    ld a1,24(sp)          ; stack access
    0x840119be    0x72    jal ra,ffffffff840106d0 <cap_frame_cap_get_capFIsDevice>
    0x840119c2    0x76    mv s0,a0
    0x840119c4    0x78    ld a0,0(sp)           ; stack access
    0x840119c6    0x7a    ld a1,8(sp)           ; stack access
    0x840119c8    0x7c    jal ra,ffffffff840106d0 <cap_frame_cap_get_capFIsDevice>
    0x840119cc    0x80    snez s0,s0
    0x840119d0    0x84    seqz a5,a0
    0x840119d4    0x88    sub s0,s0,a5
    0x840119d6    0x8a    snez a5,s0
    0x840119da    0x8e    j ffffffff8401199e <Arch_sameObjectAs+0x52>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
56 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_sameObjectAs` has 100 nodes.

Section setVMRoot (371 of 432)
==============================

Deriving specifications
-----------------------

Section `setVMRoot` consists of 65 instructions.

Skipping 18051073 csrw satp,a0

Skipping 12000073 sfence.vma

Skipping 18051073 csrw satp,a0

Skipping 12000073 sfence.vma

Skipping 18051073 csrw satp,a0

Skipping 12000073 sfence.vma


Stack analysis
---------------

16 stack accesses found. Annotated code for `setVMRoot`:

    0x84011336     0x0    addi sp,sp,-64
    0x84011338     0x2    sd ra,56(sp)          ; stack access
    0x8401133a     0x4    sd s0,48(sp)          ; stack access
    0x8401133c     0x6    sd s1,40(sp)          ; stack access
    0x8401133e     0x8    sd s2,32(sp)          ; stack access
    0x84011340     0xa    andi a5,a0,-1024
    0x84011344     0xe    ld a0,32(a5)
    0x84011346    0x10    sd a0,16(sp)          ; stack access
    0x84011348    0x12    ld a1,40(a5)
    0x8401134a    0x14    sd a1,24(sp)          ; stack access
    0x8401134c    0x16    jal ra,ffffffff8401039e <cap_get_capType>
    0x84011350    0x1a    li a5,3
    0x84011352    0x1c    beq a0,a5,ffffffff84011382 <setVMRoot+0x4c>
    0x84011356    0x20    auipc a2,0xa
    0x8401135a    0x24    addi a2,a2,-854 # ffffffff8401b000 <kernel_root_pageTable>
    0x8401135e    0x28    li a5,1
    0x84011360    0x2a    slli a5,a5,0x20
    0x84011362    0x2c    add a2,a2,a5
    0x84011364    0x2e    srli a2,a2,0xc
    0x84011366    0x30    li a1,0
    0x84011368    0x32    li a0,8
    0x8401136a    0x34    jal ra,ffffffff840102f6 <satp_new>
    0x8401136e    0x38    csrw satp,a0
    0x84011372    0x3c    sfence.vma
    0x84011376    0x40    ld ra,56(sp)          ; stack access
    0x84011378    0x42    ld s0,48(sp)          ; stack access
    0x8401137a    0x44    ld s1,40(sp)          ; stack access
    0x8401137c    0x46    ld s2,32(sp)          ; stack access
    0x8401137e    0x48    addi sp,sp,64
    0x84011380    0x4a    ret
    0x84011382    0x4c    ld a0,16(sp)          ; stack access
    0x84011384    0x4e    ld a1,24(sp)          ; stack access
    0x84011386    0x50    jal ra,ffffffff84010a76 <cap_page_table_cap_get_capPTBasePtr>
    0x8401138a    0x54    mv s0,a0
    0x8401138c    0x56    ld a0,16(sp)          ; stack access
    0x8401138e    0x58    ld a1,24(sp)          ; stack access
    0x84011390    0x5a    jal ra,ffffffff84010714 <cap_page_table_cap_get_capPTMappedASID>
    0x84011394    0x5e    mv s1,a0
    0x84011396    0x60    jal ra,ffffffff84010922 <findVSpaceForASID>
    0x8401139a    0x64    sd a0,0(sp)           ; stack access
    0x8401139c    0x66    sd a1,8(sp)           ; stack access
    0x8401139e    0x68    bnez a0,ffffffff840113be <setVMRoot+0x88>
    0x840113a0    0x6a    bne a1,s0,ffffffff840113be <setVMRoot+0x88>
    0x840113a4    0x6e    li a2,1
    0x840113a6    0x70    slli a2,a2,0x26
    0x840113a8    0x72    add a2,a2,s0
    0x840113aa    0x74    srli a2,a2,0xc
    0x840113ac    0x76    mv a1,s1
    0x840113ae    0x78    li a0,8
    0x840113b0    0x7a    jal ra,ffffffff840102f6 <satp_new>
    0x840113b4    0x7e    csrw satp,a0
    0x840113b8    0x82    sfence.vma
    0x840113bc    0x86    j ffffffff84011376 <setVMRoot+0x40>
    0x840113be    0x88    auipc a2,0xa
    0x840113c2    0x8c    addi a2,a2,-958 # ffffffff8401b000 <kernel_root_pageTable>
    0x840113c6    0x90    li a5,1
    0x840113c8    0x92    slli a5,a5,0x20
    0x840113ca    0x94    add a2,a2,a5
    0x840113cc    0x96    srli a2,a2,0xc
    0x840113ce    0x98    li a1,0
    0x840113d0    0x9a    li a0,8
    0x840113d2    0x9c    jal ra,ffffffff840102f6 <satp_new>
    0x840113d6    0xa0    csrw satp,a0
    0x840113da    0xa4    sfence.vma
    0x840113de    0xa8    j ffffffff84011376 <setVMRoot+0x40>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
65 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setVMRoot` has 103 nodes.

Section lookupPTSlot (372 of 432)
=================================

Deriving specifications
-----------------------

Section `lookupPTSlot` consists of 51 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `lookupPTSlot`:

    0x84011116     0x0    addi sp,sp,-64
    0x84011118     0x2    sd ra,56(sp)          ; stack access
    0x8401111a     0x4    sd s0,48(sp)          ; stack access
    0x8401111c     0x6    sd s1,40(sp)          ; stack access
    0x8401111e     0x8    sd s2,32(sp)          ; stack access
    0x84011120     0xa    sd s3,24(sp)          ; stack access
    0x84011122     0xc    sd s4,16(sp)          ; stack access
    0x84011124     0xe    mv s2,a1
    0x84011126    0x10    srli s0,a1,0x1e
    0x8401112a    0x14    andi s0,s0,511
    0x8401112e    0x18    slli s0,s0,0x3
    0x84011130    0x1a    add s0,s0,a0
    0x84011132    0x1c    li s1,30
    0x84011134    0x1e    li s4,3
    0x84011136    0x20    li s3,-1
    0x84011138    0x22    slli s3,s3,0x26
    0x8401113a    0x24    j ffffffff8401115a <lookupPTSlot+0x44>
    0x8401113c    0x26    addi s1,s1,-9
    0x8401113e    0x28    beq s1,s4,ffffffff8401117c <lookupPTSlot+0x66>
    0x84011142    0x2c    mv a0,s0
    0x84011144    0x2e    jal ra,ffffffff840102d0 <pte_ptr_get_ppn>
    0x84011148    0x32    slli s0,a0,0xc
    0x8401114c    0x36    add s0,s0,s3
    0x8401114e    0x38    srl a0,s2,s1
    0x84011152    0x3c    andi a0,a0,511
    0x84011156    0x40    slli a0,a0,0x3
    0x84011158    0x42    add s0,s0,a0
    0x8401115a    0x44    mv a0,s0
    0x8401115c    0x46    jal ra,ffffffff840102f0 <pte_ptr_get_valid>
    0x84011160    0x4a    beqz a0,ffffffff8401117e <lookupPTSlot+0x68>
    0x84011162    0x4c    mv a0,s0
    0x84011164    0x4e    jal ra,ffffffff840102e8 <pte_ptr_get_read>
    0x84011168    0x52    bnez a0,ffffffff8401117e <lookupPTSlot+0x68>
    0x8401116a    0x54    mv a0,s0
    0x8401116c    0x56    jal ra,ffffffff840102e0 <pte_ptr_get_write>
    0x84011170    0x5a    bnez a0,ffffffff8401117e <lookupPTSlot+0x68>
    0x84011172    0x5c    mv a0,s0
    0x84011174    0x5e    jal ra,ffffffff840102d8 <pte_ptr_get_execute>
    0x84011178    0x62    bnez a0,ffffffff8401117e <lookupPTSlot+0x68>
    0x8401117a    0x64    j ffffffff8401113c <lookupPTSlot+0x26>
    0x8401117c    0x66    li s1,12
    0x8401117e    0x68    mv a0,s0
    0x84011180    0x6a    mv a1,s1
    0x84011182    0x6c    ld ra,56(sp)          ; stack access
    0x84011184    0x6e    ld s0,48(sp)          ; stack access
    0x84011186    0x70    ld s1,40(sp)          ; stack access
    0x84011188    0x72    ld s2,32(sp)          ; stack access
    0x8401118a    0x74    ld s3,24(sp)          ; stack access
    0x8401118c    0x76    ld s4,16(sp)          ; stack access
    0x8401118e    0x78    addi sp,sp,64
    0x84011190    0x7a    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
51 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupPTSlot` has 79 nodes.

Section init_freemem (373 of 432)
=================================

Deriving specifications
-----------------------

Section `init_freemem` consists of 300 instructions.

RVC_TFFTT____T____TF..

Stack analysis
---------------

42 stack accesses found. Annotated code for `init_freemem`:

    0x84000f4e      0x0    addi sp,sp,-192
    0x84000f50      0x2    sd ra,184(sp)         ; stack access
    0x84000f52      0x4    sd s0,176(sp)         ; stack access
    0x84000f54      0x6    sd s1,168(sp)         ; stack access
    0x84000f56      0x8    sd s2,160(sp)         ; stack access
    0x84000f58      0xa    sd s3,152(sp)         ; stack access
    0x84000f5a      0xc    sd s4,144(sp)         ; stack access
    0x84000f5c      0xe    sd s5,136(sp)         ; stack access
    0x84000f5e     0x10    sd s6,128(sp)         ; stack access
    0x84000f60     0x12    sd s7,120(sp)         ; stack access
    0x84000f62     0x14    sd s8,112(sp)         ; stack access
    0x84000f64     0x16    sd s9,104(sp)         ; stack access
    0x84000f66     0x18    mv s3,a0
    0x84000f68     0x1a    mv s4,a2
    0x84000f6a     0x1c    mv s5,a3
    0x84000f6c     0x1e    sd a4,0(sp)           ; stack access
    0x84000f6e     0x20    sd a5,8(sp)           ; stack access
    0x84000f70     0x22    mv s2,a6
    0x84000f72     0x24    li a5,1
    0x84000f74     0x26    bgeu a5,a2,ffffffff84000f84 <init_freemem+0x36>
    0x84000f78     0x2a    addi a4,a2,-1
    0x84000f7c     0x2e    li a5,0
    0x84000f7e     0x30    addi a5,a5,1
    0x84000f80     0x32    bne a5,a4,ffffffff84000f7e <init_freemem+0x30>
    0x84000f84     0x36    addi a4,s3,-1
    0x84000f88     0x3a    beqz a4,ffffffff84000f92 <init_freemem+0x44>
    0x84000f8a     0x3c    li a5,0
    0x84000f8c     0x3e    addi a5,a5,1
    0x84000f8e     0x40    bne a5,a4,ffffffff84000f8c <init_freemem+0x3e>
    0x84000f92     0x44    auipc a5,0x0
    0x84000f96     0x48    addi a5,a5,1734 # ffffffff84001658 <ndks_boot+0x148>
    0x84000f9a     0x4c    auipc a4,0x0
    0x84000f9e     0x50    addi a4,a4,1982 # ffffffff84001758 <ndks_boot+0x248>
    0x84000fa2     0x54    sd zero,0(a5)
    0x84000fa6     0x58    sd zero,8(a5)
    0x84000faa     0x5c    addi a5,a5,16
    0x84000fac     0x5e    bne a5,a4,ffffffff84000fa2 <init_freemem+0x54>
    0x84000fb0     0x62    beqz s3,ffffffff8400125e <init_freemem+0x310>
    0x84000fb4     0x66    mv a6,a1
    0x84000fb6     0x68    auipc a4,0x1
    0x84000fba     0x6c    addi a4,a4,-2022 # ffffffff840017d0 <avail_reg+0x8>
    0x84000fbe     0x70    slli t1,s3,0x4
    0x84000fc2     0x74    add t1,t1,a1
    0x84000fc4     0x76    li a7,-1
    0x84000fc6     0x78    slli a7,a7,0x26
    0x84000fc8     0x7a    li a0,127
    0x84000fcc     0x7e    slli a0,a0,0x1f
    0x84000fce     0x80    lui t4,0x80000
    0x84000fd2     0x84    li t3,1
    0x84000fd4     0x86    slli t3,t3,0x26
    0x84000fd6     0x88    j ffffffff84000fe8 <init_freemem+0x9a>
    0x84000fd8     0x8a    mv a5,t4
    0x84000fda     0x8c    j ffffffff84001002 <init_freemem+0xb4>
    0x84000fdc     0x8e    sd a5,-8(a3)
    0x84000fe0     0x92    addi a6,a6,16
    0x84000fe2     0x94    addi a4,a4,16
    0x84000fe4     0x96    beq a6,t1,ffffffff84001274 <init_freemem+0x326>
    0x84000fe8     0x9a    ld a1,8(a6)
    0x84000fec     0x9e    add a5,a1,a7
    0x84000ff0     0xa2    mv a3,a4
    0x84000ff2     0xa4    ld a2,0(a6)
    0x84000ff6     0xa8    add a2,a2,a7
    0x84000ff8     0xaa    sd a2,-8(a4)
    0x84000ffc     0xae    sd a5,0(a4)
    0x84000ffe     0xb0    bltu a0,a1,ffffffff84000fd8 <init_freemem+0x8a>
    0x84001002     0xb4    sd a5,0(a3)
    0x84001004     0xb6    ld a5,-8(a3)
    0x84001008     0xba    add a2,a5,t3
    0x8400100c     0xbe    bgeu a0,a2,ffffffff84000fdc <init_freemem+0x8e>
    0x84001010     0xc2    mv a5,t4
    0x84001012     0xc4    j ffffffff84000fdc <init_freemem+0x8e>
    0x84001014     0xc6    addi s0,s0,1
    0x84001016     0xc8    bgeu s1,s3,ffffffff84001262 <init_freemem+0x314>
    0x8400101a     0xcc    bgeu s0,s4,ffffffff8400128e <init_freemem+0x340>
    0x8400101e     0xd0    slli s6,s0,0x4
    0x84001022     0xd4    add s6,s6,s5
    0x84001024     0xd6    ld a1,0(s6)
    0x84001028     0xda    ld a4,8(s6)
    0x8400102c     0xde    beq a1,a4,ffffffff84001014 <init_freemem+0xc6>
    0x84001030     0xe2    slli a5,s1,0x4
    0x84001034     0xe6    add a5,a5,s7
    0x84001036     0xe8    ld a3,696(a5)
    0x8400103a     0xec    ld a5,704(a5)
    0x8400103e     0xf0    bltu a3,a5,ffffffff84001046 <init_freemem+0xf8>
    0x84001042     0xf4    addi s1,s1,1
    0x84001044     0xf6    j ffffffff84001016 <init_freemem+0xc8>
    0x84001046     0xf8    bgeu a3,a4,ffffffff8400107a <init_freemem+0x12c>
    0x8400104a     0xfc    bgeu a1,a5,ffffffff8400108e <init_freemem+0x140>
    0x8400104e    0x100    bltu a3,a1,ffffffff840010a4 <init_freemem+0x156>
    0x84001052    0x104    slli a3,s1,0x4
    0x84001056    0x108    add a3,a3,s7
    0x84001058    0x10a    bgeu a5,a4,ffffffff8400105e <init_freemem+0x110>
    0x8400105c    0x10e    mv a4,a5
    0x8400105e    0x110    sd a4,696(a3)
    0x84001062    0x114    ld a1,8(s6)
    0x84001066    0x118    add a1,a1,s8
    0x84001068    0x11a    ld a0,0(s6)
    0x8400106c    0x11e    add a0,a0,s8
    0x8400106e    0x120    sd a0,48(sp)          ; stack access
    0x84001070    0x122    sd a1,56(sp)          ; stack access
    0x84001072    0x124    jal ra,ffffffff84000388 <reserve_region>
    0x84001076    0x128    addi s0,s0,1
    0x84001078    0x12a    j ffffffff84001016 <init_freemem+0xc8>
    0x8400107a    0x12c    add a0,a1,s8
    0x8400107e    0x130    sd a0,32(sp)          ; stack access
    0x84001080    0x132    add a1,a4,s8
    0x84001084    0x136    sd a1,40(sp)          ; stack access
    0x84001086    0x138    jal ra,ffffffff84000388 <reserve_region>
    0x8400108a    0x13c    addi s0,s0,1
    0x8400108c    0x13e    j ffffffff84001016 <init_freemem+0xc8>
    0x8400108e    0x140    slli a5,s1,0x4
    0x84001092    0x144    add a5,a5,s7
    0x84001094    0x146    ld a0,696(a5)
    0x84001098    0x14a    ld a1,704(a5)
    0x8400109c    0x14e    jal ra,ffffffff8400055e <insert_region>
    0x840010a0    0x152    addi s1,s1,1
    0x840010a2    0x154    j ffffffff84001016 <init_freemem+0xc8>
    0x840010a4    0x156    slli s9,s1,0x4
    0x840010a8    0x15a    add s9,s9,s7
    0x840010aa    0x15c    ld a0,696(s9)
    0x840010ae    0x160    sd a0,16(sp)          ; stack access
    0x840010b0    0x162    sd a1,24(sp)          ; stack access
    0x840010b2    0x164    jal ra,ffffffff8400055e <insert_region>
    0x840010b6    0x168    ld a5,8(s6)
    0x840010ba    0x16c    ld a4,704(s9)
    0x840010be    0x170    bltu a5,a4,ffffffff840010c6 <init_freemem+0x178>
    0x840010c2    0x174    addi s1,s1,1
    0x840010c4    0x176    j ffffffff84001016 <init_freemem+0xc8>
    0x840010c6    0x178    sd a5,696(s9)
    0x840010ca    0x17c    ld a0,0(s6)
    0x840010ce    0x180    add a0,a0,s8
    0x840010d0    0x182    sd a0,64(sp)          ; stack access
    0x840010d2    0x184    add a1,a5,s8
    0x840010d6    0x188    sd a1,72(sp)          ; stack access
    0x840010d8    0x18a    jal ra,ffffffff84000388 <reserve_region>
    0x840010dc    0x18e    addi s0,s0,1
    0x840010de    0x190    j ffffffff84001016 <init_freemem+0xc8>
    0x840010e0    0x192    add a0,a0,s4
    0x840010e2    0x194    sd a0,80(sp)          ; stack access
    0x840010e4    0x196    add a1,a1,s4
    0x840010e6    0x198    sd a1,88(sp)          ; stack access
    0x840010e8    0x19a    jal ra,ffffffff84000388 <reserve_region>
    0x840010ec    0x19e    addi s0,s0,16
    0x840010ee    0x1a0    beq s0,s5,ffffffff8400128a <init_freemem+0x33c>
    0x840010f2    0x1a4    ld a0,0(s0)
    0x840010f4    0x1a6    ld a1,8(s0)
    0x840010f6    0x1a8    bgeu a0,a1,ffffffff840010ec <init_freemem+0x19e>
    0x840010fa    0x1ac    j ffffffff840010e0 <init_freemem+0x192>
    0x840010fc    0x1ae    slli a5,s1,0x4
    0x84001100    0x1b2    add a5,a5,s4
    0x84001102    0x1b4    ld a0,696(a5)
    0x84001106    0x1b8    ld a1,704(a5)
    0x8400110a    0x1bc    jal ra,ffffffff8400055e <insert_region>
    0x8400110e    0x1c0    addi s1,s1,1
    0x84001110    0x1c2    addi s0,s0,16
    0x84001112    0x1c4    beq s3,s1,ffffffff84001120 <init_freemem+0x1d2>
    0x84001116    0x1c8    ld a4,0(s0)
    0x84001118    0x1ca    ld a5,8(s0)
    0x8400111a    0x1cc    bgeu a4,a5,ffffffff8400110e <init_freemem+0x1c0>
    0x8400111e    0x1d0    j ffffffff840010fc <init_freemem+0x1ae>
    0x84001120    0x1d2    auipc a5,0x0
    0x84001124    0x1d6    addi a5,a5,1008 # ffffffff84001510 <ndks_boot>
    0x84001128    0x1da    ld a3,568(a5)
    0x8400112c    0x1de    ld a4,576(a5)
    0x84001130    0x1e2    auipc a5,0x0
    0x84001134    0x1e6    addi a5,a5,1544 # ffffffff84001738 <ndks_boot+0x228>
    0x84001138    0x1ea    li s3,15
    0x8400113a    0x1ec    bne a3,a4,ffffffff840011c6 <init_freemem+0x278>
    0x8400113e    0x1f0    mv s1,s3
    0x84001140    0x1f2    addi s3,s3,-1
    0x84001142    0x1f4    ld a3,0(a5)
    0x84001144    0x1f6    addi a5,a5,-16
    0x84001146    0x1f8    ld a4,24(a5)
    0x84001148    0x1fa    beq a3,a4,ffffffff8400113e <init_freemem+0x1f0>
    0x8400114c    0x1fe    ld a5,0(sp)           ; stack access
    0x8400114e    0x200    sd a5,16(sp)          ; stack access
    0x84001150    0x202    ld a5,8(sp)           ; stack access
    0x84001152    0x204    sd a5,24(sp)          ; stack access
    0x84001154    0x206    mv s0,s2
    0x84001156    0x208    beqz s2,ffffffff84001160 <init_freemem+0x212>
    0x8400115a    0x20c    li s0,1
    0x8400115c    0x20e    sll s0,s0,s2
    0x84001160    0x212    ld a0,16(sp)          ; stack access
    0x84001162    0x214    ld a1,24(sp)          ; stack access
    0x84001164    0x216    jal ra,ffffffff8400010c <arch_get_n_paging>
    0x84001168    0x21a    lui s4,0x1004
    0x8400116c    0x21e    addi s4,s4,1024 # 1004400 <KERNEL_OFFSET-0xfffffffefeffbc00>
    0x84001170    0x222    add s0,s0,s4
    0x84001172    0x224    slli s4,a0,0xc
    0x84001176    0x228    add s4,s4,s0
    0x84001178    0x22a    mv a3,s2
    0x8400117a    0x22c    li a5,24
    0x8400117c    0x22e    bgeu s2,a5,ffffffff84001182 <init_freemem+0x234>
    0x84001180    0x232    li a3,24
    0x84001182    0x234    sext.w a4,a3
    0x84001186    0x238    addi a5,s3,20
    0x8400118a    0x23c    slli a2,a5,0x4
    0x8400118e    0x240    auipc a5,0x0
    0x84001192    0x244    addi a5,a5,898 # ffffffff84001510 <ndks_boot>
    0x84001196    0x248    add a5,a5,a2
    0x84001198    0x24a    ld s0,16(a5)
    0x8400119a    0x24c    sub s0,s0,s4
    0x8400119e    0x250    srl s0,s0,a3
    0x840011a2    0x254    sll s0,s0,a3
    0x840011a6    0x258    ld a5,8(a5)
    0x840011a8    0x25a    bgeu s0,a5,ffffffff840011ca <init_freemem+0x27c>
    0x840011ac    0x25e    slli a5,s3,0x4
    0x840011b0    0x262    auipc a3,0x0
    0x840011b4    0x266    addi a3,a3,1176 # ffffffff84001648 <ndks_boot+0x138>
    0x840011b8    0x26a    add a5,a5,a3
    0x840011ba    0x26c    li a2,15
    0x840011bc    0x26e    auipc a1,0x0
    0x840011c0    0x272    addi a1,a1,852 # ffffffff84001510 <ndks_boot>
    0x840011c4    0x276    j ffffffff8400124a <init_freemem+0x2fc>
    0x840011c6    0x278    jal ra,ffffffff84010cec <halt>
    0x840011ca    0x27c    mv s5,s3
    0x840011cc    0x27e    mv s3,s1
    0x840011ce    0x280    mv a3,s2
    0x840011d0    0x282    ld a1,0(sp)           ; stack access
    0x840011d2    0x284    ld a2,8(sp)           ; stack access
    0x840011d4    0x286    mv a0,s0
    0x840011d6    0x288    jal ra,ffffffff84000e64 <create_rootserver_objects>
    0x840011da    0x28c    li a5,15
    0x840011dc    0x28e    bltu a5,s5,ffffffff84001200 <init_freemem+0x2b2>
    0x840011e0    0x292    auipc a5,0x0
    0x840011e4    0x296    addi a5,a5,816 # ffffffff84001510 <ndks_boot>
    0x840011e8    0x29a    addi a4,s5,20
    0x840011ec    0x29e    slli a4,a4,0x4
    0x840011ee    0x2a0    add a4,a4,a5
    0x840011f0    0x2a2    ld a4,16(a4)
    0x840011f2    0x2a4    addi s3,s3,20
    0x840011f4    0x2a6    slli s3,s3,0x4
    0x840011f6    0x2a8    add a5,a5,s3
    0x840011f8    0x2aa    sd a4,16(a5)
    0x840011fa    0x2ac    add s4,s4,s0
    0x840011fc    0x2ae    sd s4,8(a5)
    0x84001200    0x2b2    addi s5,s5,20
    0x84001202    0x2b4    slli s5,s5,0x4
    0x84001204    0x2b6    auipc a5,0x0
    0x84001208    0x2ba    addi a5,a5,780 # ffffffff84001510 <ndks_boot>
    0x8400120c    0x2be    add s5,s5,a5
    0x8400120e    0x2c0    sd s0,16(s5)
    0x84001212    0x2c4    ld ra,184(sp)         ; stack access
    0x84001214    0x2c6    ld s0,176(sp)         ; stack access
    0x84001216    0x2c8    ld s1,168(sp)         ; stack access
    0x84001218    0x2ca    ld s2,160(sp)         ; stack access
    0x8400121a    0x2cc    ld s3,152(sp)         ; stack access
    0x8400121c    0x2ce    ld s4,144(sp)         ; stack access
    0x8400121e    0x2d0    ld s5,136(sp)         ; stack access
    0x84001220    0x2d2    ld s6,128(sp)         ; stack access
    0x84001222    0x2d4    ld s7,120(sp)         ; stack access
    0x84001224    0x2d6    ld s8,112(sp)         ; stack access
    0x84001226    0x2d8    ld s9,104(sp)         ; stack access
    0x84001228    0x2da    addi sp,sp,192
    0x8400122a    0x2dc    ret
    0x8400122c    0x2de    addi s5,s3,-1
    0x84001230    0x2e2    ld s0,8(a5)
    0x84001232    0x2e4    sub s0,s0,s4
    0x84001236    0x2e8    srl s0,s0,a4
    0x8400123a    0x2ec    sll s0,s0,a4
    0x8400123e    0x2f0    addi a5,a5,-16
    0x84001240    0x2f2    mv s1,s3
    0x84001242    0x2f4    ld a3,16(a5)
    0x84001244    0x2f6    bgeu s0,a3,ffffffff840011ce <init_freemem+0x280>
    0x84001248    0x2fa    mv s3,s5
    0x8400124a    0x2fc    bltu a2,s3,ffffffff8400122c <init_freemem+0x2de>
    0x8400124e    0x300    addi s1,s1,20
    0x84001250    0x302    slli s1,s1,0x4
    0x84001252    0x304    add s1,s1,a1
    0x84001254    0x306    ld a3,16(a5)
    0x84001256    0x308    sd a3,8(s1)
    0x84001258    0x30a    ld a3,24(a5)
    0x8400125a    0x30c    sd a3,16(s1)
    0x8400125c    0x30e    j ffffffff8400122c <init_freemem+0x2de>
    0x8400125e    0x310    mv s1,s3
    0x84001260    0x312    mv s0,s3
    0x84001262    0x314    bgeu s0,s4,ffffffff84001120 <init_freemem+0x1d2>
    0x84001266    0x318    slli s0,s0,0x4
    0x84001268    0x31a    add s0,s0,s5
    0x8400126a    0x31c    slli s4,s4,0x4
    0x8400126c    0x31e    add s5,s5,s4
    0x8400126e    0x320    li s4,1
    0x84001270    0x322    slli s4,s4,0x26
    0x84001272    0x324    j ffffffff840010f2 <init_freemem+0x1a4>
    0x84001274    0x326    li s0,0
    0x84001276    0x328    li s1,0
    0x84001278    0x32a    auipc s7,0x0
    0x8400127c    0x32e    addi s7,s7,664 # ffffffff84001510 <ndks_boot>
    0x84001280    0x332    li s8,1
    0x84001282    0x334    slli s8,s8,0x26
    0x84001284    0x336    bnez s4,ffffffff8400101e <init_freemem+0xd0>
    0x84001288    0x33a    mv s1,s4
    0x8400128a    0x33c    bgeu s1,s3,ffffffff84001120 <init_freemem+0x1d2>
    0x8400128e    0x340    slli a5,s1,0x4
    0x84001292    0x344    auipc s0,0x0
    0x84001296    0x348    addi s0,s0,1334 # ffffffff840017c8 <avail_reg>
    0x8400129a    0x34c    add s0,s0,a5
    0x8400129c    0x34e    auipc s4,0x0
    0x840012a0    0x352    addi s4,s4,628 # ffffffff84001510 <ndks_boot>
    0x840012a4    0x356    j ffffffff84001116 <init_freemem+0x1c8>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
300 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `init_freemem` has 464 nodes.

Section decodeSetIPCBuffer (374 of 432)
=======================================

Deriving specifications
-----------------------

Section `decodeSetIPCBuffer` consists of 78 instructions.


Stack analysis
---------------

32 stack accesses found. Annotated code for `decodeSetIPCBuffer`:

    0x840159e6     0x0    addi sp,sp,-192
    0x840159e8     0x2    sd ra,184(sp)         ; stack access
    0x840159ea     0x4    sd s0,176(sp)         ; stack access
    0x840159ec     0x6    sd s1,168(sp)         ; stack access
    0x840159ee     0x8    sd s2,160(sp)         ; stack access
    0x840159f0     0xa    sd s3,152(sp)         ; stack access
    0x840159f2     0xc    sd a0,64(sp)          ; stack access
    0x840159f4     0xe    sd a1,72(sp)          ; stack access
    0x840159f6    0x10    beqz a2,ffffffff84015a3a <decodeSetIPCBuffer+0x54>
    0x840159f8    0x12    mv s2,a3
    0x840159fa    0x14    auipc s0,0x8
    0x840159fe    0x18    ld s0,646(s0) # ffffffff8401dc80 <current_extra_caps>
    0x84015a02    0x1c    beqz s0,ffffffff84015a3a <decodeSetIPCBuffer+0x54>
    0x84015a04    0x1e    auipc a5,0x19
    0x84015a08    0x22    ld a5,148(a5) # ffffffff8402ea98 <ksCurThread>
    0x84015a0c    0x26    ld s1,88(a5)
    0x84015a0e    0x28    ld a5,0(s0)
    0x84015a10    0x2a    sd a5,112(sp)         ; stack access
    0x84015a12    0x2c    ld a5,8(s0)
    0x84015a14    0x2e    sd a5,120(sp)         ; stack access
    0x84015a16    0x30    beqz s1,ffffffff84015a48 <decodeSetIPCBuffer+0x62>
    0x84015a18    0x32    ld a2,112(sp)         ; stack access
    0x84015a1a    0x34    mv a3,a5
    0x84015a1c    0x36    mv a1,s0
    0x84015a1e    0x38    addi a0,sp,88
    0x84015a20    0x3a    jal ra,ffffffff840129da <deriveCap>
    0x84015a24    0x3e    ld a0,88(sp)          ; stack access
    0x84015a26    0x40    bnez a0,ffffffff84015a90 <decodeSetIPCBuffer+0xaa>
    0x84015a28    0x42    ld a1,96(sp)          ; stack access
    0x84015a2a    0x44    sd a1,112(sp)         ; stack access
    0x84015a2c    0x46    ld a2,104(sp)         ; stack access
    0x84015a2e    0x48    sd a2,120(sp)         ; stack access
    0x84015a30    0x4a    mv a0,s1
    0x84015a32    0x4c    jal ra,ffffffff840114ae <checkValidIPCBuffer>
    0x84015a36    0x50    beqz a0,ffffffff84015a4a <decodeSetIPCBuffer+0x64>
    0x84015a38    0x52    j ffffffff84015a90 <decodeSetIPCBuffer+0xaa>
    0x84015a3a    0x54    li a5,7
    0x84015a3c    0x56    auipc a4,0x8
    0x84015a40    0x5a    sd a5,572(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84015a44    0x5e    li a0,3
    0x84015a46    0x60    j ffffffff84015a90 <decodeSetIPCBuffer+0xaa>
    0x84015a48    0x62    li s0,0
    0x84015a4a    0x64    li a1,2
    0x84015a4c    0x66    auipc a0,0x19
    0x84015a50    0x6a    ld a0,76(a0) # ffffffff8402ea98 <ksCurThread>
    0x84015a54    0x6e    jal ra,ffffffff84013020 <setThreadState>
    0x84015a58    0x72    ld a0,64(sp)          ; stack access
    0x84015a5a    0x74    ld a1,72(sp)          ; stack access
    0x84015a5c    0x76    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x84015a60    0x7a    mv s3,a0
    0x84015a62    0x7c    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84015a66    0x80    mv a5,a0
    0x84015a68    0x82    mv a6,a1
    0x84015a6a    0x84    li a4,2
    0x84015a6c    0x86    sd a4,56(sp)          ; stack access
    0x84015a6e    0x88    sd s0,48(sp)          ; stack access
    0x84015a70    0x8a    ld a4,112(sp)         ; stack access
    0x84015a72    0x8c    sd a4,32(sp)          ; stack access
    0x84015a74    0x8e    ld a4,120(sp)         ; stack access
    0x84015a76    0x90    sd a4,40(sp)          ; stack access
    0x84015a78    0x92    sd s1,24(sp)          ; stack access
    0x84015a7a    0x94    sd zero,16(sp)        ; stack access
    0x84015a7c    0x96    sd a0,0(sp)           ; stack access
    0x84015a7e    0x98    sd a1,8(sp)           ; stack access
    0x84015a80    0x9a    li a7,0
    0x84015a82    0x9c    li a4,0
    0x84015a84    0x9e    li a3,0
    0x84015a86    0xa0    li a2,0
    0x84015a88    0xa2    mv a1,s2
    0x84015a8a    0xa4    mv a0,s3
    0x84015a8c    0xa6    jal ra,ffffffff84015466 <invokeTCB_ThreadControl>
    0x84015a90    0xaa    ld ra,184(sp)         ; stack access
    0x84015a92    0xac    ld s0,176(sp)         ; stack access
    0x84015a94    0xae    ld s1,168(sp)         ; stack access
    0x84015a96    0xb0    ld s2,160(sp)         ; stack access
    0x84015a98    0xb2    ld s3,152(sp)         ; stack access
    0x84015a9a    0xb4    addi sp,sp,192
    0x84015a9c    0xb6    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
78 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetIPCBuffer` has 134 nodes.

Section invokeTCB_ThreadControl (375 of 432)
============================================

Deriving specifications
-----------------------

Section `invokeTCB_ThreadControl` consists of 130 instructions.


Stack analysis
---------------

44 stack accesses found. Annotated code for `invokeTCB_ThreadControl`:

    0x84015466      0x0    addi sp,sp,-96
    0x84015468      0x2    sd ra,88(sp)          ; stack access
    0x8401546a      0x4    sd s0,80(sp)          ; stack access
    0x8401546c      0x6    sd s1,72(sp)          ; stack access
    0x8401546e      0x8    sd s2,64(sp)          ; stack access
    0x84015470      0xa    sd s3,56(sp)          ; stack access
    0x84015472      0xc    sd s4,48(sp)          ; stack access
    0x84015474      0xe    sd s5,40(sp)          ; stack access
    0x84015476     0x10    sd s6,32(sp)          ; stack access
    0x84015478     0x12    mv s0,a0
    0x8401547a     0x14    mv s2,a1
    0x8401547c     0x16    mv s3,a2
    0x8401547e     0x18    mv s6,a3
    0x84015480     0x1a    mv s4,a4
    0x84015482     0x1c    sd a5,0(sp)           ; stack access
    0x84015484     0x1e    sd a6,8(sp)           ; stack access
    0x84015486     0x20    mv s5,a7
    0x84015488     0x22    ld s1,152(sp)         ; stack access
    0x8401548a     0x24    jal ra,ffffffff840105de <cap_thread_cap_new>
    0x8401548e     0x28    sd a0,16(sp)          ; stack access
    0x84015490     0x2a    sd a1,24(sp)          ; stack access
    0x84015492     0x2c    andi a5,s1,4
    0x84015496     0x30    beqz a5,ffffffff84015594 <invokeTCB_ThreadControl+0x12e>
    0x8401549a     0x34    sd s3,376(s0)
    0x8401549e     0x38    andi a4,s1,8
    0x840154a2     0x3c    bnez a4,ffffffff84015516 <invokeTCB_ThreadControl+0xb0>
    0x840154a4     0x3e    andi s3,s0,-1024
    0x840154a8     0x42    li a1,1
    0x840154aa     0x44    mv a0,s3
    0x840154ac     0x46    jal ra,ffffffff84013d20 <cteDelete>
    0x840154b0     0x4a    bnez a0,ffffffff840155a6 <invokeTCB_ThreadControl+0x140>
    0x840154b4     0x4e    ld a2,0(s5)
    0x840154b8     0x52    ld a3,8(s5)
    0x840154bc     0x56    ld a0,0(sp)           ; stack access
    0x840154be     0x58    ld a1,8(sp)           ; stack access
    0x840154c0     0x5a    jal ra,ffffffff84012a88 <sameObjectAs>
    0x840154c4     0x5e    beqz a0,ffffffff840154d8 <invokeTCB_ThreadControl+0x72>
    0x840154c6     0x60    ld a2,0(s2)
    0x840154ca     0x64    ld a3,8(s2)
    0x840154ce     0x68    ld a0,16(sp)          ; stack access
    0x840154d0     0x6a    ld a1,24(sp)          ; stack access
    0x840154d2     0x6c    jal ra,ffffffff84012a88 <sameObjectAs>
    0x840154d6     0x70    bnez a0,ffffffff8401551e <invokeTCB_ThreadControl+0xb8>
    0x840154d8     0x72    addi s3,s3,32
    0x840154dc     0x76    li a1,1
    0x840154de     0x78    mv a0,s3
    0x840154e0     0x7a    jal ra,ffffffff84013d20 <cteDelete>
    0x840154e4     0x7e    bnez a0,ffffffff840155a6 <invokeTCB_ThreadControl+0x140>
    0x840154e6     0x80    ld a5,112(sp)         ; stack access
    0x840154e8     0x82    ld a2,0(a5)
    0x840154ea     0x84    ld a3,8(a5)
    0x840154ec     0x86    ld a0,96(sp)          ; stack access
    0x840154ee     0x88    ld a1,104(sp)         ; stack access
    0x840154f0     0x8a    jal ra,ffffffff84012a88 <sameObjectAs>
    0x840154f4     0x8e    beqz a0,ffffffff8401559a <invokeTCB_ThreadControl+0x134>
    0x840154f6     0x90    ld a2,0(s2)
    0x840154fa     0x94    ld a3,8(s2)
    0x840154fe     0x98    ld a0,16(sp)          ; stack access
    0x84015500     0x9a    ld a1,24(sp)          ; stack access
    0x84015502     0x9c    jal ra,ffffffff84012a88 <sameObjectAs>
    0x84015506     0xa0    beqz a0,ffffffff8401559a <invokeTCB_ThreadControl+0x134>
    0x84015508     0xa2    mv a3,s3
    0x8401550a     0xa4    ld a2,112(sp)         ; stack access
    0x8401550c     0xa6    ld a0,96(sp)          ; stack access
    0x8401550e     0xa8    ld a1,104(sp)         ; stack access
    0x84015510     0xaa    jal ra,ffffffff84011e56 <cteInsert>
    0x84015514     0xae    j ffffffff8401559a <invokeTCB_ThreadControl+0x134>
    0x84015516     0xb0    sd s6,352(s0)
    0x8401551a     0xb4    beqz a5,ffffffff8401559a <invokeTCB_ThreadControl+0x134>
    0x8401551c     0xb6    j ffffffff840154a4 <invokeTCB_ThreadControl+0x3e>
    0x8401551e     0xb8    mv a3,s3
    0x84015520     0xba    mv a2,s5
    0x84015522     0xbc    ld a0,0(sp)           ; stack access
    0x84015524     0xbe    ld a1,8(sp)           ; stack access
    0x84015526     0xc0    jal ra,ffffffff84011e56 <cteInsert>
    0x8401552a     0xc4    j ffffffff840154d8 <invokeTCB_ThreadControl+0x72>
    0x8401552c     0xc6    andi s3,s0,-1024
    0x84015530     0xca    addi s3,s3,128
    0x84015534     0xce    li a1,1
    0x84015536     0xd0    mv a0,s3
    0x84015538     0xd2    jal ra,ffffffff84013d20 <cteDelete>
    0x8401553c     0xd6    bnez a0,ffffffff840155a6 <invokeTCB_ThreadControl+0x140>
    0x8401553e     0xd8    ld a5,120(sp)         ; stack access
    0x84015540     0xda    sd a5,384(s0)
    0x84015544     0xde    ld a5,144(sp)         ; stack access
    0x84015546     0xe0    beqz a5,ffffffff84015568 <invokeTCB_ThreadControl+0x102>
    0x84015548     0xe2    ld a2,0(a5)
    0x8401554a     0xe4    ld a3,8(a5)
    0x8401554c     0xe6    ld a0,128(sp)         ; stack access
    0x8401554e     0xe8    ld a1,136(sp)         ; stack access
    0x84015550     0xea    jal ra,ffffffff84012a88 <sameObjectAs>
    0x84015554     0xee    beqz a0,ffffffff84015568 <invokeTCB_ThreadControl+0x102>
    0x84015556     0xf0    ld a2,0(s2)
    0x8401555a     0xf4    ld a3,8(s2)
    0x8401555e     0xf8    ld a0,16(sp)          ; stack access
    0x84015560     0xfa    ld a1,24(sp)          ; stack access
    0x84015562     0xfc    jal ra,ffffffff84012a88 <sameObjectAs>
    0x84015566    0x100    bnez a0,ffffffff8401557a <invokeTCB_ThreadControl+0x114>
    0x84015568    0x102    auipc a5,0x19
    0x8401556c    0x106    ld a5,1328(a5) # ffffffff8402ea98 <ksCurThread>
    0x84015570    0x10a    bne a5,s0,ffffffff840155a0 <invokeTCB_ThreadControl+0x13a>
    0x84015574    0x10e    jal ra,ffffffff84012fa8 <rescheduleRequired>
    0x84015578    0x112    j ffffffff840155a0 <invokeTCB_ThreadControl+0x13a>
    0x8401557a    0x114    mv a3,s3
    0x8401557c    0x116    ld a2,144(sp)         ; stack access
    0x8401557e    0x118    ld a0,128(sp)         ; stack access
    0x84015580    0x11a    ld a1,136(sp)         ; stack access
    0x84015582    0x11c    jal ra,ffffffff84011e56 <cteInsert>
    0x84015586    0x120    j ffffffff84015568 <invokeTCB_ThreadControl+0x102>
    0x84015588    0x122    mv a1,s4
    0x8401558a    0x124    mv a0,s0
    0x8401558c    0x126    jal ra,ffffffff84013844 <setPriority>
    0x84015590    0x12a    li a0,0
    0x84015592    0x12c    j ffffffff840155a6 <invokeTCB_ThreadControl+0x140>
    0x84015594    0x12e    andi a4,s1,8
    0x84015598    0x132    bnez a4,ffffffff84015516 <invokeTCB_ThreadControl+0xb0>
    0x8401559a    0x134    andi a5,s1,2
    0x8401559e    0x138    bnez a5,ffffffff8401552c <invokeTCB_ThreadControl+0xc6>
    0x840155a0    0x13a    andi a0,s1,1
    0x840155a4    0x13e    bnez a0,ffffffff84015588 <invokeTCB_ThreadControl+0x122>
    0x840155a6    0x140    ld ra,88(sp)          ; stack access
    0x840155a8    0x142    ld s0,80(sp)          ; stack access
    0x840155aa    0x144    ld s1,72(sp)          ; stack access
    0x840155ac    0x146    ld s2,64(sp)          ; stack access
    0x840155ae    0x148    ld s3,56(sp)          ; stack access
    0x840155b0    0x14a    ld s4,48(sp)          ; stack access
    0x840155b2    0x14c    ld s5,40(sp)          ; stack access
    0x840155b4    0x14e    ld s6,32(sp)          ; stack access
    0x840155b6    0x150    addi sp,sp,96
    0x840155b8    0x152    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
130 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_ThreadControl` has 240 nodes.

Section handleReply (376 of 432)
================================

Deriving specifications
-----------------------

Section `handleReply` consists of 40 instructions.


Stack analysis
---------------

16 stack accesses found. Annotated code for `handleReply`:

    0x84014ce4     0x0    addi sp,sp,-48
    0x84014ce6     0x2    sd ra,40(sp)          ; stack access
    0x84014ce8     0x4    sd s0,32(sp)          ; stack access
    0x84014cea     0x6    sd s1,24(sp)          ; stack access
    0x84014cec     0x8    sd s2,16(sp)          ; stack access
    0x84014cee     0xa    auipc s0,0x1a
    0x84014cf2     0xe    ld s0,-598(s0) # ffffffff8402ea98 <ksCurThread>
    0x84014cf6    0x12    andi a5,s0,-1024
    0x84014cfa    0x16    addi s1,a5,96
    0x84014cfe    0x1a    ld a0,96(a5)
    0x84014d00    0x1c    sd a0,0(sp)           ; stack access
    0x84014d02    0x1e    ld a1,104(a5)
    0x84014d04    0x20    sd a1,8(sp)           ; stack access
    0x84014d06    0x22    jal ra,ffffffff8401039e <cap_get_capType>
    0x84014d0a    0x26    beqz a0,ffffffff84014d3a <handleReply+0x56>
    0x84014d0c    0x28    li a5,8
    0x84014d0e    0x2a    bne a0,a5,ffffffff84014d46 <handleReply+0x62>
    0x84014d12    0x2e    ld a0,0(sp)           ; stack access
    0x84014d14    0x30    ld a1,8(sp)           ; stack access
    0x84014d16    0x32    jal ra,ffffffff84010574 <cap_reply_cap_get_capReplyMaster>
    0x84014d1a    0x36    bnez a0,ffffffff84014d46 <handleReply+0x62>
    0x84014d1c    0x38    ld a0,0(sp)           ; stack access
    0x84014d1e    0x3a    ld a1,8(sp)           ; stack access
    0x84014d20    0x3c    jal ra,ffffffff84010554 <cap_reply_cap_get_capTCBPtr>
    0x84014d24    0x40    mv s2,a0
    0x84014d26    0x42    ld a0,0(sp)           ; stack access
    0x84014d28    0x44    ld a1,8(sp)           ; stack access
    0x84014d2a    0x46    jal ra,ffffffff8401055c <cap_reply_cap_get_capReplyCanGrant>
    0x84014d2e    0x4a    mv a3,a0
    0x84014d30    0x4c    mv a2,s1
    0x84014d32    0x4e    mv a1,s2
    0x84014d34    0x50    mv a0,s0
    0x84014d36    0x52    jal ra,ffffffff84014c5a <doReplyTransfer>
    0x84014d3a    0x56    ld ra,40(sp)          ; stack access
    0x84014d3c    0x58    ld s0,32(sp)          ; stack access
    0x84014d3e    0x5a    ld s1,24(sp)          ; stack access
    0x84014d40    0x5c    ld s2,16(sp)          ; stack access
    0x84014d42    0x5e    addi sp,sp,48
    0x84014d44    0x60    ret
    0x84014d46    0x62    jal ra,ffffffff84010cec <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
40 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleReply` has 72 nodes.

Section restart (377 of 432)
============================

Deriving specifications
-----------------------

Section `restart` consists of 31 instructions.


Stack analysis
---------------

7 stack accesses found. Annotated code for `restart`:

    0x84014644     0x0    addi sp,sp,-48
    0x84014646     0x2    sd ra,40(sp)          ; stack access
    0x84014648     0x4    sd s0,32(sp)          ; stack access
    0x8401464a     0x6    mv s0,a0
    0x8401464c     0x8    ld a5,280(a0)
    0x84014650     0xc    sd a5,0(sp)           ; stack access
    0x84014652     0xe    ld a5,288(a0)
    0x84014656    0x12    sd a5,8(sp)           ; stack access
    0x84014658    0x14    ld a5,296(a0)
    0x8401465c    0x18    sd a5,16(sp)          ; stack access
    0x8401465e    0x1a    mv a0,sp
    0x84014660    0x1c    jal ra,ffffffff84010382 <thread_state_get_tsType>
    0x84014664    0x20    beqz a0,ffffffff8401466e <restart+0x2a>
    0x84014666    0x22    addi a0,a0,-3
    0x84014668    0x24    li a5,3
    0x8401466a    0x26    bltu a5,a0,ffffffff8401468e <restart+0x4a>
    0x8401466e    0x2a    mv a0,s0
    0x84014670    0x2c    jal ra,ffffffff84013a46 <cancelIPC>
    0x84014674    0x30    mv a0,s0
    0x84014676    0x32    jal ra,ffffffff840121f6 <setupReplyMaster>
    0x8401467a    0x36    li a1,2
    0x8401467c    0x38    mv a0,s0
    0x8401467e    0x3a    jal ra,ffffffff84013020 <setThreadState>
    0x84014682    0x3e    mv a0,s0
    0x84014684    0x40    jal ra,ffffffff84012efc <tcbSchedEnqueue>
    0x84014688    0x44    mv a0,s0
    0x8401468a    0x46    jal ra,ffffffff840132c6 <possibleSwitchTo>
    0x8401468e    0x4a    ld ra,40(sp)          ; stack access
    0x84014690    0x4c    ld s0,32(sp)          ; stack access
    0x84014692    0x4e    addi sp,sp,48
    0x84014694    0x50    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
31 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `restart` has 52 nodes.

Section schedule (378 of 432)
=============================

Deriving specifications
-----------------------

Section `schedule` consists of 102 instructions.


Stack analysis
---------------

15 stack accesses found. Annotated code for `schedule`:

    0x840136b0      0x0    auipc a5,0xa
    0x840136b4      0x4    ld a5,1424(a5) # ffffffff8401dc40 <ksSchedulerAction>
    0x840136b8      0x8    beqz a5,ffffffff840137e2 <schedule+0x132>
    0x840136bc      0xc    addi sp,sp,-80
    0x840136be      0xe    sd ra,72(sp)          ; stack access
    0x840136c0     0x10    sd s0,64(sp)          ; stack access
    0x840136c2     0x12    sd s1,56(sp)          ; stack access
    0x840136c4     0x14    sd s2,48(sp)          ; stack access
    0x840136c6     0x16    sd s3,40(sp)          ; stack access
    0x840136c8     0x18    sd s4,32(sp)          ; stack access
    0x840136ca     0x1a    auipc s0,0x1b
    0x840136ce     0x1e    ld s0,974(s0) # ffffffff8402ea98 <ksCurThread>
    0x840136d2     0x22    ld a5,280(s0)
    0x840136d6     0x26    sd a5,0(sp)           ; stack access
    0x840136d8     0x28    ld a5,288(s0)
    0x840136dc     0x2c    sd a5,8(sp)           ; stack access
    0x840136de     0x2e    ld a5,296(s0)
    0x840136e2     0x32    sd a5,16(sp)          ; stack access
    0x840136e4     0x34    mv a0,sp
    0x840136e6     0x36    jal ra,ffffffff84010382 <thread_state_get_tsType>
    0x840136ea     0x3a    addi a0,a0,-1
    0x840136ec     0x3c    li a5,1
    0x840136ee     0x3e    li s3,0
    0x840136f0     0x40    bgeu a5,a0,ffffffff8401378e <schedule+0xde>
    0x840136f4     0x44    auipc s0,0xa
    0x840136f8     0x48    ld s0,1356(s0) # ffffffff8401dc40 <ksSchedulerAction>
    0x840136fc     0x4c    li a5,1
    0x840136fe     0x4e    beq s0,a5,ffffffff84013798 <schedule+0xe8>
    0x84013702     0x52    auipc s4,0x1b
    0x84013706     0x56    ld s4,918(s4) # ffffffff8402ea98 <ksCurThread>
    0x8401370a     0x5a    auipc a5,0xa
    0x8401370e     0x5e    ld a5,1310(a5) # ffffffff8401dc28 <ksIdleThread>
    0x84013712     0x62    beq s4,a5,ffffffff84013722 <schedule+0x72>
    0x84013716     0x66    ld a4,360(s0)
    0x8401371a     0x6a    ld a5,360(s4)
    0x8401371e     0x6e    bgeu a4,a5,ffffffff8401379e <schedule+0xee>
    0x84013722     0x72    auipc s1,0x1b
    0x84013726     0x76    ld s1,222(s1) # ffffffff8402e800 <ksCurDomain>
    0x8401372a     0x7a    slli a4,s1,0x3
    0x8401372e     0x7e    auipc a5,0x1b
    0x84013732     0x82    addi a5,a5,746 # ffffffff8402ea18 <ksReadyQueuesL1Bitmap>
    0x84013736     0x86    add a5,a5,a4
    0x84013738     0x88    ld a0,0(a5)
    0x8401373a     0x8a    beqz a0,ffffffff8401379e <schedule+0xee>
    0x8401373c     0x8c    jal ra,ffffffff84017f02 <__clzdi2>
    0x84013740     0x90    sext.w s2,a0
    0x84013744     0x94    slli s1,s1,0x2
    0x84013746     0x96    addi a5,s2,-60
    0x8401374a     0x9a    add s1,s1,a5
    0x8401374c     0x9c    slli s1,s1,0x3
    0x8401374e     0x9e    auipc a5,0x1b
    0x84013752     0xa2    addi a5,a5,194 # ffffffff8402e810 <ksReadyQueuesL2Bitmap>
    0x84013756     0xa6    add s1,s1,a5
    0x84013758     0xa8    ld a0,0(s1)
    0x8401375a     0xaa    jal ra,ffffffff84017f02 <__clzdi2>
    0x8401375e     0xae    sext.w a0,a0
    0x84013760     0xb0    li a5,63
    0x84013764     0xb4    sub s2,a5,s2
    0x84013768     0xb8    slli s2,s2,0x6
    0x8401376a     0xba    sub a5,a5,a0
    0x8401376c     0xbc    or s2,s2,a5
    0x84013770     0xc0    ld a5,360(s0)
    0x84013774     0xc4    bgeu a5,s2,ffffffff8401379e <schedule+0xee>
    0x84013778     0xc8    mv a0,s0
    0x8401377a     0xca    jal ra,ffffffff84012efc <tcbSchedEnqueue>
    0x8401377e     0xce    li a5,1
    0x84013780     0xd0    auipc a4,0xa
    0x84013784     0xd4    sd a5,1216(a4) # ffffffff8401dc40 <ksSchedulerAction>
    0x84013788     0xd8    jal ra,ffffffff84013642 <scheduleChooseNewThread>
    0x8401378c     0xdc    j ffffffff840137b4 <schedule+0x104>
    0x8401378e     0xde    mv a0,s0
    0x84013790     0xe0    jal ra,ffffffff84012efc <tcbSchedEnqueue>
    0x84013794     0xe4    li s3,1
    0x84013796     0xe6    j ffffffff840136f4 <schedule+0x44>
    0x84013798     0xe8    jal ra,ffffffff84013642 <scheduleChooseNewThread>
    0x8401379c     0xec    j ffffffff840137b4 <schedule+0x104>
    0x8401379e     0xee    beqz s3,ffffffff840137ae <schedule+0xfe>
    0x840137a2     0xf2    ld a4,360(s0)
    0x840137a6     0xf6    ld a5,360(s4)
    0x840137aa     0xfa    beq a4,a5,ffffffff840137cc <schedule+0x11c>
    0x840137ae     0xfe    mv a0,s0
    0x840137b0    0x100    jal ra,ffffffff840135a4 <switchToThread>
    0x840137b4    0x104    auipc a5,0xa
    0x840137b8    0x108    sd zero,1164(a5) # ffffffff8401dc40 <ksSchedulerAction>
    0x840137bc    0x10c    ld ra,72(sp)          ; stack access
    0x840137be    0x10e    ld s0,64(sp)          ; stack access
    0x840137c0    0x110    ld s1,56(sp)          ; stack access
    0x840137c2    0x112    ld s2,48(sp)          ; stack access
    0x840137c4    0x114    ld s3,40(sp)          ; stack access
    0x840137c6    0x116    ld s4,32(sp)          ; stack access
    0x840137c8    0x118    addi sp,sp,80
    0x840137ca    0x11a    ret
    0x840137cc    0x11c    mv a0,s0
    0x840137ce    0x11e    jal ra,ffffffff840133ba <tcbSchedAppend>
    0x840137d2    0x122    li a5,1
    0x840137d4    0x124    auipc a4,0xa
    0x840137d8    0x128    sd a5,1132(a4) # ffffffff8401dc40 <ksSchedulerAction>
    0x840137dc    0x12c    jal ra,ffffffff84013642 <scheduleChooseNewThread>
    0x840137e0    0x130    j ffffffff840137b4 <schedule+0x104>
    0x840137e2    0x132    auipc a5,0xa
    0x840137e6    0x136    sd zero,1118(a5) # ffffffff8401dc40 <ksSchedulerAction>
    0x840137ea    0x13a    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
102 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `schedule` has 167 nodes.

Section decodeIRQControlInvocation (379 of 432)
===============================================

Deriving specifications
-----------------------

Section `decodeIRQControlInvocation` consists of 70 instructions.


Stack analysis
---------------

15 stack accesses found. Annotated code for `decodeIRQControlInvocation`:

    0x84013166     0x0    addi sp,sp,-80
    0x84013168     0x2    sd ra,72(sp)          ; stack access
    0x8401316a     0x4    sd s0,64(sp)          ; stack access
    0x8401316c     0x6    sd s1,56(sp)          ; stack access
    0x8401316e     0x8    sd s2,48(sp)          ; stack access
    0x84013170     0xa    sd s3,40(sp)          ; stack access
    0x84013172     0xc    mv s0,a2
    0x84013174     0xe    li a5,25
    0x84013176    0x10    bne a0,a5,ffffffff8401321a <decodeIRQControlInvocation+0xb4>
    0x8401317a    0x14    li a5,2
    0x8401317c    0x16    bgeu a5,a1,ffffffff840131cc <decodeIRQControlInvocation+0x66>
    0x84013180    0x1a    auipc a5,0xb
    0x84013184    0x1e    ld a5,-1280(a5) # ffffffff8401dc80 <current_extra_caps>
    0x84013188    0x22    beqz a5,ffffffff840131cc <decodeIRQControlInvocation+0x66>
    0x8401318a    0x24    auipc a4,0x1c
    0x8401318e    0x28    ld a4,-1778(a4) # ffffffff8402ea98 <ksCurThread>
    0x84013192    0x2c    ld s1,88(a4)
    0x84013194    0x2e    ld s2,96(a4)
    0x84013198    0x32    ld s3,104(a4)
    0x8401319c    0x36    ld a4,0(a5)
    0x8401319e    0x38    sd a4,0(sp)           ; stack access
    0x840131a0    0x3a    ld a5,8(a5)
    0x840131a2    0x3c    sd a5,8(sp)           ; stack access
    0x840131a4    0x3e    mv a0,s1
    0x840131a6    0x40    jal ra,ffffffff84011602 <Arch_checkIRQ>
    0x840131aa    0x44    bnez a0,ffffffff840131d8 <decodeIRQControlInvocation+0x72>
    0x840131ac    0x46    slli a4,s1,0x3
    0x840131b0    0x4a    auipc a5,0xb
    0x840131b4    0x4e    addi a5,a5,-1304 # ffffffff8401dc98 <intStateIRQTable>
    0x840131b8    0x52    add a5,a5,a4
    0x840131ba    0x54    ld a5,0(a5)
    0x840131bc    0x56    beqz a5,ffffffff840131e6 <decodeIRQControlInvocation+0x80>
    0x840131be    0x58    li a5,9
    0x840131c0    0x5a    auipc a4,0xb
    0x840131c4    0x5e    sd a5,-1352(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840131c8    0x62    li a0,3
    0x840131ca    0x64    j ffffffff840131d8 <decodeIRQControlInvocation+0x72>
    0x840131cc    0x66    li a5,7
    0x840131ce    0x68    auipc a4,0xb
    0x840131d2    0x6c    sd a5,-1366(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840131d6    0x70    li a0,3
    0x840131d8    0x72    ld ra,72(sp)          ; stack access
    0x840131da    0x74    ld s0,64(sp)          ; stack access
    0x840131dc    0x76    ld s1,56(sp)          ; stack access
    0x840131de    0x78    ld s2,48(sp)          ; stack access
    0x840131e0    0x7a    ld s3,40(sp)          ; stack access
    0x840131e2    0x7c    addi sp,sp,80
    0x840131e4    0x7e    ret
    0x840131e6    0x80    mv a3,s3
    0x840131e8    0x82    mv a2,s2
    0x840131ea    0x84    ld a0,0(sp)           ; stack access
    0x840131ec    0x86    ld a1,8(sp)           ; stack access
    0x840131ee    0x88    jal ra,ffffffff84011d7a <lookupTargetSlot>
    0x840131f2    0x8c    sd a1,24(sp)          ; stack access
    0x840131f4    0x8e    bnez a0,ffffffff840131d8 <decodeIRQControlInvocation+0x72>
    0x840131f6    0x90    mv s2,a1
    0x840131f8    0x92    mv a0,a1
    0x840131fa    0x94    jal ra,ffffffff8401225c <ensureEmptySlot>
    0x840131fe    0x98    bnez a0,ffffffff840131d8 <decodeIRQControlInvocation+0x72>
    0x84013200    0x9a    li a1,2
    0x84013202    0x9c    auipc a0,0x1c
    0x84013206    0xa0    ld a0,-1898(a0) # ffffffff8402ea98 <ksCurThread>
    0x8401320a    0xa4    jal ra,ffffffff84013020 <setThreadState>
    0x8401320e    0xa8    mv a2,s0
    0x84013210    0xaa    mv a1,s2
    0x84013212    0xac    mv a0,s1
    0x84013214    0xae    jal ra,ffffffff840123a2 <invokeIRQControl>
    0x84013218    0xb2    j ffffffff840131d8 <decodeIRQControlInvocation+0x72>
    0x8401321a    0xb4    jal ra,ffffffff8401303e <Arch_decodeIRQControlInvocation>
    0x8401321e    0xb8    j ffffffff840131d8 <decodeIRQControlInvocation+0x72>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
70 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeIRQControlInvocation` has 117 nodes.

Section isMDBParentOf (380 of 432)
==================================

Deriving specifications
-----------------------

Section `isMDBParentOf` consists of 65 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `isMDBParentOf`:

    0x84012908     0x0    addi sp,sp,-32
    0x8401290a     0x2    sd ra,24(sp)          ; stack access
    0x8401290c     0x4    sd s0,16(sp)          ; stack access
    0x8401290e     0x6    sd s1,8(sp)           ; stack access
    0x84012910     0x8    mv s0,a0
    0x84012912     0xa    mv s1,a1
    0x84012914     0xc    ld a0,16(a0)
    0x84012916     0xe    ld a1,24(s0)
    0x84012918    0x10    jal ra,ffffffff840101be <mdb_node_get_mdbRevocable>
    0x8401291c    0x14    beqz a0,ffffffff84012942 <isMDBParentOf+0x3a>
    0x8401291e    0x16    ld a2,0(s1)
    0x84012920    0x18    ld a3,8(s1)
    0x84012922    0x1a    ld a0,0(s0)
    0x84012924    0x1c    ld a1,8(s0)
    0x84012926    0x1e    jal ra,ffffffff840125de <sameRegionAs>
    0x8401292a    0x22    beqz a0,ffffffff84012942 <isMDBParentOf+0x3a>
    0x8401292c    0x24    ld a0,0(s0)
    0x8401292e    0x26    ld a1,8(s0)
    0x84012930    0x28    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012934    0x2c    li a5,4
    0x84012936    0x2e    beq a0,a5,ffffffff8401294c <isMDBParentOf+0x44>
    0x8401293a    0x32    li a5,6
    0x8401293c    0x34    beq a0,a5,ffffffff8401297a <isMDBParentOf+0x72>
    0x84012940    0x38    li a0,1
    0x84012942    0x3a    ld ra,24(sp)          ; stack access
    0x84012944    0x3c    ld s0,16(sp)          ; stack access
    0x84012946    0x3e    ld s1,8(sp)           ; stack access
    0x84012948    0x40    addi sp,sp,32
    0x8401294a    0x42    ret
    0x8401294c    0x44    ld a0,0(s0)
    0x8401294e    0x46    ld a1,8(s0)
    0x84012950    0x48    jal ra,ffffffff84010446 <cap_endpoint_cap_get_capEPBadge>
    0x84012954    0x4c    mv s0,a0
    0x84012956    0x4e    li a0,1
    0x84012958    0x50    beqz s0,ffffffff84012942 <isMDBParentOf+0x3a>
    0x8401295a    0x52    ld a0,0(s1)
    0x8401295c    0x54    ld a1,8(s1)
    0x8401295e    0x56    jal ra,ffffffff84010446 <cap_endpoint_cap_get_capEPBadge>
    0x84012962    0x5a    li a5,0
    0x84012964    0x5c    beq a0,s0,ffffffff8401296c <isMDBParentOf+0x64>
    0x84012968    0x60    mv a0,a5
    0x8401296a    0x62    j ffffffff84012942 <isMDBParentOf+0x3a>
    0x8401296c    0x64    ld a0,16(s1)
    0x8401296e    0x66    ld a1,24(s1)
    0x84012970    0x68    jal ra,ffffffff840101e6 <mdb_node_get_mdbFirstBadged>
    0x84012974    0x6c    seqz a5,a0
    0x84012978    0x70    j ffffffff84012968 <isMDBParentOf+0x60>
    0x8401297a    0x72    ld a0,0(s0)
    0x8401297c    0x74    ld a1,8(s0)
    0x8401297e    0x76    jal ra,ffffffff840104f0 <cap_notification_cap_get_capNtfnBadge>
    0x84012982    0x7a    mv s0,a0
    0x84012984    0x7c    li a0,1
    0x84012986    0x7e    beqz s0,ffffffff84012942 <isMDBParentOf+0x3a>
    0x84012988    0x80    ld a0,0(s1)
    0x8401298a    0x82    ld a1,8(s1)
    0x8401298c    0x84    jal ra,ffffffff840104f0 <cap_notification_cap_get_capNtfnBadge>
    0x84012990    0x88    li a5,0
    0x84012992    0x8a    beq a0,s0,ffffffff8401299a <isMDBParentOf+0x92>
    0x84012996    0x8e    mv a0,a5
    0x84012998    0x90    j ffffffff84012942 <isMDBParentOf+0x3a>
    0x8401299a    0x92    ld a0,16(s1)
    0x8401299c    0x94    ld a1,24(s1)
    0x8401299e    0x96    jal ra,ffffffff840101e6 <mdb_node_get_mdbFirstBadged>
    0x840129a2    0x9a    seqz a5,a0
    0x840129a6    0x9e    j ffffffff84012996 <isMDBParentOf+0x8e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
65 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isMDBParentOf` has 117 nodes.

Section cteMove (381 of 432)
============================

Deriving specifications
-----------------------

Section `cteMove` consists of 49 instructions.


Stack analysis
---------------

14 stack accesses found. Annotated code for `cteMove`:

    0x84011fd0     0x0    addi sp,sp,-80
    0x84011fd2     0x2    sd ra,72(sp)          ; stack access
    0x84011fd4     0x4    sd s0,64(sp)          ; stack access
    0x84011fd6     0x6    sd s1,56(sp)          ; stack access
    0x84011fd8     0x8    sd s2,48(sp)          ; stack access
    0x84011fda     0xa    sd s3,40(sp)          ; stack access
    0x84011fdc     0xc    mv s0,a2
    0x84011fde     0xe    mv s1,a3
    0x84011fe0    0x10    ld s3,16(a2)
    0x84011fe4    0x14    sd s3,16(sp)          ; stack access
    0x84011fe6    0x16    ld s2,24(a2)
    0x84011fea    0x1a    sd s2,24(sp)          ; stack access
    0x84011fec    0x1c    sd a0,0(a3)
    0x84011fee    0x1e    sd a1,8(a3)
    0x84011ff0    0x20    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84011ff4    0x24    sd a0,0(s0)
    0x84011ff6    0x26    sd a1,8(s0)
    0x84011ff8    0x28    sd s3,16(s1)
    0x84011ffc    0x2c    sd s2,24(s1)
    0x84012000    0x30    li a3,0
    0x84012002    0x32    li a2,0
    0x84012004    0x34    li a1,0
    0x84012006    0x36    li a0,0
    0x84012008    0x38    jal ra,ffffffff8401018a <mdb_node_new>
    0x8401200c    0x3c    sd a0,16(s0)
    0x8401200e    0x3e    sd a1,24(s0)
    0x84012010    0x40    mv a0,s3
    0x84012012    0x42    mv a1,s2
    0x84012014    0x44    jal ra,ffffffff84010208 <mdb_node_get_mdbPrev>
    0x84012018    0x48    bnez a0,ffffffff84012032 <cteMove+0x62>
    0x8401201a    0x4a    ld a0,16(sp)          ; stack access
    0x8401201c    0x4c    ld a1,24(sp)          ; stack access
    0x8401201e    0x4e    jal ra,ffffffff84010b08 <mdb_node_get_mdbNext>
    0x84012022    0x52    bnez a0,ffffffff8401203c <cteMove+0x6c>
    0x84012024    0x54    ld ra,72(sp)          ; stack access
    0x84012026    0x56    ld s0,64(sp)          ; stack access
    0x84012028    0x58    ld s1,56(sp)          ; stack access
    0x8401202a    0x5a    ld s2,48(sp)          ; stack access
    0x8401202c    0x5c    ld s3,40(sp)          ; stack access
    0x8401202e    0x5e    addi sp,sp,80
    0x84012030    0x60    ret
    0x84012032    0x62    mv a1,s1
    0x84012034    0x64    addi a0,a0,16
    0x84012036    0x66    jal ra,ffffffff840101a6 <mdb_node_ptr_set_mdbNext>
    0x8401203a    0x6a    j ffffffff8401201a <cteMove+0x4a>
    0x8401203c    0x6c    mv a1,s1
    0x8401203e    0x6e    addi a0,a0,16
    0x84012040    0x70    jal ra,ffffffff84010216 <mdb_node_ptr_set_mdbPrev>
    0x84012044    0x74    j ffffffff84012024 <cteMove+0x54>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
49 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteMove` has 84 nodes.

Section Arch_sameRegionAs (382 of 432)
======================================

Deriving specifications
-----------------------

Section `Arch_sameRegionAs` consists of 125 instructions.


Stack analysis
---------------

36 stack accesses found. Annotated code for `Arch_sameRegionAs`:

    0x84011804      0x0    addi sp,sp,-64
    0x84011806      0x2    sd ra,56(sp)          ; stack access
    0x84011808      0x4    sd s0,48(sp)          ; stack access
    0x8401180a      0x6    sd s1,40(sp)          ; stack access
    0x8401180c      0x8    sd s2,32(sp)          ; stack access
    0x8401180e      0xa    sd a0,16(sp)          ; stack access
    0x84011810      0xc    sd a1,24(sp)          ; stack access
    0x84011812      0xe    sd a2,0(sp)           ; stack access
    0x84011814     0x10    sd a3,8(sp)           ; stack access
    0x84011816     0x12    jal ra,ffffffff8401039e <cap_get_capType>
    0x8401181a     0x16    li a5,11
    0x8401181c     0x18    beq a0,a5,ffffffff8401193c <Arch_sameRegionAs+0x138>
    0x84011820     0x1c    bltu a5,a0,ffffffff84011862 <Arch_sameRegionAs+0x5e>
    0x84011824     0x20    li a5,1
    0x84011826     0x22    beq a0,a5,ffffffff840118a4 <Arch_sameRegionAs+0xa0>
    0x8401182a     0x26    li a5,3
    0x8401182c     0x28    bne a0,a5,ffffffff8401185e <Arch_sameRegionAs+0x5a>
    0x84011830     0x2c    ld a0,0(sp)           ; stack access
    0x84011832     0x2e    ld a1,8(sp)           ; stack access
    0x84011834     0x30    jal ra,ffffffff8401039e <cap_get_capType>
    0x84011838     0x34    mv a4,a0
    0x8401183a     0x36    li a5,3
    0x8401183c     0x38    li a0,0
    0x8401183e     0x3a    bne a4,a5,ffffffff84011898 <Arch_sameRegionAs+0x94>
    0x84011842     0x3e    ld a0,16(sp)          ; stack access
    0x84011844     0x40    ld a1,24(sp)          ; stack access
    0x84011846     0x42    jal ra,ffffffff84010a76 <cap_page_table_cap_get_capPTBasePtr>
    0x8401184a     0x46    mv s0,a0
    0x8401184c     0x48    ld a0,0(sp)           ; stack access
    0x8401184e     0x4a    ld a1,8(sp)           ; stack access
    0x84011850     0x4c    jal ra,ffffffff84010a76 <cap_page_table_cap_get_capPTBasePtr>
    0x84011854     0x50    sub a0,s0,a0
    0x84011858     0x54    seqz a0,a0
    0x8401185c     0x58    j ffffffff84011898 <Arch_sameRegionAs+0x94>
    0x8401185e     0x5a    li a0,0
    0x84011860     0x5c    j ffffffff84011898 <Arch_sameRegionAs+0x94>
    0x84011862     0x5e    li a5,13
    0x84011864     0x60    bne a0,a5,ffffffff84011896 <Arch_sameRegionAs+0x92>
    0x84011868     0x64    ld a0,0(sp)           ; stack access
    0x8401186a     0x66    ld a1,8(sp)           ; stack access
    0x8401186c     0x68    jal ra,ffffffff8401039e <cap_get_capType>
    0x84011870     0x6c    mv a4,a0
    0x84011872     0x6e    li a5,13
    0x84011874     0x70    li a0,0
    0x84011876     0x72    bne a4,a5,ffffffff84011898 <Arch_sameRegionAs+0x94>
    0x8401187a     0x76    ld a0,16(sp)          ; stack access
    0x8401187c     0x78    ld a1,24(sp)          ; stack access
    0x8401187e     0x7a    jal ra,ffffffff84010a92 <cap_asid_pool_cap_get_capASIDPool>
    0x84011882     0x7e    mv s0,a0
    0x84011884     0x80    ld a0,0(sp)           ; stack access
    0x84011886     0x82    ld a1,8(sp)           ; stack access
    0x84011888     0x84    jal ra,ffffffff84010a92 <cap_asid_pool_cap_get_capASIDPool>
    0x8401188c     0x88    sub a0,s0,a0
    0x84011890     0x8c    seqz a0,a0
    0x84011894     0x90    j ffffffff84011898 <Arch_sameRegionAs+0x94>
    0x84011896     0x92    li a0,0
    0x84011898     0x94    ld ra,56(sp)          ; stack access
    0x8401189a     0x96    ld s0,48(sp)          ; stack access
    0x8401189c     0x98    ld s1,40(sp)          ; stack access
    0x8401189e     0x9a    ld s2,32(sp)          ; stack access
    0x840118a0     0x9c    addi sp,sp,64
    0x840118a2     0x9e    ret
    0x840118a4     0xa0    ld a0,0(sp)           ; stack access
    0x840118a6     0xa2    ld a1,8(sp)           ; stack access
    0x840118a8     0xa4    jal ra,ffffffff8401039e <cap_get_capType>
    0x840118ac     0xa8    mv a4,a0
    0x840118ae     0xaa    li a5,1
    0x840118b0     0xac    li a0,0
    0x840118b2     0xae    bne a4,a5,ffffffff84011898 <Arch_sameRegionAs+0x94>
    0x840118b6     0xb2    ld a0,16(sp)          ; stack access
    0x840118b8     0xb4    ld a1,24(sp)          ; stack access
    0x840118ba     0xb6    jal ra,ffffffff84010a5a <cap_frame_cap_get_capFBasePtr>
    0x840118be     0xba    mv s1,a0
    0x840118c0     0xbc    ld a0,0(sp)           ; stack access
    0x840118c2     0xbe    ld a1,8(sp)           ; stack access
    0x840118c4     0xc0    jal ra,ffffffff84010a5a <cap_frame_cap_get_capFBasePtr>
    0x840118c8     0xc4    mv s0,a0
    0x840118ca     0xc6    ld a0,16(sp)          ; stack access
    0x840118cc     0xc8    ld a1,24(sp)          ; stack access
    0x840118ce     0xca    jal ra,ffffffff840106a8 <cap_frame_cap_get_capFSize>
    0x840118d2     0xce    li a4,1
    0x840118d4     0xd0    beq a0,a4,ffffffff840118e4 <Arch_sameRegionAs+0xe0>
    0x840118d8     0xd4    li a4,2
    0x840118da     0xd6    beq a0,a4,ffffffff840118e8 <Arch_sameRegionAs+0xe4>
    0x840118de     0xda    beqz a0,ffffffff84011904 <Arch_sameRegionAs+0x100>
    0x840118e0     0xdc    jal ra,ffffffff84010cec <halt>
    0x840118e4     0xe0    li s2,21
    0x840118e6     0xe2    j ffffffff840118ea <Arch_sameRegionAs+0xe6>
    0x840118e8     0xe4    li s2,30
    0x840118ea     0xe6    ld a0,0(sp)           ; stack access
    0x840118ec     0xe8    ld a1,8(sp)           ; stack access
    0x840118ee     0xea    jal ra,ffffffff840106a8 <cap_frame_cap_get_capFSize>
    0x840118f2     0xee    li a4,1
    0x840118f4     0xf0    beq a0,a4,ffffffff84011908 <Arch_sameRegionAs+0x104>
    0x840118f8     0xf4    li a4,2
    0x840118fa     0xf6    beq a0,a4,ffffffff8401190c <Arch_sameRegionAs+0x108>
    0x840118fe     0xfa    beqz a0,ffffffff84011938 <Arch_sameRegionAs+0x134>
    0x84011900     0xfc    jal ra,ffffffff84010cec <halt>
    0x84011904    0x100    li s2,12
    0x84011906    0x102    j ffffffff840118ea <Arch_sameRegionAs+0xe6>
    0x84011908    0x104    li a5,21
    0x8401190a    0x106    j ffffffff8401190e <Arch_sameRegionAs+0x10a>
    0x8401190c    0x108    li a5,30
    0x8401190e    0x10a    li a0,0
    0x84011910    0x10c    bltu s0,s1,ffffffff84011898 <Arch_sameRegionAs+0x94>
    0x84011914    0x110    li a4,1
    0x84011916    0x112    sll a5,a4,a5
    0x8401191a    0x116    addi a3,s0,-1
    0x8401191e    0x11a    add a5,a5,a3
    0x84011920    0x11c    sll a4,a4,s2
    0x84011924    0x120    addi s1,s1,-1
    0x84011926    0x122    add a4,a4,s1
    0x84011928    0x124    bltu a4,a5,ffffffff84011898 <Arch_sameRegionAs+0x94>
    0x8401192c    0x128    sltu a0,a5,s0
    0x84011930    0x12c    xori a0,a0,1
    0x84011934    0x130    sext.w a0,a0
    0x84011936    0x132    j ffffffff84011898 <Arch_sameRegionAs+0x94>
    0x84011938    0x134    li a5,12
    0x8401193a    0x136    j ffffffff8401190e <Arch_sameRegionAs+0x10a>
    0x8401193c    0x138    ld a0,0(sp)           ; stack access
    0x8401193e    0x13a    ld a1,8(sp)           ; stack access
    0x84011940    0x13c    jal ra,ffffffff8401039e <cap_get_capType>
    0x84011944    0x140    addi a0,a0,-11
    0x84011946    0x142    seqz a0,a0
    0x8401194a    0x146    j ffffffff84011898 <Arch_sameRegionAs+0x94>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
125 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_sameRegionAs` has 209 nodes.

Section Arch_deriveCap (383 of 432)
===================================

Deriving specifications
-----------------------

Section `Arch_deriveCap` consists of 59 instructions.


Stack analysis
---------------

Section `Arch_deriveCap` expects pointer to stack in a0.
27 stack accesses found. Annotated code for `Arch_deriveCap`:

    0x8401162a     0x0    addi sp,sp,-48
    0x8401162c     0x2    sd ra,40(sp)          ; stack access
    0x8401162e     0x4    sd s0,32(sp)          ; stack access
    0x84011630     0x6    sd s1,24(sp)          ; stack access
    0x84011632     0x8    mv s1,a0
    0x84011634     0xa    sd a2,0(sp)           ; stack access
    0x84011636     0xc    sd a3,8(sp)           ; stack access
    0x84011638     0xe    mv a0,a2
    0x8401163a    0x10    mv a1,a3
    0x8401163c    0x12    jal ra,ffffffff8401039e <cap_get_capType>
    0x84011640    0x16    mv s0,a0
    0x84011642    0x18    li a5,3
    0x84011644    0x1a    beq a0,a5,ffffffff84011678 <Arch_deriveCap+0x4e>
    0x84011648    0x1e    bgeu a5,a0,ffffffff84011658 <Arch_deriveCap+0x2e>
    0x8401164c    0x22    addi s0,a0,-11
    0x84011650    0x26    andi s0,s0,-3
    0x84011652    0x28    beqz s0,ffffffff840116ae <Arch_deriveCap+0x84>
    0x84011654    0x2a    jal ra,ffffffff84010cec <halt>
    0x84011658    0x2e    li a5,1
    0x8401165a    0x30    bne a0,a5,ffffffff84011654 <Arch_deriveCap+0x2a>
    0x8401165e    0x34    li a2,0
    0x84011660    0x36    ld a0,0(sp)           ; stack access
    0x84011662    0x38    ld a1,8(sp)           ; stack access
    0x84011664    0x3a    jal ra,ffffffff840106da <cap_frame_cap_set_capFMappedAddress>
    0x84011668    0x3e    li a2,0
    0x8401166a    0x40    jal ra,ffffffff8401069a <cap_frame_cap_set_capFMappedASID>
    0x8401166e    0x44    sd a0,8(s1)           ; stack access
    0x84011670    0x46    sd a1,16(s1)          ; stack access
    0x84011672    0x48    sd zero,0(s1)         ; stack access
    0x84011676    0x4c    j ffffffff8401168e <Arch_deriveCap+0x64>
    0x84011678    0x4e    ld a0,0(sp)           ; stack access
    0x8401167a    0x50    ld a1,8(sp)           ; stack access
    0x8401167c    0x52    jal ra,ffffffff8401072c <cap_page_table_cap_get_capPTIsMapped>
    0x84011680    0x56    beqz a0,ffffffff8401169a <Arch_deriveCap+0x70>
    0x84011682    0x58    ld a5,0(sp)           ; stack access
    0x84011684    0x5a    sd a5,8(s1)           ; stack access
    0x84011686    0x5c    ld a5,8(sp)           ; stack access
    0x84011688    0x5e    sd a5,16(s1)          ; stack access
    0x8401168a    0x60    li s0,0
    0x8401168c    0x62    sd s0,0(s1)           ; stack access
    0x8401168e    0x64    mv a0,s1
    0x84011690    0x66    ld ra,40(sp)          ; stack access
    0x84011692    0x68    ld s0,32(sp)          ; stack access
    0x84011694    0x6a    ld s1,24(sp)          ; stack access
    0x84011696    0x6c    addi sp,sp,48
    0x84011698    0x6e    ret
    0x8401169a    0x70    li a5,3
    0x8401169c    0x72    auipc a4,0xc
    0x840116a0    0x76    sd a5,1500(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840116a4    0x7a    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x840116a8    0x7e    sd a0,8(s1)           ; stack access
    0x840116aa    0x80    sd a1,16(s1)          ; stack access
    0x840116ac    0x82    j ffffffff8401168c <Arch_deriveCap+0x62>
    0x840116ae    0x84    ld a5,0(sp)           ; stack access
    0x840116b0    0x86    sd a5,8(s1)           ; stack access
    0x840116b2    0x88    ld a5,8(sp)           ; stack access
    0x840116b4    0x8a    sd a5,16(s1)          ; stack access
    0x840116b6    0x8c    sd zero,0(s1)         ; stack access
    0x840116ba    0x90    j ffffffff8401168e <Arch_deriveCap+0x64>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
59 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_deriveCap` has 104 nodes.

Section handleFaultReply (384 of 432)
=====================================

Deriving specifications
-----------------------

Section `handleFaultReply` consists of 138 instructions.


Stack analysis
---------------

14 stack accesses found. Annotated code for `handleFaultReply`:

    0x84010faa      0x0    addi sp,sp,-64
    0x84010fac      0x2    sd ra,56(sp)          ; stack access
    0x84010fae      0x4    sd s0,48(sp)          ; stack access
    0x84010fb0      0x6    sd s1,40(sp)          ; stack access
    0x84010fb2      0x8    sd s2,32(sp)          ; stack access
    0x84010fb4      0xa    sd s3,24(sp)          ; stack access
    0x84010fb6      0xc    sd s4,16(sp)          ; stack access
    0x84010fb8      0xe    mv s0,a0
    0x84010fba     0x10    mv s2,a1
    0x84010fbc     0x12    ld s1,80(a1)
    0x84010fbe     0x14    mv a0,s1
    0x84010fc0     0x16    jal ra,ffffffff84010146 <seL4_MessageInfo_get_length>
    0x84010fc4     0x1a    li a5,120
    0x84010fc8     0x1e    bgeu a5,a0,ffffffff84010fd8 <handleFaultReply+0x2e>
    0x84010fcc     0x22    li a1,120
    0x84010fd0     0x26    mv a0,s1
    0x84010fd2     0x28    jal ra,ffffffff8401014c <seL4_MessageInfo_set_length>
    0x84010fd6     0x2c    mv s1,a0
    0x84010fd8     0x2e    mv a0,s1
    0x84010fda     0x30    jal ra,ffffffff84010112 <seL4_MessageInfo_get_label>
    0x84010fde     0x34    mv s3,a0
    0x84010fe0     0x36    mv a0,s1
    0x84010fe2     0x38    jal ra,ffffffff84010146 <seL4_MessageInfo_get_length>
    0x84010fe6     0x3c    mv s1,a0
    0x84010fe8     0x3e    ld a0,312(s0)
    0x84010fec     0x42    sd a0,0(sp)           ; stack access
    0x84010fee     0x44    ld a1,320(s0)
    0x84010ff2     0x48    sd a1,8(sp)           ; stack access
    0x84010ff4     0x4a    jal ra,ffffffff8401084a <seL4_Fault_get_seL4_FaultType>
    0x84010ff8     0x4e    li a5,2
    0x84010ffa     0x50    beq a0,a5,ffffffff84011014 <handleFaultReply+0x6a>
    0x84010ffe     0x54    li a5,3
    0x84011000     0x56    beq a0,a5,ffffffff840110a6 <handleFaultReply+0xfc>
    0x84011004     0x5a    li a5,1
    0x84011006     0x5c    beq a0,a5,ffffffff84011096 <handleFaultReply+0xec>
    0x8401100a     0x60    li a5,5
    0x8401100c     0x62    bne a0,a5,ffffffff84011112 <handleFaultReply+0x168>
    0x84011010     0x66    li a0,1
    0x84011012     0x68    j ffffffff84011096 <handleFaultReply+0xec>
    0x84011014     0x6a    mv s4,s1
    0x84011016     0x6c    li a5,10
    0x84011018     0x6e    bgeu a5,s1,ffffffff8401101e <handleFaultReply+0x74>
    0x8401101c     0x72    li s4,10
    0x8401101e     0x74    mv a0,s4
    0x84011020     0x76    li a5,4
    0x84011022     0x78    bgeu a5,s4,ffffffff84011028 <handleFaultReply+0x7e>
    0x84011026     0x7c    li a0,4
    0x84011028     0x7e    beqz s1,ffffffff84011092 <handleFaultReply+0xe8>
    0x8401102a     0x80    auipc a1,0x7
    0x8401102e     0x84    addi a1,a1,678 # ffffffff840182d0 <fault_messages>
    0x84011032     0x88    auipc a2,0x7
    0x84011036     0x8c    addi a2,a2,830 # ffffffff84018370 <msgRegisters>
    0x8401103a     0x90    li a3,0
    0x8401103c     0x92    ld a5,0(a1)
    0x8401103e     0x94    ld a4,0(a2)
    0x84011040     0x96    slli a4,a4,0x3
    0x84011042     0x98    add a4,a4,s2
    0x84011044     0x9a    ld a4,0(a4)
    0x84011046     0x9c    slli a5,a5,0x3
    0x84011048     0x9e    add a5,a5,s0
    0x8401104a     0xa0    sd a4,0(a5)
    0x8401104c     0xa2    addi a3,a3,1
    0x8401104e     0xa4    addi a1,a1,8
    0x84011050     0xa6    addi a2,a2,8
    0x84011052     0xa8    bltu a3,a0,ffffffff8401103c <handleFaultReply+0x92>
    0x84011056     0xac    li a4,1
    0x84011058     0xae    beqz s1,ffffffff8401105c <handleFaultReply+0xb2>
    0x8401105a     0xb0    mv a4,a0
    0x8401105c     0xb2    mv s1,a4
    0x8401105e     0xb4    bgeu a4,s4,ffffffff84011092 <handleFaultReply+0xe8>
    0x84011062     0xb8    mv a1,s2
    0x84011064     0xba    li a0,0
    0x84011066     0xbc    jal ra,ffffffff84010f0e <lookupIPCBuffer>
    0x8401106a     0xc0    beqz a0,ffffffff84011092 <handleFaultReply+0xe8>
    0x8401106c     0xc2    slli a4,s1,0x3
    0x84011070     0xc6    auipc a3,0x7
    0x84011074     0xca    addi a3,a3,608 # ffffffff840182d0 <fault_messages>
    0x84011078     0xce    add a3,a3,a4
    0x8401107a     0xd0    add a4,a4,a0
    0x8401107c     0xd2    slli s4,s4,0x3
    0x8401107e     0xd4    add s4,s4,a0
    0x84011080     0xd6    ld a5,0(a3)
    0x84011082     0xd8    ld a2,8(a4)
    0x84011084     0xda    slli a5,a5,0x3
    0x84011086     0xdc    add a5,a5,s0
    0x84011088     0xde    sd a2,0(a5)
    0x8401108a     0xe0    addi a3,a3,8
    0x8401108c     0xe2    addi a4,a4,8
    0x8401108e     0xe4    bne a4,s4,ffffffff84011080 <handleFaultReply+0xd6>
    0x84011092     0xe8    seqz a0,s3
    0x84011096     0xec    ld ra,56(sp)          ; stack access
    0x84011098     0xee    ld s0,48(sp)          ; stack access
    0x8401109a     0xf0    ld s1,40(sp)          ; stack access
    0x8401109c     0xf2    ld s2,32(sp)          ; stack access
    0x8401109e     0xf4    ld s3,24(sp)          ; stack access
    0x840110a0     0xf6    ld s4,16(sp)          ; stack access
    0x840110a2     0xf8    addi sp,sp,64
    0x840110a4     0xfa    ret
    0x840110a6     0xfc    mv s4,s1
    0x840110a8     0xfe    li a5,2
    0x840110aa    0x100    bgeu a5,s1,ffffffff840110b0 <handleFaultReply+0x106>
    0x840110ae    0x104    li s4,2
    0x840110b0    0x106    mv a4,s4
    0x840110b2    0x108    li a5,4
    0x840110b4    0x10a    bgeu a5,s4,ffffffff840110ba <handleFaultReply+0x110>
    0x840110b8    0x10e    li a4,4
    0x840110ba    0x110    beqz s1,ffffffff8401110c <handleFaultReply+0x162>
    0x840110bc    0x112    ld a5,88(s2)
    0x840110c0    0x116    sd a5,264(s0)
    0x840110c4    0x11a    li a5,1
    0x840110c6    0x11c    bgeu a5,s1,ffffffff840110d0 <handleFaultReply+0x126>
    0x840110ca    0x120    ld a5,96(s2)
    0x840110ce    0x124    sd a5,8(s0)
    0x840110d0    0x126    li a5,1
    0x840110d2    0x128    beqz s1,ffffffff840110d6 <handleFaultReply+0x12c>
    0x840110d4    0x12a    mv a5,a4
    0x840110d6    0x12c    mv s1,a5
    0x840110d8    0x12e    bgeu a5,s4,ffffffff8401110c <handleFaultReply+0x162>
    0x840110dc    0x132    mv a1,s2
    0x840110de    0x134    li a0,0
    0x840110e0    0x136    jal ra,ffffffff84010f0e <lookupIPCBuffer>
    0x840110e4    0x13a    beqz a0,ffffffff8401110c <handleFaultReply+0x162>
    0x840110e6    0x13c    slli a5,s1,0x3
    0x840110ea    0x140    slli s4,s4,0x3
    0x840110ec    0x142    auipc a2,0x7
    0x840110f0    0x146    addi a2,a2,484 # ffffffff840182d0 <fault_messages>
    0x840110f4    0x14a    add a4,a2,a5
    0x840110f8    0x14e    ld a4,80(a4)
    0x840110fa    0x150    add a3,a0,a5
    0x840110fe    0x154    ld a3,8(a3)
    0x84011100    0x156    slli a4,a4,0x3
    0x84011102    0x158    add a4,a4,s0
    0x84011104    0x15a    sd a3,0(a4)
    0x84011106    0x15c    addi a5,a5,8
    0x84011108    0x15e    bne a5,s4,ffffffff840110f4 <handleFaultReply+0x14a>
    0x8401110c    0x162    seqz a0,s3
    0x84011110    0x166    j ffffffff84011096 <handleFaultReply+0xec>
    0x84011112    0x168    jal ra,ffffffff84010cec <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
138 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleFaultReply` has 220 nodes.

Section lookupIPCBuffer (385 of 432)
====================================

Deriving specifications
-----------------------

Section `lookupIPCBuffer` consists of 62 instructions.


Stack analysis
---------------

16 stack accesses found. Annotated code for `lookupIPCBuffer`:

    0x84010f0e     0x0    addi sp,sp,-48
    0x84010f10     0x2    sd ra,40(sp)          ; stack access
    0x84010f12     0x4    sd s0,32(sp)          ; stack access
    0x84010f14     0x6    sd s1,24(sp)          ; stack access
    0x84010f16     0x8    mv s0,a0
    0x84010f18     0xa    ld s1,384(a1)
    0x84010f1c     0xe    andi a1,a1,-1024
    0x84010f20    0x12    ld a0,128(a1)
    0x84010f22    0x14    sd a0,0(sp)           ; stack access
    0x84010f24    0x16    ld a1,136(a1)
    0x84010f26    0x18    sd a1,8(sp)           ; stack access
    0x84010f28    0x1a    jal ra,ffffffff8401039e <cap_get_capType>
    0x84010f2c    0x1e    li a5,1
    0x84010f2e    0x20    bne a0,a5,ffffffff84010f9e <lookupIPCBuffer+0x90>
    0x84010f32    0x24    ld a0,0(sp)           ; stack access
    0x84010f34    0x26    ld a1,8(sp)           ; stack access
    0x84010f36    0x28    jal ra,ffffffff840106d0 <cap_frame_cap_get_capFIsDevice>
    0x84010f3a    0x2c    bnez a0,ffffffff84010fa2 <lookupIPCBuffer+0x94>
    0x84010f3c    0x2e    ld a0,0(sp)           ; stack access
    0x84010f3e    0x30    ld a1,8(sp)           ; stack access
    0x84010f40    0x32    jal ra,ffffffff840106b2 <cap_frame_cap_get_capFVMRights>
    0x84010f44    0x36    li a5,3
    0x84010f46    0x38    bne a0,a5,ffffffff84010f6e <lookupIPCBuffer+0x60>
    0x84010f4a    0x3c    ld a0,0(sp)           ; stack access
    0x84010f4c    0x3e    ld a1,8(sp)           ; stack access
    0x84010f4e    0x40    jal ra,ffffffff84010a5a <cap_frame_cap_get_capFBasePtr>
    0x84010f52    0x44    mv s0,a0
    0x84010f54    0x46    ld a0,0(sp)           ; stack access
    0x84010f56    0x48    ld a1,8(sp)           ; stack access
    0x84010f58    0x4a    jal ra,ffffffff840106a8 <cap_frame_cap_get_capFSize>
    0x84010f5c    0x4e    li a5,1
    0x84010f5e    0x50    beq a0,a5,ffffffff84010f7a <lookupIPCBuffer+0x6c>
    0x84010f62    0x54    li a5,2
    0x84010f64    0x56    beq a0,a5,ffffffff84010f7e <lookupIPCBuffer+0x70>
    0x84010f68    0x5a    beqz a0,ffffffff84010f9a <lookupIPCBuffer+0x8c>
    0x84010f6a    0x5c    jal ra,ffffffff84010cec <halt>
    0x84010f6e    0x60    bnez s0,ffffffff84010fa6 <lookupIPCBuffer+0x98>
    0x84010f70    0x62    li a5,2
    0x84010f72    0x64    beq a0,a5,ffffffff84010f4a <lookupIPCBuffer+0x3c>
    0x84010f76    0x68    li a0,0
    0x84010f78    0x6a    j ffffffff84010f90 <lookupIPCBuffer+0x82>
    0x84010f7a    0x6c    li a0,21
    0x84010f7c    0x6e    j ffffffff84010f80 <lookupIPCBuffer+0x72>
    0x84010f7e    0x70    li a0,30
    0x84010f80    0x72    li a5,-1
    0x84010f82    0x74    sll a5,a5,a0
    0x84010f86    0x78    not a5,a5
    0x84010f8a    0x7c    and a5,a5,s1
    0x84010f8c    0x7e    add a0,a5,s0
    0x84010f90    0x82    ld ra,40(sp)          ; stack access
    0x84010f92    0x84    ld s0,32(sp)          ; stack access
    0x84010f94    0x86    ld s1,24(sp)          ; stack access
    0x84010f96    0x88    addi sp,sp,48
    0x84010f98    0x8a    ret
    0x84010f9a    0x8c    li a0,12
    0x84010f9c    0x8e    j ffffffff84010f80 <lookupIPCBuffer+0x72>
    0x84010f9e    0x90    li a0,0
    0x84010fa0    0x92    j ffffffff84010f90 <lookupIPCBuffer+0x82>
    0x84010fa2    0x94    li a0,0
    0x84010fa4    0x96    j ffffffff84010f90 <lookupIPCBuffer+0x82>
    0x84010fa6    0x98    li a0,0
    0x84010fa8    0x9a    j ffffffff84010f90 <lookupIPCBuffer+0x82>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
62 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupIPCBuffer` has 104 nodes.

Section performPageTableInvocationUnmap (386 of 432)
====================================================

Deriving specifications
-----------------------

Section `performPageTableInvocationUnmap` consists of 39 instructions.


Stack analysis
---------------

16 stack accesses found. Annotated code for `performPageTableInvocationUnmap`:

    0x840164ee     0x0    addi sp,sp,-48
    0x840164f0     0x2    sd ra,40(sp)          ; stack access
    0x840164f2     0x4    sd s0,32(sp)          ; stack access
    0x840164f4     0x6    sd s1,24(sp)          ; stack access
    0x840164f6     0x8    sd s2,16(sp)          ; stack access
    0x840164f8     0xa    sd a0,0(sp)           ; stack access
    0x840164fa     0xc    sd a1,8(sp)           ; stack access
    0x840164fc     0xe    mv s0,a2
    0x840164fe    0x10    jal ra,ffffffff8401072c <cap_page_table_cap_get_capPTIsMapped>
    0x84016502    0x14    bnez a0,ffffffff8401651a <performPageTableInvocationUnmap+0x2c>
    0x84016504    0x16    li a1,0
    0x84016506    0x18    mv a0,s0
    0x84016508    0x1a    jal ra,ffffffff8401074a <cap_page_table_cap_ptr_set_capPTIsMapped>
    0x8401650c    0x1e    li a0,0
    0x8401650e    0x20    ld ra,40(sp)          ; stack access
    0x84016510    0x22    ld s0,32(sp)          ; stack access
    0x84016512    0x24    ld s1,24(sp)          ; stack access
    0x84016514    0x26    ld s2,16(sp)          ; stack access
    0x84016516    0x28    addi sp,sp,48
    0x84016518    0x2a    ret
    0x8401651a    0x2c    ld a0,0(sp)           ; stack access
    0x8401651c    0x2e    ld a1,8(sp)           ; stack access
    0x8401651e    0x30    jal ra,ffffffff84010a76 <cap_page_table_cap_get_capPTBasePtr>
    0x84016522    0x34    mv s1,a0
    0x84016524    0x36    ld a0,0(sp)           ; stack access
    0x84016526    0x38    ld a1,8(sp)           ; stack access
    0x84016528    0x3a    jal ra,ffffffff84010714 <cap_page_table_cap_get_capPTMappedASID>
    0x8401652c    0x3e    mv s2,a0
    0x8401652e    0x40    ld a0,0(sp)           ; stack access
    0x84016530    0x42    ld a1,8(sp)           ; stack access
    0x84016532    0x44    jal ra,ffffffff84010ab2 <cap_page_table_cap_get_capPTMappedAddress>
    0x84016536    0x48    mv a1,a0
    0x84016538    0x4a    mv a2,s1
    0x8401653a    0x4c    mv a0,s2
    0x8401653c    0x4e    jal ra,ffffffff840111fe <unmapPageTable>
    0x84016540    0x52    lui a1,0x1
    0x84016542    0x54    mv a0,s1
    0x84016544    0x56    jal ra,ffffffff840164dc <memzero>
    0x84016548    0x5a    j ffffffff84016504 <performPageTableInvocationUnmap+0x16>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
39 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performPageTableInvocationUnmap` has 65 nodes.

Section doReplyTransfer (387 of 432)
====================================

Deriving specifications
-----------------------

Section `doReplyTransfer` consists of 54 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `doReplyTransfer`:

    0x84014c5a     0x0    addi sp,sp,-48
    0x84014c5c     0x2    sd ra,40(sp)          ; stack access
    0x84014c5e     0x4    sd s0,32(sp)          ; stack access
    0x84014c60     0x6    sd s1,24(sp)          ; stack access
    0x84014c62     0x8    sd s2,16(sp)          ; stack access
    0x84014c64     0xa    sd s3,8(sp)           ; stack access
    0x84014c66     0xc    mv s1,a0
    0x84014c68     0xe    mv s0,a1
    0x84014c6a    0x10    mv s2,a2
    0x84014c6c    0x12    mv s3,a3
    0x84014c6e    0x14    ld a0,312(a1)
    0x84014c72    0x18    ld a1,320(a1)
    0x84014c76    0x1c    jal ra,ffffffff8401084a <seL4_Fault_get_seL4_FaultType>
    0x84014c7a    0x20    bnez a0,ffffffff84014cac <doReplyTransfer+0x52>
    0x84014c7c    0x22    mv a4,s0
    0x84014c7e    0x24    mv a3,s3
    0x84014c80    0x26    li a2,0
    0x84014c82    0x28    li a1,0
    0x84014c84    0x2a    mv a0,s1
    0x84014c86    0x2c    jal ra,ffffffff84014bf0 <doIPCTransfer>
    0x84014c8a    0x30    mv a0,s2
    0x84014c8c    0x32    jal ra,ffffffff840144d0 <cteDeleteOne>
    0x84014c90    0x36    li a1,1
    0x84014c92    0x38    mv a0,s0
    0x84014c94    0x3a    jal ra,ffffffff84013020 <setThreadState>
    0x84014c98    0x3e    mv a0,s0
    0x84014c9a    0x40    jal ra,ffffffff840132c6 <possibleSwitchTo>
    0x84014c9e    0x44    ld ra,40(sp)          ; stack access
    0x84014ca0    0x46    ld s0,32(sp)          ; stack access
    0x84014ca2    0x48    ld s1,24(sp)          ; stack access
    0x84014ca4    0x4a    ld s2,16(sp)          ; stack access
    0x84014ca6    0x4c    ld s3,8(sp)           ; stack access
    0x84014ca8    0x4e    addi sp,sp,48
    0x84014caa    0x50    ret
    0x84014cac    0x52    mv a0,s2
    0x84014cae    0x54    jal ra,ffffffff840144d0 <cteDeleteOne>
    0x84014cb2    0x58    mv a1,s1
    0x84014cb4    0x5a    mv a0,s0
    0x84014cb6    0x5c    jal ra,ffffffff84010faa <handleFaultReply>
    0x84014cba    0x60    mv s1,a0
    0x84014cbc    0x62    jal ra,ffffffff84010852 <seL4_Fault_NullFault_new>
    0x84014cc0    0x66    sd a0,312(s0)
    0x84014cc4    0x6a    sd a1,320(s0)
    0x84014cc8    0x6e    beqz s1,ffffffff84014cda <doReplyTransfer+0x80>
    0x84014cca    0x70    li a1,2
    0x84014ccc    0x72    mv a0,s0
    0x84014cce    0x74    jal ra,ffffffff84013020 <setThreadState>
    0x84014cd2    0x78    mv a0,s0
    0x84014cd4    0x7a    jal ra,ffffffff840132c6 <possibleSwitchTo>
    0x84014cd8    0x7e    j ffffffff84014c9e <doReplyTransfer+0x44>
    0x84014cda    0x80    li a1,0
    0x84014cdc    0x82    mv a0,s0
    0x84014cde    0x84    jal ra,ffffffff84013020 <setThreadState>
    0x84014ce2    0x88    j ffffffff84014c9e <doReplyTransfer+0x44>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
54 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doReplyTransfer` has 84 nodes.

Section handleInterrupt (388 of 432)
====================================

Deriving specifications
-----------------------

Section `handleInterrupt` consists of 95 instructions.

Skipping c01027f3 rdtime a5

Skipping 00000073 ecall

Skipping c0102773 rdtime a4

Skipping 1047b7f3 csrrc a5,sie,a5


Stack analysis
---------------

12 stack accesses found. Annotated code for `handleInterrupt`:

    0x84014780      0x0    li a5,54
    0x84014784      0x4    bltu a5,a0,ffffffff840147ee <handleInterrupt+0x6e>
    0x84014788      0x8    addi sp,sp,-32
    0x8401478a      0xa    sd ra,24(sp)          ; stack access
    0x8401478c      0xc    sd s0,16(sp)          ; stack access
    0x8401478e      0xe    slli a4,a0,0x3
    0x84014792     0x12    auipc a5,0x9
    0x84014796     0x16    addi a5,a5,1286 # ffffffff8401dc98 <intStateIRQTable>
    0x8401479a     0x1a    add a5,a5,a4
    0x8401479c     0x1c    ld a5,0(a5)
    0x8401479e     0x1e    li a4,2
    0x840147a0     0x20    beq a5,a4,ffffffff84014832 <handleInterrupt+0xb2>
    0x840147a4     0x24    bltu a4,a5,ffffffff8401481c <handleInterrupt+0x9c>
    0x840147a8     0x28    beqz a5,ffffffff84014854 <handleInterrupt+0xd4>
    0x840147aa     0x2a    slli a0,a0,0x5
    0x840147ac     0x2c    auipc a5,0x1a
    0x840147b0     0x30    addi a5,a5,-1964 # ffffffff8402e000 <intStateIRQNode>
    0x840147b4     0x34    add a5,a5,a0
    0x840147b6     0x36    ld a0,0(a5)
    0x840147b8     0x38    sd a0,0(sp)           ; stack access
    0x840147ba     0x3a    ld a1,8(a5)
    0x840147bc     0x3c    sd a1,8(sp)           ; stack access
    0x840147be     0x3e    jal ra,ffffffff8401039e <cap_get_capType>
    0x840147c2     0x42    li a5,6
    0x840147c4     0x44    bne a0,a5,ffffffff84014822 <handleInterrupt+0xa2>
    0x840147c8     0x48    ld a0,0(sp)           ; stack access
    0x840147ca     0x4a    ld a1,8(sp)           ; stack access
    0x840147cc     0x4c    jal ra,ffffffff8401051e <cap_notification_cap_get_capNtfnCanSend>
    0x840147d0     0x50    beqz a0,ffffffff84014822 <handleInterrupt+0xa2>
    0x840147d2     0x52    ld a0,0(sp)           ; stack access
    0x840147d4     0x54    ld a1,8(sp)           ; stack access
    0x840147d6     0x56    jal ra,ffffffff840109aa <cap_notification_cap_get_capNtfnPtr>
    0x840147da     0x5a    mv s0,a0
    0x840147dc     0x5c    ld a0,0(sp)           ; stack access
    0x840147de     0x5e    ld a1,8(sp)           ; stack access
    0x840147e0     0x60    jal ra,ffffffff840104f0 <cap_notification_cap_get_capNtfnBadge>
    0x840147e4     0x64    mv a1,a0
    0x840147e6     0x66    mv a0,s0
    0x840147e8     0x68    jal ra,ffffffff84014696 <sendSignal>
    0x840147ec     0x6c    j ffffffff84014822 <handleInterrupt+0xa2>
    0x840147ee     0x6e    srli a4,a0,0x5
    0x840147f2     0x72    slli a4,a4,0x2
    0x840147f4     0x74    lui a5,0xcc002
    0x840147f8     0x78    addi a5,a5,256 # ffffffffcc002100 <ki_end+0x47fd3100>
    0x840147fc     0x7c    add a4,a4,a5
    0x840147fe     0x7e    lw a3,0(a4)
    0x84014800     0x80    andi a0,a0,31
    0x84014802     0x82    li a5,1
    0x84014804     0x84    sll a0,a5,a0
    0x84014808     0x88    not a5,a0
    0x8401480c     0x8c    and a5,a5,a3
    0x8401480e     0x8e    sext.w a5,a5
    0x84014810     0x90    sw a5,0(a4)
    0x84014812     0x92    auipc a5,0x4
    0x84014816     0x96    sw zero,502(a5) # ffffffff84018a08 <active_irq>
    0x8401481a     0x9a    ret
    0x8401481c     0x9c    li a4,3
    0x8401481e     0x9e    bne a5,a4,ffffffff8401488c <handleInterrupt+0x10c>
    0x84014822     0xa2    auipc a5,0x4
    0x84014826     0xa6    sw zero,486(a5) # ffffffff84018a08 <active_irq>
    0x8401482a     0xaa    ld ra,24(sp)          ; stack access
    0x8401482c     0xac    ld s0,16(sp)          ; stack access
    0x8401482e     0xae    addi sp,sp,32
    0x84014830     0xb0    ret
    0x84014832     0xb2    jal ra,ffffffff84013466 <timerTick>
    0x84014836     0xb6    rdtime a5
    0x8401483a     0xba    addi a5,a5,2000
    0x8401483e     0xbe    mv a0,a5
    0x84014840     0xc0    li a1,0
    0x84014842     0xc2    li a2,0
    0x84014844     0xc4    li a7,0
    0x84014846     0xc6    ecall
    0x8401484a     0xca    rdtime a4
    0x8401484e     0xce    bltu a5,a4,ffffffff84014836 <handleInterrupt+0xb6>
    0x84014852     0xd2    j ffffffff84014822 <handleInterrupt+0xa2>
    0x84014854     0xd4    li a5,54
    0x84014858     0xd8    beq a0,a5,ffffffff84014882 <handleInterrupt+0x102>
    0x8401485c     0xdc    srli a4,a0,0x5
    0x84014860     0xe0    slli a4,a4,0x2
    0x84014862     0xe2    lui a5,0xcc002
    0x84014866     0xe6    addi a5,a5,256 # ffffffffcc002100 <ki_end+0x47fd3100>
    0x8401486a     0xea    add a4,a4,a5
    0x8401486c     0xec    lw a3,0(a4)
    0x8401486e     0xee    andi a0,a0,31
    0x84014870     0xf0    li a5,1
    0x84014872     0xf2    sll a0,a5,a0
    0x84014876     0xf6    not a5,a0
    0x8401487a     0xfa    and a5,a5,a3
    0x8401487c     0xfc    sext.w a5,a5
    0x8401487e     0xfe    sw a5,0(a4)
    0x84014880    0x100    j ffffffff84014822 <handleInterrupt+0xa2>
    0x84014882    0x102    li a5,32
    0x84014886    0x106    csrrc a5,sie,a5
    0x8401488a    0x10a    j ffffffff84014822 <handleInterrupt+0xa2>
    0x8401488c    0x10c    jal ra,ffffffff84010cec <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
95 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleInterrupt` has 147 nodes.

Section cancelSignal (389 of 432)
=================================

Deriving specifications
-----------------------

Section `cancelSignal` consists of 40 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `cancelSignal`:

    0x840139e6     0x0    addi sp,sp,-64
    0x840139e8     0x2    sd ra,56(sp)          ; stack access
    0x840139ea     0x4    sd s0,48(sp)          ; stack access
    0x840139ec     0x6    sd s1,40(sp)          ; stack access
    0x840139ee     0x8    sd s2,32(sp)          ; stack access
    0x840139f0     0xa    sd s3,24(sp)          ; stack access
    0x840139f2     0xc    mv s1,a0
    0x840139f4     0xe    mv s0,a1
    0x840139f6    0x10    mv a0,a1
    0x840139f8    0x12    jal ra,ffffffff84010b3e <notification_ptr_get_ntfnQueue_head>
    0x840139fc    0x16    mv s2,a0
    0x840139fe    0x18    mv a0,s0
    0x84013a00    0x1a    jal ra,ffffffff84010b56 <notification_ptr_get_ntfnQueue_tail>
    0x84013a04    0x1e    mv a2,a0
    0x84013a06    0x20    mv a1,s2
    0x84013a08    0x22    mv a0,s1
    0x84013a0a    0x24    jal ra,ffffffff840138b6 <tcbEPDequeue>
    0x84013a0e    0x28    mv s2,a0
    0x84013a10    0x2a    mv s3,a1
    0x84013a12    0x2c    mv a1,a0
    0x84013a14    0x2e    mv a0,s0
    0x84013a16    0x30    jal ra,ffffffff84010236 <notification_ptr_set_ntfnQueue_head>
    0x84013a1a    0x34    mv a1,s3
    0x84013a1c    0x36    mv a0,s0
    0x84013a1e    0x38    jal ra,ffffffff8401024a <notification_ptr_set_ntfnQueue_tail>
    0x84013a22    0x3c    beqz s2,ffffffff84013a3c <cancelSignal+0x56>
    0x84013a26    0x40    li a1,0
    0x84013a28    0x42    mv a0,s1
    0x84013a2a    0x44    jal ra,ffffffff84013020 <setThreadState>
    0x84013a2e    0x48    ld ra,56(sp)          ; stack access
    0x84013a30    0x4a    ld s0,48(sp)          ; stack access
    0x84013a32    0x4c    ld s1,40(sp)          ; stack access
    0x84013a34    0x4e    ld s2,32(sp)          ; stack access
    0x84013a36    0x50    ld s3,24(sp)          ; stack access
    0x84013a38    0x52    addi sp,sp,64
    0x84013a3a    0x54    ret
    0x84013a3c    0x56    li a1,0
    0x84013a3e    0x58    mv a0,s0
    0x84013a40    0x5a    jal ra,ffffffff8401025e <notification_ptr_set_state>
    0x84013a44    0x5e    j ffffffff84013a26 <cancelSignal+0x40>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
40 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelSignal` has 60 nodes.

Section createObject (390 of 432)
=================================

Deriving specifications
-----------------------

Section `createObject` consists of 69 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `createObject`:

    0x84012dd2     0x0    addi sp,sp,-32
    0x84012dd4     0x2    sd ra,24(sp)          ; stack access
    0x84012dd6     0x4    mv a6,a2
    0x84012dd8     0x6    mv a7,a3
    0x84012dda     0x8    li a5,4
    0x84012ddc     0xa    bltu a5,a0,ffffffff84012dfa <createObject+0x28>
    0x84012de0     0xe    li a5,4
    0x84012de2    0x10    bltu a5,a0,ffffffff84012e80 <createObject+0xae>
    0x84012de6    0x14    slli a4,a0,0x2
    0x84012dea    0x18    auipc a3,0x5
    0x84012dee    0x1c    addi a3,a3,862 # ffffffff84018148 <ksDomScheduleLength+0x200>
    0x84012df2    0x20    add a4,a4,a3
    0x84012df4    0x22    lw a5,0(a4)
    0x84012df6    0x24    add a5,a5,a3
    0x84012df8    0x26    jr a5
    0x84012dfa    0x28    jal ra,ffffffff84011a0e <Arch_createObject>
    0x84012dfe    0x2c    sd a0,0(sp)           ; stack access
    0x84012e00    0x2e    sd a1,8(sp)           ; stack access
    0x84012e02    0x30    ld a0,0(sp)           ; stack access
    0x84012e04    0x32    ld a1,8(sp)           ; stack access
    0x84012e06    0x34    ld ra,24(sp)          ; stack access
    0x84012e08    0x36    addi sp,sp,32
    0x84012e0a    0x38    ret
    0x84012e0c    0x3a    addi a0,a1,512
    0x84012e10    0x3e    li a5,32
    0x84012e14    0x42    sd a5,256(a0)
    0x84012e18    0x46    li a5,5
    0x84012e1a    0x48    sd a5,368(a0)
    0x84012e1e    0x4c    auipc a5,0x1c
    0x84012e22    0x50    ld a5,-1566(a5) # ffffffff8402e800 <ksCurDomain>
    0x84012e26    0x54    sd a5,344(a0)
    0x84012e2a    0x58    jal ra,ffffffff840105de <cap_thread_cap_new>
    0x84012e2e    0x5c    sd a0,0(sp)
    0x84012e30    0x5e    sd a1,8(sp)
    0x84012e32    0x60    j ffffffff84012e02 <createObject+0x30>
    0x84012e34    0x62    mv a5,a1
    0x84012e36    0x64    li a4,1
    0x84012e38    0x66    li a3,1
    0x84012e3a    0x68    li a2,1
    0x84012e3c    0x6a    li a1,1
    0x84012e3e    0x6c    li a0,0
    0x84012e40    0x6e    jal ra,ffffffff8401041a <cap_endpoint_cap_new>
    0x84012e44    0x72    sd a0,0(sp)
    0x84012e46    0x74    sd a1,8(sp)
    0x84012e48    0x76    j ffffffff84012e02 <createObject+0x30>
    0x84012e4a    0x78    mv a3,a1
    0x84012e4c    0x7a    li a2,1
    0x84012e4e    0x7c    li a1,1
    0x84012e50    0x7e    li a0,0
    0x84012e52    0x80    jal ra,ffffffff840104ce <cap_notification_cap_new>
    0x84012e56    0x84    sd a0,0(sp)
    0x84012e58    0x86    sd a1,8(sp)
    0x84012e5a    0x88    j ffffffff84012e02 <createObject+0x30>
    0x84012e5c    0x8a    mv a3,a1
    0x84012e5e    0x8c    li a2,0
    0x84012e60    0x8e    li a1,0
    0x84012e62    0x90    mv a0,a6
    0x84012e64    0x92    jal ra,ffffffff8401057c <cap_cnode_cap_new>
    0x84012e68    0x96    sd a0,0(sp)
    0x84012e6a    0x98    sd a1,8(sp)
    0x84012e6c    0x9a    j ffffffff84012e02 <createObject+0x30>
    0x84012e6e    0x9c    mv a3,a1
    0x84012e70    0x9e    snez a1,a7
    0x84012e74    0xa2    li a0,0
    0x84012e76    0xa4    jal ra,ffffffff840103be <cap_untyped_cap_new>
    0x84012e7a    0xa8    sd a0,0(sp)
    0x84012e7c    0xaa    sd a1,8(sp)
    0x84012e7e    0xac    j ffffffff84012e02 <createObject+0x30>
    0x84012e80    0xae    jal ra,ffffffff84010cec <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
69 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `createObject` has 103 nodes.

Section performPageInvocationUnmap (391 of 432)
===============================================

Deriving specifications
-----------------------

Section `performPageInvocationUnmap` consists of 45 instructions.


Stack analysis
---------------

18 stack accesses found. Annotated code for `performPageInvocationUnmap`:

    0x84011586     0x0    addi sp,sp,-80
    0x84011588     0x2    sd ra,72(sp)          ; stack access
    0x8401158a     0x4    sd s0,64(sp)          ; stack access
    0x8401158c     0x6    sd s1,56(sp)          ; stack access
    0x8401158e     0x8    sd s2,48(sp)          ; stack access
    0x84011590     0xa    sd s3,40(sp)          ; stack access
    0x84011592     0xc    sd a0,0(sp)           ; stack access
    0x84011594     0xe    sd a1,8(sp)           ; stack access
    0x84011596    0x10    mv s0,a2
    0x84011598    0x12    jal ra,ffffffff84010690 <cap_frame_cap_get_capFMappedASID>
    0x8401159c    0x16    bnez a0,ffffffff840115c2 <performPageInvocationUnmap+0x3c>
    0x8401159e    0x18    li a2,0
    0x840115a0    0x1a    ld a0,0(s0)
    0x840115a2    0x1c    ld a1,8(s0)
    0x840115a4    0x1e    jal ra,ffffffff840106da <cap_frame_cap_set_capFMappedAddress>
    0x840115a8    0x22    li a2,0
    0x840115aa    0x24    jal ra,ffffffff8401069a <cap_frame_cap_set_capFMappedASID>
    0x840115ae    0x28    sd a0,0(s0)
    0x840115b0    0x2a    sd a1,8(s0)
    0x840115b2    0x2c    li a0,0
    0x840115b4    0x2e    ld ra,72(sp)          ; stack access
    0x840115b6    0x30    ld s0,64(sp)          ; stack access
    0x840115b8    0x32    ld s1,56(sp)          ; stack access
    0x840115ba    0x34    ld s2,48(sp)          ; stack access
    0x840115bc    0x36    ld s3,40(sp)          ; stack access
    0x840115be    0x38    addi sp,sp,80
    0x840115c0    0x3a    ret
    0x840115c2    0x3c    mv s1,a0
    0x840115c4    0x3e    ld a0,0(sp)           ; stack access
    0x840115c6    0x40    ld a1,8(sp)           ; stack access
    0x840115c8    0x42    jal ra,ffffffff840106a8 <cap_frame_cap_get_capFSize>
    0x840115cc    0x46    mv s2,a0
    0x840115ce    0x48    ld a0,0(sp)           ; stack access
    0x840115d0    0x4a    ld a1,8(sp)           ; stack access
    0x840115d2    0x4c    jal ra,ffffffff84010ad0 <cap_frame_cap_get_capFMappedAddress>
    0x840115d6    0x50    mv s3,a0
    0x840115d8    0x52    ld a0,0(sp)           ; stack access
    0x840115da    0x54    ld a1,8(sp)           ; stack access
    0x840115dc    0x56    jal ra,ffffffff84010a5a <cap_frame_cap_get_capFBasePtr>
    0x840115e0    0x5a    mv a3,a0
    0x840115e2    0x5c    mv a2,s3
    0x840115e4    0x5e    mv a1,s1
    0x840115e6    0x60    mv a0,s2
    0x840115e8    0x62    jal ra,ffffffff840112a4 <unmapPage>
    0x840115ec    0x66    j ffffffff8401159e <performPageInvocationUnmap+0x18>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
45 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performPageInvocationUnmap` has 77 nodes.

Section unmapPageTable (392 of 432)
===================================

Deriving specifications
-----------------------

Section `unmapPageTable` consists of 69 instructions.

Skipping 12000073 sfence.vma


Stack analysis
---------------

18 stack accesses found. Annotated code for `unmapPageTable`:

    0x840111fe     0x0    addi sp,sp,-96
    0x84011200     0x2    sd ra,88(sp)          ; stack access
    0x84011202     0x4    sd s0,80(sp)          ; stack access
    0x84011204     0x6    sd s1,72(sp)          ; stack access
    0x84011206     0x8    sd s2,64(sp)          ; stack access
    0x84011208     0xa    sd s3,56(sp)          ; stack access
    0x8401120a     0xc    sd s4,48(sp)          ; stack access
    0x8401120c     0xe    sd s5,40(sp)          ; stack access
    0x8401120e    0x10    mv s3,a1
    0x84011210    0x12    mv s1,a2
    0x84011212    0x14    jal ra,ffffffff84010922 <findVSpaceForASID>
    0x84011216    0x18    sd a0,16(sp)          ; stack access
    0x84011218    0x1a    sd a1,24(sp)          ; stack access
    0x8401121a    0x1c    bnez a0,ffffffff84011270 <unmapPageTable+0x72>
    0x8401121c    0x1e    mv a0,a1
    0x8401121e    0x20    beq a1,s1,ffffffff84011282 <unmapPageTable+0x84>
    0x84011222    0x24    li s2,30
    0x84011224    0x26    li s4,-1
    0x84011226    0x28    slli s4,s4,0x26
    0x84011228    0x2a    li s5,21
    0x8401122a    0x2c    srl s0,s3,s2
    0x8401122e    0x30    andi s0,s0,511
    0x84011232    0x34    slli s0,s0,0x3
    0x84011234    0x36    add s0,s0,a0
    0x84011236    0x38    mv a0,s0
    0x84011238    0x3a    jal ra,ffffffff840102f0 <pte_ptr_get_valid>
    0x8401123c    0x3e    beqz a0,ffffffff84011270 <unmapPageTable+0x72>
    0x8401123e    0x40    mv a0,s0
    0x84011240    0x42    jal ra,ffffffff840102e8 <pte_ptr_get_read>
    0x84011244    0x46    bnez a0,ffffffff84011270 <unmapPageTable+0x72>
    0x84011246    0x48    mv a0,s0
    0x84011248    0x4a    jal ra,ffffffff840102e0 <pte_ptr_get_write>
    0x8401124c    0x4e    bnez a0,ffffffff84011270 <unmapPageTable+0x72>
    0x8401124e    0x50    mv a0,s0
    0x84011250    0x52    jal ra,ffffffff840102d8 <pte_ptr_get_execute>
    0x84011254    0x56    bnez a0,ffffffff84011270 <unmapPageTable+0x72>
    0x84011256    0x58    mv a0,s0
    0x84011258    0x5a    jal ra,ffffffff840102d0 <pte_ptr_get_ppn>
    0x8401125c    0x5e    slli a0,a0,0xc
    0x8401125e    0x60    add a0,a0,s4
    0x84011260    0x62    beq s2,s5,ffffffff8401126c <unmapPageTable+0x6e>
    0x84011264    0x66    addiw s2,s2,-9
    0x84011266    0x68    bne s1,a0,ffffffff8401122a <unmapPageTable+0x2c>
    0x8401126a    0x6c    j ffffffff84011284 <unmapPageTable+0x86>
    0x8401126c    0x6e    beq s1,a0,ffffffff84011284 <unmapPageTable+0x86>
    0x84011270    0x72    ld ra,88(sp)          ; stack access
    0x84011272    0x74    ld s0,80(sp)          ; stack access
    0x84011274    0x76    ld s1,72(sp)          ; stack access
    0x84011276    0x78    ld s2,64(sp)          ; stack access
    0x84011278    0x7a    ld s3,56(sp)          ; stack access
    0x8401127a    0x7c    ld s4,48(sp)          ; stack access
    0x8401127c    0x7e    ld s5,40(sp)          ; stack access
    0x8401127e    0x80    addi sp,sp,96
    0x84011280    0x82    ret
    0x84011282    0x84    li s0,0
    0x84011284    0x86    sd zero,8(sp)         ; stack access
    0x84011286    0x88    sd zero,0(sp)         ; stack access
    0x84011288    0x8a    li a7,0
    0x8401128a    0x8c    li a6,0
    0x8401128c    0x8e    li a5,0
    0x8401128e    0x90    li a4,0
    0x84011290    0x92    li a3,0
    0x84011292    0x94    li a2,0
    0x84011294    0x96    li a1,0
    0x84011296    0x98    li a0,0
    0x84011298    0x9a    jal ra,ffffffff8401026a <pte_new>
    0x8401129c    0x9e    sd a0,0(s0)
    0x8401129e    0xa0    sfence.vma
    0x840112a2    0xa4    j ffffffff84011270 <unmapPageTable+0x72>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
69 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `unmapPageTable` has 115 nodes.

Section create_initial_thread (393 of 432)
==========================================

Deriving specifications
-----------------------

Section `create_initial_thread` consists of 106 instructions.

RVC_FTTFFFFTFFFFT_FT.

Stack analysis
---------------

35 stack accesses found. Annotated code for `create_initial_thread`:

    0x84000b8a      0x0    addi sp,sp,-160
    0x84000b8c      0x2    sd ra,136(sp)         ; stack access
    0x84000b8e      0x4    sd s0,128(sp)         ; stack access
    0x84000b90      0x6    sd s1,120(sp)         ; stack access
    0x84000b92      0x8    sd s2,112(sp)         ; stack access
    0x84000b94      0xa    sd s3,104(sp)         ; stack access
    0x84000b96      0xc    sd s4,96(sp)          ; stack access
    0x84000b98      0xe    sd s5,88(sp)          ; stack access
    0x84000b9a     0x10    sd a0,16(sp)          ; stack access
    0x84000b9c     0x12    sd a1,24(sp)          ; stack access
    0x84000b9e     0x14    sd a2,0(sp)           ; stack access
    0x84000ba0     0x16    sd a3,8(sp)           ; stack access
    0x84000ba2     0x18    mv s2,a4
    0x84000ba4     0x1a    mv s3,a5
    0x84000ba6     0x1c    mv s4,a6
    0x84000ba8     0x1e    mv s1,a7
    0x84000baa     0x20    sd a7,152(sp)         ; stack access
    0x84000bac     0x22    auipc s0,0x1
    0x84000bb0     0x26    ld s0,-1036(s0) # ffffffff840017a0 <rootserver+0x30>
    0x84000bb4     0x2a    addi s0,s0,512
    0x84000bb8     0x2e    li a5,5
    0x84000bba     0x30    sd a5,368(s0)
    0x84000bbe     0x34    li a5,32
    0x84000bc2     0x38    sd a5,256(s0)
    0x84000bc6     0x3c    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x84000bca     0x40    mv a2,s1
    0x84000bcc     0x42    ld a3,160(sp)         ; stack access
    0x84000bce     0x44    addi a1,a0,320
    0x84000bd2     0x48    addi a0,sp,56
    0x84000bd4     0x4a    jal ra,ffffffff840129da <deriveCap>
    0x84000bd8     0x4e    ld a5,56(sp)          ; stack access
    0x84000bda     0x50    li s5,0
    0x84000bdc     0x52    bnez a5,ffffffff84000ca6 <create_initial_thread+0x11c>
    0x84000bde     0x54    mv s5,s0
    0x84000be0     0x56    ld a0,16(sp)          ; stack access
    0x84000be2     0x58    ld a1,24(sp)          ; stack access
    0x84000be4     0x5a    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x84000be8     0x5e    auipc s1,0x1
    0x84000bec     0x62    addi s1,s1,-1752 # ffffffff84001510 <ndks_boot>
    0x84000bf0     0x66    ld a3,656(s1)
    0x84000bf4     0x6a    addi a2,a0,64
    0x84000bf8     0x6e    ld a0,16(sp)          ; stack access
    0x84000bfa     0x70    ld a1,24(sp)          ; stack access
    0x84000bfc     0x72    jal ra,ffffffff84011e56 <cteInsert>
    0x84000c00     0x76    ld a0,16(sp)          ; stack access
    0x84000c02     0x78    ld a1,24(sp)          ; stack access
    0x84000c04     0x7a    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x84000c08     0x7e    ld a3,656(s1)
    0x84000c0c     0x82    addi a3,a3,32
    0x84000c10     0x86    addi a2,a0,96
    0x84000c14     0x8a    ld a0,0(sp)           ; stack access
    0x84000c16     0x8c    ld a1,8(sp)           ; stack access
    0x84000c18     0x8e    jal ra,ffffffff84011e56 <cteInsert>
    0x84000c1c     0x92    ld a0,16(sp)          ; stack access
    0x84000c1e     0x94    ld a1,24(sp)          ; stack access
    0x84000c20     0x96    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x84000c24     0x9a    ld a3,656(s1)
    0x84000c28     0x9e    addi a3,a3,128
    0x84000c2c     0xa2    addi a2,a0,320
    0x84000c30     0xa6    ld a0,64(sp)          ; stack access
    0x84000c32     0xa8    ld a1,72(sp)          ; stack access
    0x84000c34     0xaa    jal ra,ffffffff84011e56 <cteInsert>
    0x84000c38     0xae    sd s4,384(s0)
    0x84000c3c     0xb2    sd s3,72(s0)
    0x84000c40     0xb6    sd s2,272(s0)
    0x84000c44     0xba    li a5,255
    0x84000c48     0xbe    sd a5,360(s0)
    0x84000c4c     0xc2    sd a5,352(s0)
    0x84000c50     0xc6    mv a0,s0
    0x84000c52     0xc8    jal ra,ffffffff840121f6 <setupReplyMaster>
    0x84000c56     0xcc    li a1,1
    0x84000c58     0xce    mv a0,s0
    0x84000c5a     0xd0    jal ra,ffffffff84013020 <setThreadState>
    0x84000c5e     0xd4    auipc a5,0x2e
    0x84000c62     0xd8    ld a5,-446(a5) # ffffffff8402eaa0 <ksDomScheduleIdx>
    0x84000c66     0xdc    slli a4,a5,0x4
    0x84000c6a     0xe0    auipc a5,0x17
    0x84000c6e     0xe4    addi a5,a5,1638 # ffffffff840182d0 <fault_messages>
    0x84000c72     0xe8    add a5,a5,a4
    0x84000c74     0xea    ld a4,192(a5)
    0x84000c76     0xec    auipc a3,0x2e
    0x84000c7a     0xf0    sd a4,-1142(a3) # ffffffff8402e800 <ksCurDomain>
    0x84000c7e     0xf4    ld a5,200(a5)
    0x84000c80     0xf6    auipc a4,0x2d
    0x84000c84     0xfa    sd a5,472(a4) # ffffffff8402de58 <ksDomainTime>
    0x84000c88     0xfe    mv a0,s0
    0x84000c8a    0x100    jal ra,ffffffff840105de <cap_thread_cap_new>
    0x84000c8e    0x104    mv s1,a0
    0x84000c90    0x106    mv s0,a1
    0x84000c92    0x108    ld a0,16(sp)          ; stack access
    0x84000c94    0x10a    ld a1,24(sp)          ; stack access
    0x84000c96    0x10c    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x84000c9a    0x110    mv a1,s1
    0x84000c9c    0x112    mv a2,s0
    0x84000c9e    0x114    addi a0,a0,32
    0x84000ca2    0x118    jal ra,ffffffff840005bc <write_slot>
    0x84000ca6    0x11c    mv a0,s5
    0x84000ca8    0x11e    ld ra,136(sp)         ; stack access
    0x84000caa    0x120    ld s0,128(sp)         ; stack access
    0x84000cac    0x122    ld s1,120(sp)         ; stack access
    0x84000cae    0x124    ld s2,112(sp)         ; stack access
    0x84000cb0    0x126    ld s3,104(sp)         ; stack access
    0x84000cb2    0x128    ld s4,96(sp)          ; stack access
    0x84000cb4    0x12a    ld s5,88(sp)          ; stack access
    0x84000cb6    0x12c    addi sp,sp,160
    0x84000cb8    0x12e    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
106 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_initial_thread` has 173 nodes.

Section create_it_address_space (394 of 432)
============================================

Deriving specifications
-----------------------

Section `create_it_address_space` consists of 98 instructions.


Stack analysis
---------------

44 stack accesses found. Annotated code for `create_it_address_space`:

    0x84000740     0x0    addi sp,sp,-192
    0x84000742     0x2    sd ra,184(sp)         ; stack access
    0x84000744     0x4    sd s0,176(sp)         ; stack access
    0x84000746     0x6    sd s1,168(sp)         ; stack access
    0x84000748     0x8    sd s2,160(sp)         ; stack access
    0x8400074a     0xa    sd s3,152(sp)         ; stack access
    0x8400074c     0xc    sd s4,144(sp)         ; stack access
    0x8400074e     0xe    sd s5,136(sp)         ; stack access
    0x84000750    0x10    sd s6,128(sp)         ; stack access
    0x84000752    0x12    sd s7,120(sp)         ; stack access
    0x84000754    0x14    sd s8,112(sp)         ; stack access
    0x84000756    0x16    sd a0,16(sp)          ; stack access
    0x84000758    0x18    sd a1,24(sp)          ; stack access
    0x8400075a    0x1a    sd a2,0(sp)           ; stack access
    0x8400075c    0x1c    mv s3,a3
    0x8400075e    0x1e    auipc s2,0x1
    0x84000762    0x22    addi s2,s2,-590 # ffffffff84001510 <ndks_boot>
    0x84000766    0x26    ld a0,616(s2)
    0x8400076a    0x2a    jal ra,ffffffff84010ee8 <copyGlobalMappings>
    0x8400076e    0x2e    ld a1,616(s2)
    0x84000772    0x32    mv a3,a1
    0x84000774    0x34    li a2,1
    0x84000776    0x36    li a0,1
    0x84000778    0x38    jal ra,ffffffff840106ee <cap_page_table_cap_new>
    0x8400077c    0x3c    mv s1,a0
    0x8400077e    0x3e    mv s0,a1
    0x84000780    0x40    sd a0,64(sp)          ; stack access
    0x84000782    0x42    sd a1,72(sp)          ; stack access
    0x84000784    0x44    ld s8,592(s2)
    0x84000788    0x48    ld a0,16(sp)          ; stack access
    0x8400078a    0x4a    ld a1,24(sp)          ; stack access
    0x8400078c    0x4c    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x84000790    0x50    mv a1,s1
    0x84000792    0x52    mv a2,s0
    0x84000794    0x54    addi a0,a0,96
    0x84000798    0x58    jal ra,ffffffff840005bc <write_slot>
    0x8400079c    0x5c    li s6,30
    0x8400079e    0x5e    li s1,1
    0x840007a0    0x60    lui s5,0x1
    0x840007a2    0x62    li s7,12
    0x840007a4    0x64    sext.w s4,s6
    0x840007a8    0x68    ld s0,0(sp)           ; stack access
    0x840007aa    0x6a    srl s0,s0,s6
    0x840007ae    0x6e    sll s0,s0,s6
    0x840007b2    0x72    bgeu s0,s3,ffffffff840007f4 <create_it_address_space+0xb4>
    0x840007b6    0x76    sll s4,s1,s4
    0x840007ba    0x7a    ld a1,664(s2)
    0x840007be    0x7e    add a5,a1,s5
    0x840007c2    0x82    sd a5,664(s2)
    0x840007c6    0x86    mv a3,s0
    0x840007c8    0x88    mv a2,s1
    0x840007ca    0x8a    mv a0,s1
    0x840007cc    0x8c    jal ra,ffffffff840106ee <cap_page_table_cap_new>
    0x840007d0    0x90    mv a2,a0
    0x840007d2    0x92    mv a3,a1
    0x840007d4    0x94    sd a0,48(sp)          ; stack access
    0x840007d6    0x96    sd a1,56(sp)          ; stack access
    0x840007d8    0x98    ld a0,64(sp)          ; stack access
    0x840007da    0x9a    ld a1,72(sp)          ; stack access
    0x840007dc    0x9c    jal ra,ffffffff84000198 <map_it_pt_cap>
    0x840007e0    0xa0    ld a2,48(sp)          ; stack access
    0x840007e2    0xa2    ld a3,56(sp)          ; stack access
    0x840007e4    0xa4    ld a0,16(sp)          ; stack access
    0x840007e6    0xa6    ld a1,24(sp)          ; stack access
    0x840007e8    0xa8    jal ra,ffffffff840006ee <provide_cap>
    0x840007ec    0xac    beqz a0,ffffffff84000834 <create_it_address_space+0xf4>
    0x840007ee    0xae    add s0,s0,s4
    0x840007f0    0xb0    bltu s0,s3,ffffffff840007ba <create_it_address_space+0x7a>
    0x840007f4    0xb4    addiw s6,s6,-9
    0x840007f6    0xb6    bne s6,s7,ffffffff840007a4 <create_it_address_space+0x64>
    0x840007fa    0xba    auipc a5,0x1
    0x840007fe    0xbe    addi a5,a5,-746 # ffffffff84001510 <ndks_boot>
    0x84000802    0xc2    ld a4,592(a5)
    0x84000806    0xc6    ld a5,584(a5)
    0x8400080a    0xca    sd s8,88(a5)
    0x8400080e    0xce    sd a4,96(a5)
    0x84000810    0xd0    ld a5,64(sp)          ; stack access
    0x84000812    0xd2    sd a5,96(sp)          ; stack access
    0x84000814    0xd4    ld a5,72(sp)          ; stack access
    0x84000816    0xd6    sd a5,104(sp)         ; stack access
    0x84000818    0xd8    ld a0,96(sp)          ; stack access
    0x8400081a    0xda    ld a1,104(sp)         ; stack access
    0x8400081c    0xdc    ld ra,184(sp)         ; stack access
    0x8400081e    0xde    ld s0,176(sp)         ; stack access
    0x84000820    0xe0    ld s1,168(sp)         ; stack access
    0x84000822    0xe2    ld s2,160(sp)         ; stack access
    0x84000824    0xe4    ld s3,152(sp)         ; stack access
    0x84000826    0xe6    ld s4,144(sp)         ; stack access
    0x84000828    0xe8    ld s5,136(sp)         ; stack access
    0x8400082a    0xea    ld s6,128(sp)         ; stack access
    0x8400082c    0xec    ld s7,120(sp)         ; stack access
    0x8400082e    0xee    ld s8,112(sp)         ; stack access
    0x84000830    0xf0    addi sp,sp,192
    0x84000832    0xf2    ret
    0x84000834    0xf4    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84000838    0xf8    sd a0,96(sp)          ; stack access
    0x8400083a    0xfa    sd a1,104(sp)         ; stack access
    0x8400083c    0xfc    j ffffffff84000818 <create_it_address_space+0xd8>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
98 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_it_address_space` has 168 nodes.

Section setMRs_syscall_error (395 of 432)
=========================================

Deriving specifications
-----------------------

Section `setMRs_syscall_error` consists of 101 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `setMRs_syscall_error`:

    0x840162f0      0x0    addi sp,sp,-48
    0x840162f2      0x2    sd ra,40(sp)          ; stack access
    0x840162f4      0x4    sd s0,32(sp)          ; stack access
    0x840162f6      0x6    sd s1,24(sp)          ; stack access
    0x840162f8      0x8    mv s0,a0
    0x840162fa      0xa    auipc a0,0x8
    0x840162fe      0xe    ld a0,-1666(a0) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016302     0x12    li a5,10
    0x84016304     0x14    bltu a5,a0,ffffffff840163ec <setMRs_syscall_error+0xfc>
    0x84016308     0x18    mv s1,a1
    0x8401630a     0x1a    slli a4,a0,0x2
    0x8401630e     0x1e    auipc a3,0x2
    0x84016312     0x22    addi a3,a3,-222 # ffffffff84018230 <ksDomScheduleLength+0x2e8>
    0x84016316     0x26    add a4,a4,a3
    0x84016318     0x28    lw a5,0(a4)
    0x8401631a     0x2a    add a5,a5,a3
    0x8401631c     0x2c    jr a5
    0x8401631e     0x2e    auipc a5,0x8
    0x84016322     0x32    ld a5,-1750(a5) # ffffffff8401dc48 <current_syscall_error>
    0x84016326     0x36    sd a5,88(s0)
    0x84016328     0x38    j ffffffff840163f2 <setMRs_syscall_error+0x102>
    0x8401632a     0x3a    auipc a5,0x8
    0x8401632e     0x3e    ld a5,-1754(a5) # ffffffff8401dc50 <current_syscall_error+0x8>
    0x84016332     0x42    sd a5,88(s0)
    0x84016334     0x44    li a0,1
    0x84016336     0x46    j ffffffff840163f2 <setMRs_syscall_error+0x102>
    0x84016338     0x48    auipc a5,0x8
    0x8401633c     0x4c    addi a5,a5,-1776 # ffffffff8401dc48 <current_syscall_error>
    0x84016340     0x50    ld a4,16(a5)
    0x84016342     0x52    sd a4,88(s0)
    0x84016344     0x54    ld a5,24(a5)
    0x84016346     0x56    sd a5,96(s0)
    0x84016348     0x58    li a0,2
    0x8401634a     0x5a    j ffffffff840163f2 <setMRs_syscall_error+0x102>
    0x8401634c     0x5c    auipc a5,0x8
    0x84016350     0x60    ld a5,-1756(a5) # ffffffff8401dc70 <current_syscall_error+0x28>
    0x84016354     0x64    snez a5,a5
    0x84016358     0x68    sd a5,88(s0)
    0x8401635a     0x6a    auipc a5,0x8
    0x8401635e     0x6e    addi a5,a5,-1834 # ffffffff8401dc30 <current_lookup_fault>
    0x84016362     0x72    ld a0,0(a5)
    0x84016364     0x74    sd a0,0(sp)
    0x84016366     0x76    ld a1,8(a5)
    0x84016368     0x78    sd a1,8(sp)
    0x8401636a     0x7a    jal ra,ffffffff840107a8 <lookup_fault_get_lufType>
    0x8401636e     0x7e    addi a5,a0,1
    0x84016372     0x82    sd a5,96(s0)
    0x84016374     0x84    li a5,2
    0x84016376     0x86    beq a0,a5,ffffffff840163be <setMRs_syscall_error+0xce>
    0x8401637a     0x8a    bltu a5,a0,ffffffff84016394 <setMRs_syscall_error+0xa4>
    0x8401637e     0x8e    beqz a0,ffffffff8401638c <setMRs_syscall_error+0x9c>
    0x84016380     0x90    ld a0,0(sp)
    0x84016382     0x92    ld a1,8(sp)
    0x84016384     0x94    jal ra,ffffffff840107cc <lookup_fault_missing_capability_get_bitsLeft>
    0x84016388     0x98    sd a0,104(s0)
    0x8401638a     0x9a    li a5,3
    0x8401638c     0x9c    slli a0,a5,0x20
    0x84016390     0xa0    srli a0,a0,0x20
    0x84016392     0xa2    j ffffffff840163f2 <setMRs_syscall_error+0x102>
    0x84016394     0xa4    li a5,3
    0x84016396     0xa6    bne a0,a5,ffffffff840163d6 <setMRs_syscall_error+0xe6>
    0x8401639a     0xaa    ld a0,0(sp)
    0x8401639c     0xac    ld a1,8(sp)
    0x8401639e     0xae    jal ra,ffffffff84010832 <lookup_fault_guard_mismatch_get_bitsLeft>
    0x840163a2     0xb2    sd a0,104(s0)
    0x840163a4     0xb4    ld a0,0(sp)
    0x840163a6     0xb6    ld a1,8(sp)
    0x840163a8     0xb8    jal ra,ffffffff8401082a <lookup_fault_guard_mismatch_get_guardFound>
    0x840163ac     0xbc    sd a0,112(s0)
    0x840163ae     0xbe    beqz s1,ffffffff840163da <setMRs_syscall_error+0xea>
    0x840163b0     0xc0    ld a0,0(sp)
    0x840163b2     0xc2    ld a1,8(sp)
    0x840163b4     0xc4    jal ra,ffffffff8401083e <lookup_fault_guard_mismatch_get_bitsFound>
    0x840163b8     0xc8    sd a0,40(s1)
    0x840163ba     0xca    li a5,5
    0x840163bc     0xcc    j ffffffff8401638c <setMRs_syscall_error+0x9c>
    0x840163be     0xce    ld a0,0(sp)
    0x840163c0     0xd0    ld a1,8(sp)
    0x840163c2     0xd2    jal ra,ffffffff84010800 <lookup_fault_depth_mismatch_get_bitsLeft>
    0x840163c6     0xd6    sd a0,104(s0)
    0x840163c8     0xd8    ld a0,0(sp)
    0x840163ca     0xda    ld a1,8(sp)
    0x840163cc     0xdc    jal ra,ffffffff840107f4 <lookup_fault_depth_mismatch_get_bitsFound>
    0x840163d0     0xe0    sd a0,112(s0)
    0x840163d2     0xe2    li a5,4
    0x840163d4     0xe4    j ffffffff8401638c <setMRs_syscall_error+0x9c>
    0x840163d6     0xe6    jal ra,ffffffff84010cec <halt>
    0x840163da     0xea    li a5,4
    0x840163dc     0xec    j ffffffff8401638c <setMRs_syscall_error+0x9c>
    0x840163de     0xee    auipc a5,0x8
    0x840163e2     0xf2    ld a5,-1910(a5) # ffffffff8401dc68 <current_syscall_error+0x20>
    0x840163e6     0xf6    sd a5,88(s0)
    0x840163e8     0xf8    li a0,1
    0x840163ea     0xfa    j ffffffff840163f2 <setMRs_syscall_error+0x102>
    0x840163ec     0xfc    jal ra,ffffffff84010cec <halt>
    0x840163f0    0x100    li a0,0
    0x840163f2    0x102    ld ra,40(sp)          ; stack access
    0x840163f4    0x104    ld s0,32(sp)          ; stack access
    0x840163f6    0x106    ld s1,24(sp)          ; stack access
    0x840163f8    0x108    addi sp,sp,48
    0x840163fa    0x10a    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
101 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setMRs_syscall_error` has 167 nodes.

Section decodeBindNotification (396 of 432)
===========================================

Deriving specifications
-----------------------

Section `decodeBindNotification` consists of 73 instructions.


Stack analysis
---------------

16 stack accesses found. Annotated code for `decodeBindNotification`:

    0x8401609a     0x0    addi sp,sp,-64
    0x8401609c     0x2    sd ra,56(sp)          ; stack access
    0x8401609e     0x4    sd s0,48(sp)          ; stack access
    0x840160a0     0x6    sd s1,40(sp)          ; stack access
    0x840160a2     0x8    sd a0,0(sp)           ; stack access
    0x840160a4     0xa    sd a1,8(sp)           ; stack access
    0x840160a6     0xc    auipc s1,0x8
    0x840160aa    0x10    ld s1,-1062(s1) # ffffffff8401dc80 <current_extra_caps>
    0x840160ae    0x14    beqz s1,ffffffff8401610e <decodeBindNotification+0x74>
    0x840160b0    0x16    ld a0,0(sp)           ; stack access
    0x840160b2    0x18    ld a1,8(sp)           ; stack access
    0x840160b4    0x1a    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x840160b8    0x1e    mv s0,a0
    0x840160ba    0x20    ld a5,304(a0)
    0x840160be    0x24    bnez a5,ffffffff8401611c <decodeBindNotification+0x82>
    0x840160c0    0x26    ld a0,0(s1)
    0x840160c2    0x28    sd a0,16(sp)          ; stack access
    0x840160c4    0x2a    ld a1,8(s1)
    0x840160c6    0x2c    sd a1,24(sp)          ; stack access
    0x840160c8    0x2e    jal ra,ffffffff8401039e <cap_get_capType>
    0x840160cc    0x32    li a5,6
    0x840160ce    0x34    bne a0,a5,ffffffff84016132 <decodeBindNotification+0x98>
    0x840160d2    0x38    ld a0,16(sp)          ; stack access
    0x840160d4    0x3a    ld a1,24(sp)          ; stack access
    0x840160d6    0x3c    jal ra,ffffffff840109aa <cap_notification_cap_get_capNtfnPtr>
    0x840160da    0x40    mv s1,a0
    0x840160dc    0x42    ld a0,16(sp)          ; stack access
    0x840160de    0x44    ld a1,24(sp)          ; stack access
    0x840160e0    0x46    jal ra,ffffffff84010500 <cap_notification_cap_get_capNtfnCanReceive>
    0x840160e4    0x4a    beqz a0,ffffffff84016140 <decodeBindNotification+0xa6>
    0x840160e6    0x4c    mv a0,s1
    0x840160e8    0x4e    jal ra,ffffffff84010b3e <notification_ptr_get_ntfnQueue_head>
    0x840160ec    0x52    bnez a0,ffffffff8401614e <decodeBindNotification+0xb4>
    0x840160ee    0x54    mv a0,s1
    0x840160f0    0x56    jal ra,ffffffff840109c8 <notification_ptr_get_ntfnBoundTCB>
    0x840160f4    0x5a    bnez a0,ffffffff8401614e <decodeBindNotification+0xb4>
    0x840160f6    0x5c    li a1,2
    0x840160f8    0x5e    auipc a0,0x19
    0x840160fc    0x62    ld a0,-1632(a0) # ffffffff8402ea98 <ksCurThread>
    0x84016100    0x66    jal ra,ffffffff84013020 <setThreadState>
    0x84016104    0x6a    mv a1,s1
    0x84016106    0x6c    mv a0,s0
    0x84016108    0x6e    jal ra,ffffffff84016082 <invokeTCB_NotificationControl>
    0x8401610c    0x72    j ffffffff84016128 <decodeBindNotification+0x8e>
    0x8401610e    0x74    li a5,7
    0x84016110    0x76    auipc a4,0x8
    0x84016114    0x7a    sd a5,-1176(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016118    0x7e    li a0,3
    0x8401611a    0x80    j ffffffff84016128 <decodeBindNotification+0x8e>
    0x8401611c    0x82    li a5,3
    0x8401611e    0x84    auipc a4,0x8
    0x84016122    0x88    sd a5,-1190(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016126    0x8c    li a0,3
    0x84016128    0x8e    ld ra,56(sp)          ; stack access
    0x8401612a    0x90    ld s0,48(sp)          ; stack access
    0x8401612c    0x92    ld s1,40(sp)          ; stack access
    0x8401612e    0x94    addi sp,sp,64
    0x84016130    0x96    ret
    0x84016132    0x98    li a5,3
    0x84016134    0x9a    auipc a4,0x8
    0x84016138    0x9e    sd a5,-1212(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x8401613c    0xa2    li a0,3
    0x8401613e    0xa4    j ffffffff84016128 <decodeBindNotification+0x8e>
    0x84016140    0xa6    li a5,3
    0x84016142    0xa8    auipc a4,0x8
    0x84016146    0xac    sd a5,-1226(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x8401614a    0xb0    li a0,3
    0x8401614c    0xb2    j ffffffff84016128 <decodeBindNotification+0x8e>
    0x8401614e    0xb4    li a5,3
    0x84016150    0xb6    auipc a4,0x8
    0x84016154    0xba    sd a5,-1240(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016158    0xbe    li a0,3
    0x8401615a    0xc0    j ffffffff84016128 <decodeBindNotification+0x8e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
73 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeBindNotification` has 120 nodes.

Section cancelAllSignals (397 of 432)
=====================================

Deriving specifications
-----------------------

Section `cancelAllSignals` consists of 35 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `cancelAllSignals`:

    0x84013360     0x0    addi sp,sp,-32
    0x84013362     0x2    sd ra,24(sp)          ; stack access
    0x84013364     0x4    sd s0,16(sp)          ; stack access
    0x84013366     0x6    sd s1,8(sp)           ; stack access
    0x84013368     0x8    mv s1,a0
    0x8401336a     0xa    jal ra,ffffffff84010258 <notification_ptr_get_state>
    0x8401336e     0xe    li a5,1
    0x84013370    0x10    beq a0,a5,ffffffff8401337e <cancelAllSignals+0x1e>
    0x84013374    0x14    ld ra,24(sp)          ; stack access
    0x84013376    0x16    ld s0,16(sp)          ; stack access
    0x84013378    0x18    ld s1,8(sp)           ; stack access
    0x8401337a    0x1a    addi sp,sp,32
    0x8401337c    0x1c    ret
    0x8401337e    0x1e    mv a0,s1
    0x84013380    0x20    jal ra,ffffffff84010b3e <notification_ptr_get_ntfnQueue_head>
    0x84013384    0x24    mv s0,a0
    0x84013386    0x26    li a1,0
    0x84013388    0x28    mv a0,s1
    0x8401338a    0x2a    jal ra,ffffffff8401025e <notification_ptr_set_state>
    0x8401338e    0x2e    li a1,0
    0x84013390    0x30    mv a0,s1
    0x84013392    0x32    jal ra,ffffffff84010236 <notification_ptr_set_ntfnQueue_head>
    0x84013396    0x36    li a1,0
    0x84013398    0x38    mv a0,s1
    0x8401339a    0x3a    jal ra,ffffffff8401024a <notification_ptr_set_ntfnQueue_tail>
    0x8401339e    0x3e    beqz s0,ffffffff840133b4 <cancelAllSignals+0x54>
    0x840133a0    0x40    li a1,2
    0x840133a2    0x42    mv a0,s0
    0x840133a4    0x44    jal ra,ffffffff84013020 <setThreadState>
    0x840133a8    0x48    mv a0,s0
    0x840133aa    0x4a    jal ra,ffffffff84012efc <tcbSchedEnqueue>
    0x840133ae    0x4e    ld s0,408(s0)
    0x840133b2    0x52    bnez s0,ffffffff840133a0 <cancelAllSignals+0x40>
    0x840133b4    0x54    jal ra,ffffffff84012fa8 <rescheduleRequired>
    0x840133b8    0x58    j ffffffff84013374 <cancelAllSignals+0x14>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
35 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelAllSignals` has 57 nodes.

Section cancelAllIPC (398 of 432)
=================================

Deriving specifications
-----------------------

Section `cancelAllIPC` consists of 34 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `cancelAllIPC`:

    0x8401330a     0x0    addi sp,sp,-32
    0x8401330c     0x2    sd ra,24(sp)          ; stack access
    0x8401330e     0x4    sd s0,16(sp)          ; stack access
    0x84013310     0x6    sd s1,8(sp)           ; stack access
    0x84013312     0x8    mv s1,a0
    0x84013314     0xa    jal ra,ffffffff84010178 <endpoint_ptr_get_state>
    0x84013318     0xe    bnez a0,ffffffff84013324 <cancelAllIPC+0x1a>
    0x8401331a    0x10    ld ra,24(sp)          ; stack access
    0x8401331c    0x12    ld s0,16(sp)          ; stack access
    0x8401331e    0x14    ld s1,8(sp)           ; stack access
    0x84013320    0x16    addi sp,sp,32
    0x84013322    0x18    ret
    0x84013324    0x1a    mv a0,s1
    0x84013326    0x1c    jal ra,ffffffff84010158 <endpoint_ptr_get_epQueue_head>
    0x8401332a    0x20    mv s0,a0
    0x8401332c    0x22    li a1,0
    0x8401332e    0x24    mv a0,s1
    0x84013330    0x26    jal ra,ffffffff8401017e <endpoint_ptr_set_state>
    0x84013334    0x2a    li a1,0
    0x84013336    0x2c    mv a0,s1
    0x84013338    0x2e    jal ra,ffffffff8401015c <endpoint_ptr_set_epQueue_head>
    0x8401333c    0x32    li a1,0
    0x8401333e    0x34    mv a0,s1
    0x84013340    0x36    jal ra,ffffffff84010160 <endpoint_ptr_set_epQueue_tail>
    0x84013344    0x3a    beqz s0,ffffffff8401335a <cancelAllIPC+0x50>
    0x84013346    0x3c    li a1,2
    0x84013348    0x3e    mv a0,s0
    0x8401334a    0x40    jal ra,ffffffff84013020 <setThreadState>
    0x8401334e    0x44    mv a0,s0
    0x84013350    0x46    jal ra,ffffffff84012efc <tcbSchedEnqueue>
    0x84013354    0x4a    ld s0,408(s0)
    0x84013358    0x4e    bnez s0,ffffffff84013346 <cancelAllIPC+0x3c>
    0x8401335a    0x50    jal ra,ffffffff84012fa8 <rescheduleRequired>
    0x8401335e    0x54    j ffffffff8401331a <cancelAllIPC+0x10>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
34 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelAllIPC` has 56 nodes.

Section resolveAddressBits (399 of 432)
=======================================

Deriving specifications
-----------------------

Section `resolveAddressBits` consists of 119 instructions.


Stack analysis
---------------

Section `resolveAddressBits` expects pointer to stack in a0.
49 stack accesses found. Annotated code for `resolveAddressBits`:

    0x84011a94      0x0    addi sp,sp,-112
    0x84011a96      0x2    sd ra,104(sp)         ; stack access
    0x84011a98      0x4    sd s0,96(sp)          ; stack access
    0x84011a9a      0x6    sd s1,88(sp)          ; stack access
    0x84011a9c      0x8    sd s2,80(sp)          ; stack access
    0x84011a9e      0xa    sd s3,72(sp)          ; stack access
    0x84011aa0      0xc    sd s4,64(sp)          ; stack access
    0x84011aa2      0xe    sd s5,56(sp)          ; stack access
    0x84011aa4     0x10    sd s6,48(sp)          ; stack access
    0x84011aa6     0x12    sd s7,40(sp)          ; stack access
    0x84011aa8     0x14    sd s8,32(sp)          ; stack access
    0x84011aaa     0x16    sd s9,24(sp)          ; stack access
    0x84011aac     0x18    mv s1,a0
    0x84011aae     0x1a    sd a1,0(sp)           ; stack access
    0x84011ab0     0x1c    sd a2,8(sp)           ; stack access
    0x84011ab2     0x1e    mv s3,a3
    0x84011ab4     0x20    mv s4,a4
    0x84011ab6     0x22    mv a0,a1
    0x84011ab8     0x24    mv a1,a2
    0x84011aba     0x26    jal ra,ffffffff8401039e <cap_get_capType>
    0x84011abe     0x2a    li a5,10
    0x84011ac0     0x2c    mv s2,s4
    0x84011ac2     0x2e    li s6,-1
    0x84011ac4     0x30    li s7,10
    0x84011ac6     0x32    bne a0,a5,ffffffff84011b56 <resolveAddressBits+0xc2>
    0x84011aca     0x36    ld a0,0(sp)           ; stack access
    0x84011acc     0x38    ld a1,8(sp)           ; stack access
    0x84011ace     0x3a    jal ra,ffffffff840105d2 <cap_cnode_cap_get_capCNodeRadix>
    0x84011ad2     0x3e    mv s8,a0
    0x84011ad4     0x40    ld a0,0(sp)           ; stack access
    0x84011ad6     0x42    ld a1,8(sp)           ; stack access
    0x84011ad8     0x44    jal ra,ffffffff840105ae <cap_cnode_cap_get_capCNodeGuardSize>
    0x84011adc     0x48    mv s9,a0
    0x84011ade     0x4a    add s5,s8,a0
    0x84011ae2     0x4e    ld a0,0(sp)           ; stack access
    0x84011ae4     0x50    ld a1,8(sp)           ; stack access
    0x84011ae6     0x52    jal ra,ffffffff8401059e <cap_cnode_cap_get_capCNodeGuard>
    0x84011aea     0x56    sext.w s0,s2
    0x84011aee     0x5a    subw a5,s2,s9
    0x84011af2     0x5e    srl a5,s3,a5
    0x84011af6     0x62    sll a4,s6,s9
    0x84011afa     0x66    not a4,a4
    0x84011afe     0x6a    and a5,a5,a4
    0x84011b00     0x6c    bltu s2,s9,ffffffff84011b74 <resolveAddressBits+0xe0>
    0x84011b04     0x70    bne a0,a5,ffffffff84011b74 <resolveAddressBits+0xe0>
    0x84011b08     0x74    bltu s2,s5,ffffffff84011b96 <resolveAddressBits+0x102>
    0x84011b0c     0x78    ld a0,0(sp)           ; stack access
    0x84011b0e     0x7a    ld a1,8(sp)           ; stack access
    0x84011b10     0x7c    jal ra,ffffffff84010a1c <cap_cnode_cap_get_capCNodePtr>
    0x84011b14     0x80    subw s0,s0,s5
    0x84011b18     0x84    srl s0,s3,s0
    0x84011b1c     0x88    sll s8,s6,s8
    0x84011b20     0x8c    not s8,s8
    0x84011b24     0x90    and s0,s0,s8
    0x84011b28     0x94    slli s0,s0,0x5
    0x84011b2a     0x96    add s0,s0,a0
    0x84011b2c     0x98    bne s2,s5,ffffffff84011bb8 <resolveAddressBits+0x124>
    0x84011b30     0x9c    sd zero,0(s1)         ; stack access
    0x84011b34     0xa0    sd s0,8(s1)           ; stack access
    0x84011b36     0xa2    sd zero,16(s1)        ; stack access
    0x84011b3a     0xa6    mv a0,s1
    0x84011b3c     0xa8    ld ra,104(sp)         ; stack access
    0x84011b3e     0xaa    ld s0,96(sp)          ; stack access
    0x84011b40     0xac    ld s1,88(sp)          ; stack access
    0x84011b42     0xae    ld s2,80(sp)          ; stack access
    0x84011b44     0xb0    ld s3,72(sp)          ; stack access
    0x84011b46     0xb2    ld s4,64(sp)          ; stack access
    0x84011b48     0xb4    ld s5,56(sp)          ; stack access
    0x84011b4a     0xb6    ld s6,48(sp)          ; stack access
    0x84011b4c     0xb8    ld s7,40(sp)          ; stack access
    0x84011b4e     0xba    ld s8,32(sp)          ; stack access
    0x84011b50     0xbc    ld s9,24(sp)          ; stack access
    0x84011b52     0xbe    addi sp,sp,112
    0x84011b54     0xc0    ret
    0x84011b56     0xc2    jal ra,ffffffff840107b0 <lookup_fault_invalid_root_new>
    0x84011b5a     0xc6    auipc a5,0xc
    0x84011b5e     0xca    addi a5,a5,214 # ffffffff8401dc30 <current_lookup_fault>
    0x84011b62     0xce    sd a0,0(a5)
    0x84011b64     0xd0    sd a1,8(a5)
    0x84011b66     0xd2    li a5,2
    0x84011b68     0xd4    sd a5,0(s1)           ; stack access
    0x84011b6a     0xd6    sd zero,8(s1)         ; stack access
    0x84011b6e     0xda    sd s4,16(s1)          ; stack access
    0x84011b72     0xde    j ffffffff84011b3a <resolveAddressBits+0xa6>
    0x84011b74     0xe0    mv a2,s9
    0x84011b76     0xe2    mv a1,s2
    0x84011b78     0xe4    jal ra,ffffffff8401080c <lookup_fault_guard_mismatch_new>
    0x84011b7c     0xe8    auipc a5,0xc
    0x84011b80     0xec    addi a5,a5,180 # ffffffff8401dc30 <current_lookup_fault>
    0x84011b84     0xf0    sd a0,0(a5)
    0x84011b86     0xf2    sd a1,8(a5)
    0x84011b88     0xf4    li a5,2
    0x84011b8a     0xf6    sd a5,0(s1)           ; stack access
    0x84011b8c     0xf8    sd zero,8(s1)         ; stack access
    0x84011b90     0xfc    sd s4,16(s1)          ; stack access
    0x84011b94    0x100    j ffffffff84011b3a <resolveAddressBits+0xa6>
    0x84011b96    0x102    mv a1,s2
    0x84011b98    0x104    mv a0,s5
    0x84011b9a    0x106    jal ra,ffffffff840107d8 <lookup_fault_depth_mismatch_new>
    0x84011b9e    0x10a    auipc a5,0xc
    0x84011ba2    0x10e    addi a5,a5,146 # ffffffff8401dc30 <current_lookup_fault>
    0x84011ba6    0x112    sd a0,0(a5)
    0x84011ba8    0x114    sd a1,8(a5)
    0x84011baa    0x116    li a5,2
    0x84011bac    0x118    sd a5,0(s1)           ; stack access
    0x84011bae    0x11a    sd zero,8(s1)         ; stack access
    0x84011bb2    0x11e    sd s4,16(s1)          ; stack access
    0x84011bb6    0x122    j ffffffff84011b3a <resolveAddressBits+0xa6>
    0x84011bb8    0x124    sub s2,s2,s5
    0x84011bbc    0x128    ld a0,0(s0)
    0x84011bbe    0x12a    sd a0,0(sp)           ; stack access
    0x84011bc0    0x12c    ld a1,8(s0)
    0x84011bc2    0x12e    sd a1,8(sp)           ; stack access
    0x84011bc4    0x130    jal ra,ffffffff8401039e <cap_get_capType>
    0x84011bc8    0x134    beq a0,s7,ffffffff84011aca <resolveAddressBits+0x36>
    0x84011bcc    0x138    sd zero,0(s1)         ; stack access
    0x84011bd0    0x13c    sd s0,8(s1)           ; stack access
    0x84011bd2    0x13e    sd s2,16(s1)          ; stack access
    0x84011bd6    0x142    j ffffffff84011b3a <resolveAddressBits+0xa6>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
119 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `resolveAddressBits` has 198 nodes.

Section unmapPage (400 of 432)
==============================

Deriving specifications
-----------------------

Section `unmapPage` consists of 59 instructions.

Skipping 12000073 sfence.vma


Stack analysis
---------------

13 stack accesses found. Annotated code for `unmapPage`:

    0x840112a4     0x0    addi sp,sp,-64
    0x840112a6     0x2    sd ra,56(sp)          ; stack access
    0x840112a8     0x4    sd s0,48(sp)          ; stack access
    0x840112aa     0x6    sd s1,40(sp)          ; stack access
    0x840112ac     0x8    sd s2,32(sp)          ; stack access
    0x840112ae     0xa    mv s0,a0
    0x840112b0     0xc    mv s1,a2
    0x840112b2     0xe    mv s2,a3
    0x840112b4    0x10    mv a0,a1
    0x840112b6    0x12    jal ra,ffffffff84010922 <findVSpaceForASID>
    0x840112ba    0x16    sd a0,16(sp)          ; stack access
    0x840112bc    0x18    sd a1,24(sp)          ; stack access
    0x840112be    0x1a    beqz a0,ffffffff840112cc <unmapPage+0x28>
    0x840112c0    0x1c    ld ra,56(sp)          ; stack access
    0x840112c2    0x1e    ld s0,48(sp)          ; stack access
    0x840112c4    0x20    ld s1,40(sp)          ; stack access
    0x840112c6    0x22    ld s2,32(sp)          ; stack access
    0x840112c8    0x24    addi sp,sp,64
    0x840112ca    0x26    ret
    0x840112cc    0x28    mv a1,s1
    0x840112ce    0x2a    ld a0,24(sp)          ; stack access
    0x840112d0    0x2c    jal ra,ffffffff84011116 <lookupPTSlot>
    0x840112d4    0x30    mv s1,a0
    0x840112d6    0x32    sd a0,0(sp)           ; stack access
    0x840112d8    0x34    sd a1,8(sp)           ; stack access
    0x840112da    0x36    li a5,1
    0x840112dc    0x38    beq s0,a5,ffffffff840112ec <unmapPage+0x48>
    0x840112e0    0x3c    li a5,2
    0x840112e2    0x3e    beq s0,a5,ffffffff840112f0 <unmapPage+0x4c>
    0x840112e6    0x42    beqz s0,ffffffff84011332 <unmapPage+0x8e>
    0x840112e8    0x44    jal ra,ffffffff84010cec <halt>
    0x840112ec    0x48    li a5,21
    0x840112ee    0x4a    j ffffffff840112f2 <unmapPage+0x4e>
    0x840112f0    0x4c    li a5,30
    0x840112f2    0x4e    bne a1,a5,ffffffff840112c0 <unmapPage+0x1c>
    0x840112f6    0x52    mv a0,s1
    0x840112f8    0x54    jal ra,ffffffff840102f0 <pte_ptr_get_valid>
    0x840112fc    0x58    beqz a0,ffffffff840112c0 <unmapPage+0x1c>
    0x840112fe    0x5a    mv a0,s1
    0x84011300    0x5c    jal ra,ffffffff840102e8 <pte_ptr_get_read>
    0x84011304    0x60    bnez a0,ffffffff84011316 <unmapPage+0x72>
    0x84011306    0x62    mv a0,s1
    0x84011308    0x64    jal ra,ffffffff840102e0 <pte_ptr_get_write>
    0x8401130c    0x68    bnez a0,ffffffff84011316 <unmapPage+0x72>
    0x8401130e    0x6a    mv a0,s1
    0x84011310    0x6c    jal ra,ffffffff840102d8 <pte_ptr_get_execute>
    0x84011314    0x70    beqz a0,ffffffff840112c0 <unmapPage+0x1c>
    0x84011316    0x72    mv a0,s1
    0x84011318    0x74    jal ra,ffffffff840102d0 <pte_ptr_get_ppn>
    0x8401131c    0x78    slli a0,a0,0xc
    0x8401131e    0x7a    li a3,1
    0x84011320    0x7c    slli a3,a3,0x26
    0x84011322    0x7e    add a3,a3,s2
    0x84011324    0x80    bne a0,a3,ffffffff840112c0 <unmapPage+0x1c>
    0x84011328    0x84    sd zero,0(s1)
    0x8401132c    0x88    sfence.vma
    0x84011330    0x8c    j ffffffff840112c0 <unmapPage+0x1c>
    0x84011332    0x8e    li a5,12
    0x84011334    0x90    j ffffffff840112f2 <unmapPage+0x4e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
59 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `unmapPage` has 103 nodes.

Section invokeUntyped_Retype (401 of 432)
=========================================

Deriving specifications
-----------------------

Section `invokeUntyped_Retype` consists of 111 instructions.


Stack analysis
---------------

37 stack accesses found. Annotated code for `invokeUntyped_Retype`:

    0x84016dce      0x0    addi sp,sp,-112
    0x84016dd0      0x2    sd ra,104(sp)         ; stack access
    0x84016dd2      0x4    sd s0,96(sp)          ; stack access
    0x84016dd4      0x6    sd s1,88(sp)          ; stack access
    0x84016dd6      0x8    sd s2,80(sp)          ; stack access
    0x84016dd8      0xa    sd s3,72(sp)          ; stack access
    0x84016dda      0xc    sd s4,64(sp)          ; stack access
    0x84016ddc      0xe    sd s5,56(sp)          ; stack access
    0x84016dde     0x10    sd s6,48(sp)          ; stack access
    0x84016de0     0x12    sd s7,40(sp)          ; stack access
    0x84016de2     0x14    sd s8,32(sp)          ; stack access
    0x84016de4     0x16    sd s9,24(sp)          ; stack access
    0x84016de6     0x18    sd s10,16(sp)         ; stack access
    0x84016de8     0x1a    mv s0,a0
    0x84016dea     0x1c    mv s1,a1
    0x84016dec     0x1e    mv s5,a2
    0x84016dee     0x20    mv s3,a3
    0x84016df0     0x22    mv s6,a4
    0x84016df2     0x24    mv s7,a5
    0x84016df4     0x26    mv s8,a6
    0x84016df6     0x28    mv s4,a7
    0x84016df8     0x2a    ld a0,0(a0)
    0x84016dfa     0x2c    ld a1,8(s0)
    0x84016dfc     0x2e    jal ra,ffffffff840109e0 <cap_untyped_cap_get_capPtr>
    0x84016e00     0x32    mv s2,a0
    0x84016e02     0x34    beqz s1,ffffffff84016e52 <invokeUntyped_Retype+0x84>
    0x84016e04     0x36    ld a0,0(s0)
    0x84016e06     0x38    sd a0,0(sp)           ; stack access
    0x84016e08     0x3a    ld a1,8(s0)
    0x84016e0a     0x3c    sd a1,8(sp)           ; stack access
    0x84016e0c     0x3e    jal ra,ffffffff840103de <cap_untyped_cap_get_capFreeIndex>
    0x84016e10     0x42    slli s1,a0,0x4
    0x84016e14     0x46    beqz s1,ffffffff84016e52 <invokeUntyped_Retype+0x84>
    0x84016e16     0x48    ld a0,0(sp)           ; stack access
    0x84016e18     0x4a    ld a1,8(sp)           ; stack access
    0x84016e1a     0x4c    jal ra,ffffffff84010404 <cap_untyped_cap_get_capIsDevice>
    0x84016e1e     0x50    bnez a0,ffffffff84016e44 <invokeUntyped_Retype+0x76>
    0x84016e20     0x52    ld a0,0(sp)           ; stack access
    0x84016e22     0x54    ld a1,8(sp)           ; stack access
    0x84016e24     0x56    jal ra,ffffffff84010410 <cap_untyped_cap_get_capBlockSize>
    0x84016e28     0x5a    mv s10,a0
    0x84016e2a     0x5c    ld a0,0(sp)           ; stack access
    0x84016e2c     0x5e    ld a1,8(sp)           ; stack access
    0x84016e2e     0x60    jal ra,ffffffff840109e0 <cap_untyped_cap_get_capPtr>
    0x84016e32     0x64    mv s9,a0
    0x84016e34     0x66    li a5,7
    0x84016e36     0x68    bltu a5,s10,ffffffff84016ea6 <invokeUntyped_Retype+0xd8>
    0x84016e3a     0x6c    li a1,1
    0x84016e3c     0x6e    sll a1,a1,s10
    0x84016e40     0x72    jal ra,ffffffff840164dc <memzero>
    0x84016e44     0x76    li a2,0
    0x84016e46     0x78    ld a0,0(sp)           ; stack access
    0x84016e48     0x7a    ld a1,8(sp)           ; stack access
    0x84016e4a     0x7c    jal ra,ffffffff840103e8 <cap_untyped_cap_set_capFreeIndex>
    0x84016e4e     0x80    sd a0,0(s0)
    0x84016e50     0x82    sd a1,8(s0)
    0x84016e52     0x84    mv a1,s6
    0x84016e54     0x86    mv a0,s3
    0x84016e56     0x88    jal ra,ffffffff84012548 <getObjectSize>
    0x84016e5a     0x8c    sll a0,s4,a0
    0x84016e5e     0x90    sub s2,s5,s2
    0x84016e62     0x94    add s2,s2,a0
    0x84016e64     0x96    srli a2,s2,0x4
    0x84016e68     0x9a    ld a0,0(s0)
    0x84016e6a     0x9c    ld a1,8(s0)
    0x84016e6c     0x9e    jal ra,ffffffff840103e8 <cap_untyped_cap_set_capFreeIndex>
    0x84016e70     0xa2    sd a0,0(s0)
    0x84016e72     0xa4    sd a1,8(s0)
    0x84016e74     0xa6    ld a7,112(sp)         ; stack access
    0x84016e76     0xa8    mv a6,s6
    0x84016e78     0xaa    mv a5,s5
    0x84016e7a     0xac    mv a4,s4
    0x84016e7c     0xae    mv a3,s8
    0x84016e7e     0xb0    mv a2,s7
    0x84016e80     0xb2    mv a1,s0
    0x84016e82     0xb4    mv a0,s3
    0x84016e84     0xb6    jal ra,ffffffff84012e84 <createNewObjects>
    0x84016e88     0xba    li a0,0
    0x84016e8a     0xbc    ld ra,104(sp)         ; stack access
    0x84016e8c     0xbe    ld s0,96(sp)          ; stack access
    0x84016e8e     0xc0    ld s1,88(sp)          ; stack access
    0x84016e90     0xc2    ld s2,80(sp)          ; stack access
    0x84016e92     0xc4    ld s3,72(sp)          ; stack access
    0x84016e94     0xc6    ld s4,64(sp)          ; stack access
    0x84016e96     0xc8    ld s5,56(sp)          ; stack access
    0x84016e98     0xca    ld s6,48(sp)          ; stack access
    0x84016e9a     0xcc    ld s7,40(sp)          ; stack access
    0x84016e9c     0xce    ld s8,32(sp)          ; stack access
    0x84016e9e     0xd0    ld s9,24(sp)          ; stack access
    0x84016ea0     0xd2    ld s10,16(sp)         ; stack access
    0x84016ea2     0xd4    addi sp,sp,112
    0x84016ea4     0xd6    ret
    0x84016ea6     0xd8    addi s1,s1,-1
    0x84016ea8     0xda    andi s1,s1,-256
    0x84016eac     0xde    li a5,-256
    0x84016eb0     0xe2    beq s1,a5,ffffffff84016e52 <invokeUntyped_Retype+0x84>
    0x84016eb4     0xe6    li s10,-256
    0x84016eb8     0xea    li a1,256
    0x84016ebc     0xee    add a0,s1,s9
    0x84016ec0     0xf2    jal ra,ffffffff840164dc <memzero>
    0x84016ec4     0xf6    srli a2,s1,0x4
    0x84016ec8     0xfa    ld a0,0(sp)           ; stack access
    0x84016eca     0xfc    ld a1,8(sp)           ; stack access
    0x84016ecc     0xfe    jal ra,ffffffff840103e8 <cap_untyped_cap_set_capFreeIndex>
    0x84016ed0    0x102    sd a0,0(s0)
    0x84016ed2    0x104    sd a1,8(s0)
    0x84016ed4    0x106    jal ra,ffffffff84011e20 <preemptionPoint>
    0x84016ed8    0x10a    bnez a0,ffffffff84016e8a <invokeUntyped_Retype+0xbc>
    0x84016eda    0x10c    addi s1,s1,-256
    0x84016ede    0x110    bne s1,s10,ffffffff84016eb8 <invokeUntyped_Retype+0xea>
    0x84016ee2    0x114    j ffffffff84016e52 <invokeUntyped_Retype+0x84>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
111 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeUntyped_Retype` has 188 nodes.

Section decodeSetSpace (402 of 432)
===================================

Deriving specifications
-----------------------

Section `decodeSetSpace` consists of 145 instructions.


Stack analysis
---------------

60 stack accesses found. Annotated code for `decodeSetSpace`:

    0x84015a9e      0x0    addi sp,sp,-224
    0x84015aa0      0x2    sd ra,216(sp)         ; stack access
    0x84015aa2      0x4    sd s0,208(sp)         ; stack access
    0x84015aa4      0x6    sd s1,200(sp)         ; stack access
    0x84015aa6      0x8    sd s2,192(sp)         ; stack access
    0x84015aa8      0xa    sd s3,184(sp)         ; stack access
    0x84015aaa      0xc    sd s4,176(sp)         ; stack access
    0x84015aac      0xe    sd s5,168(sp)         ; stack access
    0x84015aae     0x10    sd s6,160(sp)         ; stack access
    0x84015ab0     0x12    sd a0,64(sp)          ; stack access
    0x84015ab2     0x14    sd a1,72(sp)          ; stack access
    0x84015ab4     0x16    li a5,2
    0x84015ab6     0x18    bgeu a5,a2,ffffffff84015bcc <decodeSetSpace+0x12e>
    0x84015aba     0x1c    mv s3,a3
    0x84015abc     0x1e    auipc s0,0x8
    0x84015ac0     0x22    ld s0,452(s0) # ffffffff8401dc80 <current_extra_caps>
    0x84015ac4     0x26    beqz s0,ffffffff84015bcc <decodeSetSpace+0x12e>
    0x84015ac8     0x2a    auipc s2,0x8
    0x84015acc     0x2e    ld s2,448(s2) # ffffffff8401dc88 <current_extra_caps+0x8>
    0x84015ad0     0x32    beqz s2,ffffffff84015bcc <decodeSetSpace+0x12e>
    0x84015ad4     0x36    auipc a5,0x19
    0x84015ad8     0x3a    ld a5,-60(a5) # ffffffff8402ea98 <ksCurThread>
    0x84015adc     0x3e    ld s5,88(a5)
    0x84015ae0     0x42    ld s4,96(a5)
    0x84015ae4     0x46    ld s6,104(a5)
    0x84015ae8     0x4a    ld a5,0(s0)
    0x84015aea     0x4c    sd a5,128(sp)         ; stack access
    0x84015aec     0x4e    ld a5,8(s0)
    0x84015aee     0x50    sd a5,136(sp)         ; stack access
    0x84015af0     0x52    ld a5,0(s2)
    0x84015af4     0x56    sd a5,112(sp)         ; stack access
    0x84015af6     0x58    ld a5,8(s2)
    0x84015afa     0x5c    sd a5,120(sp)         ; stack access
    0x84015afc     0x5e    ld a0,64(sp)          ; stack access
    0x84015afe     0x60    ld a1,72(sp)          ; stack access
    0x84015b00     0x62    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x84015b04     0x66    andi s1,a0,-1024
    0x84015b08     0x6a    mv a0,s1
    0x84015b0a     0x6c    jal ra,ffffffff84012b44 <slotCapLongRunningDelete>
    0x84015b0e     0x70    bnez a0,ffffffff84015bec <decodeSetSpace+0x14e>
    0x84015b12     0x74    addi a0,s1,32
    0x84015b16     0x78    jal ra,ffffffff84012b44 <slotCapLongRunningDelete>
    0x84015b1a     0x7c    bnez a0,ffffffff84015bec <decodeSetSpace+0x14e>
    0x84015b1c     0x7e    beqz s4,ffffffff84015b30 <decodeSetSpace+0x92>
    0x84015b20     0x82    ld a2,128(sp)         ; stack access
    0x84015b22     0x84    ld a3,136(sp)         ; stack access
    0x84015b24     0x86    mv a1,s4
    0x84015b26     0x88    li a0,0
    0x84015b28     0x8a    jal ra,ffffffff84012b8e <updateCapData>
    0x84015b2c     0x8e    sd a0,128(sp)         ; stack access
    0x84015b2e     0x90    sd a1,136(sp)         ; stack access
    0x84015b30     0x92    ld a2,128(sp)         ; stack access
    0x84015b32     0x94    ld a3,136(sp)         ; stack access
    0x84015b34     0x96    mv a1,s0
    0x84015b36     0x98    addi a0,sp,88
    0x84015b38     0x9a    jal ra,ffffffff840129da <deriveCap>
    0x84015b3c     0x9e    ld a0,88(sp)          ; stack access
    0x84015b3e     0xa0    bnez a0,ffffffff84015bd8 <decodeSetSpace+0x13a>
    0x84015b40     0xa2    ld a0,96(sp)          ; stack access
    0x84015b42     0xa4    sd a0,128(sp)         ; stack access
    0x84015b44     0xa6    ld a1,104(sp)         ; stack access
    0x84015b46     0xa8    sd a1,136(sp)         ; stack access
    0x84015b48     0xaa    jal ra,ffffffff8401039e <cap_get_capType>
    0x84015b4c     0xae    li a5,10
    0x84015b4e     0xb0    bne a0,a5,ffffffff84015bfa <decodeSetSpace+0x15c>
    0x84015b52     0xb4    beqz s6,ffffffff84015b66 <decodeSetSpace+0xc8>
    0x84015b56     0xb8    ld a2,112(sp)         ; stack access
    0x84015b58     0xba    ld a3,120(sp)         ; stack access
    0x84015b5a     0xbc    mv a1,s6
    0x84015b5c     0xbe    li a0,0
    0x84015b5e     0xc0    jal ra,ffffffff84012b8e <updateCapData>
    0x84015b62     0xc4    sd a0,112(sp)         ; stack access
    0x84015b64     0xc6    sd a1,120(sp)         ; stack access
    0x84015b66     0xc8    ld a2,112(sp)         ; stack access
    0x84015b68     0xca    ld a3,120(sp)         ; stack access
    0x84015b6a     0xcc    mv a1,s2
    0x84015b6c     0xce    addi a0,sp,88
    0x84015b6e     0xd0    jal ra,ffffffff840129da <deriveCap>
    0x84015b72     0xd4    ld a0,88(sp)          ; stack access
    0x84015b74     0xd6    bnez a0,ffffffff84015bd8 <decodeSetSpace+0x13a>
    0x84015b76     0xd8    ld a0,96(sp)          ; stack access
    0x84015b78     0xda    sd a0,112(sp)         ; stack access
    0x84015b7a     0xdc    ld a1,104(sp)         ; stack access
    0x84015b7c     0xde    sd a1,120(sp)         ; stack access
    0x84015b7e     0xe0    jal ra,ffffffff84011486 <isValidVTableRoot>
    0x84015b82     0xe4    beqz a0,ffffffff84015c08 <decodeSetSpace+0x16a>
    0x84015b84     0xe6    li a1,2
    0x84015b86     0xe8    auipc a0,0x19
    0x84015b8a     0xec    ld a0,-238(a0) # ffffffff8402ea98 <ksCurThread>
    0x84015b8e     0xf0    jal ra,ffffffff84013020 <setThreadState>
    0x84015b92     0xf4    ld a0,64(sp)          ; stack access
    0x84015b94     0xf6    ld a1,72(sp)          ; stack access
    0x84015b96     0xf8    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x84015b9a     0xfc    mv s1,a0
    0x84015b9c     0xfe    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84015ba0    0x102    li a5,4
    0x84015ba2    0x104    sd a5,56(sp)          ; stack access
    0x84015ba4    0x106    sd zero,48(sp)        ; stack access
    0x84015ba6    0x108    sd a0,32(sp)          ; stack access
    0x84015ba8    0x10a    sd a1,40(sp)          ; stack access
    0x84015baa    0x10c    sd zero,24(sp)        ; stack access
    0x84015bac    0x10e    sd s2,16(sp)          ; stack access
    0x84015bae    0x110    ld a5,112(sp)         ; stack access
    0x84015bb0    0x112    sd a5,0(sp)           ; stack access
    0x84015bb2    0x114    ld a5,120(sp)         ; stack access
    0x84015bb4    0x116    sd a5,8(sp)           ; stack access
    0x84015bb6    0x118    mv a7,s0
    0x84015bb8    0x11a    ld a5,128(sp)         ; stack access
    0x84015bba    0x11c    ld a6,136(sp)         ; stack access
    0x84015bbc    0x11e    li a4,0
    0x84015bbe    0x120    li a3,0
    0x84015bc0    0x122    mv a2,s5
    0x84015bc2    0x124    mv a1,s3
    0x84015bc4    0x126    mv a0,s1
    0x84015bc6    0x128    jal ra,ffffffff84015466 <invokeTCB_ThreadControl>
    0x84015bca    0x12c    j ffffffff84015bd8 <decodeSetSpace+0x13a>
    0x84015bcc    0x12e    li a5,7
    0x84015bce    0x130    auipc a4,0x8
    0x84015bd2    0x134    sd a5,170(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84015bd6    0x138    li a0,3
    0x84015bd8    0x13a    ld ra,216(sp)         ; stack access
    0x84015bda    0x13c    ld s0,208(sp)         ; stack access
    0x84015bdc    0x13e    ld s1,200(sp)         ; stack access
    0x84015bde    0x140    ld s2,192(sp)         ; stack access
    0x84015be0    0x142    ld s3,184(sp)         ; stack access
    0x84015be2    0x144    ld s4,176(sp)         ; stack access
    0x84015be4    0x146    ld s5,168(sp)         ; stack access
    0x84015be6    0x148    ld s6,160(sp)         ; stack access
    0x84015be8    0x14a    addi sp,sp,224
    0x84015bea    0x14c    ret
    0x84015bec    0x14e    li a5,3
    0x84015bee    0x150    auipc a4,0x8
    0x84015bf2    0x154    sd a5,138(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84015bf6    0x158    li a0,3
    0x84015bf8    0x15a    j ffffffff84015bd8 <decodeSetSpace+0x13a>
    0x84015bfa    0x15c    li a5,3
    0x84015bfc    0x15e    auipc a4,0x8
    0x84015c00    0x162    sd a5,124(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84015c04    0x166    li a0,3
    0x84015c06    0x168    j ffffffff84015bd8 <decodeSetSpace+0x13a>
    0x84015c08    0x16a    li a5,3
    0x84015c0a    0x16c    auipc a4,0x8
    0x84015c0e    0x170    sd a5,110(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84015c12    0x174    li a0,3
    0x84015c14    0x176    j ffffffff84015bd8 <decodeSetSpace+0x13a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
145 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetSpace` has 256 nodes.

Section decodeTCBConfigure (403 of 432)
=======================================

Deriving specifications
-----------------------

Section `decodeTCBConfigure` consists of 173 instructions.


Stack analysis
---------------

74 stack accesses found. Annotated code for `decodeTCBConfigure`:

    0x840155ba      0x0    addi sp,sp,-240
    0x840155bc      0x2    sd ra,232(sp)         ; stack access
    0x840155be      0x4    sd s0,224(sp)         ; stack access
    0x840155c0      0x6    sd s1,216(sp)         ; stack access
    0x840155c2      0x8    sd s2,208(sp)         ; stack access
    0x840155c4      0xa    sd s3,200(sp)         ; stack access
    0x840155c6      0xc    sd s4,192(sp)         ; stack access
    0x840155c8      0xe    sd s5,184(sp)         ; stack access
    0x840155ca     0x10    sd s6,176(sp)         ; stack access
    0x840155cc     0x12    sd s7,168(sp)         ; stack access
    0x840155ce     0x14    sd s8,160(sp)         ; stack access
    0x840155d0     0x16    sd a0,64(sp)          ; stack access
    0x840155d2     0x18    sd a1,72(sp)          ; stack access
    0x840155d4     0x1a    li a5,3
    0x840155d6     0x1c    bgeu a5,a2,ffffffff84015708 <decodeTCBConfigure+0x14e>
    0x840155da     0x20    mv s4,a3
    0x840155dc     0x22    auipc s0,0x8
    0x840155e0     0x26    ld s0,1700(s0) # ffffffff8401dc80 <current_extra_caps>
    0x840155e4     0x2a    beqz s0,ffffffff84015708 <decodeTCBConfigure+0x14e>
    0x840155e8     0x2e    auipc s2,0x8
    0x840155ec     0x32    ld s2,1696(s2) # ffffffff8401dc88 <current_extra_caps+0x8>
    0x840155f0     0x36    beqz s2,ffffffff84015708 <decodeTCBConfigure+0x14e>
    0x840155f4     0x3a    auipc s1,0x8
    0x840155f8     0x3e    ld s1,1692(s1) # ffffffff8401dc90 <current_extra_caps+0x10>
    0x840155fc     0x42    beqz s1,ffffffff84015708 <decodeTCBConfigure+0x14e>
    0x84015600     0x46    auipc a5,0x19
    0x84015604     0x4a    ld a5,1176(a5) # ffffffff8402ea98 <ksCurThread>
    0x84015608     0x4e    ld s7,88(a5)
    0x8401560c     0x52    ld s5,96(a5)
    0x84015610     0x56    ld s6,104(a5)
    0x84015614     0x5a    ld s8,112(a5)
    0x84015618     0x5e    ld a5,0(s0)
    0x8401561a     0x60    sd a5,128(sp)         ; stack access
    0x8401561c     0x62    ld a5,8(s0)
    0x8401561e     0x64    sd a5,136(sp)         ; stack access
    0x84015620     0x66    ld a5,0(s2)
    0x84015624     0x6a    sd a5,112(sp)         ; stack access
    0x84015626     0x6c    ld a5,8(s2)
    0x8401562a     0x70    sd a5,120(sp)         ; stack access
    0x8401562c     0x72    ld a5,0(s1)
    0x8401562e     0x74    sd a5,144(sp)         ; stack access
    0x84015630     0x76    ld a5,8(s1)
    0x84015632     0x78    sd a5,152(sp)         ; stack access
    0x84015634     0x7a    bnez s8,ffffffff8401572c <decodeTCBConfigure+0x172>
    0x84015638     0x7e    li s1,0
    0x8401563a     0x80    ld a0,64(sp)          ; stack access
    0x8401563c     0x82    ld a1,72(sp)          ; stack access
    0x8401563e     0x84    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x84015642     0x88    andi s3,a0,-1024
    0x84015646     0x8c    mv a0,s3
    0x84015648     0x8e    jal ra,ffffffff84012b44 <slotCapLongRunningDelete>
    0x8401564c     0x92    bnez a0,ffffffff84015750 <decodeTCBConfigure+0x196>
    0x84015650     0x96    addi a0,s3,32
    0x84015654     0x9a    jal ra,ffffffff84012b44 <slotCapLongRunningDelete>
    0x84015658     0x9e    bnez a0,ffffffff84015750 <decodeTCBConfigure+0x196>
    0x8401565c     0xa2    beqz s5,ffffffff84015670 <decodeTCBConfigure+0xb6>
    0x84015660     0xa6    ld a2,128(sp)         ; stack access
    0x84015662     0xa8    ld a3,136(sp)         ; stack access
    0x84015664     0xaa    mv a1,s5
    0x84015666     0xac    li a0,0
    0x84015668     0xae    jal ra,ffffffff84012b8e <updateCapData>
    0x8401566c     0xb2    sd a0,128(sp)         ; stack access
    0x8401566e     0xb4    sd a1,136(sp)         ; stack access
    0x84015670     0xb6    ld a2,128(sp)         ; stack access
    0x84015672     0xb8    ld a3,136(sp)         ; stack access
    0x84015674     0xba    mv a1,s0
    0x84015676     0xbc    addi a0,sp,88
    0x84015678     0xbe    jal ra,ffffffff840129da <deriveCap>
    0x8401567c     0xc2    ld a0,88(sp)          ; stack access
    0x8401567e     0xc4    bnez a0,ffffffff84015714 <decodeTCBConfigure+0x15a>
    0x84015680     0xc6    ld a0,96(sp)          ; stack access
    0x84015682     0xc8    sd a0,128(sp)         ; stack access
    0x84015684     0xca    ld a1,104(sp)         ; stack access
    0x84015686     0xcc    sd a1,136(sp)         ; stack access
    0x84015688     0xce    jal ra,ffffffff8401039e <cap_get_capType>
    0x8401568c     0xd2    li a5,10
    0x8401568e     0xd4    bne a0,a5,ffffffff8401575e <decodeTCBConfigure+0x1a4>
    0x84015692     0xd8    beqz s6,ffffffff840156a6 <decodeTCBConfigure+0xec>
    0x84015696     0xdc    ld a2,112(sp)         ; stack access
    0x84015698     0xde    ld a3,120(sp)         ; stack access
    0x8401569a     0xe0    mv a1,s6
    0x8401569c     0xe2    li a0,0
    0x8401569e     0xe4    jal ra,ffffffff84012b8e <updateCapData>
    0x840156a2     0xe8    sd a0,112(sp)         ; stack access
    0x840156a4     0xea    sd a1,120(sp)         ; stack access
    0x840156a6     0xec    ld a2,112(sp)         ; stack access
    0x840156a8     0xee    ld a3,120(sp)         ; stack access
    0x840156aa     0xf0    mv a1,s2
    0x840156ac     0xf2    addi a0,sp,88
    0x840156ae     0xf4    jal ra,ffffffff840129da <deriveCap>
    0x840156b2     0xf8    ld a0,88(sp)          ; stack access
    0x840156b4     0xfa    bnez a0,ffffffff84015714 <decodeTCBConfigure+0x15a>
    0x840156b6     0xfc    ld a0,96(sp)          ; stack access
    0x840156b8     0xfe    sd a0,112(sp)         ; stack access
    0x840156ba    0x100    ld a1,104(sp)         ; stack access
    0x840156bc    0x102    sd a1,120(sp)         ; stack access
    0x840156be    0x104    jal ra,ffffffff84011486 <isValidVTableRoot>
    0x840156c2    0x108    beqz a0,ffffffff8401576c <decodeTCBConfigure+0x1b2>
    0x840156c4    0x10a    li a1,2
    0x840156c6    0x10c    auipc a0,0x19
    0x840156ca    0x110    ld a0,978(a0) # ffffffff8402ea98 <ksCurThread>
    0x840156ce    0x114    jal ra,ffffffff84013020 <setThreadState>
    0x840156d2    0x118    ld a0,64(sp)          ; stack access
    0x840156d4    0x11a    ld a1,72(sp)          ; stack access
    0x840156d6    0x11c    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x840156da    0x120    li a5,6
    0x840156dc    0x122    sd a5,56(sp)          ; stack access
    0x840156de    0x124    sd s1,48(sp)          ; stack access
    0x840156e0    0x126    ld a5,144(sp)         ; stack access
    0x840156e2    0x128    sd a5,32(sp)          ; stack access
    0x840156e4    0x12a    ld a5,152(sp)         ; stack access
    0x840156e6    0x12c    sd a5,40(sp)          ; stack access
    0x840156e8    0x12e    sd s8,24(sp)          ; stack access
    0x840156ea    0x130    sd s2,16(sp)          ; stack access
    0x840156ec    0x132    ld a5,112(sp)         ; stack access
    0x840156ee    0x134    sd a5,0(sp)           ; stack access
    0x840156f0    0x136    ld a5,120(sp)         ; stack access
    0x840156f2    0x138    sd a5,8(sp)           ; stack access
    0x840156f4    0x13a    mv a7,s0
    0x840156f6    0x13c    ld a5,128(sp)         ; stack access
    0x840156f8    0x13e    ld a6,136(sp)         ; stack access
    0x840156fa    0x140    li a4,0
    0x840156fc    0x142    li a3,0
    0x840156fe    0x144    mv a2,s7
    0x84015700    0x146    mv a1,s4
    0x84015702    0x148    jal ra,ffffffff84015466 <invokeTCB_ThreadControl>
    0x84015706    0x14c    j ffffffff84015714 <decodeTCBConfigure+0x15a>
    0x84015708    0x14e    li a5,7
    0x8401570a    0x150    auipc a4,0x8
    0x8401570e    0x154    sd a5,1390(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84015712    0x158    li a0,3
    0x84015714    0x15a    ld ra,232(sp)         ; stack access
    0x84015716    0x15c    ld s0,224(sp)         ; stack access
    0x84015718    0x15e    ld s1,216(sp)         ; stack access
    0x8401571a    0x160    ld s2,208(sp)         ; stack access
    0x8401571c    0x162    ld s3,200(sp)         ; stack access
    0x8401571e    0x164    ld s4,192(sp)         ; stack access
    0x84015720    0x166    ld s5,184(sp)         ; stack access
    0x84015722    0x168    ld s6,176(sp)         ; stack access
    0x84015724    0x16a    ld s7,168(sp)         ; stack access
    0x84015726    0x16c    ld s8,160(sp)         ; stack access
    0x84015728    0x16e    addi sp,sp,240
    0x8401572a    0x170    ret
    0x8401572c    0x172    ld a2,144(sp)         ; stack access
    0x8401572e    0x174    mv a3,a5
    0x84015730    0x176    mv a1,s1
    0x84015732    0x178    addi a0,sp,88
    0x84015734    0x17a    jal ra,ffffffff840129da <deriveCap>
    0x84015738    0x17e    ld a0,88(sp)          ; stack access
    0x8401573a    0x180    bnez a0,ffffffff84015714 <decodeTCBConfigure+0x15a>
    0x8401573c    0x182    ld a1,96(sp)          ; stack access
    0x8401573e    0x184    sd a1,144(sp)         ; stack access
    0x84015740    0x186    ld a2,104(sp)         ; stack access
    0x84015742    0x188    sd a2,152(sp)         ; stack access
    0x84015744    0x18a    mv a0,s8
    0x84015746    0x18c    jal ra,ffffffff840114ae <checkValidIPCBuffer>
    0x8401574a    0x190    beqz a0,ffffffff8401563a <decodeTCBConfigure+0x80>
    0x8401574e    0x194    j ffffffff84015714 <decodeTCBConfigure+0x15a>
    0x84015750    0x196    li a5,3
    0x84015752    0x198    auipc a4,0x8
    0x84015756    0x19c    sd a5,1318(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x8401575a    0x1a0    li a0,3
    0x8401575c    0x1a2    j ffffffff84015714 <decodeTCBConfigure+0x15a>
    0x8401575e    0x1a4    li a5,3
    0x84015760    0x1a6    auipc a4,0x8
    0x84015764    0x1aa    sd a5,1304(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84015768    0x1ae    li a0,3
    0x8401576a    0x1b0    j ffffffff84015714 <decodeTCBConfigure+0x15a>
    0x8401576c    0x1b2    li a5,3
    0x8401576e    0x1b4    auipc a4,0x8
    0x84015772    0x1b8    sd a5,1290(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84015776    0x1bc    li a0,3
    0x84015778    0x1be    j ffffffff84015714 <decodeTCBConfigure+0x15a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
173 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeTCBConfigure` has 311 nodes.

Section handleSyscall (404 of 432)
==================================

Deriving specifications
-----------------------

Section `handleSyscall` consists of 103 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleSyscall`:

    0x84017500      0x0    addi sp,sp,-16
    0x84017502      0x2    sd ra,8(sp)           ; stack access
    0x84017504      0x4    sd s0,0(sp)           ; stack access
    0x84017506      0x6    addi a0,a0,8
    0x84017508      0x8    li a5,7
    0x8401750a      0xa    bltu a5,a0,ffffffff84017644 <handleSyscall+0x144>
    0x8401750e      0xe    slli a0,a0,0x2
    0x84017510     0x10    auipc a4,0x1
    0x84017514     0x14    addi a4,a4,-608 # ffffffff840182b0 <ksDomScheduleLength+0x368>
    0x84017518     0x18    add a0,a0,a4
    0x8401751a     0x1a    lw a5,0(a0)
    0x8401751c     0x1c    add a5,a5,a4
    0x8401751e     0x1e    jr a5
    0x84017520     0x20    li a1,1
    0x84017522     0x22    li a0,0
    0x84017524     0x24    jal ra,ffffffff840173c6 <handleInvocation>
    0x84017528     0x28    beqz a0,ffffffff840175fe <handleSyscall+0xfe>
    0x8401752a     0x2a    auipc a4,0x1
    0x8401752e     0x2e    lw a4,1246(a4) # ffffffff84018a08 <active_irq>
    0x84017532     0x32    addiw a3,a4,-1
    0x84017536     0x36    li a5,53
    0x8401753a     0x3a    bltu a5,a3,ffffffff8401754a <handleSyscall+0x4a>
    0x8401753e     0x3e    slli a0,a4,0x20
    0x84017542     0x42    srli a0,a0,0x20
    0x84017544     0x44    jal ra,ffffffff84014780 <handleInterrupt>
    0x84017548     0x48    j ffffffff840175fe <handleSyscall+0xfe>
    0x8401754a     0x4a    jal ra,ffffffff84010986 <getNewActiveIRQ>
    0x8401754e     0x4e    sext.w a4,a0
    0x84017552     0x52    auipc a5,0x1
    0x84017556     0x56    sw a0,1206(a5) # ffffffff84018a08 <active_irq>
    0x8401755a     0x5a    addiw a5,a0,-1
    0x8401755e     0x5e    li a3,53
    0x84017562     0x62    bltu a3,a5,ffffffff840175fe <handleSyscall+0xfe>
    0x84017566     0x66    j ffffffff8401753e <handleSyscall+0x3e>
    0x84017568     0x68    li a1,0
    0x8401756a     0x6a    li a0,0
    0x8401756c     0x6c    jal ra,ffffffff840173c6 <handleInvocation>
    0x84017570     0x70    beqz a0,ffffffff840175fe <handleSyscall+0xfe>
    0x84017572     0x72    auipc a4,0x1
    0x84017576     0x76    lw a4,1174(a4) # ffffffff84018a08 <active_irq>
    0x8401757a     0x7a    addiw a3,a4,-1
    0x8401757e     0x7e    li a5,53
    0x84017582     0x82    bltu a5,a3,ffffffff84017592 <handleSyscall+0x92>
    0x84017586     0x86    slli a0,a4,0x20
    0x8401758a     0x8a    srli a0,a0,0x20
    0x8401758c     0x8c    jal ra,ffffffff84014780 <handleInterrupt>
    0x84017590     0x90    j ffffffff840175fe <handleSyscall+0xfe>
    0x84017592     0x92    jal ra,ffffffff84010986 <getNewActiveIRQ>
    0x84017596     0x96    sext.w a4,a0
    0x8401759a     0x9a    auipc a5,0x1
    0x8401759e     0x9e    sw a0,1134(a5) # ffffffff84018a08 <active_irq>
    0x840175a2     0xa2    addiw a5,a0,-1
    0x840175a6     0xa6    li a3,53
    0x840175aa     0xaa    bltu a3,a5,ffffffff840175fe <handleSyscall+0xfe>
    0x840175ae     0xae    j ffffffff84017586 <handleSyscall+0x86>
    0x840175b0     0xb0    li a1,1
    0x840175b2     0xb2    li a0,1
    0x840175b4     0xb4    jal ra,ffffffff840173c6 <handleInvocation>
    0x840175b8     0xb8    beqz a0,ffffffff840175fe <handleSyscall+0xfe>
    0x840175ba     0xba    auipc a4,0x1
    0x840175be     0xbe    lw a4,1102(a4) # ffffffff84018a08 <active_irq>
    0x840175c2     0xc2    addiw a3,a4,-1
    0x840175c6     0xc6    li a5,53
    0x840175ca     0xca    bltu a5,a3,ffffffff840175da <handleSyscall+0xda>
    0x840175ce     0xce    slli a0,a4,0x20
    0x840175d2     0xd2    srli a0,a0,0x20
    0x840175d4     0xd4    jal ra,ffffffff84014780 <handleInterrupt>
    0x840175d8     0xd8    j ffffffff840175fe <handleSyscall+0xfe>
    0x840175da     0xda    jal ra,ffffffff84010986 <getNewActiveIRQ>
    0x840175de     0xde    sext.w a4,a0
    0x840175e2     0xe2    auipc a5,0x1
    0x840175e6     0xe6    sw a0,1062(a5) # ffffffff84018a08 <active_irq>
    0x840175ea     0xea    addiw a5,a0,-1
    0x840175ee     0xee    li a3,53
    0x840175f2     0xf2    bltu a3,a5,ffffffff840175fe <handleSyscall+0xfe>
    0x840175f6     0xf6    j ffffffff840175ce <handleSyscall+0xce>
    0x840175f8     0xf8    li a0,1
    0x840175fa     0xfa    jal ra,ffffffff8401523a <handleRecv>
    0x840175fe     0xfe    jal ra,ffffffff840136b0 <schedule>
    0x84017602    0x102    jal ra,ffffffff84013112 <activateThread>
    0x84017606    0x106    li a0,0
    0x84017608    0x108    ld ra,8(sp)
    0x8401760a    0x10a    ld s0,0(sp)
    0x8401760c    0x10c    addi sp,sp,16
    0x8401760e    0x10e    ret
    0x84017610    0x110    jal ra,ffffffff84014ce4 <handleReply>
    0x84017614    0x114    j ffffffff840175fe <handleSyscall+0xfe>
    0x84017616    0x116    jal ra,ffffffff84014ce4 <handleReply>
    0x8401761a    0x11a    li a0,1
    0x8401761c    0x11c    jal ra,ffffffff8401523a <handleRecv>
    0x84017620    0x120    j ffffffff840175fe <handleSyscall+0xfe>
    0x84017622    0x122    li a0,0
    0x84017624    0x124    jal ra,ffffffff8401523a <handleRecv>
    0x84017628    0x128    j ffffffff840175fe <handleSyscall+0xfe>
    0x8401762a    0x12a    auipc s0,0x17
    0x8401762e    0x12e    addi s0,s0,1134 # ffffffff8402ea98 <ksCurThread>
    0x84017632    0x132    ld a0,0(s0)
    0x84017634    0x134    jal ra,ffffffff840134d2 <tcbSchedDequeue>
    0x84017638    0x138    ld a0,0(s0)
    0x8401763a    0x13a    jal ra,ffffffff840133ba <tcbSchedAppend>
    0x8401763e    0x13e    jal ra,ffffffff84012fa8 <rescheduleRequired>
    0x84017642    0x142    j ffffffff840175fe <handleSyscall+0xfe>
    0x84017644    0x144    jal ra,ffffffff84010cec <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
103 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleSyscall` has 158 nodes.

Section sendFaultIPC (405 of 432)
=================================

Deriving specifications
-----------------------

Section `sendFaultIPC` consists of 102 instructions.


Stack analysis
---------------

29 stack accesses found. Annotated code for `sendFaultIPC`:

    0x84014eae      0x0    addi sp,sp,-96
    0x84014eb0      0x2    sd ra,88(sp)          ; stack access
    0x84014eb2      0x4    sd s0,80(sp)          ; stack access
    0x84014eb4      0x6    sd s1,72(sp)          ; stack access
    0x84014eb6      0x8    sd s2,64(sp)          ; stack access
    0x84014eb8      0xa    sd s3,56(sp)          ; stack access
    0x84014eba      0xc    sd s4,48(sp)          ; stack access
    0x84014ebc      0xe    mv s0,a0
    0x84014ebe     0x10    auipc a5,0x9
    0x84014ec2     0x14    addi a5,a5,-654 # ffffffff8401dc30 <current_lookup_fault>
    0x84014ec6     0x18    ld s4,0(a5)
    0x84014eca     0x1c    ld s3,8(a5)
    0x84014ece     0x20    ld s2,376(a0)
    0x84014ed2     0x24    mv a2,s2
    0x84014ed4     0x26    mv a1,a0
    0x84014ed6     0x28    addi a0,sp,8
    0x84014ed8     0x2a    jal ra,ffffffff84011bfa <lookupCap>
    0x84014edc     0x2e    ld s1,8(sp)           ; stack access
    0x84014ede     0x30    bnez s1,ffffffff84014f5e <sendFaultIPC+0xb0>
    0x84014ee0     0x32    ld a0,16(sp)          ; stack access
    0x84014ee2     0x34    sd a0,32(sp)          ; stack access
    0x84014ee4     0x36    ld a1,24(sp)          ; stack access
    0x84014ee6     0x38    sd a1,40(sp)          ; stack access
    0x84014ee8     0x3a    jal ra,ffffffff8401039e <cap_get_capType>
    0x84014eec     0x3e    li a5,4
    0x84014eee     0x40    bne a0,a5,ffffffff84014f80 <sendFaultIPC+0xd2>
    0x84014ef2     0x44    ld a0,32(sp)          ; stack access
    0x84014ef4     0x46    ld a1,40(sp)          ; stack access
    0x84014ef6     0x48    jal ra,ffffffff840104b0 <cap_endpoint_cap_get_capCanSend>
    0x84014efa     0x4c    beqz a0,ffffffff84014f80 <sendFaultIPC+0xd2>
    0x84014efc     0x4e    ld a0,32(sp)          ; stack access
    0x84014efe     0x50    ld a1,40(sp)          ; stack access
    0x84014f00     0x52    jal ra,ffffffff84010474 <cap_endpoint_cap_get_capCanGrant>
    0x84014f04     0x56    bnez a0,ffffffff84014f10 <sendFaultIPC+0x62>
    0x84014f06     0x58    ld a0,32(sp)          ; stack access
    0x84014f08     0x5a    ld a1,40(sp)          ; stack access
    0x84014f0a     0x5c    jal ra,ffffffff84010456 <cap_endpoint_cap_get_capCanGrantReply>
    0x84014f0e     0x60    beqz a0,ffffffff84014f80 <sendFaultIPC+0xd2>
    0x84014f10     0x62    auipc a5,0x8
    0x84014f14     0x66    addi a5,a5,-1808 # ffffffff8401c800 <current_fault>
    0x84014f18     0x6a    ld a0,0(a5)
    0x84014f1a     0x6c    sd a0,312(s0)
    0x84014f1e     0x70    ld a1,8(a5)
    0x84014f20     0x72    sd a1,320(s0)
    0x84014f24     0x76    jal ra,ffffffff8401084a <seL4_Fault_get_seL4_FaultType>
    0x84014f28     0x7a    li a5,1
    0x84014f2a     0x7c    beq a0,a5,ffffffff84014f76 <sendFaultIPC+0xc8>
    0x84014f2e     0x80    ld a0,32(sp)          ; stack access
    0x84014f30     0x82    ld a1,40(sp)          ; stack access
    0x84014f32     0x84    jal ra,ffffffff84010446 <cap_endpoint_cap_get_capEPBadge>
    0x84014f36     0x88    mv s2,a0
    0x84014f38     0x8a    ld a0,32(sp)          ; stack access
    0x84014f3a     0x8c    ld a1,40(sp)          ; stack access
    0x84014f3c     0x8e    jal ra,ffffffff84010474 <cap_endpoint_cap_get_capCanGrant>
    0x84014f40     0x92    mv s3,a0
    0x84014f42     0x94    ld a0,32(sp)          ; stack access
    0x84014f44     0x96    ld a1,40(sp)          ; stack access
    0x84014f46     0x98    jal ra,ffffffff840109fe <cap_endpoint_cap_get_capEPPtr>
    0x84014f4a     0x9c    mv a6,a0
    0x84014f4c     0x9e    mv a5,s0
    0x84014f4e     0xa0    li a4,1
    0x84014f50     0xa2    mv a3,s3
    0x84014f52     0xa4    mv a2,s2
    0x84014f54     0xa6    li a1,1
    0x84014f56     0xa8    li a0,1
    0x84014f58     0xaa    jal ra,ffffffff84014d68 <sendIPC>
    0x84014f5c     0xae    j ffffffff84014fa8 <sendFaultIPC+0xfa>
    0x84014f5e     0xb0    li a1,0
    0x84014f60     0xb2    mv a0,s2
    0x84014f62     0xb4    jal ra,ffffffff8401085c <seL4_Fault_CapFault_new>
    0x84014f66     0xb8    auipc a5,0x8
    0x84014f6a     0xbc    addi a5,a5,-1894 # ffffffff8401c800 <current_fault>
    0x84014f6e     0xc0    sd a0,0(a5)
    0x84014f70     0xc2    sd a1,8(a5)
    0x84014f72     0xc4    li s1,1
    0x84014f74     0xc6    j ffffffff84014fa8 <sendFaultIPC+0xfa>
    0x84014f76     0xc8    sd s4,328(s0)
    0x84014f7a     0xcc    sd s3,336(s0)
    0x84014f7e     0xd0    j ffffffff84014f2e <sendFaultIPC+0x80>
    0x84014f80     0xd2    li a1,0
    0x84014f82     0xd4    mv a0,s2
    0x84014f84     0xd6    jal ra,ffffffff8401085c <seL4_Fault_CapFault_new>
    0x84014f88     0xda    auipc a5,0x8
    0x84014f8c     0xde    addi a5,a5,-1928 # ffffffff8401c800 <current_fault>
    0x84014f90     0xe2    sd a0,0(a5)
    0x84014f92     0xe4    sd a1,8(a5)
    0x84014f94     0xe6    li a0,0
    0x84014f96     0xe8    jal ra,ffffffff840107ba <lookup_fault_missing_capability_new>
    0x84014f9a     0xec    auipc a5,0x9
    0x84014f9e     0xf0    addi a5,a5,-874 # ffffffff8401dc30 <current_lookup_fault>
    0x84014fa2     0xf4    sd a0,0(a5)
    0x84014fa4     0xf6    sd a1,8(a5)
    0x84014fa6     0xf8    li s1,1
    0x84014fa8     0xfa    mv a0,s1
    0x84014faa     0xfc    ld ra,88(sp)          ; stack access
    0x84014fac     0xfe    ld s0,80(sp)          ; stack access
    0x84014fae    0x100    ld s1,72(sp)          ; stack access
    0x84014fb0    0x102    ld s2,64(sp)          ; stack access
    0x84014fb2    0x104    ld s3,56(sp)          ; stack access
    0x84014fb4    0x106    ld s4,48(sp)          ; stack access
    0x84014fb6    0x108    addi sp,sp,96
    0x84014fb8    0x10a    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
102 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sendFaultIPC` has 172 nodes.

Section cteDelete (406 of 432)
==============================

Deriving specifications
-----------------------

Section `cteDelete` consists of 260 instructions.


Stack analysis
---------------

67 stack accesses found. Annotated code for `cteDelete`:

    0x84013d20      0x0    addi sp,sp,-240
    0x84013d22      0x2    sd ra,232(sp)         ; stack access
    0x84013d24      0x4    sd s0,224(sp)         ; stack access
    0x84013d26      0x6    sd s1,216(sp)         ; stack access
    0x84013d28      0x8    sd s2,208(sp)         ; stack access
    0x84013d2a      0xa    sd s3,200(sp)         ; stack access
    0x84013d2c      0xc    sd s4,192(sp)         ; stack access
    0x84013d2e      0xe    sd s5,184(sp)         ; stack access
    0x84013d30     0x10    sd s6,176(sp)         ; stack access
    0x84013d32     0x12    sd s7,168(sp)         ; stack access
    0x84013d34     0x14    sd s8,160(sp)         ; stack access
    0x84013d36     0x16    sd s9,152(sp)         ; stack access
    0x84013d38     0x18    sd s10,144(sp)        ; stack access
    0x84013d3a     0x1a    mv s0,a0
    0x84013d3c     0x1c    mv s5,a1
    0x84013d3e     0x1e    li s7,18
    0x84013d40     0x20    li s3,64
    0x84013d44     0x24    li s6,4
    0x84013d46     0x26    li s8,-1
    0x84013d48     0x28    li s4,1
    0x84013d4a     0x2a    j ffffffff84013dd8 <cteDelete+0xb8>
    0x84013d4c     0x2c    mv s1,s6
    0x84013d4e     0x2e    j ffffffff84013e1e <cteDelete+0xfe>
    0x84013d50     0x30    mv s2,s6
    0x84013d52     0x32    j ffffffff84013e46 <cteDelete+0x126>
    0x84013d54     0x34    addiw s2,s2,1
    0x84013d56     0x36    sll s2,s4,s2
    0x84013d5a     0x3a    neg s2,s2
    0x84013d5e     0x3e    and a0,s2,a0
    0x84013d62     0x42    sub a0,s0,a0
    0x84013d66     0x46    seqz a5,a0
    0x84013d6a     0x4a    j ffffffff84013e58 <cteDelete+0x138>
    0x84013d6c     0x4c    jal ra,ffffffff84010cec <halt>
    0x84013d70     0x50    ld a5,48(sp)          ; stack access
    0x84013d72     0x52    sd a5,112(sp)         ; stack access
    0x84013d74     0x54    ld a5,56(sp)          ; stack access
    0x84013d76     0x56    sd a5,120(sp)         ; stack access
    0x84013d78     0x58    j ffffffff84013fb6 <cteDelete+0x296>
    0x84013d7a     0x5a    ld a0,0(sp)           ; stack access
    0x84013d7c     0x5c    sd a0,16(sp)          ; stack access
    0x84013d7e     0x5e    ld a1,8(sp)           ; stack access
    0x84013d80     0x60    sd a1,24(sp)          ; stack access
    0x84013d82     0x62    jal ra,ffffffff8401063e <cap_zombie_cap_get_capZombieType>
    0x84013d86     0x66    beq a0,s3,ffffffff84013daa <cteDelete+0x8a>
    0x84013d8a     0x6a    andi s1,a0,63
    0x84013d8e     0x6e    ld a0,16(sp)          ; stack access
    0x84013d90     0x70    ld a1,24(sp)          ; stack access
    0x84013d92     0x72    jal ra,ffffffff8401062e <cap_zombie_cap_get_capZombieID>
    0x84013d96     0x76    addiw s1,s1,1
    0x84013d98     0x78    sll s1,s4,s1
    0x84013d9c     0x7c    neg s1,s1
    0x84013da0     0x80    and s1,s1,a0
    0x84013da2     0x82    bne s0,s1,ffffffff84013e78 <cteDelete+0x158>
    0x84013da6     0x86    mv s9,s5
    0x84013da8     0x88    j ffffffff84013fc2 <cteDelete+0x2a2>
    0x84013daa     0x8a    mv s1,s6
    0x84013dac     0x8c    j ffffffff84013d8e <cteDelete+0x6e>
    0x84013dae     0x8e    mv s1,s6
    0x84013db0     0x90    j ffffffff84013e8c <cteDelete+0x16c>
    0x84013db2     0x92    mv s2,s6
    0x84013db4     0x94    j ffffffff84013eb4 <cteDelete+0x194>
    0x84013db6     0x96    mv s9,s6
    0x84013db8     0x98    j ffffffff84013f10 <cteDelete+0x1f0>
    0x84013dba     0x9a    mv s1,s6
    0x84013dbc     0x9c    j ffffffff84013f3e <cteDelete+0x21e>
    0x84013dbe     0x9e    mv s1,s6
    0x84013dc0     0xa0    j ffffffff84013f7a <cteDelete+0x25a>
    0x84013dc2     0xa2    jal ra,ffffffff84010cec <halt>
    0x84013dc6     0xa6    mv a1,s0
    0x84013dc8     0xa8    mv a0,s1
    0x84013dca     0xaa    jal ra,ffffffff84012176 <capSwapForDelete>
    0x84013dce     0xae    jal ra,ffffffff84011e20 <preemptionPoint>
    0x84013dd2     0xb2    mv s9,a0
    0x84013dd4     0xb4    bnez a0,ffffffff84013fc2 <cteDelete+0x2a2>
    0x84013dd8     0xb8    ld a0,0(s0)
    0x84013dda     0xba    ld a1,8(s0)
    0x84013ddc     0xbc    jal ra,ffffffff8401039e <cap_get_capType>
    0x84013de0     0xc0    beqz a0,ffffffff84013fae <cteDelete+0x28e>
    0x84013de4     0xc4    mv a0,s0
    0x84013de6     0xc6    jal ra,ffffffff84012af4 <isFinalCapability>
    0x84013dea     0xca    mv a3,a0
    0x84013dec     0xcc    li a4,0
    0x84013dee     0xce    ld a1,0(s0)
    0x84013df0     0xd0    ld a2,8(s0)
    0x84013df2     0xd2    addi a0,sp,32
    0x84013df4     0xd4    jal ra,ffffffff84013b48 <finaliseCap>
    0x84013df8     0xd8    ld a0,32(sp)          ; stack access
    0x84013dfa     0xda    sd a0,0(sp)           ; stack access
    0x84013dfc     0xdc    ld a1,40(sp)          ; stack access
    0x84013dfe     0xde    sd a1,8(sp)           ; stack access
    0x84013e00     0xe0    jal ra,ffffffff8401039e <cap_get_capType>
    0x84013e04     0xe4    beqz a0,ffffffff84013d70 <cteDelete+0x50>
    0x84013e06     0xe6    bne a0,s7,ffffffff84013d6c <cteDelete+0x4c>
    0x84013e0a     0xea    ld a0,0(sp)           ; stack access
    0x84013e0c     0xec    sd a0,16(sp)          ; stack access
    0x84013e0e     0xee    ld a1,8(sp)           ; stack access
    0x84013e10     0xf0    sd a1,24(sp)          ; stack access
    0x84013e12     0xf2    jal ra,ffffffff8401063e <cap_zombie_cap_get_capZombieType>
    0x84013e16     0xf6    beq a0,s3,ffffffff84013d4c <cteDelete+0x2c>
    0x84013e1a     0xfa    andi s1,a0,63
    0x84013e1e     0xfe    ld a0,16(sp)          ; stack access
    0x84013e20    0x100    ld a1,24(sp)          ; stack access
    0x84013e22    0x102    jal ra,ffffffff8401062e <cap_zombie_cap_get_capZombieID>
    0x84013e26    0x106    addiw s1,s1,1
    0x84013e28    0x108    sll s1,s8,s1
    0x84013e2c    0x10c    not s1,s1
    0x84013e30    0x110    and s1,s1,a0
    0x84013e32    0x112    ld a0,0(sp)           ; stack access
    0x84013e34    0x114    sd a0,16(sp)          ; stack access
    0x84013e36    0x116    ld a1,8(sp)           ; stack access
    0x84013e38    0x118    sd a1,24(sp)          ; stack access
    0x84013e3a    0x11a    jal ra,ffffffff8401063e <cap_zombie_cap_get_capZombieType>
    0x84013e3e    0x11e    beq a0,s3,ffffffff84013d50 <cteDelete+0x30>
    0x84013e42    0x122    andi s2,a0,63
    0x84013e46    0x126    ld a0,16(sp)          ; stack access
    0x84013e48    0x128    ld a1,24(sp)          ; stack access
    0x84013e4a    0x12a    jal ra,ffffffff8401062e <cap_zombie_cap_get_capZombieID>
    0x84013e4e    0x12e    mv a5,s4
    0x84013e50    0x130    beqz s1,ffffffff84013e58 <cteDelete+0x138>
    0x84013e52    0x132    li a5,0
    0x84013e54    0x134    beq s1,s4,ffffffff84013d54 <cteDelete+0x34>
    0x84013e58    0x138    bnez a5,ffffffff84013d70 <cteDelete+0x50>
    0x84013e5c    0x13c    ld a5,32(sp)          ; stack access
    0x84013e5e    0x13e    sd a5,0(s0)
    0x84013e60    0x140    ld a5,40(sp)          ; stack access
    0x84013e62    0x142    sd a5,8(s0)
    0x84013e64    0x144    bnez s5,ffffffff84013e78 <cteDelete+0x158>
    0x84013e68    0x148    ld a0,32(sp)          ; stack access
    0x84013e6a    0x14a    sd a0,0(sp)           ; stack access
    0x84013e6c    0x14c    mv a1,a5
    0x84013e6e    0x14e    sd a5,8(sp)           ; stack access
    0x84013e70    0x150    jal ra,ffffffff8401039e <cap_get_capType>
    0x84013e74    0x154    beq a0,s7,ffffffff84013d7a <cteDelete+0x5a>
    0x84013e78    0x158    ld a0,0(s0)
    0x84013e7a    0x15a    sd a0,16(sp)          ; stack access
    0x84013e7c    0x15c    ld a1,8(s0)
    0x84013e7e    0x15e    sd a1,24(sp)          ; stack access
    0x84013e80    0x160    jal ra,ffffffff8401063e <cap_zombie_cap_get_capZombieType>
    0x84013e84    0x164    beq a0,s3,ffffffff84013dae <cteDelete+0x8e>
    0x84013e88    0x168    andi s1,a0,63
    0x84013e8c    0x16c    ld a0,16(sp)          ; stack access
    0x84013e8e    0x16e    ld a1,24(sp)          ; stack access
    0x84013e90    0x170    jal ra,ffffffff8401062e <cap_zombie_cap_get_capZombieID>
    0x84013e94    0x174    addiw s1,s1,1
    0x84013e96    0x176    sll s1,s4,s1
    0x84013e9a    0x17a    neg s1,s1
    0x84013e9e    0x17e    and s1,s1,a0
    0x84013ea0    0x180    ld a0,0(s0)
    0x84013ea2    0x182    sd a0,16(sp)          ; stack access
    0x84013ea4    0x184    ld a1,8(s0)
    0x84013ea6    0x186    sd a1,24(sp)          ; stack access
    0x84013ea8    0x188    jal ra,ffffffff8401063e <cap_zombie_cap_get_capZombieType>
    0x84013eac    0x18c    beq a0,s3,ffffffff84013db2 <cteDelete+0x92>
    0x84013eb0    0x190    andi s2,a0,63
    0x84013eb4    0x194    ld a0,16(sp)          ; stack access
    0x84013eb6    0x196    ld a1,24(sp)          ; stack access
    0x84013eb8    0x198    jal ra,ffffffff8401062e <cap_zombie_cap_get_capZombieID>
    0x84013ebc    0x19c    beqz s5,ffffffff84013dc6 <cteDelete+0xa6>
    0x84013ec0    0x1a0    addiw s2,s2,1
    0x84013ec2    0x1a2    sll s2,s8,s2
    0x84013ec6    0x1a6    not s2,s2
    0x84013eca    0x1aa    and s2,s2,a0
    0x84013ece    0x1ae    ld a0,0(s0)
    0x84013ed0    0x1b0    ld a1,8(s0)
    0x84013ed2    0x1b2    jal ra,ffffffff8401063e <cap_zombie_cap_get_capZombieType>
    0x84013ed6    0x1b6    mv s10,a0
    0x84013ed8    0x1b8    slli a0,s2,0x5
    0x84013edc    0x1bc    addi a0,a0,-32
    0x84013ede    0x1be    li a1,0
    0x84013ee0    0x1c0    add a0,a0,s1
    0x84013ee2    0x1c2    jal ra,ffffffff84013d20 <cteDelete>
    0x84013ee6    0x1c6    mv s9,a0
    0x84013ee8    0x1c8    bnez a0,ffffffff84013fc2 <cteDelete+0x2a2>
    0x84013eec    0x1cc    ld a0,0(s0)
    0x84013eee    0x1ce    ld a1,8(s0)
    0x84013ef0    0x1d0    jal ra,ffffffff8401039e <cap_get_capType>
    0x84013ef4    0x1d4    beqz a0,ffffffff84013dce <cteDelete+0xae>
    0x84013ef8    0x1d8    bne a0,s7,ffffffff84013dc2 <cteDelete+0xa2>
    0x84013efc    0x1dc    ld a0,0(s0)
    0x84013efe    0x1de    sd a0,16(sp)
    0x84013f00    0x1e0    ld a1,8(s0)
    0x84013f02    0x1e2    sd a1,24(sp)
    0x84013f04    0x1e4    jal ra,ffffffff8401063e <cap_zombie_cap_get_capZombieType>
    0x84013f08    0x1e8    beq a0,s3,ffffffff84013db6 <cteDelete+0x96>
    0x84013f0c    0x1ec    andi s9,a0,63
    0x84013f10    0x1f0    ld a0,16(sp)
    0x84013f12    0x1f2    ld a1,24(sp)
    0x84013f14    0x1f4    jal ra,ffffffff8401062e <cap_zombie_cap_get_capZombieID>
    0x84013f18    0x1f8    addiw s9,s9,1
    0x84013f1a    0x1fa    sll s9,s4,s9
    0x84013f1e    0x1fe    neg s9,s9
    0x84013f22    0x202    and s9,s9,a0
    0x84013f26    0x206    bne s1,s9,ffffffff84013dce <cteDelete+0xae>
    0x84013f2a    0x20a    ld a0,0(s0)
    0x84013f2c    0x20c    sd a0,16(sp)
    0x84013f2e    0x20e    ld a1,8(s0)
    0x84013f30    0x210    sd a1,24(sp)
    0x84013f32    0x212    jal ra,ffffffff8401063e <cap_zombie_cap_get_capZombieType>
    0x84013f36    0x216    beq a0,s3,ffffffff84013dba <cteDelete+0x9a>
    0x84013f3a    0x21a    andi s1,a0,63
    0x84013f3e    0x21e    ld a0,16(sp)
    0x84013f40    0x220    ld a1,24(sp)
    0x84013f42    0x222    jal ra,ffffffff8401062e <cap_zombie_cap_get_capZombieID>
    0x84013f46    0x226    addiw a5,s1,1
    0x84013f4a    0x22a    sll a5,s8,a5
    0x84013f4e    0x22e    not a5,a5
    0x84013f52    0x232    and a5,a5,a0
    0x84013f54    0x234    bne s2,a5,ffffffff84013dce <cteDelete+0xae>
    0x84013f58    0x238    ld a0,0(s0)
    0x84013f5a    0x23a    ld a1,8(s0)
    0x84013f5c    0x23c    jal ra,ffffffff8401063e <cap_zombie_cap_get_capZombieType>
    0x84013f60    0x240    bne s10,a0,ffffffff84013dce <cteDelete+0xae>
    0x84013f64    0x244    addi s2,s2,-1
    0x84013f66    0x246    ld a0,0(s0)
    0x84013f68    0x248    sd a0,16(sp)
    0x84013f6a    0x24a    ld a1,8(s0)
    0x84013f6c    0x24c    sd a1,24(sp)
    0x84013f6e    0x24e    jal ra,ffffffff8401063e <cap_zombie_cap_get_capZombieType>
    0x84013f72    0x252    beq a0,s3,ffffffff84013dbe <cteDelete+0x9e>
    0x84013f76    0x256    andi s1,a0,63
    0x84013f7a    0x25a    ld a0,16(sp)
    0x84013f7c    0x25c    ld a1,24(sp)
    0x84013f7e    0x25e    jal ra,ffffffff8401062e <cap_zombie_cap_get_capZombieID>
    0x84013f82    0x262    addi a5,s1,1
    0x84013f86    0x266    sll a2,s4,a5
    0x84013f8a    0x26a    neg a2,a2
    0x84013f8e    0x26e    and a2,a2,a0
    0x84013f90    0x270    sll a5,s8,a5
    0x84013f94    0x274    not a5,a5
    0x84013f98    0x278    and s2,a5,s2
    0x84013f9c    0x27c    or a2,a2,s2
    0x84013fa0    0x280    ld a0,16(sp)
    0x84013fa2    0x282    ld a1,24(sp)
    0x84013fa4    0x284    jal ra,ffffffff84010636 <cap_zombie_cap_set_capZombieID>
    0x84013fa8    0x288    sd a0,0(s0)
    0x84013faa    0x28a    sd a1,8(s0)
    0x84013fac    0x28c    j ffffffff84013dce <cteDelete+0xae>
    0x84013fae    0x28e    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84013fb2    0x292    sd a0,112(sp)         ; stack access
    0x84013fb4    0x294    sd a1,120(sp)         ; stack access
    0x84013fb6    0x296    ld a1,112(sp)         ; stack access
    0x84013fb8    0x298    ld a2,120(sp)         ; stack access
    0x84013fba    0x29a    mv a0,s0
    0x84013fbc    0x29c    jal ra,ffffffff840123e8 <emptySlot>
    0x84013fc0    0x2a0    li s9,0
    0x84013fc2    0x2a2    mv a0,s9
    0x84013fc4    0x2a4    ld ra,232(sp)         ; stack access
    0x84013fc6    0x2a6    ld s0,224(sp)         ; stack access
    0x84013fc8    0x2a8    ld s1,216(sp)         ; stack access
    0x84013fca    0x2aa    ld s2,208(sp)         ; stack access
    0x84013fcc    0x2ac    ld s3,200(sp)         ; stack access
    0x84013fce    0x2ae    ld s4,192(sp)         ; stack access
    0x84013fd0    0x2b0    ld s5,184(sp)         ; stack access
    0x84013fd2    0x2b2    ld s6,176(sp)         ; stack access
    0x84013fd4    0x2b4    ld s7,168(sp)         ; stack access
    0x84013fd6    0x2b6    ld s8,160(sp)         ; stack access
    0x84013fd8    0x2b8    ld s9,152(sp)         ; stack access
    0x84013fda    0x2ba    ld s10,144(sp)        ; stack access
    0x84013fdc    0x2bc    addi sp,sp,240
    0x84013fde    0x2be    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
260 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteDelete` has 447 nodes.

Section receiveSignal (407 of 432)
==================================

Deriving specifications
-----------------------

Section `receiveSignal` consists of 63 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `receiveSignal`:

    0x84013220     0x0    addi sp,sp,-64
    0x84013222     0x2    sd ra,56(sp)          ; stack access
    0x84013224     0x4    sd s0,48(sp)          ; stack access
    0x84013226     0x6    sd s1,40(sp)          ; stack access
    0x84013228     0x8    sd s2,32(sp)          ; stack access
    0x8401322a     0xa    sd s3,24(sp)          ; stack access
    0x8401322c     0xc    mv s2,a0
    0x8401322e     0xe    mv s1,a3
    0x84013230    0x10    mv a0,a1
    0x84013232    0x12    mv a1,a2
    0x84013234    0x14    jal ra,ffffffff840109aa <cap_notification_cap_get_capNtfnPtr>
    0x84013238    0x18    mv s0,a0
    0x8401323a    0x1a    jal ra,ffffffff84010258 <notification_ptr_get_state>
    0x8401323e    0x1e    li a5,1
    0x84013240    0x20    bgeu a5,a0,ffffffff8401326a <receiveSignal+0x4a>
    0x84013244    0x24    li a5,2
    0x84013246    0x26    bne a0,a5,ffffffff8401325c <receiveSignal+0x3c>
    0x8401324a    0x2a    mv a0,s0
    0x8401324c    0x2c    jal ra,ffffffff8401022e <notification_ptr_get_ntfnMsgIdentifier>
    0x84013250    0x30    sd a0,72(s2)
    0x84013254    0x34    li a1,0
    0x84013256    0x36    mv a0,s0
    0x84013258    0x38    jal ra,ffffffff8401025e <notification_ptr_set_state>
    0x8401325c    0x3c    ld ra,56(sp)          ; stack access
    0x8401325e    0x3e    ld s0,48(sp)          ; stack access
    0x84013260    0x40    ld s1,40(sp)          ; stack access
    0x84013262    0x42    ld s2,32(sp)          ; stack access
    0x84013264    0x44    ld s3,24(sp)          ; stack access
    0x84013266    0x46    addi sp,sp,64
    0x84013268    0x48    ret
    0x8401326a    0x4a    beqz s1,ffffffff840132c0 <receiveSignal+0xa0>
    0x8401326c    0x4c    addi s1,s2,280
    0x84013270    0x50    li a1,6
    0x84013272    0x52    mv a0,s1
    0x84013274    0x54    jal ra,ffffffff8401038e <thread_state_ptr_set_tsType>
    0x84013278    0x58    mv a1,s0
    0x8401327a    0x5a    mv a0,s1
    0x8401327c    0x5c    jal ra,ffffffff8401036a <thread_state_ptr_set_blockingObject>
    0x84013280    0x60    mv a0,s2
    0x84013282    0x62    jal ra,ffffffff84012fda <scheduleTCB>
    0x84013286    0x66    mv a0,s0
    0x84013288    0x68    jal ra,ffffffff84010b3e <notification_ptr_get_ntfnQueue_head>
    0x8401328c    0x6c    mv s1,a0
    0x8401328e    0x6e    mv a0,s0
    0x84013290    0x70    jal ra,ffffffff84010b56 <notification_ptr_get_ntfnQueue_tail>
    0x84013294    0x74    mv s3,s2
    0x84013296    0x76    beqz s1,ffffffff8401329e <receiveSignal+0x7e>
    0x84013298    0x78    mv s3,s1
    0x8401329a    0x7a    sd s2,408(a0)
    0x8401329e    0x7e    sd a0,416(s2)
    0x840132a2    0x82    sd zero,408(s2)
    0x840132a6    0x86    li a1,1
    0x840132a8    0x88    mv a0,s0
    0x840132aa    0x8a    jal ra,ffffffff8401025e <notification_ptr_set_state>
    0x840132ae    0x8e    mv a1,s3
    0x840132b0    0x90    mv a0,s0
    0x840132b2    0x92    jal ra,ffffffff84010236 <notification_ptr_set_ntfnQueue_head>
    0x840132b6    0x96    mv a1,s2
    0x840132b8    0x98    mv a0,s0
    0x840132ba    0x9a    jal ra,ffffffff8401024a <notification_ptr_set_ntfnQueue_tail>
    0x840132be    0x9e    j ffffffff8401325c <receiveSignal+0x3c>
    0x840132c0    0xa0    sd zero,72(s2)
    0x840132c4    0xa4    j ffffffff8401325c <receiveSignal+0x3c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
63 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `receiveSignal` has 99 nodes.

Section updateCapData (408 of 432)
==================================

Deriving specifications
-----------------------

Section `updateCapData` consists of 97 instructions.


Stack analysis
---------------

44 stack accesses found. Annotated code for `updateCapData`:

    0x84012b8e     0x0    addi sp,sp,-80
    0x84012b90     0x2    sd ra,72(sp)          ; stack access
    0x84012b92     0x4    sd s0,64(sp)          ; stack access
    0x84012b94     0x6    sd s1,56(sp)          ; stack access
    0x84012b96     0x8    mv s0,a0
    0x84012b98     0xa    mv s1,a1
    0x84012b9a     0xc    sd a2,0(sp)           ; stack access
    0x84012b9c     0xe    sd a3,8(sp)           ; stack access
    0x84012b9e    0x10    mv a0,a2
    0x84012ba0    0x12    mv a1,a3
    0x84012ba2    0x14    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012ba6    0x18    andi a5,a0,1
    0x84012baa    0x1c    bnez a5,ffffffff84012bd0 <updateCapData+0x42>
    0x84012bac    0x1e    ld a0,0(sp)           ; stack access
    0x84012bae    0x20    ld a1,8(sp)           ; stack access
    0x84012bb0    0x22    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012bb4    0x26    li a5,6
    0x84012bb6    0x28    beq a0,a5,ffffffff84012c0c <updateCapData+0x7e>
    0x84012bba    0x2c    li a5,10
    0x84012bbc    0x2e    beq a0,a5,ffffffff84012c32 <updateCapData+0xa4>
    0x84012bc0    0x32    li a5,4
    0x84012bc2    0x34    beq a0,a5,ffffffff84012be6 <updateCapData+0x58>
    0x84012bc6    0x38    ld a5,0(sp)           ; stack access
    0x84012bc8    0x3a    sd a5,32(sp)          ; stack access
    0x84012bca    0x3c    ld a5,8(sp)           ; stack access
    0x84012bcc    0x3e    sd a5,40(sp)          ; stack access
    0x84012bce    0x40    j ffffffff84012bd8 <updateCapData+0x4a>
    0x84012bd0    0x42    ld a5,0(sp)           ; stack access
    0x84012bd2    0x44    sd a5,32(sp)          ; stack access
    0x84012bd4    0x46    ld a5,8(sp)           ; stack access
    0x84012bd6    0x48    sd a5,40(sp)          ; stack access
    0x84012bd8    0x4a    ld a0,32(sp)          ; stack access
    0x84012bda    0x4c    ld a1,40(sp)          ; stack access
    0x84012bdc    0x4e    ld ra,72(sp)          ; stack access
    0x84012bde    0x50    ld s0,64(sp)          ; stack access
    0x84012be0    0x52    ld s1,56(sp)          ; stack access
    0x84012be2    0x54    addi sp,sp,80
    0x84012be4    0x56    ret
    0x84012be6    0x58    bnez s0,ffffffff84012c02 <updateCapData+0x74>
    0x84012be8    0x5a    ld a0,0(sp)           ; stack access
    0x84012bea    0x5c    ld a1,8(sp)           ; stack access
    0x84012bec    0x5e    jal ra,ffffffff84010446 <cap_endpoint_cap_get_capEPBadge>
    0x84012bf0    0x62    bnez a0,ffffffff84012c02 <updateCapData+0x74>
    0x84012bf2    0x64    mv a2,s1
    0x84012bf4    0x66    ld a0,0(sp)           ; stack access
    0x84012bf6    0x68    ld a1,8(sp)           ; stack access
    0x84012bf8    0x6a    jal ra,ffffffff8401044e <cap_endpoint_cap_set_capEPBadge>
    0x84012bfc    0x6e    sd a0,32(sp)          ; stack access
    0x84012bfe    0x70    sd a1,40(sp)          ; stack access
    0x84012c00    0x72    j ffffffff84012bd8 <updateCapData+0x4a>
    0x84012c02    0x74    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84012c06    0x78    sd a0,32(sp)          ; stack access
    0x84012c08    0x7a    sd a1,40(sp)          ; stack access
    0x84012c0a    0x7c    j ffffffff84012bd8 <updateCapData+0x4a>
    0x84012c0c    0x7e    bnez s0,ffffffff84012c28 <updateCapData+0x9a>
    0x84012c0e    0x80    ld a0,0(sp)           ; stack access
    0x84012c10    0x82    ld a1,8(sp)           ; stack access
    0x84012c12    0x84    jal ra,ffffffff840104f0 <cap_notification_cap_get_capNtfnBadge>
    0x84012c16    0x88    bnez a0,ffffffff84012c28 <updateCapData+0x9a>
    0x84012c18    0x8a    mv a2,s1
    0x84012c1a    0x8c    ld a0,0(sp)           ; stack access
    0x84012c1c    0x8e    ld a1,8(sp)           ; stack access
    0x84012c1e    0x90    jal ra,ffffffff840104f8 <cap_notification_cap_set_capNtfnBadge>
    0x84012c22    0x94    sd a0,32(sp)          ; stack access
    0x84012c24    0x96    sd a1,40(sp)          ; stack access
    0x84012c26    0x98    j ffffffff84012bd8 <updateCapData+0x4a>
    0x84012c28    0x9a    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84012c2c    0x9e    sd a0,32(sp)          ; stack access
    0x84012c2e    0xa0    sd a1,40(sp)          ; stack access
    0x84012c30    0xa2    j ffffffff84012bd8 <updateCapData+0x4a>
    0x84012c32    0xa4    mv a0,s1
    0x84012c34    0xa6    jal ra,ffffffff840100d8 <seL4_CNode_CapData_get_guardSize>
    0x84012c38    0xaa    mv s0,a0
    0x84012c3a    0xac    ld a0,0(sp)           ; stack access
    0x84012c3c    0xae    ld a1,8(sp)           ; stack access
    0x84012c3e    0xb0    jal ra,ffffffff840105d2 <cap_cnode_cap_get_capCNodeRadix>
    0x84012c42    0xb4    add a0,a0,s0
    0x84012c44    0xb6    li a5,64
    0x84012c48    0xba    bgeu a5,a0,ffffffff84012c56 <updateCapData+0xc8>
    0x84012c4c    0xbe    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84012c50    0xc2    sd a0,32(sp)          ; stack access
    0x84012c52    0xc4    sd a1,40(sp)          ; stack access
    0x84012c54    0xc6    j ffffffff84012bd8 <updateCapData+0x4a>
    0x84012c56    0xc8    mv a0,s1
    0x84012c58    0xca    jal ra,ffffffff840100d4 <seL4_CNode_CapData_get_guard>
    0x84012c5c    0xce    li a5,-1
    0x84012c5e    0xd0    sll a5,a5,s0
    0x84012c62    0xd4    not a5,a5
    0x84012c66    0xd8    and a2,a5,a0
    0x84012c6a    0xdc    ld a0,0(sp)           ; stack access
    0x84012c6c    0xde    ld a1,8(sp)           ; stack access
    0x84012c6e    0xe0    jal ra,ffffffff840105a6 <cap_cnode_cap_set_capCNodeGuard>
    0x84012c72    0xe4    mv a2,s0
    0x84012c74    0xe6    jal ra,ffffffff840105ba <cap_cnode_cap_set_capCNodeGuardSize>
    0x84012c78    0xea    sd a0,32(sp)          ; stack access
    0x84012c7a    0xec    sd a1,40(sp)          ; stack access
    0x84012c7c    0xee    j ffffffff84012bd8 <updateCapData+0x4a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
97 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `updateCapData` has 174 nodes.

Section emptySlot (409 of 432)
==============================

Deriving specifications
-----------------------

Section `emptySlot` consists of 76 instructions.


Stack analysis
---------------

22 stack accesses found. Annotated code for `emptySlot`:

    0x840123e8     0x0    addi sp,sp,-96
    0x840123ea     0x2    sd ra,88(sp)          ; stack access
    0x840123ec     0x4    sd s0,80(sp)          ; stack access
    0x840123ee     0x6    sd s1,72(sp)          ; stack access
    0x840123f0     0x8    sd s2,64(sp)          ; stack access
    0x840123f2     0xa    sd s3,56(sp)          ; stack access
    0x840123f4     0xc    mv s0,a0
    0x840123f6     0xe    sd a1,0(sp)           ; stack access
    0x840123f8    0x10    sd a2,8(sp)           ; stack access
    0x840123fa    0x12    ld a0,0(a0)
    0x840123fc    0x14    ld a1,8(s0)
    0x840123fe    0x16    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012402    0x1a    beqz a0,ffffffff84012452 <emptySlot+0x6a>
    0x84012404    0x1c    ld s3,16(s0)
    0x84012408    0x20    sd s3,16(sp)          ; stack access
    0x8401240a    0x22    ld s1,24(s0)
    0x8401240c    0x24    sd s1,24(sp)          ; stack access
    0x8401240e    0x26    mv a0,s3
    0x84012410    0x28    mv a1,s1
    0x84012412    0x2a    jal ra,ffffffff84010208 <mdb_node_get_mdbPrev>
    0x84012416    0x2e    mv s2,a0
    0x84012418    0x30    mv a0,s3
    0x8401241a    0x32    mv a1,s1
    0x8401241c    0x34    jal ra,ffffffff84010b08 <mdb_node_get_mdbNext>
    0x84012420    0x38    mv s1,a0
    0x84012422    0x3a    bnez s2,ffffffff84012460 <emptySlot+0x78>
    0x84012426    0x3e    bnez s1,ffffffff8401246c <emptySlot+0x84>
    0x84012428    0x40    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x8401242c    0x44    sd a0,0(s0)
    0x8401242e    0x46    sd a1,8(s0)
    0x84012430    0x48    li a3,0
    0x84012432    0x4a    li a2,0
    0x84012434    0x4c    li a1,0
    0x84012436    0x4e    li a0,0
    0x84012438    0x50    jal ra,ffffffff8401018a <mdb_node_new>
    0x8401243c    0x54    sd a0,16(s0)
    0x8401243e    0x56    sd a1,24(s0)
    0x84012440    0x58    ld a0,0(sp)           ; stack access
    0x84012442    0x5a    sd a0,32(sp)          ; stack access
    0x84012444    0x5c    ld a1,8(sp)           ; stack access
    0x84012446    0x5e    sd a1,40(sp)          ; stack access
    0x84012448    0x60    jal ra,ffffffff8401039e <cap_get_capType>
    0x8401244c    0x64    li a5,16
    0x8401244e    0x66    beq a0,a5,ffffffff84012498 <emptySlot+0xb0>
    0x84012452    0x6a    ld ra,88(sp)          ; stack access
    0x84012454    0x6c    ld s0,80(sp)          ; stack access
    0x84012456    0x6e    ld s1,72(sp)          ; stack access
    0x84012458    0x70    ld s2,64(sp)          ; stack access
    0x8401245a    0x72    ld s3,56(sp)          ; stack access
    0x8401245c    0x74    addi sp,sp,96
    0x8401245e    0x76    ret
    0x84012460    0x78    mv a1,a0
    0x84012462    0x7a    addi a0,s2,16
    0x84012466    0x7e    jal ra,ffffffff840101a6 <mdb_node_ptr_set_mdbNext>
    0x8401246a    0x82    j ffffffff84012426 <emptySlot+0x3e>
    0x8401246c    0x84    addi s3,s1,16
    0x84012470    0x88    mv a1,s2
    0x84012472    0x8a    mv a0,s3
    0x84012474    0x8c    jal ra,ffffffff84010216 <mdb_node_ptr_set_mdbPrev>
    0x84012478    0x90    ld a0,16(s1)
    0x8401247a    0x92    ld a1,24(s1)
    0x8401247c    0x94    jal ra,ffffffff840101e6 <mdb_node_get_mdbFirstBadged>
    0x84012480    0x98    li a1,1
    0x84012482    0x9a    bnez a0,ffffffff84012490 <emptySlot+0xa8>
    0x84012484    0x9c    ld a0,16(sp)          ; stack access
    0x84012486    0x9e    ld a1,24(sp)          ; stack access
    0x84012488    0xa0    jal ra,ffffffff840101e6 <mdb_node_get_mdbFirstBadged>
    0x8401248c    0xa4    snez a1,a0
    0x84012490    0xa8    mv a0,s3
    0x84012492    0xaa    jal ra,ffffffff840101fc <mdb_node_ptr_set_mdbFirstBadged>
    0x84012496    0xae    j ffffffff84012428 <emptySlot+0x40>
    0x84012498    0xb0    ld a0,32(sp)          ; stack access
    0x8401249a    0xb2    ld a1,40(sp)          ; stack access
    0x8401249c    0xb4    jal ra,ffffffff8401060e <cap_irq_handler_cap_get_capIRQ>
    0x840124a0    0xb8    jal ra,ffffffff840123d6 <deletedIRQHandler>
    0x840124a4    0xbc    j ffffffff84012452 <emptySlot+0x6a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
76 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `emptySlot` has 132 nodes.

Section cap_get_capPtr (410 of 432)
===================================

Deriving specifications
-----------------------

Section `cap_get_capPtr` consists of 87 instructions.


Stack analysis
---------------

16 stack accesses found. Annotated code for `cap_get_capPtr`:

    0x84010b68     0x0    addi sp,sp,-64
    0x84010b6a     0x2    sd ra,56(sp)          ; stack access
    0x84010b6c     0x4    sd s0,48(sp)          ; stack access
    0x84010b6e     0x6    sd a0,0(sp)           ; stack access
    0x84010b70     0x8    sd a1,8(sp)           ; stack access
    0x84010b72     0xa    jal ra,ffffffff8401039e <cap_get_capType>
    0x84010b76     0xe    sext.w a4,a0
    0x84010b7a    0x12    li a5,20
    0x84010b7c    0x14    bltu a5,a4,ffffffff84010bfe <cap_get_capPtr+0x96>
    0x84010b80    0x18    slli a0,a0,0x20
    0x84010b82    0x1a    srli a0,a0,0x20
    0x84010b84    0x1c    slli a0,a0,0x2
    0x84010b86    0x1e    auipc a4,0x7
    0x84010b8a    0x22    addi a4,a4,970 # ffffffff84017f50 <ksDomScheduleLength+0x8>
    0x84010b8e    0x26    add a0,a0,a4
    0x84010b90    0x28    lw a5,0(a0)
    0x84010b92    0x2a    add a5,a5,a4
    0x84010b94    0x2c    jr a5
    0x84010b96    0x2e    ld a0,0(sp)
    0x84010b98    0x30    ld a1,8(sp)
    0x84010b9a    0x32    jal ra,ffffffff840109e0 <cap_untyped_cap_get_capPtr>
    0x84010b9e    0x36    j ffffffff84010c42 <cap_get_capPtr+0xda>
    0x84010ba0    0x38    ld a0,0(sp)
    0x84010ba2    0x3a    ld a1,8(sp)
    0x84010ba4    0x3c    jal ra,ffffffff840109fe <cap_endpoint_cap_get_capEPPtr>
    0x84010ba8    0x40    j ffffffff84010c42 <cap_get_capPtr+0xda>
    0x84010baa    0x42    ld a0,0(sp)
    0x84010bac    0x44    ld a1,8(sp)
    0x84010bae    0x46    jal ra,ffffffff840109aa <cap_notification_cap_get_capNtfnPtr>
    0x84010bb2    0x4a    j ffffffff84010c42 <cap_get_capPtr+0xda>
    0x84010bb4    0x4c    ld a0,0(sp)
    0x84010bb6    0x4e    ld a1,8(sp)
    0x84010bb8    0x50    jal ra,ffffffff84010a1c <cap_cnode_cap_get_capCNodePtr>
    0x84010bbc    0x54    j ffffffff84010c42 <cap_get_capPtr+0xda>
    0x84010bbe    0x56    ld a0,0(sp)
    0x84010bc0    0x58    ld a1,8(sp)
    0x84010bc2    0x5a    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x84010bc6    0x5e    andi a0,a0,-1024
    0x84010bca    0x62    j ffffffff84010c42 <cap_get_capPtr+0xda>
    0x84010bcc    0x64    ld a0,0(sp)
    0x84010bce    0x66    sd a0,16(sp)
    0x84010bd0    0x68    ld a1,8(sp)
    0x84010bd2    0x6a    sd a1,24(sp)
    0x84010bd4    0x6c    jal ra,ffffffff8401063e <cap_zombie_cap_get_capZombieType>
    0x84010bd8    0x70    li a5,64
    0x84010bdc    0x74    beq a0,a5,ffffffff84010bfa <cap_get_capPtr+0x92>
    0x84010be0    0x78    andi s0,a0,63
    0x84010be4    0x7c    ld a0,16(sp)
    0x84010be6    0x7e    ld a1,24(sp)
    0x84010be8    0x80    jal ra,ffffffff8401062e <cap_zombie_cap_get_capZombieID>
    0x84010bec    0x84    addiw a4,s0,1
    0x84010bf0    0x88    li a5,-1
    0x84010bf2    0x8a    sll a5,a5,a4
    0x84010bf6    0x8e    and a0,a0,a5
    0x84010bf8    0x90    j ffffffff84010c42 <cap_get_capPtr+0xda>
    0x84010bfa    0x92    li s0,4
    0x84010bfc    0x94    j ffffffff84010be4 <cap_get_capPtr+0x7c>
    0x84010bfe    0x96    ld a0,0(sp)           ; stack access
    0x84010c00    0x98    sd a0,32(sp)          ; stack access
    0x84010c02    0x9a    ld a1,8(sp)           ; stack access
    0x84010c04    0x9c    sd a1,40(sp)          ; stack access
    0x84010c06    0x9e    jal ra,ffffffff8401039e <cap_get_capType>
    0x84010c0a    0xa2    sext.w a5,a0
    0x84010c0e    0xa6    li a4,3
    0x84010c10    0xa8    beq a5,a4,ffffffff84010c2c <cap_get_capPtr+0xc4>
    0x84010c14    0xac    li a4,13
    0x84010c16    0xae    beq a5,a4,ffffffff84010c36 <cap_get_capPtr+0xce>
    0x84010c1a    0xb2    li a4,1
    0x84010c1c    0xb4    li a0,0
    0x84010c1e    0xb6    bne a5,a4,ffffffff84010c42 <cap_get_capPtr+0xda>
    0x84010c22    0xba    ld a0,32(sp)          ; stack access
    0x84010c24    0xbc    ld a1,40(sp)          ; stack access
    0x84010c26    0xbe    jal ra,ffffffff84010a5a <cap_frame_cap_get_capFBasePtr>
    0x84010c2a    0xc2    j ffffffff84010c42 <cap_get_capPtr+0xda>
    0x84010c2c    0xc4    ld a0,32(sp)          ; stack access
    0x84010c2e    0xc6    ld a1,40(sp)          ; stack access
    0x84010c30    0xc8    jal ra,ffffffff84010a76 <cap_page_table_cap_get_capPTBasePtr>
    0x84010c34    0xcc    j ffffffff84010c42 <cap_get_capPtr+0xda>
    0x84010c36    0xce    ld a0,32(sp)          ; stack access
    0x84010c38    0xd0    ld a1,40(sp)          ; stack access
    0x84010c3a    0xd2    jal ra,ffffffff84010a92 <cap_asid_pool_cap_get_capASIDPool>
    0x84010c3e    0xd6    j ffffffff84010c42 <cap_get_capPtr+0xda>
    0x84010c40    0xd8    li a0,0
    0x84010c42    0xda    ld ra,56(sp)          ; stack access
    0x84010c44    0xdc    ld s0,48(sp)          ; stack access
    0x84010c46    0xde    addi sp,sp,64
    0x84010c48    0xe0    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
87 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_get_capPtr` has 144 nodes.

Section handleRecv (411 of 432)
===============================

Deriving specifications
-----------------------

Section `handleRecv` consists of 121 instructions.


Stack analysis
---------------

21 stack accesses found. Annotated code for `handleRecv`:

    0x8401523a      0x0    addi sp,sp,-64
    0x8401523c      0x2    sd ra,56(sp)          ; stack access
    0x8401523e      0x4    sd s0,48(sp)          ; stack access
    0x84015240      0x6    sd s1,40(sp)          ; stack access
    0x84015242      0x8    sd s2,32(sp)          ; stack access
    0x84015244      0xa    mv s0,a0
    0x84015246      0xc    auipc a1,0x1a
    0x8401524a     0x10    ld a1,-1966(a1) # ffffffff8402ea98 <ksCurThread>
    0x8401524e     0x14    ld s1,72(a1)
    0x84015250     0x16    mv a2,s1
    0x84015252     0x18    addi a0,sp,8
    0x84015254     0x1a    jal ra,ffffffff84011bfa <lookupCap>
    0x84015258     0x1e    ld a5,8(sp)           ; stack access
    0x8401525a     0x20    bnez a5,ffffffff840152ae <handleRecv+0x74>
    0x8401525c     0x22    ld a0,16(sp)          ; stack access
    0x8401525e     0x24    ld a1,24(sp)          ; stack access
    0x84015260     0x26    jal ra,ffffffff8401039e <cap_get_capType>
    0x84015264     0x2a    li a5,4
    0x84015266     0x2c    beq a0,a5,ffffffff840152d0 <handleRecv+0x96>
    0x8401526a     0x30    li a5,6
    0x8401526c     0x32    beq a0,a5,ffffffff84015328 <handleRecv+0xee>
    0x84015270     0x36    li a0,0
    0x84015272     0x38    jal ra,ffffffff840107ba <lookup_fault_missing_capability_new>
    0x84015276     0x3c    auipc a5,0x9
    0x8401527a     0x40    addi a5,a5,-1606 # ffffffff8401dc30 <current_lookup_fault>
    0x8401527e     0x44    sd a0,0(a5)
    0x84015280     0x46    sd a1,8(a5)
    0x84015282     0x48    li a1,1
    0x84015284     0x4a    mv a0,s1
    0x84015286     0x4c    jal ra,ffffffff8401085c <seL4_Fault_CapFault_new>
    0x8401528a     0x50    auipc a5,0x7
    0x8401528e     0x54    addi a5,a5,1398 # ffffffff8401c800 <current_fault>
    0x84015292     0x58    sd a0,0(a5)
    0x84015294     0x5a    sd a1,8(a5)
    0x84015296     0x5c    auipc a0,0x1a
    0x8401529a     0x60    ld a0,-2046(a0) # ffffffff8402ea98 <ksCurThread>
    0x8401529e     0x64    jal ra,ffffffff84014fba <handleFault>
    0x840152a2     0x68    ld ra,56(sp)          ; stack access
    0x840152a4     0x6a    ld s0,48(sp)          ; stack access
    0x840152a6     0x6c    ld s1,40(sp)          ; stack access
    0x840152a8     0x6e    ld s2,32(sp)          ; stack access
    0x840152aa     0x70    addi sp,sp,64
    0x840152ac     0x72    ret
    0x840152ae     0x74    li a1,1
    0x840152b0     0x76    mv a0,s1
    0x840152b2     0x78    jal ra,ffffffff8401085c <seL4_Fault_CapFault_new>
    0x840152b6     0x7c    auipc a5,0x7
    0x840152ba     0x80    addi a5,a5,1354 # ffffffff8401c800 <current_fault>
    0x840152be     0x84    sd a0,0(a5)
    0x840152c0     0x86    sd a1,8(a5)
    0x840152c2     0x88    auipc a0,0x19
    0x840152c6     0x8c    ld a0,2006(a0) # ffffffff8402ea98 <ksCurThread>
    0x840152ca     0x90    jal ra,ffffffff84014fba <handleFault>
    0x840152ce     0x94    j ffffffff840152a2 <handleRecv+0x68>
    0x840152d0     0x96    ld a0,16(sp)          ; stack access
    0x840152d2     0x98    ld a1,24(sp)          ; stack access
    0x840152d4     0x9a    jal ra,ffffffff84010492 <cap_endpoint_cap_get_capCanReceive>
    0x840152d8     0x9e    beqz a0,ffffffff840152f6 <handleRecv+0xbc>
    0x840152da     0xa0    auipc s1,0x19
    0x840152de     0xa4    addi s1,s1,1982 # ffffffff8402ea98 <ksCurThread>
    0x840152e2     0xa8    ld a0,0(s1)
    0x840152e4     0xaa    jal ra,ffffffff84014952 <deleteCallerCap>
    0x840152e8     0xae    mv a3,s0
    0x840152ea     0xb0    ld a1,16(sp)          ; stack access
    0x840152ec     0xb2    ld a2,24(sp)          ; stack access
    0x840152ee     0xb4    ld a0,0(s1)
    0x840152f0     0xb6    jal ra,ffffffff840150c4 <receiveIPC>
    0x840152f4     0xba    j ffffffff840152a2 <handleRecv+0x68>
    0x840152f6     0xbc    jal ra,ffffffff840107ba <lookup_fault_missing_capability_new>
    0x840152fa     0xc0    auipc a5,0x9
    0x840152fe     0xc4    addi a5,a5,-1738 # ffffffff8401dc30 <current_lookup_fault>
    0x84015302     0xc8    sd a0,0(a5)
    0x84015304     0xca    sd a1,8(a5)
    0x84015306     0xcc    li a1,1
    0x84015308     0xce    mv a0,s1
    0x8401530a     0xd0    jal ra,ffffffff8401085c <seL4_Fault_CapFault_new>
    0x8401530e     0xd4    auipc a5,0x7
    0x84015312     0xd8    addi a5,a5,1266 # ffffffff8401c800 <current_fault>
    0x84015316     0xdc    sd a0,0(a5)
    0x84015318     0xde    sd a1,8(a5)
    0x8401531a     0xe0    auipc a0,0x19
    0x8401531e     0xe4    ld a0,1918(a0) # ffffffff8402ea98 <ksCurThread>
    0x84015322     0xe8    jal ra,ffffffff84014fba <handleFault>
    0x84015326     0xec    j ffffffff840152a2 <handleRecv+0x68>
    0x84015328     0xee    ld a0,16(sp)          ; stack access
    0x8401532a     0xf0    ld a1,24(sp)          ; stack access
    0x8401532c     0xf2    jal ra,ffffffff840109aa <cap_notification_cap_get_capNtfnPtr>
    0x84015330     0xf6    jal ra,ffffffff840109c8 <notification_ptr_get_ntfnBoundTCB>
    0x84015334     0xfa    mv s2,a0
    0x84015336     0xfc    ld a0,16(sp)          ; stack access
    0x84015338     0xfe    ld a1,24(sp)          ; stack access
    0x8401533a    0x100    jal ra,ffffffff84010500 <cap_notification_cap_get_capNtfnCanReceive>
    0x8401533e    0x104    beqz a0,ffffffff84015364 <handleRecv+0x12a>
    0x84015340    0x106    bnez s2,ffffffff84015358 <handleRecv+0x11e>
    0x84015344    0x10a    mv a3,s0
    0x84015346    0x10c    ld a1,16(sp)          ; stack access
    0x84015348    0x10e    ld a2,24(sp)          ; stack access
    0x8401534a    0x110    auipc a0,0x19
    0x8401534e    0x114    ld a0,1870(a0) # ffffffff8402ea98 <ksCurThread>
    0x84015352    0x118    jal ra,ffffffff84013220 <receiveSignal>
    0x84015356    0x11c    j ffffffff840152a2 <handleRecv+0x68>
    0x84015358    0x11e    auipc a5,0x19
    0x8401535c    0x122    ld a5,1856(a5) # ffffffff8402ea98 <ksCurThread>
    0x84015360    0x126    beq a5,s2,ffffffff84015344 <handleRecv+0x10a>
    0x84015364    0x12a    li a0,0
    0x84015366    0x12c    jal ra,ffffffff840107ba <lookup_fault_missing_capability_new>
    0x8401536a    0x130    auipc a5,0x9
    0x8401536e    0x134    addi a5,a5,-1850 # ffffffff8401dc30 <current_lookup_fault>
    0x84015372    0x138    sd a0,0(a5)
    0x84015374    0x13a    sd a1,8(a5)
    0x84015376    0x13c    li a1,1
    0x84015378    0x13e    mv a0,s1
    0x8401537a    0x140    jal ra,ffffffff8401085c <seL4_Fault_CapFault_new>
    0x8401537e    0x144    auipc a5,0x7
    0x84015382    0x148    addi a5,a5,1154 # ffffffff8401c800 <current_fault>
    0x84015386    0x14c    sd a0,0(a5)
    0x84015388    0x14e    sd a1,8(a5)
    0x8401538a    0x150    auipc a0,0x19
    0x8401538e    0x154    ld a0,1806(a0) # ffffffff8402ea98 <ksCurThread>
    0x84015392    0x158    jal ra,ffffffff84014fba <handleFault>
    0x84015396    0x15c    j ffffffff840152a2 <handleRecv+0x68>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
121 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleRecv` has 201 nodes.

Section cancelBadgedSends (412 of 432)
======================================

Deriving specifications
-----------------------

Section `cancelBadgedSends` consists of 82 instructions.


Stack analysis
---------------

16 stack accesses found. Annotated code for `cancelBadgedSends`:

    0x840138ec     0x0    addi sp,sp,-80
    0x840138ee     0x2    sd ra,72(sp)          ; stack access
    0x840138f0     0x4    sd s0,64(sp)          ; stack access
    0x840138f2     0x6    sd s1,56(sp)          ; stack access
    0x840138f4     0x8    sd s2,48(sp)          ; stack access
    0x840138f6     0xa    sd s3,40(sp)          ; stack access
    0x840138f8     0xc    sd s4,32(sp)          ; stack access
    0x840138fa     0xe    sd s5,24(sp)          ; stack access
    0x840138fc    0x10    mv s3,a0
    0x840138fe    0x12    mv s2,a1
    0x84013900    0x14    jal ra,ffffffff84010178 <endpoint_ptr_get_state>
    0x84013904    0x18    li a5,1
    0x84013906    0x1a    beq a0,a5,ffffffff84013912 <cancelBadgedSends+0x26>
    0x8401390a    0x1e    andi a0,a0,-3
    0x8401390c    0x20    beqz a0,ffffffff84013996 <cancelBadgedSends+0xaa>
    0x8401390e    0x22    jal ra,ffffffff84010cec <halt>
    0x84013912    0x26    mv a0,s3
    0x84013914    0x28    jal ra,ffffffff84010158 <endpoint_ptr_get_epQueue_head>
    0x84013918    0x2c    mv s0,a0
    0x8401391a    0x2e    mv a0,s3
    0x8401391c    0x30    jal ra,ffffffff84010aee <endpoint_ptr_get_epQueue_tail>
    0x84013920    0x34    mv s1,a0
    0x84013922    0x36    mv s4,a0
    0x84013924    0x38    li a1,0
    0x84013926    0x3a    mv a0,s3
    0x84013928    0x3c    jal ra,ffffffff8401017e <endpoint_ptr_set_state>
    0x8401392c    0x40    li a1,0
    0x8401392e    0x42    mv a0,s3
    0x84013930    0x44    jal ra,ffffffff8401015c <endpoint_ptr_set_epQueue_head>
    0x84013934    0x48    li a1,0
    0x84013936    0x4a    mv a0,s3
    0x84013938    0x4c    jal ra,ffffffff84010160 <endpoint_ptr_set_epQueue_tail>
    0x8401393c    0x50    beqz s0,ffffffff840139a8 <cancelBadgedSends+0xbc>
    0x8401393e    0x52    mv s1,s0
    0x84013940    0x54    j ffffffff84013964 <cancelBadgedSends+0x78>
    0x84013942    0x56    li a1,2
    0x84013944    0x58    mv a0,s5
    0x84013946    0x5a    jal ra,ffffffff84013020 <setThreadState>
    0x8401394a    0x5e    mv a0,s5
    0x8401394c    0x60    jal ra,ffffffff84012efc <tcbSchedEnqueue>
    0x84013950    0x64    mv a1,s1
    0x84013952    0x66    mv a2,s4
    0x84013954    0x68    mv a0,s5
    0x84013956    0x6a    jal ra,ffffffff840138b6 <tcbEPDequeue>
    0x8401395a    0x6e    mv s1,a0
    0x8401395c    0x70    mv s4,a1
    0x8401395e    0x72    sd a0,0(sp)           ; stack access
    0x84013960    0x74    sd a1,8(sp)           ; stack access
    0x84013962    0x76    beqz s0,ffffffff84013978 <cancelBadgedSends+0x8c>
    0x84013964    0x78    addi a0,s0,280
    0x84013968    0x7c    jal ra,ffffffff8401030e <thread_state_ptr_get_blockingIPCBadge>
    0x8401396c    0x80    mv s5,s0
    0x8401396e    0x82    ld s0,408(s0)
    0x84013972    0x86    bne a0,s2,ffffffff84013962 <cancelBadgedSends+0x76>
    0x84013976    0x8a    j ffffffff84013942 <cancelBadgedSends+0x56>
    0x84013978    0x8c    mv a1,s1
    0x8401397a    0x8e    mv a0,s3
    0x8401397c    0x90    jal ra,ffffffff8401015c <endpoint_ptr_set_epQueue_head>
    0x84013980    0x94    mv a1,s4
    0x84013982    0x96    mv a0,s3
    0x84013984    0x98    jal ra,ffffffff84010160 <endpoint_ptr_set_epQueue_tail>
    0x84013988    0x9c    beqz s1,ffffffff84013992 <cancelBadgedSends+0xa6>
    0x8401398a    0x9e    li a1,1
    0x8401398c    0xa0    mv a0,s3
    0x8401398e    0xa2    jal ra,ffffffff8401017e <endpoint_ptr_set_state>
    0x84013992    0xa6    jal ra,ffffffff84012fa8 <rescheduleRequired>
    0x84013996    0xaa    ld ra,72(sp)          ; stack access
    0x84013998    0xac    ld s0,64(sp)          ; stack access
    0x8401399a    0xae    ld s1,56(sp)          ; stack access
    0x8401399c    0xb0    ld s2,48(sp)          ; stack access
    0x8401399e    0xb2    ld s3,40(sp)          ; stack access
    0x840139a0    0xb4    ld s4,32(sp)          ; stack access
    0x840139a2    0xb6    ld s5,24(sp)          ; stack access
    0x840139a4    0xb8    addi sp,sp,80
    0x840139a6    0xba    ret
    0x840139a8    0xbc    li a1,0
    0x840139aa    0xbe    mv a0,s3
    0x840139ac    0xc0    jal ra,ffffffff8401015c <endpoint_ptr_set_epQueue_head>
    0x840139b0    0xc4    mv a1,s1
    0x840139b2    0xc6    mv a0,s3
    0x840139b4    0xc8    jal ra,ffffffff84010160 <endpoint_ptr_set_epQueue_tail>
    0x840139b8    0xcc    j ffffffff84013992 <cancelBadgedSends+0xa6>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
82 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelBadgedSends` has 129 nodes.

Section cteInsert (413 of 432)
==============================

Deriving specifications
-----------------------

Section `cteInsert` consists of 140 instructions.


Stack analysis
---------------

58 stack accesses found. Annotated code for `cteInsert`:

    0x84011e56      0x0    addi sp,sp,-144
    0x84011e58      0x2    sd ra,136(sp)         ; stack access
    0x84011e5a      0x4    sd s0,128(sp)         ; stack access
    0x84011e5c      0x6    sd s1,120(sp)         ; stack access
    0x84011e5e      0x8    sd s2,112(sp)         ; stack access
    0x84011e60      0xa    sd s3,104(sp)         ; stack access
    0x84011e62      0xc    sd s4,96(sp)          ; stack access
    0x84011e64      0xe    sd a0,0(sp)           ; stack access
    0x84011e66     0x10    sd a1,8(sp)           ; stack access
    0x84011e68     0x12    mv s1,a2
    0x84011e6a     0x14    mv s2,a3
    0x84011e6c     0x16    ld a5,16(a2)
    0x84011e6e     0x18    sd a5,80(sp)          ; stack access
    0x84011e70     0x1a    ld a5,24(a2)
    0x84011e72     0x1c    sd a5,88(sp)          ; stack access
    0x84011e74     0x1e    ld s4,0(a2)
    0x84011e78     0x22    ld s3,8(a2)
    0x84011e7c     0x26    sd a0,16(sp)          ; stack access
    0x84011e7e     0x28    sd a1,24(sp)          ; stack access
    0x84011e80     0x2a    sd s4,32(sp)          ; stack access
    0x84011e82     0x2c    sd s3,40(sp)          ; stack access
    0x84011e84     0x2e    jal ra,ffffffff8401039e <cap_get_capType>
    0x84011e88     0x32    andi s0,a0,1
    0x84011e8c     0x36    bnez s0,ffffffff84011ef6 <cteInsert+0xa0>
    0x84011e8e     0x38    ld a0,16(sp)          ; stack access
    0x84011e90     0x3a    ld a1,24(sp)          ; stack access
    0x84011e92     0x3c    jal ra,ffffffff8401039e <cap_get_capType>
    0x84011e96     0x40    li a5,6
    0x84011e98     0x42    beq a0,a5,ffffffff84011edc <cteInsert+0x86>
    0x84011e9c     0x46    bltu a5,a0,ffffffff84011ec6 <cteInsert+0x70>
    0x84011ea0     0x4a    li a5,2
    0x84011ea2     0x4c    beq a0,a5,ffffffff84011f68 <cteInsert+0x112>
    0x84011ea6     0x50    li a5,4
    0x84011ea8     0x52    bne a0,a5,ffffffff84011ef8 <cteInsert+0xa2>
    0x84011eac     0x56    ld a0,16(sp)          ; stack access
    0x84011eae     0x58    ld a1,24(sp)          ; stack access
    0x84011eb0     0x5a    jal ra,ffffffff84010446 <cap_endpoint_cap_get_capEPBadge>
    0x84011eb4     0x5e    mv s0,a0
    0x84011eb6     0x60    ld a0,32(sp)          ; stack access
    0x84011eb8     0x62    ld a1,40(sp)          ; stack access
    0x84011eba     0x64    jal ra,ffffffff84010446 <cap_endpoint_cap_get_capEPBadge>
    0x84011ebe     0x68    sub s0,s0,a0
    0x84011ec0     0x6a    snez s0,s0
    0x84011ec4     0x6e    j ffffffff84011ef8 <cteInsert+0xa2>
    0x84011ec6     0x70    li a5,16
    0x84011ec8     0x72    bne a0,a5,ffffffff84011ef8 <cteInsert+0xa2>
    0x84011ecc     0x76    ld a0,32(sp)          ; stack access
    0x84011ece     0x78    ld a1,40(sp)          ; stack access
    0x84011ed0     0x7a    jal ra,ffffffff8401039e <cap_get_capType>
    0x84011ed4     0x7e    addi a0,a0,-14
    0x84011ed6     0x80    seqz s0,a0
    0x84011eda     0x84    j ffffffff84011ef8 <cteInsert+0xa2>
    0x84011edc     0x86    ld a0,16(sp)          ; stack access
    0x84011ede     0x88    ld a1,24(sp)          ; stack access
    0x84011ee0     0x8a    jal ra,ffffffff840104f0 <cap_notification_cap_get_capNtfnBadge>
    0x84011ee4     0x8e    mv s0,a0
    0x84011ee6     0x90    ld a0,32(sp)          ; stack access
    0x84011ee8     0x92    ld a1,40(sp)          ; stack access
    0x84011eea     0x94    jal ra,ffffffff840104f0 <cap_notification_cap_get_capNtfnBadge>
    0x84011eee     0x98    sub s0,s0,a0
    0x84011ef0     0x9a    snez s0,s0
    0x84011ef4     0x9e    j ffffffff84011ef8 <cteInsert+0xa2>
    0x84011ef6     0xa0    li s0,0
    0x84011ef8     0xa2    mv a2,s1
    0x84011efa     0xa4    ld a0,80(sp)          ; stack access
    0x84011efc     0xa6    ld a1,88(sp)          ; stack access
    0x84011efe     0xa8    jal ra,ffffffff8401020e <mdb_node_set_mdbPrev>
    0x84011f02     0xac    mv a2,s0
    0x84011f04     0xae    jal ra,ffffffff840101ca <mdb_node_set_mdbRevocable>
    0x84011f08     0xb2    mv a2,s0
    0x84011f0a     0xb4    jal ra,ffffffff840101f0 <mdb_node_set_mdbFirstBadged>
    0x84011f0e     0xb8    sd a0,64(sp)          ; stack access
    0x84011f10     0xba    sd a1,72(sp)          ; stack access
    0x84011f12     0xbc    sd s4,32(sp)          ; stack access
    0x84011f14     0xbe    sd s3,40(sp)          ; stack access
    0x84011f16     0xc0    ld a5,0(sp)           ; stack access
    0x84011f18     0xc2    sd a5,48(sp)          ; stack access
    0x84011f1a     0xc4    ld a5,8(sp)           ; stack access
    0x84011f1c     0xc6    sd a5,56(sp)          ; stack access
    0x84011f1e     0xc8    mv a0,s4
    0x84011f20     0xca    mv a1,s3
    0x84011f22     0xcc    jal ra,ffffffff8401039e <cap_get_capType>
    0x84011f26     0xd0    li a5,2
    0x84011f28     0xd2    beq a0,a5,ffffffff84011f6c <cteInsert+0x116>
    0x84011f2c     0xd6    ld a5,0(sp)           ; stack access
    0x84011f2e     0xd8    sd a5,0(s2)
    0x84011f32     0xdc    ld a5,8(sp)           ; stack access
    0x84011f34     0xde    sd a5,8(s2)
    0x84011f38     0xe2    ld a5,64(sp)          ; stack access
    0x84011f3a     0xe4    sd a5,16(s2)
    0x84011f3e     0xe8    ld a5,72(sp)          ; stack access
    0x84011f40     0xea    sd a5,24(s2)
    0x84011f44     0xee    mv a1,s2
    0x84011f46     0xf0    addi a0,s1,16
    0x84011f4a     0xf4    jal ra,ffffffff840101a6 <mdb_node_ptr_set_mdbNext>
    0x84011f4e     0xf8    ld a0,64(sp)          ; stack access
    0x84011f50     0xfa    ld a1,72(sp)          ; stack access
    0x84011f52     0xfc    jal ra,ffffffff84010b08 <mdb_node_get_mdbNext>
    0x84011f56    0x100    bnez a0,ffffffff84011fb6 <cteInsert+0x160>
    0x84011f58    0x102    ld ra,136(sp)         ; stack access
    0x84011f5a    0x104    ld s0,128(sp)         ; stack access
    0x84011f5c    0x106    ld s1,120(sp)         ; stack access
    0x84011f5e    0x108    ld s2,112(sp)         ; stack access
    0x84011f60    0x10a    ld s3,104(sp)         ; stack access
    0x84011f62    0x10c    ld s4,96(sp)          ; stack access
    0x84011f64    0x10e    addi sp,sp,144
    0x84011f66    0x110    ret
    0x84011f68    0x112    li s0,1
    0x84011f6a    0x114    j ffffffff84011ef8 <cteInsert+0xa2>
    0x84011f6c    0x116    ld a0,48(sp)          ; stack access
    0x84011f6e    0x118    ld a1,56(sp)          ; stack access
    0x84011f70    0x11a    jal ra,ffffffff8401039e <cap_get_capType>
    0x84011f74    0x11e    li a5,2
    0x84011f76    0x120    bne a0,a5,ffffffff84011f2c <cteInsert+0xd6>
    0x84011f7a    0x124    ld a0,32(sp)          ; stack access
    0x84011f7c    0x126    ld a1,40(sp)          ; stack access
    0x84011f7e    0x128    jal ra,ffffffff840109e0 <cap_untyped_cap_get_capPtr>
    0x84011f82    0x12c    mv s0,a0
    0x84011f84    0x12e    ld a0,48(sp)          ; stack access
    0x84011f86    0x130    ld a1,56(sp)          ; stack access
    0x84011f88    0x132    jal ra,ffffffff840109e0 <cap_untyped_cap_get_capPtr>
    0x84011f8c    0x136    bne s0,a0,ffffffff84011f2c <cteInsert+0xd6>
    0x84011f90    0x13a    ld a0,48(sp)          ; stack access
    0x84011f92    0x13c    ld a1,56(sp)          ; stack access
    0x84011f94    0x13e    jal ra,ffffffff84010410 <cap_untyped_cap_get_capBlockSize>
    0x84011f98    0x142    mv s0,a0
    0x84011f9a    0x144    ld a0,32(sp)          ; stack access
    0x84011f9c    0x146    ld a1,40(sp)          ; stack access
    0x84011f9e    0x148    jal ra,ffffffff84010410 <cap_untyped_cap_get_capBlockSize>
    0x84011fa2    0x14c    bne s0,a0,ffffffff84011f2c <cteInsert+0xd6>
    0x84011fa6    0x150    addiw a0,a0,-4
    0x84011fa8    0x152    li a1,1
    0x84011faa    0x154    sll a1,a1,a0
    0x84011fae    0x158    mv a0,s1
    0x84011fb0    0x15a    jal ra,ffffffff840103f6 <cap_untyped_cap_ptr_set_capFreeIndex>
    0x84011fb4    0x15e    j ffffffff84011f2c <cteInsert+0xd6>
    0x84011fb6    0x160    mv a1,s2
    0x84011fb8    0x162    addi a0,a0,16
    0x84011fba    0x164    jal ra,ffffffff84010216 <mdb_node_ptr_set_mdbPrev>
    0x84011fbe    0x168    j ffffffff84011f58 <cteInsert+0x102>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
140 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteInsert` has 249 nodes.

Section handleInvocation (414 of 432)
=====================================

Deriving specifications
-----------------------

Section `handleInvocation` consists of 121 instructions.


Stack analysis
---------------

26 stack accesses found. Annotated code for `handleInvocation`:

    0x840173c6      0x0    addi sp,sp,-160
    0x840173c8      0x2    sd ra,152(sp)         ; stack access
    0x840173ca      0x4    sd s0,144(sp)         ; stack access
    0x840173cc      0x6    sd s1,136(sp)         ; stack access
    0x840173ce      0x8    sd s2,128(sp)         ; stack access
    0x840173d0      0xa    sd s3,120(sp)         ; stack access
    0x840173d2      0xc    sd s4,112(sp)         ; stack access
    0x840173d4      0xe    sd s5,104(sp)         ; stack access
    0x840173d6     0x10    sd s6,96(sp)          ; stack access
    0x840173d8     0x12    sd s7,88(sp)          ; stack access
    0x840173da     0x14    mv s5,a0
    0x840173dc     0x16    mv s3,a1
    0x840173de     0x18    auipc s0,0x17
    0x840173e2     0x1c    ld s0,1722(s0) # ffffffff8402ea98 <ksCurThread>
    0x840173e6     0x20    ld s1,80(s0)
    0x840173e8     0x22    mv a0,s1
    0x840173ea     0x24    jal ra,ffffffff84010146 <seL4_MessageInfo_get_length>
    0x840173ee     0x28    li a5,120
    0x840173f2     0x2c    bgeu a5,a0,ffffffff84017402 <handleInvocation+0x3c>
    0x840173f6     0x30    li a1,120
    0x840173fa     0x34    mv a0,s1
    0x840173fc     0x36    jal ra,ffffffff8401014c <seL4_MessageInfo_set_length>
    0x84017400     0x3a    mv s1,a0
    0x84017402     0x3c    mv s7,s1
    0x84017404     0x3e    ld s6,72(s0)
    0x84017408     0x42    mv a2,s6
    0x8401740a     0x44    mv a1,s0
    0x8401740c     0x46    addi a0,sp,48
    0x8401740e     0x48    jal ra,ffffffff84011c3a <lookupCapAndSlot>
    0x84017412     0x4c    ld s4,48(sp)          ; stack access
    0x84017414     0x4e    bnez s4,ffffffff8401749a <handleInvocation+0xd4>
    0x84017418     0x52    mv a1,s0
    0x8401741a     0x54    li a0,0
    0x8401741c     0x56    jal ra,ffffffff84010f0e <lookupIPCBuffer>
    0x84017420     0x5a    mv s2,a0
    0x84017422     0x5c    mv a2,s1
    0x84017424     0x5e    mv a1,a0
    0x84017426     0x60    mv a0,s0
    0x84017428     0x62    jal ra,ffffffff84014968 <lookupExtraCaps>
    0x8401742c     0x66    mv s1,a0
    0x8401742e     0x68    bnez a0,ffffffff840174be <handleInvocation+0xf8>
    0x84017430     0x6a    mv a0,s7
    0x84017432     0x6c    jal ra,ffffffff84010146 <seL4_MessageInfo_get_length>
    0x84017436     0x70    mv s4,a0
    0x84017438     0x72    li a5,4
    0x8401743a     0x74    bltu a5,a0,ffffffff840174ce <handleInvocation+0x108>
    0x8401743e     0x78    mv a0,s7
    0x84017440     0x7a    jal ra,ffffffff84010112 <seL4_MessageInfo_get_label>
    0x84017444     0x7e    sd s2,0(sp)           ; stack access
    0x84017446     0x80    mv a7,s5
    0x84017448     0x82    mv a6,s3
    0x8401744a     0x84    ld a4,56(sp)          ; stack access
    0x8401744c     0x86    ld a5,64(sp)          ; stack access
    0x8401744e     0x88    ld a3,72(sp)          ; stack access
    0x84017450     0x8a    mv a2,s6
    0x84017452     0x8c    mv a1,s4
    0x84017454     0x8e    jal ra,ffffffff840171b4 <decodeInvocation>
    0x84017458     0x92    li a5,4
    0x8401745a     0x94    beq a0,a5,ffffffff840174fc <handleInvocation+0x136>
    0x8401745e     0x98    li a5,3
    0x84017460     0x9a    beq a0,a5,ffffffff840174d6 <handleInvocation+0x110>
    0x84017464     0x9e    ld a5,280(s0)
    0x84017468     0xa2    sd a5,16(sp)          ; stack access
    0x8401746a     0xa4    ld a5,288(s0)
    0x8401746e     0xa8    sd a5,24(sp)          ; stack access
    0x84017470     0xaa    ld a5,296(s0)
    0x84017474     0xae    sd a5,32(sp)          ; stack access
    0x84017476     0xb0    addi a0,sp,16
    0x84017478     0xb2    jal ra,ffffffff84010382 <thread_state_get_tsType>
    0x8401747c     0xb6    li a5,2
    0x8401747e     0xb8    beq a0,a5,ffffffff840174e6 <handleInvocation+0x120>
    0x84017482     0xbc    mv a0,s1
    0x84017484     0xbe    ld ra,152(sp)         ; stack access
    0x84017486     0xc0    ld s0,144(sp)         ; stack access
    0x84017488     0xc2    ld s1,136(sp)         ; stack access
    0x8401748a     0xc4    ld s2,128(sp)         ; stack access
    0x8401748c     0xc6    ld s3,120(sp)         ; stack access
    0x8401748e     0xc8    ld s4,112(sp)         ; stack access
    0x84017490     0xca    ld s5,104(sp)         ; stack access
    0x84017492     0xcc    ld s6,96(sp)          ; stack access
    0x84017494     0xce    ld s7,88(sp)          ; stack access
    0x84017496     0xd0    addi sp,sp,160
    0x84017498     0xd2    ret
    0x8401749a     0xd4    li a1,0
    0x8401749c     0xd6    mv a0,s6
    0x8401749e     0xd8    jal ra,ffffffff8401085c <seL4_Fault_CapFault_new>
    0x840174a2     0xdc    auipc a5,0x5
    0x840174a6     0xe0    addi a5,a5,862 # ffffffff8401c800 <current_fault>
    0x840174aa     0xe4    sd a0,0(a5)
    0x840174ac     0xe6    sd a1,8(a5)
    0x840174ae     0xe8    mv s1,s3
    0x840174b0     0xea    beqz s3,ffffffff84017482 <handleInvocation+0xbc>
    0x840174b4     0xee    mv a0,s0
    0x840174b6     0xf0    jal ra,ffffffff84014fba <handleFault>
    0x840174ba     0xf4    li s1,0
    0x840174bc     0xf6    j ffffffff84017482 <handleInvocation+0xbc>
    0x840174be     0xf8    mv s1,s3
    0x840174c0     0xfa    beqz s3,ffffffff84017482 <handleInvocation+0xbc>
    0x840174c4     0xfe    mv a0,s0
    0x840174c6    0x100    jal ra,ffffffff84014fba <handleFault>
    0x840174ca    0x104    mv s1,s4
    0x840174cc    0x106    j ffffffff84017482 <handleInvocation+0xbc>
    0x840174ce    0x108    bnez s2,ffffffff8401743e <handleInvocation+0x78>
    0x840174d2    0x10c    li s4,4
    0x840174d4    0x10e    j ffffffff8401743e <handleInvocation+0x78>
    0x840174d6    0x110    bnez s5,ffffffff840174de <handleInvocation+0x118>
    0x840174da    0x114    mv s1,s5
    0x840174dc    0x116    j ffffffff84017482 <handleInvocation+0xbc>
    0x840174de    0x118    mv a0,s0
    0x840174e0    0x11a    jal ra,ffffffff840163fc <replyFromKernel_error>
    0x840174e4    0x11e    j ffffffff84017482 <handleInvocation+0xbc>
    0x840174e6    0x120    bnez s5,ffffffff840174f4 <handleInvocation+0x12e>
    0x840174ea    0x124    li a1,1
    0x840174ec    0x126    mv a0,s0
    0x840174ee    0x128    jal ra,ffffffff84013020 <setThreadState>
    0x840174f2    0x12c    j ffffffff84017482 <handleInvocation+0xbc>
    0x840174f4    0x12e    mv a0,s0
    0x840174f6    0x130    jal ra,ffffffff840122fa <replyFromKernel_success_empty>
    0x840174fa    0x134    j ffffffff840174ea <handleInvocation+0x124>
    0x840174fc    0x136    mv s1,a0
    0x840174fe    0x138    j ffffffff84017482 <handleInvocation+0xbc>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
121 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleInvocation` has 195 nodes.

Section doNormalTransfer (415 of 432)
=====================================

Deriving specifications
-----------------------

Section `doNormalTransfer` consists of 142 instructions.

SLLW.....

Stack analysis
---------------

39 stack accesses found. Annotated code for `doNormalTransfer`:

    0x84014a7e      0x0    addi sp,sp,-160
    0x84014a80      0x2    sd ra,152(sp)         ; stack access
    0x84014a82      0x4    sd s0,144(sp)         ; stack access
    0x84014a84      0x6    sd s1,136(sp)         ; stack access
    0x84014a86      0x8    sd s2,128(sp)         ; stack access
    0x84014a88      0xa    sd s3,120(sp)         ; stack access
    0x84014a8a      0xc    sd s4,112(sp)         ; stack access
    0x84014a8c      0xe    sd s5,104(sp)         ; stack access
    0x84014a8e     0x10    sd s6,96(sp)          ; stack access
    0x84014a90     0x12    sd s7,88(sp)          ; stack access
    0x84014a92     0x14    sd s8,80(sp)          ; stack access
    0x84014a94     0x16    sd s9,72(sp)          ; stack access
    0x84014a96     0x18    sd s10,64(sp)         ; stack access
    0x84014a98     0x1a    sd s11,56(sp)         ; stack access
    0x84014a9a     0x1c    mv s4,a0
    0x84014a9c     0x1e    mv s6,a1
    0x84014a9e     0x20    mv s5,a2
    0x84014aa0     0x22    mv s3,a3
    0x84014aa2     0x24    mv s7,a4
    0x84014aa4     0x26    mv s1,a5
    0x84014aa6     0x28    mv s2,a6
    0x84014aa8     0x2a    ld s0,80(a0)
    0x84014aaa     0x2c    mv a0,s0
    0x84014aac     0x2e    jal ra,ffffffff84010146 <seL4_MessageInfo_get_length>
    0x84014ab0     0x32    li a5,120
    0x84014ab4     0x36    bgeu a5,a0,ffffffff84014ac4 <doNormalTransfer+0x46>
    0x84014ab8     0x3a    li a1,120
    0x84014abc     0x3e    mv a0,s0
    0x84014abe     0x40    jal ra,ffffffff8401014c <seL4_MessageInfo_set_length>
    0x84014ac2     0x44    mv s0,a0
    0x84014ac4     0x46    bnez s7,ffffffff84014b2c <doNormalTransfer+0xae>
    0x84014ac8     0x4a    auipc a5,0x9
    0x84014acc     0x4e    sd zero,440(a5) # ffffffff8401dc80 <current_extra_caps>
    0x84014ad0     0x52    mv a0,s0
    0x84014ad2     0x54    jal ra,ffffffff84010146 <seL4_MessageInfo_get_length>
    0x84014ad6     0x58    mv a4,a0
    0x84014ad8     0x5a    mv a3,s2
    0x84014ada     0x5c    mv a2,s1
    0x84014adc     0x5e    mv a1,s6
    0x84014ade     0x60    mv a0,s4
    0x84014ae0     0x62    jal ra,ffffffff84014a0e <copyMRs>
    0x84014ae4     0x66    mv s4,a0
    0x84014ae6     0x68    li a1,0
    0x84014ae8     0x6a    mv a0,s0
    0x84014aea     0x6c    jal ra,ffffffff84010138 <seL4_MessageInfo_set_extraCaps>
    0x84014aee     0x70    li a1,0
    0x84014af0     0x72    jal ra,ffffffff8401011c <seL4_MessageInfo_set_capsUnwrapped>
    0x84014af4     0x76    mv s0,a0
    0x84014af6     0x78    auipc a5,0x9
    0x84014afa     0x7c    ld a5,394(a5) # ffffffff8401dc80 <current_extra_caps>
    0x84014afe     0x80    bnez a5,ffffffff84014b42 <doNormalTransfer+0xc4>
    0x84014b00     0x82    mv a0,s0
    0x84014b02     0x84    mv a1,s4
    0x84014b04     0x86    jal ra,ffffffff8401014c <seL4_MessageInfo_set_length>
    0x84014b08     0x8a    sd a0,80(s1)
    0x84014b0a     0x8c    sd s3,72(s1)
    0x84014b0e     0x90    ld ra,152(sp)         ; stack access
    0x84014b10     0x92    ld s0,144(sp)         ; stack access
    0x84014b12     0x94    ld s1,136(sp)         ; stack access
    0x84014b14     0x96    ld s2,128(sp)         ; stack access
    0x84014b16     0x98    ld s3,120(sp)         ; stack access
    0x84014b18     0x9a    ld s4,112(sp)         ; stack access
    0x84014b1a     0x9c    ld s5,104(sp)         ; stack access
    0x84014b1c     0x9e    ld s6,96(sp)          ; stack access
    0x84014b1e     0xa0    ld s7,88(sp)          ; stack access
    0x84014b20     0xa2    ld s8,80(sp)          ; stack access
    0x84014b22     0xa4    ld s9,72(sp)          ; stack access
    0x84014b24     0xa6    ld s10,64(sp)         ; stack access
    0x84014b26     0xa8    ld s11,56(sp)         ; stack access
    0x84014b28     0xaa    addi sp,sp,160
    0x84014b2a     0xac    ret
    0x84014b2c     0xae    mv a2,s0
    0x84014b2e     0xb0    mv a1,s6
    0x84014b30     0xb2    mv a0,s4
    0x84014b32     0xb4    jal ra,ffffffff84014968 <lookupExtraCaps>
    0x84014b36     0xb8    beqz a0,ffffffff84014ad0 <doNormalTransfer+0x52>
    0x84014b38     0xba    auipc a5,0x9
    0x84014b3c     0xbe    sd zero,328(a5) # ffffffff8401dc80 <current_extra_caps>
    0x84014b40     0xc2    j ffffffff84014ad0 <doNormalTransfer+0x52>
    0x84014b42     0xc4    beqz s2,ffffffff84014b00 <doNormalTransfer+0x82>
    0x84014b46     0xc8    mv a1,s2
    0x84014b48     0xca    mv a0,s1
    0x84014b4a     0xcc    jal ra,ffffffff84012280 <getReceiveSlots>
    0x84014b4e     0xd0    mv s7,a0
    0x84014b50     0xd2    auipc s9,0x9
    0x84014b54     0xd6    addi s9,s9,304 # ffffffff8401dc80 <current_extra_caps>
    0x84014b58     0xda    li s8,0
    0x84014b5a     0xdc    li s10,4
    0x84014b5c     0xde    li s11,3
    0x84014b5e     0xe0    j ffffffff84014b94 <doNormalTransfer+0x116>
    0x84014b60     0xe2    beqz s7,ffffffff84014be6 <doNormalTransfer+0x168>
    0x84014b64     0xe6    ld a2,8(sp)           ; stack access
    0x84014b66     0xe8    ld a3,16(sp)          ; stack access
    0x84014b68     0xea    mv a1,s6
    0x84014b6a     0xec    addi a0,sp,24
    0x84014b6c     0xee    jal ra,ffffffff840129da <deriveCap>
    0x84014b70     0xf2    ld a5,24(sp)          ; stack access
    0x84014b72     0xf4    bnez a5,ffffffff84014be6 <doNormalTransfer+0x168>
    0x84014b74     0xf6    ld a0,32(sp)          ; stack access
    0x84014b76     0xf8    ld a1,40(sp)          ; stack access
    0x84014b78     0xfa    jal ra,ffffffff8401039e <cap_get_capType>
    0x84014b7c     0xfe    beqz a0,ffffffff84014be6 <doNormalTransfer+0x168>
    0x84014b7e    0x100    mv a3,s7
    0x84014b80    0x102    mv a2,s6
    0x84014b82    0x104    ld a0,32(sp)          ; stack access
    0x84014b84    0x106    ld a1,40(sp)          ; stack access
    0x84014b86    0x108    jal ra,ffffffff84011e56 <cteInsert>
    0x84014b8a    0x10c    li s7,0
    0x84014b8c    0x10e    addi s8,s8,1
    0x84014b8e    0x110    addi s9,s9,8
    0x84014b90    0x112    beq s8,s11,ffffffff84014be6 <doNormalTransfer+0x168>
    0x84014b94    0x116    ld s6,0(s9)
    0x84014b98    0x11a    beqz s6,ffffffff84014be6 <doNormalTransfer+0x168>
    0x84014b9c    0x11e    ld a0,0(s6)
    0x84014ba0    0x122    sd a0,8(sp)           ; stack access
    0x84014ba2    0x124    ld a1,8(s6)
    0x84014ba6    0x128    sd a1,16(sp)          ; stack access
    0x84014ba8    0x12a    jal ra,ffffffff8401039e <cap_get_capType>
    0x84014bac    0x12e    bne a0,s10,ffffffff84014b60 <doNormalTransfer+0xe2>
    0x84014bb0    0x132    ld a0,8(sp)           ; stack access
    0x84014bb2    0x134    ld a1,16(sp)          ; stack access
    0x84014bb4    0x136    jal ra,ffffffff840109fe <cap_endpoint_cap_get_capEPPtr>
    0x84014bb8    0x13a    bne s5,a0,ffffffff84014b60 <doNormalTransfer+0xe2>
    0x84014bbc    0x13e    ld a0,8(sp)           ; stack access
    0x84014bbe    0x140    ld a1,16(sp)          ; stack access
    0x84014bc0    0x142    jal ra,ffffffff84010446 <cap_endpoint_cap_get_capEPBadge>
    0x84014bc4    0x146    slli a5,s8,0x3
    0x84014bc8    0x14a    add a5,a5,s2
    0x84014bca    0x14c    sd a0,976(a5)
    0x84014bce    0x150    mv a0,s0
    0x84014bd0    0x152    jal ra,ffffffff84010116 <seL4_MessageInfo_get_capsUnwrapped>
    0x84014bd4    0x156    li a5,1
    0x84014bd6    0x158    sllw a1,a5,s8
    0x84014bda    0x15c    or a1,a1,a0
    0x84014bdc    0x15e    mv a0,s0
    0x84014bde    0x160    jal ra,ffffffff8401011c <seL4_MessageInfo_set_capsUnwrapped>
    0x84014be2    0x164    mv s0,a0
    0x84014be4    0x166    j ffffffff84014b8c <doNormalTransfer+0x10e>
    0x84014be6    0x168    mv a1,s8
    0x84014be8    0x16a    mv a0,s0
    0x84014bea    0x16c    jal ra,ffffffff84010138 <seL4_MessageInfo_set_extraCaps>
    0x84014bee    0x170    j ffffffff84014b02 <doNormalTransfer+0x84>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
142 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doNormalTransfer` has 234 nodes.

Section cancelIPC (416 of 432)
==============================

Deriving specifications
-----------------------

Section `cancelIPC` consists of 68 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `cancelIPC`:

    0x84013a46     0x0    addi sp,sp,-64
    0x84013a48     0x2    sd ra,56(sp)          ; stack access
    0x84013a4a     0x4    sd s0,48(sp)          ; stack access
    0x84013a4c     0x6    sd s1,40(sp)          ; stack access
    0x84013a4e     0x8    sd s2,32(sp)          ; stack access
    0x84013a50     0xa    sd s3,24(sp)          ; stack access
    0x84013a52     0xc    mv s0,a0
    0x84013a54     0xe    addi s1,a0,280
    0x84013a58    0x12    mv a0,s1
    0x84013a5a    0x14    jal ra,ffffffff84010388 <thread_state_ptr_get_tsType>
    0x84013a5e    0x18    li a5,5
    0x84013a60    0x1a    beq a0,a5,ffffffff84013ade <cancelIPC+0x98>
    0x84013a64    0x1e    bltu a5,a0,ffffffff84013abe <cancelIPC+0x78>
    0x84013a68    0x22    addi a5,a0,-3
    0x84013a6c    0x26    li a4,1
    0x84013a6e    0x28    bltu a4,a5,ffffffff84013ab0 <cancelIPC+0x6a>
    0x84013a72    0x2c    mv a0,s1
    0x84013a74    0x2e    jal ra,ffffffff84010b24 <thread_state_ptr_get_blockingObject>
    0x84013a78    0x32    mv s1,a0
    0x84013a7a    0x34    jal ra,ffffffff84010158 <endpoint_ptr_get_epQueue_head>
    0x84013a7e    0x38    mv s2,a0
    0x84013a80    0x3a    mv a0,s1
    0x84013a82    0x3c    jal ra,ffffffff84010aee <endpoint_ptr_get_epQueue_tail>
    0x84013a86    0x40    mv a2,a0
    0x84013a88    0x42    mv a1,s2
    0x84013a8a    0x44    mv a0,s0
    0x84013a8c    0x46    jal ra,ffffffff840138b6 <tcbEPDequeue>
    0x84013a90    0x4a    mv s2,a0
    0x84013a92    0x4c    mv s3,a1
    0x84013a94    0x4e    mv a1,a0
    0x84013a96    0x50    mv a0,s1
    0x84013a98    0x52    jal ra,ffffffff8401015c <endpoint_ptr_set_epQueue_head>
    0x84013a9c    0x56    mv a1,s3
    0x84013a9e    0x58    mv a0,s1
    0x84013aa0    0x5a    jal ra,ffffffff84010160 <endpoint_ptr_set_epQueue_tail>
    0x84013aa4    0x5e    beqz s2,ffffffff84013ad4 <cancelIPC+0x8e>
    0x84013aa8    0x62    li a1,0
    0x84013aaa    0x64    mv a0,s0
    0x84013aac    0x66    jal ra,ffffffff84013020 <setThreadState>
    0x84013ab0    0x6a    ld ra,56(sp)          ; stack access
    0x84013ab2    0x6c    ld s0,48(sp)          ; stack access
    0x84013ab4    0x6e    ld s1,40(sp)          ; stack access
    0x84013ab6    0x70    ld s2,32(sp)          ; stack access
    0x84013ab8    0x72    ld s3,24(sp)          ; stack access
    0x84013aba    0x74    addi sp,sp,64
    0x84013abc    0x76    ret
    0x84013abe    0x78    li a5,6
    0x84013ac0    0x7a    bne a0,a5,ffffffff84013ab0 <cancelIPC+0x6a>
    0x84013ac4    0x7e    mv a0,s1
    0x84013ac6    0x80    jal ra,ffffffff84010b24 <thread_state_ptr_get_blockingObject>
    0x84013aca    0x84    mv a1,a0
    0x84013acc    0x86    mv a0,s0
    0x84013ace    0x88    jal ra,ffffffff840139e6 <cancelSignal>
    0x84013ad2    0x8c    j ffffffff84013ab0 <cancelIPC+0x6a>
    0x84013ad4    0x8e    li a1,0
    0x84013ad6    0x90    mv a0,s1
    0x84013ad8    0x92    jal ra,ffffffff8401017e <endpoint_ptr_set_state>
    0x84013adc    0x96    j ffffffff84013aa8 <cancelIPC+0x62>
    0x84013ade    0x98    jal ra,ffffffff84010852 <seL4_Fault_NullFault_new>
    0x84013ae2    0x9c    sd a0,312(s0)
    0x84013ae6    0xa0    sd a1,320(s0)
    0x84013aea    0xa4    andi s0,s0,-1024
    0x84013aee    0xa8    ld a0,80(s0)
    0x84013af0    0xaa    ld a1,88(s0)
    0x84013af2    0xac    jal ra,ffffffff84010b08 <mdb_node_get_mdbNext>
    0x84013af6    0xb0    beqz a0,ffffffff84013ab0 <cancelIPC+0x6a>
    0x84013af8    0xb2    jal ra,ffffffff840144d0 <cteDeleteOne>
    0x84013afc    0xb6    j ffffffff84013ab0 <cancelIPC+0x6a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
68 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelIPC` has 109 nodes.

Section decodeUntypedInvocation (417 of 432)
============================================

Deriving specifications
-----------------------

Section `decodeUntypedInvocation` consists of 258 instructions.


Stack analysis
---------------

49 stack accesses found. Annotated code for `decodeUntypedInvocation`:

    0x84016ee4      0x0    addi sp,sp,-176
    0x84016ee6      0x2    sd ra,168(sp)         ; stack access
    0x84016ee8      0x4    sd s0,160(sp)         ; stack access
    0x84016eea      0x6    sd s1,152(sp)         ; stack access
    0x84016eec      0x8    sd s2,144(sp)         ; stack access
    0x84016eee      0xa    sd s3,136(sp)         ; stack access
    0x84016ef0      0xc    sd s4,128(sp)         ; stack access
    0x84016ef2      0xe    sd s5,120(sp)         ; stack access
    0x84016ef4     0x10    sd s6,112(sp)         ; stack access
    0x84016ef6     0x12    sd s7,104(sp)         ; stack access
    0x84016ef8     0x14    sd s8,96(sp)          ; stack access
    0x84016efa     0x16    sd s9,88(sp)          ; stack access
    0x84016efc     0x18    sd s10,80(sp)         ; stack access
    0x84016efe     0x1a    sd a3,16(sp)          ; stack access
    0x84016f00     0x1c    sd a4,24(sp)          ; stack access
    0x84016f02     0x1e    li a5,1
    0x84016f04     0x20    bne a0,a5,ffffffff84017072 <decodeUntypedInvocation+0x18e>
    0x84016f08     0x24    mv s0,a0
    0x84016f0a     0x26    mv s1,a2
    0x84016f0c     0x28    mv s4,a6
    0x84016f0e     0x2a    li a5,5
    0x84016f10     0x2c    bgeu a5,a1,ffffffff8401709a <decodeUntypedInvocation+0x1b6>
    0x84016f14     0x30    auipc s10,0x7
    0x84016f18     0x34    ld s10,-660(s10) # ffffffff8401dc80 <current_extra_caps>
    0x84016f1c     0x38    beqz s10,ffffffff8401709a <decodeUntypedInvocation+0x1b6>
    0x84016f20     0x3c    auipc s8,0x18
    0x84016f24     0x40    ld s8,-1160(s8) # ffffffff8402ea98 <ksCurThread>
    0x84016f28     0x44    ld s2,88(s8)
    0x84016f2c     0x48    li a5,8
    0x84016f2e     0x4a    bltu a5,s2,ffffffff840170a8 <decodeUntypedInvocation+0x1c4>
    0x84016f32     0x4e    ld s6,96(s8)
    0x84016f36     0x52    mv a1,s6
    0x84016f38     0x54    mv a0,s2
    0x84016f3a     0x56    jal ra,ffffffff84012548 <getObjectSize>
    0x84016f3e     0x5a    mv s3,a0
    0x84016f40     0x5c    li a5,63
    0x84016f44     0x60    bltu a5,s6,ffffffff840170bc <decodeUntypedInvocation+0x1d8>
    0x84016f48     0x64    li a5,38
    0x84016f4c     0x68    bltu a5,a0,ffffffff840170bc <decodeUntypedInvocation+0x1d8>
    0x84016f50     0x6c    li a5,4
    0x84016f52     0x6e    beq s2,a5,ffffffff840170d6 <decodeUntypedInvocation+0x1f2>
    0x84016f56     0x72    bnez s2,ffffffff84016f60 <decodeUntypedInvocation+0x7c>
    0x84016f5a     0x76    li a5,3
    0x84016f5c     0x78    bgeu a5,s6,ffffffff840170ec <decodeUntypedInvocation+0x208>
    0x84016f60     0x7c    ld s5,112(s8)
    0x84016f64     0x80    ld s7,40(s4)
    0x84016f68     0x84    ld s9,48(s4)
    0x84016f6c     0x88    bnez s5,ffffffff840170fe <decodeUntypedInvocation+0x21a>
    0x84016f70     0x8c    ld a5,0(s10)
    0x84016f74     0x90    sd a5,64(sp)          ; stack access
    0x84016f76     0x92    ld a5,8(s10)
    0x84016f7a     0x96    sd a5,72(sp)          ; stack access
    0x84016f7c     0x98    ld a0,64(sp)          ; stack access
    0x84016f7e     0x9a    ld a1,72(sp)          ; stack access
    0x84016f80     0x9c    jal ra,ffffffff8401039e <cap_get_capType>
    0x84016f84     0xa0    li a5,10
    0x84016f86     0xa2    bne a0,a5,ffffffff84017124 <decodeUntypedInvocation+0x240>
    0x84016f8a     0xa6    ld a0,64(sp)          ; stack access
    0x84016f8c     0xa8    ld a1,72(sp)          ; stack access
    0x84016f8e     0xaa    jal ra,ffffffff840105d2 <cap_cnode_cap_get_capCNodeRadix>
    0x84016f92     0xae    li a5,1
    0x84016f94     0xb0    sll a0,a5,a0
    0x84016f98     0xb4    addi a5,a0,-1
    0x84016f9c     0xb8    bltu a5,s7,ffffffff8401714a <decodeUntypedInvocation+0x266>
    0x84016fa0     0xbc    addi a5,s9,-1
    0x84016fa4     0xc0    li a4,255
    0x84016fa8     0xc4    bltu a4,a5,ffffffff84017160 <decodeUntypedInvocation+0x27c>
    0x84016fac     0xc8    sub a0,a0,s7
    0x84016fb0     0xcc    bltu a0,s9,ffffffff8401717a <decodeUntypedInvocation+0x296>
    0x84016fb4     0xd0    ld a0,64(sp)          ; stack access
    0x84016fb6     0xd2    ld a1,72(sp)          ; stack access
    0x84016fb8     0xd4    jal ra,ffffffff84010a1c <cap_cnode_cap_get_capCNodePtr>
    0x84016fbc     0xd8    mv s10,a0
    0x84016fbe     0xda    add s8,s9,s7
    0x84016fc2     0xde    bgeu s7,s8,ffffffff84016fe0 <decodeUntypedInvocation+0xfc>
    0x84016fc6     0xe2    slli s4,s7,0x5
    0x84016fca     0xe6    add s4,s4,a0
    0x84016fcc     0xe8    mv s5,s7
    0x84016fce     0xea    mv a0,s4
    0x84016fd0     0xec    jal ra,ffffffff8401225c <ensureEmptySlot>
    0x84016fd4     0xf0    bnez a0,ffffffff8401707e <decodeUntypedInvocation+0x19a>
    0x84016fd6     0xf2    addi s5,s5,1
    0x84016fd8     0xf4    addi s4,s4,32
    0x84016fdc     0xf8    bltu s5,s8,ffffffff84016fce <decodeUntypedInvocation+0xea>
    0x84016fe0     0xfc    mv a0,s1
    0x84016fe2     0xfe    jal ra,ffffffff840129a8 <ensureNoChildren>
    0x84016fe6    0x102    beqz a0,ffffffff84016ff2 <decodeUntypedInvocation+0x10e>
    0x84016fe8    0x104    ld a0,16(sp)          ; stack access
    0x84016fea    0x106    ld a1,24(sp)          ; stack access
    0x84016fec    0x108    jal ra,ffffffff840103de <cap_untyped_cap_get_capFreeIndex>
    0x84016ff0    0x10c    li s0,0
    0x84016ff2    0x10e    slli s4,a0,0x4
    0x84016ff6    0x112    ld a0,16(sp)          ; stack access
    0x84016ff8    0x114    ld a1,24(sp)          ; stack access
    0x84016ffa    0x116    jal ra,ffffffff84010410 <cap_untyped_cap_get_capBlockSize>
    0x84016ffe    0x11a    li a5,1
    0x84017000    0x11c    sll a5,a5,a0
    0x84017004    0x120    sub a5,a5,s4
    0x84017008    0x124    sext.w s5,s3
    0x8401700c    0x128    srl s3,a5,s3
    0x84017010    0x12c    bltu s3,s9,ffffffff84017190 <decodeUntypedInvocation+0x2ac>
    0x84017014    0x130    ld a0,16(sp)          ; stack access
    0x84017016    0x132    ld a1,24(sp)          ; stack access
    0x84017018    0x134    jal ra,ffffffff84010404 <cap_untyped_cap_get_capIsDevice>
    0x8401701c    0x138    mv s8,a0
    0x8401701e    0x13a    beqz a0,ffffffff8401702e <decodeUntypedInvocation+0x14a>
    0x84017020    0x13c    addi a5,s2,-5
    0x84017024    0x140    li a4,2
    0x84017026    0x142    bgeu a4,a5,ffffffff8401702e <decodeUntypedInvocation+0x14a>
    0x8401702a    0x146    bnez s2,ffffffff840171a2 <decodeUntypedInvocation+0x2be>
    0x8401702e    0x14a    ld a0,16(sp)          ; stack access
    0x84017030    0x14c    ld a1,24(sp)          ; stack access
    0x84017032    0x14e    jal ra,ffffffff840109e0 <cap_untyped_cap_get_capPtr>
    0x84017036    0x152    li a5,1
    0x84017038    0x154    sll s5,a5,s5
    0x8401703c    0x158    addi a5,s5,-1
    0x84017040    0x15c    add s4,s4,a5
    0x84017042    0x15e    add s4,s4,a0
    0x84017044    0x160    neg s5,s5
    0x84017048    0x164    and s4,s4,s5
    0x8401704c    0x168    li a1,2
    0x8401704e    0x16a    auipc a0,0x18
    0x84017052    0x16e    ld a0,-1462(a0) # ffffffff8402ea98 <ksCurThread>
    0x84017056    0x172    jal ra,ffffffff84013020 <setThreadState>
    0x8401705a    0x176    sd s8,0(sp)           ; stack access
    0x8401705c    0x178    mv a7,s9
    0x8401705e    0x17a    mv a6,s7
    0x84017060    0x17c    mv a5,s10
    0x84017062    0x17e    mv a4,s6
    0x84017064    0x180    mv a3,s2
    0x84017066    0x182    mv a2,s4
    0x84017068    0x184    mv a1,s0
    0x8401706a    0x186    mv a0,s1
    0x8401706c    0x188    jal ra,ffffffff84016dce <invokeUntyped_Retype>
    0x84017070    0x18c    j ffffffff8401707e <decodeUntypedInvocation+0x19a>
    0x84017072    0x18e    li a5,3
    0x84017074    0x190    auipc a4,0x7
    0x84017078    0x194    sd a5,-1020(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x8401707c    0x198    li a0,3
    0x8401707e    0x19a    ld ra,168(sp)         ; stack access
    0x84017080    0x19c    ld s0,160(sp)         ; stack access
    0x84017082    0x19e    ld s1,152(sp)         ; stack access
    0x84017084    0x1a0    ld s2,144(sp)         ; stack access
    0x84017086    0x1a2    ld s3,136(sp)         ; stack access
    0x84017088    0x1a4    ld s4,128(sp)         ; stack access
    0x8401708a    0x1a6    ld s5,120(sp)         ; stack access
    0x8401708c    0x1a8    ld s6,112(sp)         ; stack access
    0x8401708e    0x1aa    ld s7,104(sp)         ; stack access
    0x84017090    0x1ac    ld s8,96(sp)          ; stack access
    0x84017092    0x1ae    ld s9,88(sp)          ; stack access
    0x84017094    0x1b0    ld s10,80(sp)         ; stack access
    0x84017096    0x1b2    addi sp,sp,176
    0x84017098    0x1b4    ret
    0x8401709a    0x1b6    li a5,7
    0x8401709c    0x1b8    auipc a4,0x7
    0x840170a0    0x1bc    sd a5,-1060(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840170a4    0x1c0    li a0,3
    0x840170a6    0x1c2    j ffffffff8401707e <decodeUntypedInvocation+0x19a>
    0x840170a8    0x1c4    auipc a5,0x7
    0x840170ac    0x1c8    addi a5,a5,-1120 # ffffffff8401dc48 <current_syscall_error>
    0x840170b0    0x1cc    li a4,1
    0x840170b2    0x1ce    sd a4,48(a5)
    0x840170b4    0x1d0    sd zero,0(a5)
    0x840170b8    0x1d4    li a0,3
    0x840170ba    0x1d6    j ffffffff8401707e <decodeUntypedInvocation+0x19a>
    0x840170bc    0x1d8    auipc a5,0x7
    0x840170c0    0x1dc    addi a5,a5,-1140 # ffffffff8401dc48 <current_syscall_error>
    0x840170c4    0x1e0    li a4,4
    0x840170c6    0x1e2    sd a4,48(a5)
    0x840170c8    0x1e4    sd zero,16(a5)
    0x840170cc    0x1e8    li a4,38
    0x840170d0    0x1ec    sd a4,24(a5)
    0x840170d2    0x1ee    li a0,3
    0x840170d4    0x1f0    j ffffffff8401707e <decodeUntypedInvocation+0x19a>
    0x840170d6    0x1f2    bnez s6,ffffffff84016f60 <decodeUntypedInvocation+0x7c>
    0x840170da    0x1f6    auipc a5,0x7
    0x840170de    0x1fa    addi a5,a5,-1170 # ffffffff8401dc48 <current_syscall_error>
    0x840170e2    0x1fe    li a4,1
    0x840170e4    0x200    sd a4,48(a5)
    0x840170e6    0x202    sd a4,0(a5)
    0x840170e8    0x204    li a0,3
    0x840170ea    0x206    j ffffffff8401707e <decodeUntypedInvocation+0x19a>
    0x840170ec    0x208    auipc a5,0x7
    0x840170f0    0x20c    addi a5,a5,-1188 # ffffffff8401dc48 <current_syscall_error>
    0x840170f4    0x210    li a4,1
    0x840170f6    0x212    sd a4,48(a5)
    0x840170f8    0x214    sd a4,0(a5)
    0x840170fa    0x216    li a0,3
    0x840170fc    0x218    j ffffffff8401707e <decodeUntypedInvocation+0x19a>
    0x840170fe    0x21a    ld a0,0(s10)
    0x84017102    0x21e    sd a0,32(sp)          ; stack access
    0x84017104    0x220    ld a1,8(s10)
    0x84017108    0x224    sd a1,40(sp)          ; stack access
    0x8401710a    0x226    mv a3,s5
    0x8401710c    0x228    ld a2,104(s8)
    0x84017110    0x22c    jal ra,ffffffff84011d7a <lookupTargetSlot>
    0x84017114    0x230    sd a0,48(sp)          ; stack access
    0x84017116    0x232    sd a1,56(sp)          ; stack access
    0x84017118    0x234    bnez a0,ffffffff8401707e <decodeUntypedInvocation+0x19a>
    0x8401711a    0x236    ld a4,0(a1)
    0x8401711c    0x238    sd a4,64(sp)          ; stack access
    0x8401711e    0x23a    ld a5,8(a1)
    0x84017120    0x23c    sd a5,72(sp)          ; stack access
    0x84017122    0x23e    j ffffffff84016f7c <decodeUntypedInvocation+0x98>
    0x84017124    0x240    auipc a5,0x7
    0x84017128    0x244    addi a5,a5,-1244 # ffffffff8401dc48 <current_syscall_error>
    0x8401712c    0x248    li a4,6
    0x8401712e    0x24a    sd a4,48(a5)
    0x84017130    0x24c    sd zero,40(a5)
    0x84017134    0x250    mv a0,s5
    0x84017136    0x252    jal ra,ffffffff840107ba <lookup_fault_missing_capability_new>
    0x8401713a    0x256    auipc a5,0x7
    0x8401713e    0x25a    addi a5,a5,-1290 # ffffffff8401dc30 <current_lookup_fault>
    0x84017142    0x25e    sd a0,0(a5)
    0x84017144    0x260    sd a1,8(a5)
    0x84017146    0x262    li a0,3
    0x84017148    0x264    j ffffffff8401707e <decodeUntypedInvocation+0x19a>
    0x8401714a    0x266    auipc a4,0x7
    0x8401714e    0x26a    addi a4,a4,-1282 # ffffffff8401dc48 <current_syscall_error>
    0x84017152    0x26e    li a3,4
    0x84017154    0x270    sd a3,48(a4)
    0x84017156    0x272    sd zero,16(a4)
    0x8401715a    0x276    sd a5,24(a4)
    0x8401715c    0x278    li a0,3
    0x8401715e    0x27a    j ffffffff8401707e <decodeUntypedInvocation+0x19a>
    0x84017160    0x27c    auipc a5,0x7
    0x84017164    0x280    addi a5,a5,-1304 # ffffffff8401dc48 <current_syscall_error>
    0x84017168    0x284    li a4,4
    0x8401716a    0x286    sd a4,48(a5)
    0x8401716c    0x288    li a4,1
    0x8401716e    0x28a    sd a4,16(a5)
    0x84017170    0x28c    li a4,256
    0x84017174    0x290    sd a4,24(a5)
    0x84017176    0x292    li a0,3
    0x84017178    0x294    j ffffffff8401707e <decodeUntypedInvocation+0x19a>
    0x8401717a    0x296    auipc a5,0x7
    0x8401717e    0x29a    addi a5,a5,-1330 # ffffffff8401dc48 <current_syscall_error>
    0x84017182    0x29e    li a4,4
    0x84017184    0x2a0    sd a4,48(a5)
    0x84017186    0x2a2    li a4,1
    0x84017188    0x2a4    sd a4,16(a5)
    0x8401718a    0x2a6    sd a0,24(a5)
    0x8401718c    0x2a8    li a0,3
    0x8401718e    0x2aa    j ffffffff8401707e <decodeUntypedInvocation+0x19a>
    0x84017190    0x2ac    auipc a4,0x7
    0x84017194    0x2b0    addi a4,a4,-1352 # ffffffff8401dc48 <current_syscall_error>
    0x84017198    0x2b4    li a3,10
    0x8401719a    0x2b6    sd a3,48(a4)
    0x8401719c    0x2b8    sd a5,32(a4)
    0x8401719e    0x2ba    li a0,3
    0x840171a0    0x2bc    j ffffffff8401707e <decodeUntypedInvocation+0x19a>
    0x840171a2    0x2be    auipc a5,0x7
    0x840171a6    0x2c2    addi a5,a5,-1370 # ffffffff8401dc48 <current_syscall_error>
    0x840171aa    0x2c6    li a4,1
    0x840171ac    0x2c8    sd a4,48(a5)
    0x840171ae    0x2ca    sd a4,0(a5)
    0x840171b0    0x2cc    li a0,3
    0x840171b2    0x2ce    j ffffffff8401707e <decodeUntypedInvocation+0x19a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
258 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeUntypedInvocation` has 413 nodes.

Section sendSignal (418 of 432)
===============================

Deriving specifications
-----------------------

Section `sendSignal` consists of 89 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `sendSignal`:

    0x84014696     0x0    addi sp,sp,-64
    0x84014698     0x2    sd ra,56(sp)          ; stack access
    0x8401469a     0x4    sd s0,48(sp)          ; stack access
    0x8401469c     0x6    sd s1,40(sp)          ; stack access
    0x8401469e     0x8    sd s2,32(sp)          ; stack access
    0x840146a0     0xa    sd s3,24(sp)          ; stack access
    0x840146a2     0xc    sd s4,16(sp)          ; stack access
    0x840146a4     0xe    mv s0,a0
    0x840146a6    0x10    mv s2,a1
    0x840146a8    0x12    jal ra,ffffffff84010258 <notification_ptr_get_state>
    0x840146ac    0x16    li a5,1
    0x840146ae    0x18    beq a0,a5,ffffffff84014720 <sendSignal+0x8a>
    0x840146b2    0x1c    li a5,2
    0x840146b4    0x1e    beq a0,a5,ffffffff8401476e <sendSignal+0xd8>
    0x840146b8    0x22    beqz a0,ffffffff840146ca <sendSignal+0x34>
    0x840146ba    0x24    ld ra,56(sp)          ; stack access
    0x840146bc    0x26    ld s0,48(sp)          ; stack access
    0x840146be    0x28    ld s1,40(sp)          ; stack access
    0x840146c0    0x2a    ld s2,32(sp)          ; stack access
    0x840146c2    0x2c    ld s3,24(sp)          ; stack access
    0x840146c4    0x2e    ld s4,16(sp)          ; stack access
    0x840146c6    0x30    addi sp,sp,64
    0x840146c8    0x32    ret
    0x840146ca    0x34    mv a0,s0
    0x840146cc    0x36    jal ra,ffffffff840109c8 <notification_ptr_get_ntfnBoundTCB>
    0x840146d0    0x3a    mv s1,a0
    0x840146d2    0x3c    beqz a0,ffffffff8401470e <sendSignal+0x78>
    0x840146d4    0x3e    addi a0,a0,280
    0x840146d8    0x42    jal ra,ffffffff84010388 <thread_state_ptr_get_tsType>
    0x840146dc    0x46    li a5,3
    0x840146de    0x48    beq a0,a5,ffffffff840146f4 <sendSignal+0x5e>
    0x840146e2    0x4c    li a1,2
    0x840146e4    0x4e    mv a0,s0
    0x840146e6    0x50    jal ra,ffffffff8401025e <notification_ptr_set_state>
    0x840146ea    0x54    mv a1,s2
    0x840146ec    0x56    mv a0,s0
    0x840146ee    0x58    jal ra,ffffffff84010232 <notification_ptr_set_ntfnMsgIdentifier>
    0x840146f2    0x5c    j ffffffff840146ba <sendSignal+0x24>
    0x840146f4    0x5e    mv a0,s1
    0x840146f6    0x60    jal ra,ffffffff84013a46 <cancelIPC>
    0x840146fa    0x64    li a1,1
    0x840146fc    0x66    mv a0,s1
    0x840146fe    0x68    jal ra,ffffffff84013020 <setThreadState>
    0x84014702    0x6c    sd s2,72(s1)
    0x84014706    0x70    mv a0,s1
    0x84014708    0x72    jal ra,ffffffff840132c6 <possibleSwitchTo>
    0x8401470c    0x76    j ffffffff840146ba <sendSignal+0x24>
    0x8401470e    0x78    li a1,2
    0x84014710    0x7a    mv a0,s0
    0x84014712    0x7c    jal ra,ffffffff8401025e <notification_ptr_set_state>
    0x84014716    0x80    mv a1,s2
    0x84014718    0x82    mv a0,s0
    0x8401471a    0x84    jal ra,ffffffff84010232 <notification_ptr_set_ntfnMsgIdentifier>
    0x8401471e    0x88    j ffffffff840146ba <sendSignal+0x24>
    0x84014720    0x8a    mv a0,s0
    0x84014722    0x8c    jal ra,ffffffff84010b3e <notification_ptr_get_ntfnQueue_head>
    0x84014726    0x90    mv s1,a0
    0x84014728    0x92    mv a0,s0
    0x8401472a    0x94    jal ra,ffffffff84010b56 <notification_ptr_get_ntfnQueue_tail>
    0x8401472e    0x98    mv a2,a0
    0x84014730    0x9a    mv a1,s1
    0x84014732    0x9c    mv a0,s1
    0x84014734    0x9e    jal ra,ffffffff840138b6 <tcbEPDequeue>
    0x84014738    0xa2    mv s3,a0
    0x8401473a    0xa4    mv s4,a1
    0x8401473c    0xa6    mv a1,a0
    0x8401473e    0xa8    mv a0,s0
    0x84014740    0xaa    jal ra,ffffffff84010236 <notification_ptr_set_ntfnQueue_head>
    0x84014744    0xae    mv a1,s4
    0x84014746    0xb0    mv a0,s0
    0x84014748    0xb2    jal ra,ffffffff8401024a <notification_ptr_set_ntfnQueue_tail>
    0x8401474c    0xb6    beqz s3,ffffffff84014764 <sendSignal+0xce>
    0x84014750    0xba    li a1,1
    0x84014752    0xbc    mv a0,s1
    0x84014754    0xbe    jal ra,ffffffff84013020 <setThreadState>
    0x84014758    0xc2    sd s2,72(s1)
    0x8401475c    0xc6    mv a0,s1
    0x8401475e    0xc8    jal ra,ffffffff840132c6 <possibleSwitchTo>
    0x84014762    0xcc    j ffffffff840146ba <sendSignal+0x24>
    0x84014764    0xce    li a1,0
    0x84014766    0xd0    mv a0,s0
    0x84014768    0xd2    jal ra,ffffffff8401025e <notification_ptr_set_state>
    0x8401476c    0xd6    j ffffffff84014750 <sendSignal+0xba>
    0x8401476e    0xd8    mv a0,s0
    0x84014770    0xda    jal ra,ffffffff8401022e <notification_ptr_get_ntfnMsgIdentifier>
    0x84014774    0xde    or a1,a0,s2
    0x84014778    0xe2    mv a0,s0
    0x8401477a    0xe4    jal ra,ffffffff84010232 <notification_ptr_set_ntfnMsgIdentifier>
    0x8401477e    0xe8    j ffffffff840146ba <sendSignal+0x24>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
89 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sendSignal` has 136 nodes.

Section sameRegionAs (419 of 432)
=================================

Deriving specifications
-----------------------

Section `sameRegionAs` consists of 312 instructions.

RVC_FTTFFT___FFFT_FT.

Stack analysis
---------------

20 stack accesses found. Annotated code for `sameRegionAs`:

    0x840125de      0x0    addi sp,sp,-96
    0x840125e0      0x2    sd ra,88(sp)          ; stack access
    0x840125e2      0x4    sd s0,80(sp)          ; stack access
    0x840125e4      0x6    sd s1,72(sp)          ; stack access
    0x840125e6      0x8    sd s2,64(sp)          ; stack access
    0x840125e8      0xa    sd a0,16(sp)          ; stack access
    0x840125ea      0xc    sd a1,24(sp)          ; stack access
    0x840125ec      0xe    sd a2,0(sp)           ; stack access
    0x840125ee     0x10    sd a3,8(sp)           ; stack access
    0x840125f0     0x12    jal ra,ffffffff8401039e <cap_get_capType>
    0x840125f4     0x16    li a5,20
    0x840125f6     0x18    bltu a5,a0,ffffffff840128de <sameRegionAs+0x300>
    0x840125fa     0x1c    slli a0,a0,0x2
    0x840125fc     0x1e    auipc a4,0x6
    0x84012600     0x22    addi a4,a4,-1540 # ffffffff84017ff8 <ksDomScheduleLength+0xb0>
    0x84012604     0x26    add a0,a0,a4
    0x84012606     0x28    lw a5,0(a0)
    0x84012608     0x2a    add a5,a5,a4
    0x8401260a     0x2c    jr a5
    0x8401260c     0x2e    ld a0,0(sp)
    0x8401260e     0x30    sd a0,32(sp)
    0x84012610     0x32    ld a1,8(sp)
    0x84012612     0x34    sd a1,40(sp)
    0x84012614     0x36    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012618     0x3a    sext.w a4,a0
    0x8401261c     0x3e    li a5,20
    0x8401261e     0x40    bltu a5,a4,ffffffff84012638 <sameRegionAs+0x5a>
    0x84012622     0x44    slli a0,a0,0x20
    0x84012624     0x46    srli a0,a0,0x20
    0x84012626     0x48    slli a0,a0,0x2
    0x84012628     0x4a    auipc a4,0x6
    0x8401262c     0x4e    addi a4,a4,-1500 # ffffffff8401804c <ksDomScheduleLength+0x104>
    0x84012630     0x52    add a0,a0,a4
    0x84012632     0x54    lw a5,0(a0)
    0x84012634     0x56    add a5,a5,a4
    0x84012636     0x58    jr a5
    0x84012638     0x5a    ld a0,32(sp)
    0x8401263a     0x5c    ld a1,40(sp)
    0x8401263c     0x5e    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012640     0x62    sext.w a5,a0
    0x84012644     0x66    li a4,13
    0x84012646     0x68    bltu a4,a5,ffffffff8401265c <sameRegionAs+0x7e>
    0x8401264a     0x6c    li a0,1
    0x8401264c     0x6e    sll a0,a0,a5
    0x84012650     0x72    lui a5,0x2
    0x84012652     0x74    addi a5,a5,10
    0x84012654     0x76    and a0,a0,a5
    0x84012656     0x78    snez a0,a0
    0x8401265a     0x7c    j ffffffff84012662 <sameRegionAs+0x84>
    0x8401265c     0x7e    li a0,0
    0x8401265e     0x80    j ffffffff84012662 <sameRegionAs+0x84>
    0x84012660     0x82    li a0,1
    0x84012662     0x84    beqz a0,ffffffff84012892 <sameRegionAs+0x2b4>
    0x84012666     0x88    ld a0,16(sp)
    0x84012668     0x8a    ld a1,24(sp)
    0x8401266a     0x8c    jal ra,ffffffff840109e0 <cap_untyped_cap_get_capPtr>
    0x8401266e     0x90    mv s1,a0
    0x84012670     0x92    ld a0,0(sp)
    0x84012672     0x94    ld a1,8(sp)
    0x84012674     0x96    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x84012678     0x9a    mv s0,a0
    0x8401267a     0x9c    ld a0,16(sp)
    0x8401267c     0x9e    ld a1,24(sp)
    0x8401267e     0xa0    jal ra,ffffffff84010410 <cap_untyped_cap_get_capBlockSize>
    0x84012682     0xa4    mv s2,a0
    0x84012684     0xa6    ld a0,0(sp)
    0x84012686     0xa8    sd a0,32(sp)
    0x84012688     0xaa    ld a1,8(sp)
    0x8401268a     0xac    sd a1,40(sp)
    0x8401268c     0xae    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012690     0xb2    sext.w a3,a0
    0x84012694     0xb6    li a4,20
    0x84012696     0xb8    bltu a4,a3,ffffffff84012728 <sameRegionAs+0x14a>
    0x8401269a     0xbc    slli a5,a0,0x20
    0x8401269e     0xc0    srli a5,a5,0x20
    0x840126a0     0xc2    slli a5,a5,0x2
    0x840126a2     0xc4    auipc a4,0x6
    0x840126a6     0xc8    addi a4,a4,-1538 # ffffffff840180a0 <ksDomScheduleLength+0x158>
    0x840126aa     0xcc    add a5,a5,a4
    0x840126ac     0xce    lw a5,0(a5)
    0x840126ae     0xd0    add a5,a5,a4
    0x840126b0     0xd2    jr a5
    0x840126b2     0xd4    li a5,5
    0x840126b4     0xd6    j ffffffff840126c0 <sameRegionAs+0xe2>
    0x840126b6     0xd8    ld a0,32(sp)
    0x840126b8     0xda    ld a1,40(sp)
    0x840126ba     0xdc    jal ra,ffffffff84010410 <cap_untyped_cap_get_capBlockSize>
    0x840126be     0xe0    mv a5,a0
    0x840126c0     0xe2    li a0,0
    0x840126c2     0xe4    bltu s0,s1,ffffffff84012892 <sameRegionAs+0x2b4>
    0x840126c6     0xe8    li a4,1
    0x840126c8     0xea    sll a5,a4,a5
    0x840126cc     0xee    addi a3,s0,-1
    0x840126d0     0xf2    add a5,a5,a3
    0x840126d2     0xf4    sll a4,a4,s2
    0x840126d6     0xf8    addi s1,s1,-1
    0x840126d8     0xfa    add a4,a4,s1
    0x840126da     0xfc    bltu a4,a5,ffffffff84012892 <sameRegionAs+0x2b4>
    0x840126de    0x100    sltu a0,a5,s0
    0x840126e2    0x104    xori a0,a0,1
    0x840126e6    0x108    sext.w a0,a0
    0x840126e8    0x10a    j ffffffff84012892 <sameRegionAs+0x2b4>
    0x840126ea    0x10c    ld a0,32(sp)
    0x840126ec    0x10e    ld a1,40(sp)
    0x840126ee    0x110    jal ra,ffffffff840105d2 <cap_cnode_cap_get_capCNodeRadix>
    0x840126f2    0x114    addi a5,a0,5
    0x840126f6    0x118    j ffffffff840126c0 <sameRegionAs+0xe2>
    0x840126f8    0x11a    li a5,10
    0x840126fa    0x11c    j ffffffff840126c0 <sameRegionAs+0xe2>
    0x840126fc    0x11e    ld a0,32(sp)
    0x840126fe    0x120    ld a1,40(sp)
    0x84012700    0x122    jal ra,ffffffff8401063e <cap_zombie_cap_get_capZombieType>
    0x84012704    0x126    li a5,64
    0x84012708    0x12a    beq a0,a5,ffffffff8401277e <sameRegionAs+0x1a0>
    0x8401270c    0x12e    andi a5,a0,63
    0x84012710    0x132    addi a5,a5,5
    0x84012712    0x134    j ffffffff840126c0 <sameRegionAs+0xe2>
    0x84012714    0x136    li a5,0
    0x84012716    0x138    j ffffffff840126c0 <sameRegionAs+0xe2>
    0x84012718    0x13a    li a5,0
    0x8401271a    0x13c    j ffffffff840126c0 <sameRegionAs+0xe2>
    0x8401271c    0x13e    li a5,0
    0x8401271e    0x140    j ffffffff840126c0 <sameRegionAs+0xe2>
    0x84012720    0x142    li a5,0
    0x84012722    0x144    j ffffffff840126c0 <sameRegionAs+0xe2>
    0x84012724    0x146    li a5,0
    0x84012726    0x148    j ffffffff840126c0 <sameRegionAs+0xe2>
    0x84012728    0x14a    ld a0,32(sp)
    0x8401272a    0x14c    sd a0,48(sp)
    0x8401272c    0x14e    ld a1,40(sp)
    0x8401272e    0x150    sd a1,56(sp)
    0x84012730    0x152    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012734    0x156    sext.w a4,a0
    0x84012738    0x15a    li a5,3
    0x8401273a    0x15c    beq a4,a5,ffffffff84012766 <sameRegionAs+0x188>
    0x8401273e    0x160    li a5,13
    0x84012740    0x162    beq a4,a5,ffffffff8401276a <sameRegionAs+0x18c>
    0x84012744    0x166    li a3,1
    0x84012746    0x168    li a5,0
    0x84012748    0x16a    bne a4,a3,ffffffff840126c0 <sameRegionAs+0xe2>
    0x8401274c    0x16e    ld a0,48(sp)
    0x8401274e    0x170    ld a1,56(sp)
    0x84012750    0x172    jal ra,ffffffff840106a8 <cap_frame_cap_get_capFSize>
    0x84012754    0x176    li a4,1
    0x84012756    0x178    beq a0,a4,ffffffff8401276e <sameRegionAs+0x190>
    0x8401275a    0x17c    li a4,2
    0x8401275c    0x17e    beq a0,a4,ffffffff84012772 <sameRegionAs+0x194>
    0x84012760    0x182    beqz a0,ffffffff84012776 <sameRegionAs+0x198>
    0x84012762    0x184    jal ra,ffffffff84010cec <halt>
    0x84012766    0x188    li a5,12
    0x84012768    0x18a    j ffffffff840126c0 <sameRegionAs+0xe2>
    0x8401276a    0x18c    li a5,12
    0x8401276c    0x18e    j ffffffff840126c0 <sameRegionAs+0xe2>
    0x8401276e    0x190    li a5,21
    0x84012770    0x192    j ffffffff840126c0 <sameRegionAs+0xe2>
    0x84012772    0x194    li a5,30
    0x84012774    0x196    j ffffffff840126c0 <sameRegionAs+0xe2>
    0x84012776    0x198    li a5,12
    0x84012778    0x19a    j ffffffff840126c0 <sameRegionAs+0xe2>
    0x8401277a    0x19c    li a5,4
    0x8401277c    0x19e    j ffffffff840126c0 <sameRegionAs+0xe2>
    0x8401277e    0x1a0    li a5,10
    0x84012780    0x1a2    j ffffffff840126c0 <sameRegionAs+0xe2>
    0x84012782    0x1a4    ld a0,0(sp)
    0x84012784    0x1a6    ld a1,8(sp)
    0x84012786    0x1a8    jal ra,ffffffff8401039e <cap_get_capType>
    0x8401278a    0x1ac    mv a4,a0
    0x8401278c    0x1ae    li a5,4
    0x8401278e    0x1b0    li a0,0
    0x84012790    0x1b2    bne a4,a5,ffffffff84012892 <sameRegionAs+0x2b4>
    0x84012794    0x1b6    ld a0,16(sp)
    0x84012796    0x1b8    ld a1,24(sp)
    0x84012798    0x1ba    jal ra,ffffffff840109fe <cap_endpoint_cap_get_capEPPtr>
    0x8401279c    0x1be    mv s0,a0
    0x8401279e    0x1c0    ld a0,0(sp)
    0x840127a0    0x1c2    ld a1,8(sp)
    0x840127a2    0x1c4    jal ra,ffffffff840109fe <cap_endpoint_cap_get_capEPPtr>
    0x840127a6    0x1c8    sub a0,s0,a0
    0x840127aa    0x1cc    seqz a0,a0
    0x840127ae    0x1d0    j ffffffff84012892 <sameRegionAs+0x2b4>
    0x840127b0    0x1d2    ld a0,0(sp)
    0x840127b2    0x1d4    ld a1,8(sp)
    0x840127b4    0x1d6    jal ra,ffffffff8401039e <cap_get_capType>
    0x840127b8    0x1da    mv a4,a0
    0x840127ba    0x1dc    li a5,6
    0x840127bc    0x1de    li a0,0
    0x840127be    0x1e0    bne a4,a5,ffffffff84012892 <sameRegionAs+0x2b4>
    0x840127c2    0x1e4    ld a0,16(sp)
    0x840127c4    0x1e6    ld a1,24(sp)
    0x840127c6    0x1e8    jal ra,ffffffff840109aa <cap_notification_cap_get_capNtfnPtr>
    0x840127ca    0x1ec    mv s0,a0
    0x840127cc    0x1ee    ld a0,0(sp)
    0x840127ce    0x1f0    ld a1,8(sp)
    0x840127d0    0x1f2    jal ra,ffffffff840109aa <cap_notification_cap_get_capNtfnPtr>
    0x840127d4    0x1f6    sub a0,s0,a0
    0x840127d8    0x1fa    seqz a0,a0
    0x840127dc    0x1fe    j ffffffff84012892 <sameRegionAs+0x2b4>
    0x840127de    0x200    ld a0,0(sp)
    0x840127e0    0x202    ld a1,8(sp)
    0x840127e2    0x204    jal ra,ffffffff8401039e <cap_get_capType>
    0x840127e6    0x208    mv a4,a0
    0x840127e8    0x20a    li a5,10
    0x840127ea    0x20c    li a0,0
    0x840127ec    0x20e    bne a4,a5,ffffffff84012892 <sameRegionAs+0x2b4>
    0x840127f0    0x212    ld a0,16(sp)
    0x840127f2    0x214    ld a1,24(sp)
    0x840127f4    0x216    jal ra,ffffffff84010a1c <cap_cnode_cap_get_capCNodePtr>
    0x840127f8    0x21a    mv s0,a0
    0x840127fa    0x21c    ld a0,0(sp)
    0x840127fc    0x21e    ld a1,8(sp)
    0x840127fe    0x220    jal ra,ffffffff84010a1c <cap_cnode_cap_get_capCNodePtr>
    0x84012802    0x224    li a5,0
    0x84012804    0x226    beq s0,a0,ffffffff8401280c <sameRegionAs+0x22e>
    0x84012808    0x22a    mv a0,a5
    0x8401280a    0x22c    j ffffffff84012892 <sameRegionAs+0x2b4>
    0x8401280c    0x22e    ld a0,16(sp)
    0x8401280e    0x230    ld a1,24(sp)
    0x84012810    0x232    jal ra,ffffffff840105d2 <cap_cnode_cap_get_capCNodeRadix>
    0x84012814    0x236    mv s0,a0
    0x84012816    0x238    ld a0,0(sp)
    0x84012818    0x23a    ld a1,8(sp)
    0x8401281a    0x23c    jal ra,ffffffff840105d2 <cap_cnode_cap_get_capCNodeRadix>
    0x8401281e    0x240    sub a5,s0,a0
    0x84012822    0x244    seqz a5,a5
    0x84012826    0x248    j ffffffff84012808 <sameRegionAs+0x22a>
    0x84012828    0x24a    ld a0,0(sp)
    0x8401282a    0x24c    ld a1,8(sp)
    0x8401282c    0x24e    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012830    0x252    mv a4,a0
    0x84012832    0x254    li a5,12
    0x84012834    0x256    li a0,0
    0x84012836    0x258    bne a4,a5,ffffffff84012892 <sameRegionAs+0x2b4>
    0x8401283a    0x25c    ld a0,16(sp)
    0x8401283c    0x25e    ld a1,24(sp)
    0x8401283e    0x260    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x84012842    0x264    mv s0,a0
    0x84012844    0x266    ld a0,0(sp)
    0x84012846    0x268    ld a1,8(sp)
    0x84012848    0x26a    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x8401284c    0x26e    sub a0,s0,a0
    0x84012850    0x272    seqz a0,a0
    0x84012854    0x276    j ffffffff84012892 <sameRegionAs+0x2b4>
    0x84012856    0x278    ld a0,0(sp)
    0x84012858    0x27a    ld a1,8(sp)
    0x8401285a    0x27c    jal ra,ffffffff8401039e <cap_get_capType>
    0x8401285e    0x280    mv a4,a0
    0x84012860    0x282    li a5,8
    0x84012862    0x284    li a0,0
    0x84012864    0x286    bne a4,a5,ffffffff84012892 <sameRegionAs+0x2b4>
    0x84012868    0x28a    ld a0,16(sp)
    0x8401286a    0x28c    ld a1,24(sp)
    0x8401286c    0x28e    jal ra,ffffffff84010554 <cap_reply_cap_get_capTCBPtr>
    0x84012870    0x292    mv s0,a0
    0x84012872    0x294    ld a0,0(sp)
    0x84012874    0x296    ld a1,8(sp)
    0x84012876    0x298    jal ra,ffffffff84010554 <cap_reply_cap_get_capTCBPtr>
    0x8401287a    0x29c    sub a0,s0,a0
    0x8401287e    0x2a0    seqz a0,a0
    0x84012882    0x2a4    j ffffffff84012892 <sameRegionAs+0x2b4>
    0x84012884    0x2a6    ld a0,0(sp)
    0x84012886    0x2a8    ld a1,8(sp)
    0x84012888    0x2aa    jal ra,ffffffff8401039e <cap_get_capType>
    0x8401288c    0x2ae    addi a0,a0,-20
    0x8401288e    0x2b0    seqz a0,a0
    0x84012892    0x2b4    ld ra,88(sp)          ; stack access
    0x84012894    0x2b6    ld s0,80(sp)          ; stack access
    0x84012896    0x2b8    ld s1,72(sp)          ; stack access
    0x84012898    0x2ba    ld s2,64(sp)          ; stack access
    0x8401289a    0x2bc    addi sp,sp,96
    0x8401289c    0x2be    ret
    0x8401289e    0x2c0    ld a0,0(sp)
    0x840128a0    0x2c2    ld a1,8(sp)
    0x840128a2    0x2c4    jal ra,ffffffff8401039e <cap_get_capType>
    0x840128a6    0x2c8    addi a0,a0,-14
    0x840128a8    0x2ca    andi a0,a0,-3
    0x840128aa    0x2cc    seqz a0,a0
    0x840128ae    0x2d0    j ffffffff84012892 <sameRegionAs+0x2b4>
    0x840128b0    0x2d2    ld a0,0(sp)
    0x840128b2    0x2d4    ld a1,8(sp)
    0x840128b4    0x2d6    jal ra,ffffffff8401039e <cap_get_capType>
    0x840128b8    0x2da    mv a4,a0
    0x840128ba    0x2dc    li a5,16
    0x840128bc    0x2de    li a0,0
    0x840128be    0x2e0    bne a4,a5,ffffffff84012892 <sameRegionAs+0x2b4>
    0x840128c2    0x2e4    ld a0,16(sp)
    0x840128c4    0x2e6    ld a1,24(sp)
    0x840128c6    0x2e8    jal ra,ffffffff8401060e <cap_irq_handler_cap_get_capIRQ>
    0x840128ca    0x2ec    mv s0,a0
    0x840128cc    0x2ee    ld a0,0(sp)
    0x840128ce    0x2f0    ld a1,8(sp)
    0x840128d0    0x2f2    jal ra,ffffffff8401060e <cap_irq_handler_cap_get_capIRQ>
    0x840128d4    0x2f6    sub a0,s0,a0
    0x840128d8    0x2fa    seqz a0,a0
    0x840128dc    0x2fe    j ffffffff84012892 <sameRegionAs+0x2b4>
    0x840128de    0x300    ld a0,16(sp)          ; stack access
    0x840128e0    0x302    ld a1,24(sp)          ; stack access
    0x840128e2    0x304    jal ra,ffffffff8401039e <cap_get_capType>
    0x840128e6    0x308    andi a0,a0,1
    0x840128e8    0x30a    beqz a0,ffffffff84012892 <sameRegionAs+0x2b4>
    0x840128ea    0x30c    ld a0,0(sp)           ; stack access
    0x840128ec    0x30e    ld a1,8(sp)           ; stack access
    0x840128ee    0x310    jal ra,ffffffff8401039e <cap_get_capType>
    0x840128f2    0x314    andi a0,a0,1
    0x840128f4    0x316    beqz a0,ffffffff84012892 <sameRegionAs+0x2b4>
    0x840128f6    0x318    ld a2,0(sp)           ; stack access
    0x840128f8    0x31a    ld a3,8(sp)           ; stack access
    0x840128fa    0x31c    ld a0,16(sp)          ; stack access
    0x840128fc    0x31e    ld a1,24(sp)          ; stack access
    0x840128fe    0x320    jal ra,ffffffff84011804 <Arch_sameRegionAs>
    0x84012902    0x324    j ffffffff84012892 <sameRegionAs+0x2b4>
    0x84012904    0x326    li a0,0
    0x84012906    0x328    j ffffffff84012892 <sameRegionAs+0x2b4>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
312 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sameRegionAs` has 495 nodes.

Section setMRs_fault (420 of 432)
=================================

Deriving specifications
-----------------------

Section `setMRs_fault` consists of 139 instructions.


Stack analysis
---------------

22 stack accesses found. Annotated code for `setMRs_fault`:

    0x84010d5c      0x0    addi sp,sp,-48
    0x84010d5e      0x2    sd ra,40(sp)          ; stack access
    0x84010d60      0x4    sd s0,32(sp)          ; stack access
    0x84010d62      0x6    sd s1,24(sp)          ; stack access
    0x84010d64      0x8    sd s2,16(sp)          ; stack access
    0x84010d66      0xa    mv s0,a0
    0x84010d68      0xc    mv s1,a1
    0x84010d6a      0xe    mv s2,a2
    0x84010d6c     0x10    ld a0,312(a0)
    0x84010d70     0x14    ld a1,320(s0)
    0x84010d74     0x18    jal ra,ffffffff8401084a <seL4_Fault_get_seL4_FaultType>
    0x84010d78     0x1c    li a5,2
    0x84010d7a     0x1e    beq a0,a5,ffffffff84010e5a <setMRs_fault+0xfe>
    0x84010d7e     0x22    li a5,3
    0x84010d80     0x24    beq a0,a5,ffffffff84010eba <setMRs_fault+0x15e>
    0x84010d84     0x28    li a5,1
    0x84010d86     0x2a    beq a0,a5,ffffffff84010d98 <setMRs_fault+0x3c>
    0x84010d8a     0x2e    mv a3,a0
    0x84010d8c     0x30    mv a2,s2
    0x84010d8e     0x32    mv a1,s1
    0x84010d90     0x34    mv a0,s0
    0x84010d92     0x36    jal ra,ffffffff84010d0a <Arch_setMRs_fault>
    0x84010d96     0x3a    j ffffffff84010eae <setMRs_fault+0x152>
    0x84010d98     0x3c    ld a5,264(s0)
    0x84010d9c     0x40    sd a5,88(s1)
    0x84010d9e     0x42    ld a0,312(s0)
    0x84010da2     0x46    ld a1,320(s0)
    0x84010da6     0x4a    jal ra,ffffffff8401086e <seL4_Fault_CapFault_get_address>
    0x84010daa     0x4e    sd a0,96(s1)
    0x84010dac     0x50    ld a0,312(s0)
    0x84010db0     0x54    ld a1,320(s0)
    0x84010db4     0x58    jal ra,ffffffff84010876 <seL4_Fault_CapFault_get_inReceivePhase>
    0x84010db8     0x5c    sd a0,104(s1)
    0x84010dba     0x5e    ld a0,328(s0)
    0x84010dbe     0x62    sd a0,0(sp)           ; stack access
    0x84010dc0     0x64    ld a1,336(s0)
    0x84010dc4     0x68    sd a1,8(sp)           ; stack access
    0x84010dc6     0x6a    jal ra,ffffffff840107a8 <lookup_fault_get_lufType>
    0x84010dca     0x6e    addi a5,a0,1
    0x84010dce     0x72    sd a5,112(s1)
    0x84010dd0     0x74    li a5,2
    0x84010dd2     0x76    beq a0,a5,ffffffff84010e2a <setMRs_fault+0xce>
    0x84010dd6     0x7a    bltu a5,a0,ffffffff84010df8 <setMRs_fault+0x9c>
    0x84010dda     0x7e    li a5,4
    0x84010ddc     0x80    beqz a0,ffffffff84010df0 <setMRs_fault+0x94>
    0x84010dde     0x82    beqz s2,ffffffff84010e4e <setMRs_fault+0xf2>
    0x84010de2     0x86    ld a0,0(sp)           ; stack access
    0x84010de4     0x88    ld a1,8(sp)           ; stack access
    0x84010de6     0x8a    jal ra,ffffffff840107cc <lookup_fault_missing_capability_get_bitsLeft>
    0x84010dea     0x8e    sd a0,40(s2)
    0x84010dee     0x92    li a5,5
    0x84010df0     0x94    slli a0,a5,0x20
    0x84010df4     0x98    srli a0,a0,0x20
    0x84010df6     0x9a    j ffffffff84010eae <setMRs_fault+0x152>
    0x84010df8     0x9c    li a5,3
    0x84010dfa     0x9e    bne a0,a5,ffffffff84010e4a <setMRs_fault+0xee>
    0x84010dfe     0xa2    beqz s2,ffffffff84010e56 <setMRs_fault+0xfa>
    0x84010e02     0xa6    ld a0,0(sp)           ; stack access
    0x84010e04     0xa8    ld a1,8(sp)           ; stack access
    0x84010e06     0xaa    jal ra,ffffffff84010832 <lookup_fault_guard_mismatch_get_bitsLeft>
    0x84010e0a     0xae    sd a0,40(s2)
    0x84010e0e     0xb2    ld a0,0(sp)           ; stack access
    0x84010e10     0xb4    ld a1,8(sp)           ; stack access
    0x84010e12     0xb6    jal ra,ffffffff8401082a <lookup_fault_guard_mismatch_get_guardFound>
    0x84010e16     0xba    sd a0,48(s2)
    0x84010e1a     0xbe    ld a0,0(sp)           ; stack access
    0x84010e1c     0xc0    ld a1,8(sp)           ; stack access
    0x84010e1e     0xc2    jal ra,ffffffff8401083e <lookup_fault_guard_mismatch_get_bitsFound>
    0x84010e22     0xc6    sd a0,56(s2)
    0x84010e26     0xca    li a5,7
    0x84010e28     0xcc    j ffffffff84010df0 <setMRs_fault+0x94>
    0x84010e2a     0xce    beqz s2,ffffffff84010e52 <setMRs_fault+0xf6>
    0x84010e2e     0xd2    ld a0,0(sp)           ; stack access
    0x84010e30     0xd4    ld a1,8(sp)           ; stack access
    0x84010e32     0xd6    jal ra,ffffffff84010800 <lookup_fault_depth_mismatch_get_bitsLeft>
    0x84010e36     0xda    sd a0,40(s2)
    0x84010e3a     0xde    ld a0,0(sp)           ; stack access
    0x84010e3c     0xe0    ld a1,8(sp)           ; stack access
    0x84010e3e     0xe2    jal ra,ffffffff840107f4 <lookup_fault_depth_mismatch_get_bitsFound>
    0x84010e42     0xe6    sd a0,48(s2)
    0x84010e46     0xea    li a5,6
    0x84010e48     0xec    j ffffffff84010df0 <setMRs_fault+0x94>
    0x84010e4a     0xee    jal ra,ffffffff84010cec <halt>
    0x84010e4e     0xf2    li a5,4
    0x84010e50     0xf4    j ffffffff84010df0 <setMRs_fault+0x94>
    0x84010e52     0xf6    li a5,4
    0x84010e54     0xf8    j ffffffff84010df0 <setMRs_fault+0x94>
    0x84010e56     0xfa    li a5,4
    0x84010e58     0xfc    j ffffffff84010df0 <setMRs_fault+0x94>
    0x84010e5a     0xfe    ld a5,264(s0)
    0x84010e5e    0x102    sd a5,88(s1)
    0x84010e60    0x104    ld a5,8(s0)
    0x84010e62    0x106    sd a5,96(s1)
    0x84010e64    0x108    ld a5,0(s0)
    0x84010e66    0x10a    sd a5,104(s1)
    0x84010e68    0x10c    ld a5,72(s0)
    0x84010e6a    0x10e    sd a5,112(s1)
    0x84010e6c    0x110    li a0,4
    0x84010e6e    0x112    beqz s2,ffffffff84010eaa <setMRs_fault+0x14e>
    0x84010e72    0x116    auipc a4,0x7
    0x84010e76    0x11a    addi a4,a4,1118 # ffffffff840182d0 <fault_messages>
    0x84010e7a    0x11e    addi a3,s2,40
    0x84010e7e    0x122    auipc a2,0x7
    0x84010e82    0x126    addi a2,a2,1154 # ffffffff84018300 <fault_messages+0x30>
    0x84010e86    0x12a    ld a5,32(a4)
    0x84010e88    0x12c    slli a5,a5,0x3
    0x84010e8a    0x12e    add a5,a5,s0
    0x84010e8c    0x130    ld a5,0(a5)
    0x84010e8e    0x132    sd a5,0(a3)
    0x84010e90    0x134    addi a4,a4,8
    0x84010e92    0x136    addi a3,a3,8
    0x84010e94    0x138    bne a4,a2,ffffffff84010e86 <setMRs_fault+0x12a>
    0x84010e98    0x13c    ld a0,312(s0)
    0x84010e9c    0x140    ld a1,320(s0)
    0x84010ea0    0x144    jal ra,ffffffff84010888 <seL4_Fault_UnknownSyscall_get_syscallNumber>
    0x84010ea4    0x148    sd a0,88(s2)
    0x84010ea8    0x14c    li a0,11
    0x84010eaa    0x14e    slli a0,a0,0x20
    0x84010eac    0x150    srli a0,a0,0x20
    0x84010eae    0x152    ld ra,40(sp)          ; stack access
    0x84010eb0    0x154    ld s0,32(sp)          ; stack access
    0x84010eb2    0x156    ld s1,24(sp)          ; stack access
    0x84010eb4    0x158    ld s2,16(sp)          ; stack access
    0x84010eb6    0x15a    addi sp,sp,48
    0x84010eb8    0x15c    ret
    0x84010eba    0x15e    ld a5,264(s0)
    0x84010ebe    0x162    sd a5,88(s1)
    0x84010ec0    0x164    ld a5,8(s0)
    0x84010ec2    0x166    sd a5,96(s1)
    0x84010ec4    0x168    ld a0,312(s0)
    0x84010ec8    0x16c    ld a1,320(s0)
    0x84010ecc    0x170    jal ra,ffffffff840108a8 <seL4_Fault_UserException_get_number>
    0x84010ed0    0x174    sd a0,104(s1)
    0x84010ed2    0x176    ld a0,312(s0)
    0x84010ed6    0x17a    ld a1,320(s0)
    0x84010eda    0x17e    jal ra,ffffffff840108b0 <seL4_Fault_UserException_get_code>
    0x84010ede    0x182    sd a0,112(s1)
    0x84010ee0    0x184    li a0,4
    0x84010ee2    0x186    j ffffffff84010eae <setMRs_fault+0x152>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
139 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setMRs_fault` has 244 nodes.

Section decodeTCBInvocation (421 of 432)
========================================

Deriving specifications
-----------------------

Section `decodeTCBInvocation` consists of 135 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `decodeTCBInvocation`:

    0x8401619e      0x0    addi sp,sp,-64
    0x840161a0      0x2    sd ra,56(sp)          ; stack access
    0x840161a2      0x4    sd s0,48(sp)          ; stack access
    0x840161a4      0x6    sd s1,40(sp)          ; stack access
    0x840161a6      0x8    sd a2,0(sp)           ; stack access
    0x840161a8      0xa    sd a3,8(sp)           ; stack access
    0x840161aa      0xc    mv a3,a4
    0x840161ac      0xe    li a4,15
    0x840161ae     0x10    bltu a4,a0,ffffffff840162e2 <decodeTCBInvocation+0x144>
    0x840161b2     0x14    slli a0,a0,0x2
    0x840161b4     0x16    auipc a4,0x2
    0x840161b8     0x1a    addi a4,a4,60 # ffffffff840181f0 <ksDomScheduleLength+0x2a8>
    0x840161bc     0x1e    add a0,a0,a4
    0x840161be     0x20    lw a2,0(a0)
    0x840161c0     0x22    add a2,a2,a4
    0x840161c2     0x24    jr a2
    0x840161c4     0x26    mv a4,a6
    0x840161c6     0x28    mv a3,a5
    0x840161c8     0x2a    mv a2,a1
    0x840161ca     0x2c    ld a0,0(sp)
    0x840161cc     0x2e    ld a1,8(sp)
    0x840161ce     0x30    jal ra,ffffffff84015e6c <decodeReadRegisters>
    0x840161d2     0x34    ld ra,56(sp)          ; stack access
    0x840161d4     0x36    ld s0,48(sp)          ; stack access
    0x840161d6     0x38    ld s1,40(sp)          ; stack access
    0x840161d8     0x3a    addi sp,sp,64
    0x840161da     0x3c    ret
    0x840161dc     0x3e    mv a3,a6
    0x840161de     0x40    mv a2,a1
    0x840161e0     0x42    ld a0,0(sp)
    0x840161e2     0x44    ld a1,8(sp)
    0x840161e4     0x46    jal ra,ffffffff84015ff2 <decodeWriteRegisters>
    0x840161e8     0x4a    j ffffffff840161d2 <decodeTCBInvocation+0x34>
    0x840161ea     0x4c    mv a3,a6
    0x840161ec     0x4e    mv a2,a1
    0x840161ee     0x50    ld a0,0(sp)
    0x840161f0     0x52    ld a1,8(sp)
    0x840161f2     0x54    jal ra,ffffffff84015cc0 <decodeCopyRegisters>
    0x840161f6     0x58    j ffffffff840161d2 <decodeTCBInvocation+0x34>
    0x840161f8     0x5a    li a1,2
    0x840161fa     0x5c    auipc a0,0x19
    0x840161fe     0x60    ld a0,-1890(a0) # ffffffff8402ea98 <ksCurThread>
    0x84016202     0x64    jal ra,ffffffff84013020 <setThreadState>
    0x84016206     0x68    ld a0,0(sp)
    0x84016208     0x6a    ld a1,8(sp)
    0x8401620a     0x6c    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x8401620e     0x70    jal ra,ffffffff84013afe <suspend>
    0x84016212     0x74    li a0,0
    0x84016214     0x76    j ffffffff840161d2 <decodeTCBInvocation+0x34>
    0x84016216     0x78    li a1,2
    0x84016218     0x7a    auipc a0,0x19
    0x8401621c     0x7e    ld a0,-1920(a0) # ffffffff8402ea98 <ksCurThread>
    0x84016220     0x82    jal ra,ffffffff84013020 <setThreadState>
    0x84016224     0x86    ld a0,0(sp)
    0x84016226     0x88    ld a1,8(sp)
    0x84016228     0x8a    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x8401622c     0x8e    jal ra,ffffffff84014644 <restart>
    0x84016230     0x92    li a0,0
    0x84016232     0x94    j ffffffff840161d2 <decodeTCBInvocation+0x34>
    0x84016234     0x96    mv a4,a6
    0x84016236     0x98    mv a2,a1
    0x84016238     0x9a    ld a0,0(sp)
    0x8401623a     0x9c    ld a1,8(sp)
    0x8401623c     0x9e    jal ra,ffffffff840155ba <decodeTCBConfigure>
    0x84016240     0xa2    j ffffffff840161d2 <decodeTCBInvocation+0x34>
    0x84016242     0xa4    mv a3,a6
    0x84016244     0xa6    mv a2,a1
    0x84016246     0xa8    ld a0,0(sp)
    0x84016248     0xaa    ld a1,8(sp)
    0x8401624a     0xac    jal ra,ffffffff8401577a <decodeSetPriority>
    0x8401624e     0xb0    j ffffffff840161d2 <decodeTCBInvocation+0x34>
    0x84016250     0xb2    mv a3,a6
    0x84016252     0xb4    mv a2,a1
    0x84016254     0xb6    ld a0,0(sp)
    0x84016256     0xb8    ld a1,8(sp)
    0x84016258     0xba    jal ra,ffffffff8401583c <decodeSetMCPriority>
    0x8401625c     0xbe    j ffffffff840161d2 <decodeTCBInvocation+0x34>
    0x8401625e     0xc0    mv a3,a6
    0x84016260     0xc2    mv a2,a1
    0x84016262     0xc4    ld a0,0(sp)
    0x84016264     0xc6    ld a1,8(sp)
    0x84016266     0xc8    jal ra,ffffffff840158fe <decodeSetSchedParams>
    0x8401626a     0xcc    j ffffffff840161d2 <decodeTCBInvocation+0x34>
    0x8401626c     0xce    mv a4,a6
    0x8401626e     0xd0    mv a2,a1
    0x84016270     0xd2    ld a0,0(sp)
    0x84016272     0xd4    ld a1,8(sp)
    0x84016274     0xd6    jal ra,ffffffff840159e6 <decodeSetIPCBuffer>
    0x84016278     0xda    j ffffffff840161d2 <decodeTCBInvocation+0x34>
    0x8401627a     0xdc    mv a4,a6
    0x8401627c     0xde    mv a2,a1
    0x8401627e     0xe0    ld a0,0(sp)
    0x84016280     0xe2    ld a1,8(sp)
    0x84016282     0xe4    jal ra,ffffffff84015a9e <decodeSetSpace>
    0x84016286     0xe8    j ffffffff840161d2 <decodeTCBInvocation+0x34>
    0x84016288     0xea    ld a0,0(sp)
    0x8401628a     0xec    ld a1,8(sp)
    0x8401628c     0xee    jal ra,ffffffff8401609a <decodeBindNotification>
    0x84016290     0xf2    j ffffffff840161d2 <decodeTCBInvocation+0x34>
    0x84016292     0xf4    ld a0,0(sp)
    0x84016294     0xf6    ld a1,8(sp)
    0x84016296     0xf8    jal ra,ffffffff8401615c <decodeUnbindNotification>
    0x8401629a     0xfc    j ffffffff840161d2 <decodeTCBInvocation+0x34>
    0x8401629c     0xfe    ld a5,0(sp)
    0x8401629e    0x100    sd a5,16(sp)
    0x840162a0    0x102    ld a5,8(sp)
    0x840162a2    0x104    sd a5,24(sp)
    0x840162a4    0x106    beqz a1,ffffffff840162d4 <decodeTCBInvocation+0x136>
    0x840162a6    0x108    auipc s0,0x18
    0x840162aa    0x10c    addi s0,s0,2034 # ffffffff8402ea98 <ksCurThread>
    0x840162ae    0x110    ld a0,0(s0)
    0x840162b0    0x112    ld s1,88(a0)
    0x840162b2    0x114    li a1,2
    0x840162b4    0x116    jal ra,ffffffff84013020 <setThreadState>
    0x840162b8    0x11a    ld a0,16(sp)
    0x840162ba    0x11c    ld a1,24(sp)
    0x840162bc    0x11e    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x840162c0    0x122    mv a5,a0
    0x840162c2    0x124    sd s1,24(a0)
    0x840162c4    0x126    ld a4,0(s0)
    0x840162c6    0x128    li a0,0
    0x840162c8    0x12a    bne a5,a4,ffffffff840161d2 <decodeTCBInvocation+0x34>
    0x840162cc    0x12e    jal ra,ffffffff84012fa8 <rescheduleRequired>
    0x840162d0    0x132    li a0,0
    0x840162d2    0x134    j ffffffff840161d2 <decodeTCBInvocation+0x34>
    0x840162d4    0x136    li a5,7
    0x840162d6    0x138    auipc a4,0x8
    0x840162da    0x13c    sd a5,-1630(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840162de    0x140    li a0,3
    0x840162e0    0x142    j ffffffff840161d2 <decodeTCBInvocation+0x34>
    0x840162e2    0x144    li a5,3
    0x840162e4    0x146    auipc a4,0x8
    0x840162e8    0x14a    sd a5,-1644(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840162ec    0x14e    li a0,3
    0x840162ee    0x150    j ffffffff840161d2 <decodeTCBInvocation+0x34>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
135 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeTCBInvocation` has 212 nodes.

Section finaliseCap (422 of 432)
================================

Deriving specifications
-----------------------

Section `finaliseCap` consists of 175 instructions.

XOR.....
RVC_TFFFTT___FT___FT..

Stack analysis
---------------

Section `finaliseCap` expects pointer to stack in a0.
48 stack accesses found. Annotated code for `finaliseCap`:

    0x84013b48      0x0    addi sp,sp,-144
    0x84013b4a      0x2    sd ra,136(sp)         ; stack access
    0x84013b4c      0x4    sd s0,128(sp)         ; stack access
    0x84013b4e      0x6    sd s1,120(sp)         ; stack access
    0x84013b50      0x8    sd s2,112(sp)         ; stack access
    0x84013b52      0xa    sd s3,104(sp)         ; stack access
    0x84013b54      0xc    mv s0,a0
    0x84013b56      0xe    sd a1,0(sp)           ; stack access
    0x84013b58     0x10    sd a2,8(sp)           ; stack access
    0x84013b5a     0x12    mv s2,a3
    0x84013b5c     0x14    mv s1,a4
    0x84013b5e     0x16    mv a0,a1
    0x84013b60     0x18    mv a1,a2
    0x84013b62     0x1a    jal ra,ffffffff8401039e <cap_get_capType>
    0x84013b66     0x1e    andi a0,a0,1
    0x84013b68     0x20    bnez a0,ffffffff84013b8c <finaliseCap+0x44>
    0x84013b6a     0x22    ld a0,0(sp)           ; stack access
    0x84013b6c     0x24    ld a1,8(sp)           ; stack access
    0x84013b6e     0x26    jal ra,ffffffff8401039e <cap_get_capType>
    0x84013b72     0x2a    li a5,20
    0x84013b74     0x2c    bltu a5,a0,ffffffff84013c1c <finaliseCap+0xd4>
    0x84013b78     0x30    slli a4,a0,0x2
    0x84013b7c     0x34    auipc a3,0x4
    0x84013b80     0x38    addi a3,a3,1504 # ffffffff8401815c <ksDomScheduleLength+0x214>
    0x84013b84     0x3c    add a4,a4,a3
    0x84013b86     0x3e    lw a5,0(a4)
    0x84013b88     0x40    add a5,a5,a3
    0x84013b8a     0x42    jr a5
    0x84013b8c     0x44    mv a3,s2
    0x84013b8e     0x46    ld a1,0(sp)           ; stack access
    0x84013b90     0x48    ld a2,8(sp)           ; stack access
    0x84013b92     0x4a    mv a0,s0
    0x84013b94     0x4c    jal ra,ffffffff84011712 <Arch_finaliseCap>
    0x84013b98     0x50    mv a0,s0
    0x84013b9a     0x52    ld ra,136(sp)         ; stack access
    0x84013b9c     0x54    ld s0,128(sp)         ; stack access
    0x84013b9e     0x56    ld s1,120(sp)         ; stack access
    0x84013ba0     0x58    ld s2,112(sp)         ; stack access
    0x84013ba2     0x5a    ld s3,104(sp)         ; stack access
    0x84013ba4     0x5c    addi sp,sp,144
    0x84013ba6     0x5e    ret
    0x84013ba8     0x60    bnez s2,ffffffff84013bc4 <finaliseCap+0x7c>
    0x84013bac     0x64    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84013bb0     0x68    mv s2,a0
    0x84013bb2     0x6a    mv s1,a1
    0x84013bb4     0x6c    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84013bb8     0x70    sd s2,0(s0)
    0x84013bbc     0x74    sd s1,8(s0)
    0x84013bbe     0x76    sd a0,16(s0)
    0x84013bc0     0x78    sd a1,24(s0)
    0x84013bc2     0x7a    j ffffffff84013b98 <finaliseCap+0x50>
    0x84013bc4     0x7c    ld a0,0(sp)
    0x84013bc6     0x7e    ld a1,8(sp)
    0x84013bc8     0x80    jal ra,ffffffff840109fe <cap_endpoint_cap_get_capEPPtr>
    0x84013bcc     0x84    jal ra,ffffffff8401330a <cancelAllIPC>
    0x84013bd0     0x88    j ffffffff84013bac <finaliseCap+0x64>
    0x84013bd2     0x8a    bnez s2,ffffffff84013bee <finaliseCap+0xa6>
    0x84013bd6     0x8e    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84013bda     0x92    mv s2,a0
    0x84013bdc     0x94    mv s1,a1
    0x84013bde     0x96    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84013be2     0x9a    sd s2,0(s0)
    0x84013be6     0x9e    sd s1,8(s0)
    0x84013be8     0xa0    sd a0,16(s0)
    0x84013bea     0xa2    sd a1,24(s0)
    0x84013bec     0xa4    j ffffffff84013b98 <finaliseCap+0x50>
    0x84013bee     0xa6    ld a0,0(sp)
    0x84013bf0     0xa8    ld a1,8(sp)
    0x84013bf2     0xaa    jal ra,ffffffff840109aa <cap_notification_cap_get_capNtfnPtr>
    0x84013bf6     0xae    mv s1,a0
    0x84013bf8     0xb0    jal ra,ffffffff840124dc <unbindMaybeNotification>
    0x84013bfc     0xb4    mv a0,s1
    0x84013bfe     0xb6    jal ra,ffffffff84013360 <cancelAllSignals>
    0x84013c02     0xba    j ffffffff84013bd6 <finaliseCap+0x8e>
    0x84013c04     0xbc    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84013c08     0xc0    mv s2,a0
    0x84013c0a     0xc2    mv s1,a1
    0x84013c0c     0xc4    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84013c10     0xc8    sd s2,0(s0)
    0x84013c14     0xcc    sd s1,8(s0)
    0x84013c16     0xce    sd a0,16(s0)
    0x84013c18     0xd0    sd a1,24(s0)
    0x84013c1a     0xd2    j ffffffff84013b98 <finaliseCap+0x50>
    0x84013c1c     0xd4    bnez s1,ffffffff84013c50 <finaliseCap+0x108>
    0x84013c1e     0xd6    li a5,16
    0x84013c20     0xd8    beq a0,a5,ffffffff84013cfe <finaliseCap+0x1b6>
    0x84013c24     0xdc    bltu a5,a0,ffffffff84013c54 <finaliseCap+0x10c>
    0x84013c28     0xe0    li a5,10
    0x84013c2a     0xe2    beq a0,a5,ffffffff84013c6c <finaliseCap+0x124>
    0x84013c2e     0xe6    li a5,12
    0x84013c30     0xe8    bne a0,a5,ffffffff84013c38 <finaliseCap+0xf0>
    0x84013c34     0xec    bnez s2,ffffffff84013cc6 <finaliseCap+0x17e>
    0x84013c38     0xf0    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84013c3c     0xf4    mv s2,a0
    0x84013c3e     0xf6    mv s1,a1
    0x84013c40     0xf8    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84013c44     0xfc    sd s2,0(s0)           ; stack access
    0x84013c48    0x100    sd s1,8(s0)           ; stack access
    0x84013c4a    0x102    sd a0,16(s0)          ; stack access
    0x84013c4c    0x104    sd a1,24(s0)          ; stack access
    0x84013c4e    0x106    j ffffffff84013b98 <finaliseCap+0x50>
    0x84013c50    0x108    jal ra,ffffffff84010cec <halt>
    0x84013c54    0x10c    li a5,18
    0x84013c56    0x10e    bne a0,a5,ffffffff84013c38 <finaliseCap+0xf0>
    0x84013c5a    0x112    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84013c5e    0x116    ld a5,0(sp)           ; stack access
    0x84013c60    0x118    sd a5,0(s0)           ; stack access
    0x84013c62    0x11a    ld a5,8(sp)           ; stack access
    0x84013c64    0x11c    sd a5,8(s0)           ; stack access
    0x84013c66    0x11e    sd a0,16(s0)          ; stack access
    0x84013c68    0x120    sd a1,24(s0)          ; stack access
    0x84013c6a    0x122    j ffffffff84013b98 <finaliseCap+0x50>
    0x84013c6c    0x124    beqz s2,ffffffff84013c38 <finaliseCap+0xf0>
    0x84013c70    0x128    ld a0,0(sp)           ; stack access
    0x84013c72    0x12a    ld a1,8(sp)           ; stack access
    0x84013c74    0x12c    jal ra,ffffffff840105d2 <cap_cnode_cap_get_capCNodeRadix>
    0x84013c78    0x130    mv s2,a0
    0x84013c7a    0x132    sext.w s3,a0
    0x84013c7e    0x136    li s1,1
    0x84013c80    0x138    sll s1,s1,a0
    0x84013c84    0x13c    ld a0,0(sp)           ; stack access
    0x84013c86    0x13e    ld a1,8(sp)           ; stack access
    0x84013c88    0x140    jal ra,ffffffff84010a1c <cap_cnode_cap_get_capCNodePtr>
    0x84013c8c    0x144    li a5,64
    0x84013c90    0x148    li a4,31
    0x84013c92    0x14a    beq s2,a5,ffffffff84013ca4 <finaliseCap+0x15c>
    0x84013c96    0x14e    addiw a4,s3,1
    0x84013c9a    0x152    li a5,1
    0x84013c9c    0x154    sll a5,a5,a4
    0x84013ca0    0x158    addi a4,a5,-1
    0x84013ca4    0x15c    xor a5,s1,a0
    0x84013ca8    0x160    and a5,a5,a4
    0x84013caa    0x162    mv a1,s2
    0x84013cac    0x164    xor a0,a0,a5
    0x84013cae    0x166    jal ra,ffffffff8401061a <cap_zombie_cap_new>
    0x84013cb2    0x16a    mv s2,a0
    0x84013cb4    0x16c    mv s1,a1
    0x84013cb6    0x16e    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84013cba    0x172    sd s2,0(s0)           ; stack access
    0x84013cbe    0x176    sd s1,8(s0)           ; stack access
    0x84013cc0    0x178    sd a0,16(s0)          ; stack access
    0x84013cc2    0x17a    sd a1,24(s0)          ; stack access
    0x84013cc4    0x17c    j ffffffff84013b98 <finaliseCap+0x50>
    0x84013cc6    0x17e    ld a0,0(sp)           ; stack access
    0x84013cc8    0x180    ld a1,8(sp)           ; stack access
    0x84013cca    0x182    jal ra,ffffffff84010a3c <cap_thread_cap_get_capTCBPtr>
    0x84013cce    0x186    mv s1,a0
    0x84013cd0    0x188    jal ra,ffffffff84012506 <unbindNotification>
    0x84013cd4    0x18c    mv a0,s1
    0x84013cd6    0x18e    jal ra,ffffffff84013afe <suspend>
    0x84013cda    0x192    andi a0,s1,-1024
    0x84013cde    0x196    li a1,64
    0x84013ce2    0x19a    xori a0,a0,5
    0x84013ce6    0x19e    jal ra,ffffffff8401061a <cap_zombie_cap_new>
    0x84013cea    0x1a2    mv s2,a0
    0x84013cec    0x1a4    mv s1,a1
    0x84013cee    0x1a6    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84013cf2    0x1aa    sd s2,0(s0)           ; stack access
    0x84013cf6    0x1ae    sd s1,8(s0)           ; stack access
    0x84013cf8    0x1b0    sd a0,16(s0)          ; stack access
    0x84013cfa    0x1b2    sd a1,24(s0)          ; stack access
    0x84013cfc    0x1b4    j ffffffff84013b98 <finaliseCap+0x50>
    0x84013cfe    0x1b6    beqz s2,ffffffff84013c38 <finaliseCap+0xf0>
    0x84013d02    0x1ba    ld a0,0(sp)           ; stack access
    0x84013d04    0x1bc    ld a1,8(sp)           ; stack access
    0x84013d06    0x1be    jal ra,ffffffff8401060e <cap_irq_handler_cap_get_capIRQ>
    0x84013d0a    0x1c2    jal ra,ffffffff8401462a <deletingIRQHandler>
    0x84013d0e    0x1c6    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84013d12    0x1ca    sd a0,0(s0)           ; stack access
    0x84013d14    0x1cc    sd a1,8(s0)           ; stack access
    0x84013d16    0x1ce    ld a5,0(sp)           ; stack access
    0x84013d18    0x1d0    sd a5,16(s0)          ; stack access
    0x84013d1a    0x1d2    ld a5,8(sp)           ; stack access
    0x84013d1c    0x1d4    sd a5,24(s0)          ; stack access
    0x84013d1e    0x1d6    j ffffffff84013b98 <finaliseCap+0x50>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
175 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `finaliseCap` has 300 nodes.

Section Arch_finaliseCap (423 of 432)
=====================================

Deriving specifications
-----------------------

Section `Arch_finaliseCap` consists of 98 instructions.


Stack analysis
---------------

Section `Arch_finaliseCap` expects pointer to stack in a0.
38 stack accesses found. Annotated code for `Arch_finaliseCap`:

    0x84011712     0x0    addi sp,sp,-80
    0x84011714     0x2    sd ra,72(sp)          ; stack access
    0x84011716     0x4    sd s0,64(sp)          ; stack access
    0x84011718     0x6    sd s1,56(sp)          ; stack access
    0x8401171a     0x8    sd s2,48(sp)          ; stack access
    0x8401171c     0xa    sd s3,40(sp)          ; stack access
    0x8401171e     0xc    mv s0,a0
    0x84011720     0xe    sd a1,0(sp)           ; stack access
    0x84011722    0x10    sd a2,8(sp)           ; stack access
    0x84011724    0x12    mv s1,a3
    0x84011726    0x14    mv a0,a1
    0x84011728    0x16    mv a1,a2
    0x8401172a    0x18    jal ra,ffffffff8401039e <cap_get_capType>
    0x8401172e    0x1c    li a5,3
    0x84011730    0x1e    beq a0,a5,ffffffff84011796 <Arch_finaliseCap+0x84>
    0x84011734    0x22    li a5,13
    0x84011736    0x24    beq a0,a5,ffffffff840117e6 <Arch_finaliseCap+0xd4>
    0x8401173a    0x28    li a5,1
    0x8401173c    0x2a    beq a0,a5,ffffffff84011760 <Arch_finaliseCap+0x4e>
    0x84011740    0x2e    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84011744    0x32    sd a0,0(s0)           ; stack access
    0x84011746    0x34    sd a1,8(s0)           ; stack access
    0x84011748    0x36    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x8401174c    0x3a    sd a0,16(s0)          ; stack access
    0x8401174e    0x3c    sd a1,24(s0)          ; stack access
    0x84011750    0x3e    mv a0,s0
    0x84011752    0x40    ld ra,72(sp)          ; stack access
    0x84011754    0x42    ld s0,64(sp)          ; stack access
    0x84011756    0x44    ld s1,56(sp)          ; stack access
    0x84011758    0x46    ld s2,48(sp)          ; stack access
    0x8401175a    0x48    ld s3,40(sp)          ; stack access
    0x8401175c    0x4a    addi sp,sp,80
    0x8401175e    0x4c    ret
    0x84011760    0x4e    ld a0,0(sp)           ; stack access
    0x84011762    0x50    ld a1,8(sp)           ; stack access
    0x84011764    0x52    jal ra,ffffffff84010690 <cap_frame_cap_get_capFMappedASID>
    0x84011768    0x56    mv s1,a0
    0x8401176a    0x58    beqz a0,ffffffff84011740 <Arch_finaliseCap+0x2e>
    0x8401176c    0x5a    ld a0,0(sp)           ; stack access
    0x8401176e    0x5c    ld a1,8(sp)           ; stack access
    0x84011770    0x5e    jal ra,ffffffff840106a8 <cap_frame_cap_get_capFSize>
    0x84011774    0x62    mv s2,a0
    0x84011776    0x64    ld a0,0(sp)           ; stack access
    0x84011778    0x66    ld a1,8(sp)           ; stack access
    0x8401177a    0x68    jal ra,ffffffff84010ad0 <cap_frame_cap_get_capFMappedAddress>
    0x8401177e    0x6c    mv s3,a0
    0x84011780    0x6e    ld a0,0(sp)           ; stack access
    0x84011782    0x70    ld a1,8(sp)           ; stack access
    0x84011784    0x72    jal ra,ffffffff84010a5a <cap_frame_cap_get_capFBasePtr>
    0x84011788    0x76    mv a3,a0
    0x8401178a    0x78    mv a2,s3
    0x8401178c    0x7a    mv a1,s1
    0x8401178e    0x7c    mv a0,s2
    0x84011790    0x7e    jal ra,ffffffff840112a4 <unmapPage>
    0x84011794    0x82    j ffffffff84011740 <Arch_finaliseCap+0x2e>
    0x84011796    0x84    beqz s1,ffffffff84011740 <Arch_finaliseCap+0x2e>
    0x84011798    0x86    ld a0,0(sp)           ; stack access
    0x8401179a    0x88    ld a1,8(sp)           ; stack access
    0x8401179c    0x8a    jal ra,ffffffff8401072c <cap_page_table_cap_get_capPTIsMapped>
    0x840117a0    0x8e    beqz a0,ffffffff84011740 <Arch_finaliseCap+0x2e>
    0x840117a2    0x90    ld a0,0(sp)           ; stack access
    0x840117a4    0x92    ld a1,8(sp)           ; stack access
    0x840117a6    0x94    jal ra,ffffffff84010714 <cap_page_table_cap_get_capPTMappedASID>
    0x840117aa    0x98    mv s3,a0
    0x840117ac    0x9a    jal ra,ffffffff84010922 <findVSpaceForASID>
    0x840117b0    0x9e    mv s2,a0
    0x840117b2    0xa0    sd a1,24(sp)          ; stack access
    0x840117b4    0xa2    ld a0,0(sp)           ; stack access
    0x840117b6    0xa4    ld a1,8(sp)           ; stack access
    0x840117b8    0xa6    jal ra,ffffffff84010a76 <cap_page_table_cap_get_capPTBasePtr>
    0x840117bc    0xaa    mv s1,a0
    0x840117be    0xac    bnez s2,ffffffff840117c8 <Arch_finaliseCap+0xb6>
    0x840117c2    0xb0    ld a5,24(sp)          ; stack access
    0x840117c4    0xb2    beq a5,a0,ffffffff840117dc <Arch_finaliseCap+0xca>
    0x840117c8    0xb6    ld a0,0(sp)           ; stack access
    0x840117ca    0xb8    ld a1,8(sp)           ; stack access
    0x840117cc    0xba    jal ra,ffffffff84010ab2 <cap_page_table_cap_get_capPTMappedAddress>
    0x840117d0    0xbe    mv a1,a0
    0x840117d2    0xc0    mv a2,s1
    0x840117d4    0xc2    mv a0,s3
    0x840117d6    0xc4    jal ra,ffffffff840111fe <unmapPageTable>
    0x840117da    0xc8    j ffffffff84011740 <Arch_finaliseCap+0x2e>
    0x840117dc    0xca    mv a1,a0
    0x840117de    0xcc    mv a0,s3
    0x840117e0    0xce    jal ra,ffffffff84011442 <deleteASID>
    0x840117e4    0xd2    j ffffffff84011740 <Arch_finaliseCap+0x2e>
    0x840117e6    0xd4    beqz s1,ffffffff84011740 <Arch_finaliseCap+0x2e>
    0x840117e8    0xd6    ld a0,0(sp)           ; stack access
    0x840117ea    0xd8    ld a1,8(sp)           ; stack access
    0x840117ec    0xda    jal ra,ffffffff8401079c <cap_asid_pool_cap_get_capASIDBase>
    0x840117f0    0xde    mv s1,a0
    0x840117f2    0xe0    ld a0,0(sp)           ; stack access
    0x840117f4    0xe2    ld a1,8(sp)           ; stack access
    0x840117f6    0xe4    jal ra,ffffffff84010a92 <cap_asid_pool_cap_get_capASIDPool>
    0x840117fa    0xe8    mv a1,a0
    0x840117fc    0xea    mv a0,s1
    0x840117fe    0xec    jal ra,ffffffff84011404 <deleteASIDPool>
    0x84011802    0xf0    j ffffffff84011740 <Arch_finaliseCap+0x2e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
98 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_finaliseCap` has 173 nodes.

Section decodeCNodeInvocation (424 of 432)
==========================================

Deriving specifications
-----------------------

Section `decodeCNodeInvocation` consists of 418 instructions.


Stack analysis
---------------

75 stack accesses found. Annotated code for `decodeCNodeInvocation`:

    0x84014044      0x0    addi sp,sp,-224
    0x84014046      0x2    sd ra,216(sp)         ; stack access
    0x84014048      0x4    sd s0,208(sp)         ; stack access
    0x8401404a      0x6    sd s1,200(sp)         ; stack access
    0x8401404c      0x8    sd s2,192(sp)         ; stack access
    0x8401404e      0xa    sd s3,184(sp)         ; stack access
    0x84014050      0xc    sd s4,176(sp)         ; stack access
    0x84014052      0xe    sd s5,168(sp)         ; stack access
    0x84014054     0x10    sd s6,160(sp)         ; stack access
    0x84014056     0x12    sd s7,152(sp)         ; stack access
    0x84014058     0x14    sd a2,0(sp)           ; stack access
    0x8401405a     0x16    sd a3,8(sp)           ; stack access
    0x8401405c     0x18    addi a3,a0,-16
    0x84014060     0x1c    li a5,8
    0x84014062     0x1e    bltu a5,a3,ffffffff84014116 <decodeCNodeInvocation+0xd2>
    0x84014066     0x22    mv s1,a0
    0x84014068     0x24    mv s2,a1
    0x8401406a     0x26    mv s3,a4
    0x8401406c     0x28    li a5,1
    0x8401406e     0x2a    bgeu a5,a1,ffffffff84014124 <decodeCNodeInvocation+0xe0>
    0x84014072     0x2e    auipc a5,0x1b
    0x84014076     0x32    ld a5,-1498(a5) # ffffffff8402ea98 <ksCurThread>
    0x8401407a     0x36    ld a3,96(a5)
    0x8401407c     0x38    ld a2,88(a5)
    0x8401407e     0x3a    ld a0,0(sp)           ; stack access
    0x84014080     0x3c    ld a1,8(sp)           ; stack access
    0x84014082     0x3e    jal ra,ffffffff84011d7a <lookupTargetSlot>
    0x84014086     0x42    sd a0,112(sp)         ; stack access
    0x84014088     0x44    sd a1,120(sp)         ; stack access
    0x8401408a     0x46    mv s0,a0
    0x8401408c     0x48    bnez a0,ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x8401408e     0x4a    mv s4,a1
    0x84014090     0x4c    addi a5,s1,-19
    0x84014094     0x50    li a4,3
    0x84014096     0x52    bltu a4,a5,ffffffff84014272 <decodeCNodeInvocation+0x22e>
    0x8401409a     0x56    li a5,3
    0x8401409c     0x58    bgeu a5,s2,ffffffff84014148 <decodeCNodeInvocation+0x104>
    0x840140a0     0x5c    auipc a5,0xa
    0x840140a4     0x60    ld a5,-1056(a5) # ffffffff8401dc80 <current_extra_caps>
    0x840140a8     0x64    beqz a5,ffffffff84014148 <decodeCNodeInvocation+0x104>
    0x840140aa     0x66    auipc a4,0x1b
    0x840140ae     0x6a    ld a4,-1554(a4) # ffffffff8402ea98 <ksCurThread>
    0x840140b2     0x6e    ld s6,104(a4)
    0x840140b6     0x72    ld s5,112(a4)
    0x840140ba     0x76    ld a4,0(a5)
    0x840140bc     0x78    sd a4,24(sp)          ; stack access
    0x840140be     0x7a    ld a5,8(a5)
    0x840140c0     0x7c    sd a5,32(sp)          ; stack access
    0x840140c2     0x7e    mv a0,a1
    0x840140c4     0x80    jal ra,ffffffff8401225c <ensureEmptySlot>
    0x840140c8     0x84    mv s0,a0
    0x840140ca     0x86    bnez a0,ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x840140cc     0x88    mv a3,s5
    0x840140ce     0x8a    mv a2,s6
    0x840140d0     0x8c    ld a0,24(sp)          ; stack access
    0x840140d2     0x8e    ld a1,32(sp)          ; stack access
    0x840140d4     0x90    jal ra,ffffffff84011d60 <lookupSourceSlot>
    0x840140d8     0x94    sd a0,112(sp)         ; stack access
    0x840140da     0x96    sd a1,120(sp)         ; stack access
    0x840140dc     0x98    mv s0,a0
    0x840140de     0x9a    bnez a0,ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x840140e0     0x9c    mv s6,a1
    0x840140e2     0x9e    ld a0,0(a1)
    0x840140e4     0xa0    ld a1,8(a1)
    0x840140e6     0xa2    jal ra,ffffffff8401039e <cap_get_capType>
    0x840140ea     0xa6    beqz a0,ffffffff84014156 <decodeCNodeInvocation+0x112>
    0x840140ec     0xa8    li a5,21
    0x840140ee     0xaa    beq s1,a5,ffffffff84014218 <decodeCNodeInvocation+0x1d4>
    0x840140f2     0xae    bltu a5,s1,ffffffff8401423e <decodeCNodeInvocation+0x1fa>
    0x840140f6     0xb2    li a5,19
    0x840140f8     0xb4    beq s1,a5,ffffffff8401417c <decodeCNodeInvocation+0x138>
    0x840140fc     0xb8    li a5,20
    0x840140fe     0xba    bne s1,a5,ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x84014102     0xbe    li a5,5
    0x84014104     0xc0    bltu a5,s2,ffffffff840141de <decodeCNodeInvocation+0x19a>
    0x84014108     0xc4    li a5,7
    0x8401410a     0xc6    auipc a4,0xa
    0x8401410e     0xca    sd a5,-1170(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84014112     0xce    li s0,3
    0x84014114     0xd0    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x84014116     0xd2    li a5,3
    0x84014118     0xd4    auipc a4,0xa
    0x8401411c     0xd8    sd a5,-1184(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84014120     0xdc    li s0,3
    0x84014122     0xde    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x84014124     0xe0    li a5,7
    0x84014126     0xe2    auipc a4,0xa
    0x8401412a     0xe6    sd a5,-1198(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x8401412e     0xea    li s0,3
    0x84014130     0xec    mv a0,s0
    0x84014132     0xee    ld ra,216(sp)         ; stack access
    0x84014134     0xf0    ld s0,208(sp)         ; stack access
    0x84014136     0xf2    ld s1,200(sp)         ; stack access
    0x84014138     0xf4    ld s2,192(sp)         ; stack access
    0x8401413a     0xf6    ld s3,184(sp)         ; stack access
    0x8401413c     0xf8    ld s4,176(sp)         ; stack access
    0x8401413e     0xfa    ld s5,168(sp)         ; stack access
    0x84014140     0xfc    ld s6,160(sp)         ; stack access
    0x84014142     0xfe    ld s7,152(sp)         ; stack access
    0x84014144    0x100    addi sp,sp,224
    0x84014146    0x102    ret
    0x84014148    0x104    li a5,7
    0x8401414a    0x106    auipc a4,0xa
    0x8401414e    0x10a    sd a5,-1234(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84014152    0x10e    li s0,3
    0x84014154    0x110    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x84014156    0x112    auipc a5,0xa
    0x8401415a    0x116    addi a5,a5,-1294 # ffffffff8401dc48 <current_syscall_error>
    0x8401415e    0x11a    li a4,6
    0x84014160    0x11c    sd a4,48(a5)
    0x84014162    0x11e    li a4,1
    0x84014164    0x120    sd a4,40(a5)
    0x84014166    0x122    mv a0,s5
    0x84014168    0x124    jal ra,ffffffff840107ba <lookup_fault_missing_capability_new>
    0x8401416c    0x128    auipc a5,0xa
    0x84014170    0x12c    addi a5,a5,-1340 # ffffffff8401dc30 <current_lookup_fault>
    0x84014174    0x130    sd a0,0(a5)
    0x84014176    0x132    sd a1,8(a5)
    0x84014178    0x134    li s0,3
    0x8401417a    0x136    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x8401417c    0x138    li a5,4
    0x8401417e    0x13a    bltu a5,s2,ffffffff84014190 <decodeCNodeInvocation+0x14c>
    0x84014182    0x13e    li a5,7
    0x84014184    0x140    auipc a4,0xa
    0x84014188    0x144    sd a5,-1292(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x8401418c    0x148    li s0,3
    0x8401418e    0x14a    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x84014190    0x14c    ld a1,0(s6)
    0x84014194    0x150    ld a2,8(s6)
    0x84014198    0x154    ld a0,40(s3)
    0x8401419c    0x158    jal ra,ffffffff84012c7e <maskCapRights>
    0x840141a0    0x15c    mv a2,a0
    0x840141a2    0x15e    mv a3,a1
    0x840141a4    0x160    mv a1,s6
    0x840141a6    0x162    addi a0,sp,88
    0x840141a8    0x164    jal ra,ffffffff840129da <deriveCap>
    0x840141ac    0x168    ld a5,88(sp)          ; stack access
    0x840141ae    0x16a    bnez a5,ffffffff8401426a <decodeCNodeInvocation+0x226>
    0x840141b0    0x16c    ld a5,96(sp)          ; stack access
    0x840141b2    0x16e    sd a5,40(sp)          ; stack access
    0x840141b4    0x170    ld a5,104(sp)         ; stack access
    0x840141b6    0x172    sd a5,48(sp)          ; stack access
    0x840141b8    0x174    ld a0,40(sp)          ; stack access
    0x840141ba    0x176    ld a1,48(sp)          ; stack access
    0x840141bc    0x178    jal ra,ffffffff8401039e <cap_get_capType>
    0x840141c0    0x17c    beqz a0,ffffffff84014230 <decodeCNodeInvocation+0x1ec>
    0x840141c2    0x17e    li a1,2
    0x840141c4    0x180    auipc a0,0x1b
    0x840141c8    0x184    ld a0,-1836(a0) # ffffffff8402ea98 <ksCurThread>
    0x840141cc    0x188    jal ra,ffffffff84013020 <setThreadState>
    0x840141d0    0x18c    mv a3,s4
    0x840141d2    0x18e    mv a2,s6
    0x840141d4    0x190    ld a0,40(sp)          ; stack access
    0x840141d6    0x192    ld a1,48(sp)          ; stack access
    0x840141d8    0x194    jal ra,ffffffff84011e56 <cteInsert>
    0x840141dc    0x198    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x840141de    0x19a    ld s1,48(s3)
    0x840141e2    0x19e    ld a1,0(s6)
    0x840141e6    0x1a2    ld a2,8(s6)
    0x840141ea    0x1a6    ld a0,40(s3)
    0x840141ee    0x1aa    jal ra,ffffffff84012c7e <maskCapRights>
    0x840141f2    0x1ae    mv a2,a0
    0x840141f4    0x1b0    mv a3,a1
    0x840141f6    0x1b2    mv a1,s1
    0x840141f8    0x1b4    li a0,0
    0x840141fa    0x1b6    jal ra,ffffffff84012b8e <updateCapData>
    0x840141fe    0x1ba    mv a2,a0
    0x84014200    0x1bc    mv a3,a1
    0x84014202    0x1be    mv a1,s6
    0x84014204    0x1c0    addi a0,sp,88
    0x84014206    0x1c2    jal ra,ffffffff840129da <deriveCap>
    0x8401420a    0x1c6    ld a5,88(sp)          ; stack access
    0x8401420c    0x1c8    bnez a5,ffffffff8401426e <decodeCNodeInvocation+0x22a>
    0x8401420e    0x1ca    ld a5,96(sp)          ; stack access
    0x84014210    0x1cc    sd a5,40(sp)          ; stack access
    0x84014212    0x1ce    ld a5,104(sp)         ; stack access
    0x84014214    0x1d0    sd a5,48(sp)          ; stack access
    0x84014216    0x1d2    j ffffffff840141b8 <decodeCNodeInvocation+0x174>
    0x84014218    0x1d4    ld a5,0(s6)
    0x8401421c    0x1d8    sd a5,40(sp)          ; stack access
    0x8401421e    0x1da    ld a5,8(s6)
    0x84014222    0x1de    sd a5,48(sp)          ; stack access
    0x84014224    0x1e0    ld a0,40(sp)          ; stack access
    0x84014226    0x1e2    ld a1,48(sp)          ; stack access
    0x84014228    0x1e4    jal ra,ffffffff8401039e <cap_get_capType>
    0x8401422c    0x1e8    bnez a0,ffffffff840144b4 <decodeCNodeInvocation+0x470>
    0x84014230    0x1ec    li a5,3
    0x84014232    0x1ee    auipc a4,0xa
    0x84014236    0x1f2    sd a5,-1466(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x8401423a    0x1f6    li s0,3
    0x8401423c    0x1f8    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x8401423e    0x1fa    li a5,4
    0x84014240    0x1fc    bgeu a5,s2,ffffffff8401425c <decodeCNodeInvocation+0x218>
    0x84014244    0x200    ld a2,0(s6)
    0x84014248    0x204    ld a3,8(s6)
    0x8401424c    0x208    ld a1,40(s3)
    0x84014250    0x20c    li a0,1
    0x84014252    0x20e    jal ra,ffffffff84012b8e <updateCapData>
    0x84014256    0x212    sd a0,40(sp)          ; stack access
    0x84014258    0x214    sd a1,48(sp)          ; stack access
    0x8401425a    0x216    j ffffffff84014224 <decodeCNodeInvocation+0x1e0>
    0x8401425c    0x218    li a5,7
    0x8401425e    0x21a    auipc a4,0xa
    0x84014262    0x21e    sd a5,-1510(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84014266    0x222    li s0,3
    0x84014268    0x224    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x8401426a    0x226    mv s0,a5
    0x8401426c    0x228    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x8401426e    0x22a    mv s0,a5
    0x84014270    0x22c    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x84014272    0x22e    li a5,16
    0x84014274    0x230    beq s1,a5,ffffffff84014390 <decodeCNodeInvocation+0x34c>
    0x84014278    0x234    li a5,17
    0x8401427a    0x236    beq s1,a5,ffffffff840143a8 <decodeCNodeInvocation+0x364>
    0x8401427e    0x23a    li a5,24
    0x84014280    0x23c    beq s1,a5,ffffffff840143c0 <decodeCNodeInvocation+0x37c>
    0x84014284    0x240    li a5,18
    0x84014286    0x242    beq s1,a5,ffffffff840143e4 <decodeCNodeInvocation+0x3a0>
    0x8401428a    0x246    li a5,23
    0x8401428c    0x248    bne s1,a5,ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x84014290    0x24c    li a5,7
    0x84014292    0x24e    bgeu a5,s2,ffffffff8401441a <decodeCNodeInvocation+0x3d6>
    0x84014296    0x252    auipc a5,0xa
    0x8401429a    0x256    ld a5,-1558(a5) # ffffffff8401dc80 <current_extra_caps>
    0x8401429e    0x25a    beqz a5,ffffffff8401441a <decodeCNodeInvocation+0x3d6>
    0x840142a2    0x25e    auipc a4,0xa
    0x840142a6    0x262    ld a4,-1562(a4) # ffffffff8401dc88 <current_extra_caps+0x8>
    0x840142aa    0x266    beqz a4,ffffffff8401441a <decodeCNodeInvocation+0x3d6>
    0x840142ae    0x26a    auipc a3,0x1a
    0x840142b2    0x26e    ld a3,2026(a3) # ffffffff8402ea98 <ksCurThread>
    0x840142b6    0x272    ld s5,104(a3)
    0x840142ba    0x276    ld s7,112(a3)
    0x840142be    0x27a    ld s2,40(s3)
    0x840142c2    0x27e    ld s6,48(s3)
    0x840142c6    0x282    ld s1,64(s3)
    0x840142ca    0x286    ld a3,0(a5)
    0x840142cc    0x288    sd a3,40(sp)          ; stack access
    0x840142ce    0x28a    ld a5,8(a5)
    0x840142d0    0x28c    sd a5,48(sp)          ; stack access
    0x840142d2    0x28e    ld a0,0(a4)
    0x840142d4    0x290    sd a0,56(sp)          ; stack access
    0x840142d6    0x292    ld a1,8(a4)
    0x840142d8    0x294    sd a1,64(sp)          ; stack access
    0x840142da    0x296    mv a3,s1
    0x840142dc    0x298    ld a2,56(s3)
    0x840142e0    0x29c    jal ra,ffffffff84011d60 <lookupSourceSlot>
    0x840142e4    0x2a0    sd a1,120(sp)         ; stack access
    0x840142e6    0x2a2    mv s0,a0
    0x840142e8    0x2a4    bnez a0,ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x840142ec    0x2a8    mv s3,a1
    0x840142ee    0x2aa    mv a3,s2
    0x840142f0    0x2ac    mv a2,s7
    0x840142f2    0x2ae    ld a0,40(sp)          ; stack access
    0x840142f4    0x2b0    ld a1,48(sp)          ; stack access
    0x840142f6    0x2b2    jal ra,ffffffff84011d94 <lookupPivotSlot>
    0x840142fa    0x2b6    sd a0,112(sp)         ; stack access
    0x840142fc    0x2b8    sd a1,120(sp)         ; stack access
    0x840142fe    0x2ba    mv s0,a0
    0x84014300    0x2bc    bnez a0,ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x84014304    0x2c0    mv s7,a1
    0x84014306    0x2c2    beq s3,a1,ffffffff84014428 <decodeCNodeInvocation+0x3e4>
    0x8401430a    0x2c6    beq s4,a1,ffffffff84014428 <decodeCNodeInvocation+0x3e4>
    0x8401430e    0x2ca    beq s4,s3,ffffffff8401431e <decodeCNodeInvocation+0x2da>
    0x84014312    0x2ce    mv a0,s4
    0x84014314    0x2d0    jal ra,ffffffff8401225c <ensureEmptySlot>
    0x84014318    0x2d4    mv s0,a0
    0x8401431a    0x2d6    bnez a0,ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x8401431e    0x2da    ld a0,0(s3)
    0x84014322    0x2de    ld a1,8(s3)
    0x84014326    0x2e2    jal ra,ffffffff8401039e <cap_get_capType>
    0x8401432a    0x2e6    beqz a0,ffffffff84014436 <decodeCNodeInvocation+0x3f2>
    0x8401432e    0x2ea    ld a0,0(s7)
    0x84014332    0x2ee    ld a1,8(s7)
    0x84014336    0x2f2    jal ra,ffffffff8401039e <cap_get_capType>
    0x8401433a    0x2f6    beqz a0,ffffffff8401445c <decodeCNodeInvocation+0x418>
    0x8401433e    0x2fa    ld a2,0(s3)
    0x84014342    0x2fe    ld a3,8(s3)
    0x84014346    0x302    mv a1,s6
    0x84014348    0x304    li a0,1
    0x8401434a    0x306    jal ra,ffffffff84012b8e <updateCapData>
    0x8401434e    0x30a    mv s1,a0
    0x84014350    0x30c    mv s0,a1
    0x84014352    0x30e    sd a0,72(sp)          ; stack access
    0x84014354    0x310    sd a1,80(sp)          ; stack access
    0x84014356    0x312    ld a2,0(s7)
    0x8401435a    0x316    ld a3,8(s7)
    0x8401435e    0x31a    mv a1,s5
    0x84014360    0x31c    li a0,1
    0x84014362    0x31e    jal ra,ffffffff84012b8e <updateCapData>
    0x84014366    0x322    sd a0,88(sp)          ; stack access
    0x84014368    0x324    sd a1,96(sp)          ; stack access
    0x8401436a    0x326    mv a0,s1
    0x8401436c    0x328    mv a1,s0
    0x8401436e    0x32a    jal ra,ffffffff8401039e <cap_get_capType>
    0x84014372    0x32e    beqz a0,ffffffff84014482 <decodeCNodeInvocation+0x43e>
    0x84014376    0x332    ld a0,88(sp)          ; stack access
    0x84014378    0x334    ld a1,96(sp)          ; stack access
    0x8401437a    0x336    jal ra,ffffffff8401039e <cap_get_capType>
    0x8401437e    0x33a    bnez a0,ffffffff84014490 <decodeCNodeInvocation+0x44c>
    0x84014382    0x33e    li a5,3
    0x84014384    0x340    auipc a4,0xa
    0x84014388    0x344    sd a5,-1804(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x8401438c    0x348    li s0,3
    0x8401438e    0x34a    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x84014390    0x34c    li a1,2
    0x84014392    0x34e    auipc a0,0x1a
    0x84014396    0x352    ld a0,1798(a0) # ffffffff8402ea98 <ksCurThread>
    0x8401439a    0x356    jal ra,ffffffff84013020 <setThreadState>
    0x8401439e    0x35a    mv a0,s4
    0x840143a0    0x35c    jal ra,ffffffff84013ff0 <cteRevoke>
    0x840143a4    0x360    mv s0,a0
    0x840143a6    0x362    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x840143a8    0x364    li a1,2
    0x840143aa    0x366    auipc a0,0x1a
    0x840143ae    0x36a    ld a0,1774(a0) # ffffffff8402ea98 <ksCurThread>
    0x840143b2    0x36e    jal ra,ffffffff84013020 <setThreadState>
    0x840143b6    0x372    mv a0,s4
    0x840143b8    0x374    jal ra,ffffffff84013fe0 <invokeCNodeDelete>
    0x840143bc    0x378    mv s0,a0
    0x840143be    0x37a    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x840143c0    0x37c    mv a0,a1
    0x840143c2    0x37e    jal ra,ffffffff8401225c <ensureEmptySlot>
    0x840143c6    0x382    mv s0,a0
    0x840143c8    0x384    bnez a0,ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x840143cc    0x388    li a1,2
    0x840143ce    0x38a    auipc a0,0x1a
    0x840143d2    0x38e    ld a0,1738(a0) # ffffffff8402ea98 <ksCurThread>
    0x840143d6    0x392    jal ra,ffffffff84013020 <setThreadState>
    0x840143da    0x396    mv a0,s4
    0x840143dc    0x398    jal ra,ffffffff84012056 <invokeCNodeSaveCaller>
    0x840143e0    0x39c    mv s0,a0
    0x840143e2    0x39e    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x840143e4    0x3a0    ld a0,0(a1)
    0x840143e6    0x3a2    sd a0,88(sp)          ; stack access
    0x840143e8    0x3a4    ld a1,8(a1)
    0x840143ea    0x3a6    sd a1,96(sp)          ; stack access
    0x840143ec    0x3a8    jal ra,ffffffff84012590 <hasCancelSendRights>
    0x840143f0    0x3ac    bnez a0,ffffffff84014400 <decodeCNodeInvocation+0x3bc>
    0x840143f2    0x3ae    li a5,3
    0x840143f4    0x3b0    auipc a4,0xa
    0x840143f8    0x3b4    sd a5,-1916(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840143fc    0x3b8    li s0,3
    0x840143fe    0x3ba    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x84014400    0x3bc    li a1,2
    0x84014402    0x3be    auipc a0,0x1a
    0x84014406    0x3c2    ld a0,1686(a0) # ffffffff8402ea98 <ksCurThread>
    0x8401440a    0x3c6    jal ra,ffffffff84013020 <setThreadState>
    0x8401440e    0x3ca    ld a0,88(sp)          ; stack access
    0x84014410    0x3cc    ld a1,96(sp)          ; stack access
    0x84014412    0x3ce    jal ra,ffffffff840139ba <invokeCNodeCancelBadgedSends>
    0x84014416    0x3d2    mv s0,a0
    0x84014418    0x3d4    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x8401441a    0x3d6    li a5,7
    0x8401441c    0x3d8    auipc a4,0xa
    0x84014420    0x3dc    sd a5,-1956(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84014424    0x3e0    li s0,3
    0x84014426    0x3e2    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x84014428    0x3e4    li a5,3
    0x8401442a    0x3e6    auipc a4,0xa
    0x8401442e    0x3ea    sd a5,-1970(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84014432    0x3ee    li s0,3
    0x84014434    0x3f0    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x84014436    0x3f2    auipc a5,0xa
    0x8401443a    0x3f6    addi a5,a5,-2030 # ffffffff8401dc48 <current_syscall_error>
    0x8401443e    0x3fa    li a4,6
    0x84014440    0x3fc    sd a4,48(a5)
    0x84014442    0x3fe    li a4,1
    0x84014444    0x400    sd a4,40(a5)
    0x84014446    0x402    mv a0,s1
    0x84014448    0x404    jal ra,ffffffff840107ba <lookup_fault_missing_capability_new>
    0x8401444c    0x408    auipc a5,0x9
    0x84014450    0x40c    addi a5,a5,2020 # ffffffff8401dc30 <current_lookup_fault>
    0x84014454    0x410    sd a0,0(a5)
    0x84014456    0x412    sd a1,8(a5)
    0x84014458    0x414    li s0,3
    0x8401445a    0x416    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x8401445c    0x418    auipc a5,0x9
    0x84014460    0x41c    addi a5,a5,2028 # ffffffff8401dc48 <current_syscall_error>
    0x84014464    0x420    li a4,6
    0x84014466    0x422    sd a4,48(a5)
    0x84014468    0x424    sd zero,40(a5)
    0x8401446c    0x428    mv a0,s2
    0x8401446e    0x42a    jal ra,ffffffff840107ba <lookup_fault_missing_capability_new>
    0x84014472    0x42e    auipc a5,0x9
    0x84014476    0x432    addi a5,a5,1982 # ffffffff8401dc30 <current_lookup_fault>
    0x8401447a    0x436    sd a0,0(a5)
    0x8401447c    0x438    sd a1,8(a5)
    0x8401447e    0x43a    li s0,3
    0x84014480    0x43c    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x84014482    0x43e    li a5,3
    0x84014484    0x440    auipc a4,0x9
    0x84014488    0x444    sd a5,2036(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x8401448c    0x448    li s0,3
    0x8401448e    0x44a    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x84014490    0x44c    li a1,2
    0x84014492    0x44e    auipc a0,0x1a
    0x84014496    0x452    ld a0,1542(a0) # ffffffff8402ea98 <ksCurThread>
    0x8401449a    0x456    jal ra,ffffffff84013020 <setThreadState>
    0x8401449e    0x45a    mv a6,s4
    0x840144a0    0x45c    mv a5,s7
    0x840144a2    0x45e    mv a4,s3
    0x840144a4    0x460    ld a2,88(sp)          ; stack access
    0x840144a6    0x462    ld a3,96(sp)          ; stack access
    0x840144a8    0x464    ld a0,72(sp)          ; stack access
    0x840144aa    0x466    ld a1,80(sp)          ; stack access
    0x840144ac    0x468    jal ra,ffffffff8401212e <invokeCNodeRotate>
    0x840144b0    0x46c    mv s0,a0
    0x840144b2    0x46e    j ffffffff84014130 <decodeCNodeInvocation+0xec>
    0x840144b4    0x470    li a1,2
    0x840144b6    0x472    auipc a0,0x1a
    0x840144ba    0x476    ld a0,1506(a0) # ffffffff8402ea98 <ksCurThread>
    0x840144be    0x47a    jal ra,ffffffff84013020 <setThreadState>
    0x840144c2    0x47e    mv a3,s4
    0x840144c4    0x480    mv a2,s6
    0x840144c6    0x482    ld a0,40(sp)          ; stack access
    0x840144c8    0x484    ld a1,48(sp)          ; stack access
    0x840144ca    0x486    jal ra,ffffffff84011fd0 <cteMove>
    0x840144ce    0x48a    j ffffffff84014130 <decodeCNodeInvocation+0xec>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
418 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeCNodeInvocation` has 691 nodes.

Section sendIPC (425 of 432)
============================

Deriving specifications
-----------------------

Section `sendIPC` consists of 127 instructions.


Stack analysis
---------------

20 stack accesses found. Annotated code for `sendIPC`:

    0x84014d68      0x0    addi sp,sp,-96
    0x84014d6a      0x2    sd ra,88(sp)          ; stack access
    0x84014d6c      0x4    sd s0,80(sp)          ; stack access
    0x84014d6e      0x6    sd s1,72(sp)          ; stack access
    0x84014d70      0x8    sd s2,64(sp)          ; stack access
    0x84014d72      0xa    sd s3,56(sp)          ; stack access
    0x84014d74      0xc    sd s4,48(sp)          ; stack access
    0x84014d76      0xe    sd s5,40(sp)          ; stack access
    0x84014d78     0x10    sd s6,32(sp)          ; stack access
    0x84014d7a     0x12    sd s7,24(sp)          ; stack access
    0x84014d7c     0x14    sd s8,16(sp)          ; stack access
    0x84014d7e     0x16    mv s1,a0
    0x84014d80     0x18    mv s4,a1
    0x84014d82     0x1a    mv s5,a2
    0x84014d84     0x1c    mv s3,a3
    0x84014d86     0x1e    mv s6,a4
    0x84014d88     0x20    mv s2,a5
    0x84014d8a     0x22    mv s0,a6
    0x84014d8c     0x24    mv a0,a6
    0x84014d8e     0x26    jal ra,ffffffff84010178 <endpoint_ptr_get_state>
    0x84014d92     0x2a    li a6,1
    0x84014d94     0x2c    bgeu a6,a0,ffffffff84014e0c <sendIPC+0xa4>
    0x84014d98     0x30    li a6,2
    0x84014d9a     0x32    bne a0,a6,ffffffff84014e0e <sendIPC+0xa6>
    0x84014d9e     0x36    mv a0,s0
    0x84014da0     0x38    jal ra,ffffffff84010158 <endpoint_ptr_get_epQueue_head>
    0x84014da4     0x3c    mv s1,a0
    0x84014da6     0x3e    mv a0,s0
    0x84014da8     0x40    jal ra,ffffffff84010aee <endpoint_ptr_get_epQueue_tail>
    0x84014dac     0x44    mv a2,a0
    0x84014dae     0x46    mv a1,s1
    0x84014db0     0x48    mv a0,s1
    0x84014db2     0x4a    jal ra,ffffffff840138b6 <tcbEPDequeue>
    0x84014db6     0x4e    mv s7,a0
    0x84014db8     0x50    mv s8,a1
    0x84014dba     0x52    mv a1,a0
    0x84014dbc     0x54    mv a0,s0
    0x84014dbe     0x56    jal ra,ffffffff8401015c <endpoint_ptr_set_epQueue_head>
    0x84014dc2     0x5a    mv a1,s8
    0x84014dc4     0x5c    mv a0,s0
    0x84014dc6     0x5e    jal ra,ffffffff84010160 <endpoint_ptr_set_epQueue_tail>
    0x84014dca     0x62    beqz s7,ffffffff84014e9a <sendIPC+0x132>
    0x84014dce     0x66    mv a4,s1
    0x84014dd0     0x68    mv a3,s3
    0x84014dd2     0x6a    mv a2,s5
    0x84014dd4     0x6c    mv a1,s0
    0x84014dd6     0x6e    mv a0,s2
    0x84014dd8     0x70    jal ra,ffffffff84014bf0 <doIPCTransfer>
    0x84014ddc     0x74    addi a0,s1,280
    0x84014de0     0x78    jal ra,ffffffff84010316 <thread_state_ptr_get_blockingIPCCanGrant>
    0x84014de4     0x7c    mv s0,a0
    0x84014de6     0x7e    li a1,1
    0x84014de8     0x80    mv a0,s1
    0x84014dea     0x82    jal ra,ffffffff84013020 <setThreadState>
    0x84014dee     0x86    mv a0,s1
    0x84014df0     0x88    jal ra,ffffffff840132c6 <possibleSwitchTo>
    0x84014df4     0x8c    beqz s4,ffffffff84014e0e <sendIPC+0xa6>
    0x84014df8     0x90    or s3,s3,s6
    0x84014dfc     0x94    beqz s3,ffffffff84014ea4 <sendIPC+0x13c>
    0x84014e00     0x98    mv a2,s0
    0x84014e02     0x9a    mv a1,s1
    0x84014e04     0x9c    mv a0,s2
    0x84014e06     0x9e    jal ra,ffffffff84014912 <setupCallerCap>
    0x84014e0a     0xa2    j ffffffff84014e0e <sendIPC+0xa6>
    0x84014e0c     0xa4    bnez s1,ffffffff84014e26 <sendIPC+0xbe>
    0x84014e0e     0xa6    ld ra,88(sp)          ; stack access
    0x84014e10     0xa8    ld s0,80(sp)          ; stack access
    0x84014e12     0xaa    ld s1,72(sp)          ; stack access
    0x84014e14     0xac    ld s2,64(sp)          ; stack access
    0x84014e16     0xae    ld s3,56(sp)          ; stack access
    0x84014e18     0xb0    ld s4,48(sp)          ; stack access
    0x84014e1a     0xb2    ld s5,40(sp)          ; stack access
    0x84014e1c     0xb4    ld s6,32(sp)          ; stack access
    0x84014e1e     0xb6    ld s7,24(sp)          ; stack access
    0x84014e20     0xb8    ld s8,16(sp)          ; stack access
    0x84014e22     0xba    addi sp,sp,96
    0x84014e24     0xbc    ret
    0x84014e26     0xbe    addi s1,s2,280
    0x84014e2a     0xc2    li a1,4
    0x84014e2c     0xc4    mv a0,s1
    0x84014e2e     0xc6    jal ra,ffffffff8401038e <thread_state_ptr_set_tsType>
    0x84014e32     0xca    mv a1,s0
    0x84014e34     0xcc    mv a0,s1
    0x84014e36     0xce    jal ra,ffffffff8401036a <thread_state_ptr_set_blockingObject>
    0x84014e3a     0xd2    mv a1,s5
    0x84014e3c     0xd4    mv a0,s1
    0x84014e3e     0xd6    jal ra,ffffffff84010312 <thread_state_ptr_set_blockingIPCBadge>
    0x84014e42     0xda    mv a1,s3
    0x84014e44     0xdc    mv a0,s1
    0x84014e46     0xde    jal ra,ffffffff8401031e <thread_state_ptr_set_blockingIPCCanGrant>
    0x84014e4a     0xe2    mv a1,s6
    0x84014e4c     0xe4    mv a0,s1
    0x84014e4e     0xe6    jal ra,ffffffff84010334 <thread_state_ptr_set_blockingIPCCanGrantReply>
    0x84014e52     0xea    mv a1,s4
    0x84014e54     0xec    mv a0,s1
    0x84014e56     0xee    jal ra,ffffffff8401034a <thread_state_ptr_set_blockingIPCIsCall>
    0x84014e5a     0xf2    mv a0,s2
    0x84014e5c     0xf4    jal ra,ffffffff84012fda <scheduleTCB>
    0x84014e60     0xf8    mv a0,s0
    0x84014e62     0xfa    jal ra,ffffffff84010158 <endpoint_ptr_get_epQueue_head>
    0x84014e66     0xfe    mv s1,a0
    0x84014e68    0x100    mv a0,s0
    0x84014e6a    0x102    jal ra,ffffffff84010aee <endpoint_ptr_get_epQueue_tail>
    0x84014e6e    0x106    mv s3,s2
    0x84014e70    0x108    beqz s1,ffffffff84014e78 <sendIPC+0x110>
    0x84014e72    0x10a    mv s3,s1
    0x84014e74    0x10c    sd s2,408(a0)
    0x84014e78    0x110    sd a0,416(s2)
    0x84014e7c    0x114    sd zero,408(s2)
    0x84014e80    0x118    li a1,1
    0x84014e82    0x11a    mv a0,s0
    0x84014e84    0x11c    jal ra,ffffffff8401017e <endpoint_ptr_set_state>
    0x84014e88    0x120    mv a1,s3
    0x84014e8a    0x122    mv a0,s0
    0x84014e8c    0x124    jal ra,ffffffff8401015c <endpoint_ptr_set_epQueue_head>
    0x84014e90    0x128    mv a1,s2
    0x84014e92    0x12a    mv a0,s0
    0x84014e94    0x12c    jal ra,ffffffff84010160 <endpoint_ptr_set_epQueue_tail>
    0x84014e98    0x130    j ffffffff84014e0e <sendIPC+0xa6>
    0x84014e9a    0x132    li a1,0
    0x84014e9c    0x134    mv a0,s0
    0x84014e9e    0x136    jal ra,ffffffff8401017e <endpoint_ptr_set_state>
    0x84014ea2    0x13a    j ffffffff84014dce <sendIPC+0x66>
    0x84014ea4    0x13c    li a1,0
    0x84014ea6    0x13e    mv a0,s2
    0x84014ea8    0x140    jal ra,ffffffff84013020 <setThreadState>
    0x84014eac    0x144    j ffffffff84014e0e <sendIPC+0xa6>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
127 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sendIPC` has 190 nodes.

Section maskCapRights (426 of 432)
==================================

Deriving specifications
-----------------------

Section `maskCapRights` consists of 134 instructions.


Stack analysis
---------------

20 stack accesses found. Annotated code for `maskCapRights`:

    0x84012c7e      0x0    addi sp,sp,-96
    0x84012c80      0x2    sd ra,88(sp)          ; stack access
    0x84012c82      0x4    sd s0,80(sp)          ; stack access
    0x84012c84      0x6    sd s1,72(sp)          ; stack access
    0x84012c86      0x8    sd s2,64(sp)          ; stack access
    0x84012c88      0xa    sd s3,56(sp)          ; stack access
    0x84012c8a      0xc    mv s0,a0
    0x84012c8c      0xe    sd a1,0(sp)           ; stack access
    0x84012c8e     0x10    sd a2,8(sp)           ; stack access
    0x84012c90     0x12    mv a0,a1
    0x84012c92     0x14    mv a1,a2
    0x84012c94     0x16    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012c98     0x1a    andi a0,a0,1
    0x84012c9a     0x1c    bnez a0,ffffffff84012cbe <maskCapRights+0x40>
    0x84012c9c     0x1e    ld a0,0(sp)           ; stack access
    0x84012c9e     0x20    ld a1,8(sp)           ; stack access
    0x84012ca0     0x22    jal ra,ffffffff8401039e <cap_get_capType>
    0x84012ca4     0x26    li a5,20
    0x84012ca6     0x28    bltu a5,a0,ffffffff84012dce <maskCapRights+0x150>
    0x84012caa     0x2c    slli a5,a0,0x2
    0x84012cae     0x30    auipc a4,0x5
    0x84012cb2     0x34    addi a4,a4,1094 # ffffffff840180f4 <ksDomScheduleLength+0x1ac>
    0x84012cb6     0x38    add a5,a5,a4
    0x84012cb8     0x3a    lw a5,0(a5)
    0x84012cba     0x3c    add a5,a5,a4
    0x84012cbc     0x3e    jr a5
    0x84012cbe     0x40    ld a1,0(sp)           ; stack access
    0x84012cc0     0x42    ld a2,8(sp)           ; stack access
    0x84012cc2     0x44    mv a0,s0
    0x84012cc4     0x46    jal ra,ffffffff840116c6 <Arch_maskCapRights>
    0x84012cc8     0x4a    sd a0,32(sp)          ; stack access
    0x84012cca     0x4c    sd a1,40(sp)          ; stack access
    0x84012ccc     0x4e    ld a0,32(sp)          ; stack access
    0x84012cce     0x50    ld a1,40(sp)          ; stack access
    0x84012cd0     0x52    ld ra,88(sp)          ; stack access
    0x84012cd2     0x54    ld s0,80(sp)          ; stack access
    0x84012cd4     0x56    ld s1,72(sp)          ; stack access
    0x84012cd6     0x58    ld s2,64(sp)          ; stack access
    0x84012cd8     0x5a    ld s3,56(sp)          ; stack access
    0x84012cda     0x5c    addi sp,sp,96
    0x84012cdc     0x5e    ret
    0x84012cde     0x60    ld a5,0(sp)
    0x84012ce0     0x62    sd a5,32(sp)
    0x84012ce2     0x64    ld a5,8(sp)
    0x84012ce4     0x66    sd a5,40(sp)
    0x84012ce6     0x68    j ffffffff84012ccc <maskCapRights+0x4e>
    0x84012ce8     0x6a    ld a0,0(sp)
    0x84012cea     0x6c    ld a1,8(sp)
    0x84012cec     0x6e    jal ra,ffffffff840104b0 <cap_endpoint_cap_get_capCanSend>
    0x84012cf0     0x72    mv s1,a0
    0x84012cf2     0x74    mv a0,s0
    0x84012cf4     0x76    jal ra,ffffffff840100f0 <seL4_CapRights_get_capAllowWrite>
    0x84012cf8     0x7a    and a2,s1,a0
    0x84012cfc     0x7e    ld a0,0(sp)
    0x84012cfe     0x80    ld a1,8(sp)
    0x84012d00     0x82    jal ra,ffffffff840104ba <cap_endpoint_cap_set_capCanSend>
    0x84012d04     0x86    mv s2,a0
    0x84012d06     0x88    mv s1,a1
    0x84012d08     0x8a    ld a0,0(sp)
    0x84012d0a     0x8c    ld a1,8(sp)
    0x84012d0c     0x8e    jal ra,ffffffff84010492 <cap_endpoint_cap_get_capCanReceive>
    0x84012d10     0x92    mv s3,a0
    0x84012d12     0x94    mv a0,s0
    0x84012d14     0x96    jal ra,ffffffff840100ea <seL4_CapRights_get_capAllowRead>
    0x84012d18     0x9a    and a2,s3,a0
    0x84012d1c     0x9e    mv a0,s2
    0x84012d1e     0xa0    mv a1,s1
    0x84012d20     0xa2    jal ra,ffffffff8401049c <cap_endpoint_cap_set_capCanReceive>
    0x84012d24     0xa6    mv s2,a0
    0x84012d26     0xa8    mv s1,a1
    0x84012d28     0xaa    ld a0,0(sp)
    0x84012d2a     0xac    ld a1,8(sp)
    0x84012d2c     0xae    jal ra,ffffffff84010474 <cap_endpoint_cap_get_capCanGrant>
    0x84012d30     0xb2    mv s3,a0
    0x84012d32     0xb4    mv a0,s0
    0x84012d34     0xb6    jal ra,ffffffff840100e4 <seL4_CapRights_get_capAllowGrant>
    0x84012d38     0xba    and a2,s3,a0
    0x84012d3c     0xbe    mv a0,s2
    0x84012d3e     0xc0    mv a1,s1
    0x84012d40     0xc2    jal ra,ffffffff8401047e <cap_endpoint_cap_set_capCanGrant>
    0x84012d44     0xc6    mv s2,a0
    0x84012d46     0xc8    mv s1,a1
    0x84012d48     0xca    ld a0,0(sp)
    0x84012d4a     0xcc    ld a1,8(sp)
    0x84012d4c     0xce    jal ra,ffffffff84010456 <cap_endpoint_cap_get_capCanGrantReply>
    0x84012d50     0xd2    mv s3,a0
    0x84012d52     0xd4    mv a0,s0
    0x84012d54     0xd6    jal ra,ffffffff840100de <seL4_CapRights_get_capAllowGrantReply>
    0x84012d58     0xda    and a2,s3,a0
    0x84012d5c     0xde    mv a0,s2
    0x84012d5e     0xe0    mv a1,s1
    0x84012d60     0xe2    jal ra,ffffffff84010460 <cap_endpoint_cap_set_capCanGrantReply>
    0x84012d64     0xe6    sd a0,32(sp)
    0x84012d66     0xe8    sd a1,40(sp)
    0x84012d68     0xea    j ffffffff84012ccc <maskCapRights+0x4e>
    0x84012d6a     0xec    ld a0,0(sp)
    0x84012d6c     0xee    ld a1,8(sp)
    0x84012d6e     0xf0    jal ra,ffffffff8401051e <cap_notification_cap_get_capNtfnCanSend>
    0x84012d72     0xf4    mv s1,a0
    0x84012d74     0xf6    mv a0,s0
    0x84012d76     0xf8    jal ra,ffffffff840100f0 <seL4_CapRights_get_capAllowWrite>
    0x84012d7a     0xfc    and a2,s1,a0
    0x84012d7e    0x100    ld a0,0(sp)
    0x84012d80    0x102    ld a1,8(sp)
    0x84012d82    0x104    jal ra,ffffffff84010528 <cap_notification_cap_set_capNtfnCanSend>
    0x84012d86    0x108    mv s2,a0
    0x84012d88    0x10a    mv s1,a1
    0x84012d8a    0x10c    ld a0,0(sp)
    0x84012d8c    0x10e    ld a1,8(sp)
    0x84012d8e    0x110    jal ra,ffffffff84010500 <cap_notification_cap_get_capNtfnCanReceive>
    0x84012d92    0x114    mv s3,a0
    0x84012d94    0x116    mv a0,s0
    0x84012d96    0x118    jal ra,ffffffff840100ea <seL4_CapRights_get_capAllowRead>
    0x84012d9a    0x11c    and a2,s3,a0
    0x84012d9e    0x120    mv a0,s2
    0x84012da0    0x122    mv a1,s1
    0x84012da2    0x124    jal ra,ffffffff8401050a <cap_notification_cap_set_capNtfnCanReceive>
    0x84012da6    0x128    sd a0,32(sp)
    0x84012da8    0x12a    sd a1,40(sp)
    0x84012daa    0x12c    j ffffffff84012ccc <maskCapRights+0x4e>
    0x84012dac    0x12e    ld a0,0(sp)
    0x84012dae    0x130    ld a1,8(sp)
    0x84012db0    0x132    jal ra,ffffffff8401055c <cap_reply_cap_get_capReplyCanGrant>
    0x84012db4    0x136    mv s1,a0
    0x84012db6    0x138    mv a0,s0
    0x84012db8    0x13a    jal ra,ffffffff840100e4 <seL4_CapRights_get_capAllowGrant>
    0x84012dbc    0x13e    and a2,s1,a0
    0x84012dc0    0x142    ld a0,0(sp)
    0x84012dc2    0x144    ld a1,8(sp)
    0x84012dc4    0x146    jal ra,ffffffff84010566 <cap_reply_cap_set_capReplyCanGrant>
    0x84012dc8    0x14a    sd a0,32(sp)
    0x84012dca    0x14c    sd a1,40(sp)
    0x84012dcc    0x14e    j ffffffff84012ccc <maskCapRights+0x4e>
    0x84012dce    0x150    jal ra,ffffffff84010cec <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
134 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `maskCapRights` has 216 nodes.

Section fastpath_call (427 of 432)
==================================

Deriving specifications
-----------------------

Section `fastpath_call` consists of 286 instructions.

Skipping 18051073 csrw satp,a0

Skipping 12000073 sfence.vma

Skipping 14131073 csrw sepc,t1

Skipping 14029073 csrw sscratch,t0

Skipping 10031073 csrw sstatus,t1

Skipping 10200073 sret


Stack analysis
---------------

56 stack accesses found. Annotated code for `fastpath_call`:

    0x84017660      0x0    addi sp,sp,-160
    0x84017662      0x2    sd ra,152(sp)         ; stack access
    0x84017664      0x4    sd s0,144(sp)         ; stack access
    0x84017666      0x6    sd s1,136(sp)         ; stack access
    0x84017668      0x8    sd s2,128(sp)         ; stack access
    0x8401766a      0xa    sd s3,120(sp)         ; stack access
    0x8401766c      0xc    sd s4,112(sp)         ; stack access
    0x8401766e      0xe    sd s5,104(sp)         ; stack access
    0x84017670     0x10    sd s6,96(sp)          ; stack access
    0x84017672     0x12    sd s7,88(sp)          ; stack access
    0x84017674     0x14    sd s8,80(sp)          ; stack access
    0x84017676     0x16    sd s9,72(sp)          ; stack access
    0x84017678     0x18    sd s10,64(sp)         ; stack access
    0x8401767a     0x1a    mv s6,a0
    0x8401767c     0x1c    mv s3,a1
    0x8401767e     0x1e    auipc s4,0x17
    0x84017682     0x22    ld s4,1050(s4) # ffffffff8402ea98 <ksCurThread>
    0x84017686     0x26    ld a0,312(s4)
    0x8401768a     0x2a    ld a1,320(s4)
    0x8401768e     0x2e    jal ra,ffffffff8401084a <seL4_Fault_get_seL4_FaultType>
    0x84017692     0x32    andi a4,s3,511
    0x84017696     0x36    li a5,4
    0x84017698     0x38    bltu a5,a4,ffffffff840177a0 <fastpath_call+0x140>
    0x8401769c     0x3c    mv s1,a0
    0x8401769e     0x3e    bnez a0,ffffffff840177a0 <fastpath_call+0x140>
    0x840176a2     0x42    mv a0,s3
    0x840176a4     0x44    jal ra,ffffffff84010146 <seL4_MessageInfo_get_length>
    0x840176a8     0x48    mv s5,a0
    0x840176aa     0x4a    andi a5,s4,-1024
    0x840176ae     0x4e    ld a0,0(a5)
    0x840176b0     0x50    sd a0,0(sp)           ; stack access
    0x840176b2     0x52    ld a1,8(a5)
    0x840176b4     0x54    sd a1,8(sp)           ; stack access
    0x840176b6     0x56    li a2,10
    0x840176b8     0x58    jal ra,ffffffff840103a6 <cap_capType_equals>
    0x840176bc     0x5c    li s8,64
    0x840176c0     0x60    li s9,63
    0x840176c4     0x64    beqz a0,ffffffff840177a6 <fastpath_call+0x146>
    0x840176c8     0x68    ld a0,0(sp)           ; stack access
    0x840176ca     0x6a    ld a1,8(sp)           ; stack access
    0x840176cc     0x6c    jal ra,ffffffff840105ae <cap_cnode_cap_get_capCNodeGuardSize>
    0x840176d0     0x70    mv s2,a0
    0x840176d2     0x72    ld a0,0(sp)           ; stack access
    0x840176d4     0x74    ld a1,8(sp)           ; stack access
    0x840176d6     0x76    jal ra,ffffffff840105d2 <cap_cnode_cap_get_capCNodeRadix>
    0x840176da     0x7a    mv s7,a0
    0x840176dc     0x7c    sll s0,s6,s1
    0x840176e0     0x80    ld a0,0(sp)           ; stack access
    0x840176e2     0x82    ld a1,8(sp)           ; stack access
    0x840176e4     0x84    jal ra,ffffffff8401059e <cap_cnode_cap_get_capCNodeGuard>
    0x840176e8     0x88    beqz s2,ffffffff840176f8 <fastpath_call+0x98>
    0x840176ec     0x8c    subw a5,s8,s2
    0x840176f0     0x90    srl a5,s0,a5
    0x840176f4     0x94    bne a0,a5,ffffffff840177b0 <fastpath_call+0x150>
    0x840176f8     0x98    ld a0,0(sp)           ; stack access
    0x840176fa     0x9a    ld a1,8(sp)           ; stack access
    0x840176fc     0x9c    jal ra,ffffffff84010a1c <cap_cnode_cap_get_capCNodePtr>
    0x84017700     0xa0    sll a5,s0,s2
    0x84017704     0xa4    subw s0,s8,s7
    0x84017708     0xa8    srl a5,a5,s0
    0x8401770c     0xac    slli a5,a5,0x5
    0x8401770e     0xae    add a5,a5,a0
    0x84017710     0xb0    ld a4,0(a5)
    0x84017712     0xb2    sd a4,0(sp)           ; stack access
    0x84017714     0xb4    ld a5,8(a5)
    0x84017716     0xb6    sd a5,8(sp)           ; stack access
    0x84017718     0xb8    add s2,s2,s7
    0x8401771a     0xba    add s1,s1,s2
    0x8401771c     0xbc    bgeu s9,s1,ffffffff840177ba <fastpath_call+0x15a>
    0x84017720     0xc0    li a5,64
    0x84017724     0xc4    bltu a5,s1,ffffffff840177c8 <fastpath_call+0x168>
    0x84017728     0xc8    ld a5,0(sp)           ; stack access
    0x8401772a     0xca    sd a5,48(sp)          ; stack access
    0x8401772c     0xcc    ld a5,8(sp)           ; stack access
    0x8401772e     0xce    sd a5,56(sp)          ; stack access
    0x84017730     0xd0    ld a0,48(sp)          ; stack access
    0x84017732     0xd2    sd a0,32(sp)          ; stack access
    0x84017734     0xd4    ld a1,56(sp)          ; stack access
    0x84017736     0xd6    sd a1,40(sp)          ; stack access
    0x84017738     0xd8    li a2,4
    0x8401773a     0xda    jal ra,ffffffff840103a6 <cap_capType_equals>
    0x8401773e     0xde    beqz a0,ffffffff840177d2 <fastpath_call+0x172>
    0x84017740     0xe0    ld a0,32(sp)          ; stack access
    0x84017742     0xe2    ld a1,40(sp)          ; stack access
    0x84017744     0xe4    jal ra,ffffffff840104b0 <cap_endpoint_cap_get_capCanSend>
    0x84017748     0xe8    beqz a0,ffffffff840177d2 <fastpath_call+0x172>
    0x8401774a     0xea    ld a0,32(sp)          ; stack access
    0x8401774c     0xec    ld a1,40(sp)          ; stack access
    0x8401774e     0xee    jal ra,ffffffff840109fe <cap_endpoint_cap_get_capEPPtr>
    0x84017752     0xf2    mv s1,a0
    0x84017754     0xf4    jal ra,ffffffff84010158 <endpoint_ptr_get_epQueue_head>
    0x84017758     0xf8    mv s0,a0
    0x8401775a     0xfa    mv a0,s1
    0x8401775c     0xfc    jal ra,ffffffff84010178 <endpoint_ptr_get_state>
    0x84017760    0x100    li a5,2
    0x84017762    0x102    bne a0,a5,ffffffff840177d8 <fastpath_call+0x178>
    0x84017766    0x106    andi s8,s0,-1024
    0x8401776a    0x10a    ld s7,32(s8)
    0x8401776e    0x10e    sd s7,16(sp)          ; stack access
    0x84017770    0x110    ld s6,40(s8)
    0x84017774    0x114    sd s6,24(sp)          ; stack access
    0x84017776    0x116    mv a0,s7
    0x84017778    0x118    mv a1,s6
    0x8401777a    0x11a    jal ra,ffffffff84010a76 <cap_page_table_cap_get_capPTBasePtr>
    0x8401777e    0x11e    mv s2,a0
    0x84017780    0x120    sd s7,0(sp)           ; stack access
    0x84017782    0x122    sd s6,8(sp)           ; stack access
    0x84017784    0x124    li a2,3
    0x84017786    0x126    mv a0,s7
    0x84017788    0x128    mv a1,s6
    0x8401778a    0x12a    jal ra,ffffffff840103a6 <cap_capType_equals>
    0x8401778e    0x12e    beqz a0,ffffffff8401779a <fastpath_call+0x13a>
    0x84017790    0x130    ld a0,0(sp)           ; stack access
    0x84017792    0x132    ld a1,8(sp)           ; stack access
    0x84017794    0x134    jal ra,ffffffff8401072c <cap_page_table_cap_get_capPTIsMapped>
    0x84017798    0x138    bnez a0,ffffffff8401784c <fastpath_call+0x1ec>
    0x8401779a    0x13a    li a0,-1
    0x8401779c    0x13c    jal ra,ffffffff84017648 <slowpath>
    0x840177a0    0x140    li a0,-1
    0x840177a2    0x142    jal ra,ffffffff84017648 <slowpath>
    0x840177a6    0x146    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x840177aa    0x14a    sd a0,48(sp)          ; stack access
    0x840177ac    0x14c    sd a1,56(sp)          ; stack access
    0x840177ae    0x14e    j ffffffff84017730 <fastpath_call+0xd0>
    0x840177b0    0x150    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x840177b4    0x154    sd a0,48(sp)          ; stack access
    0x840177b6    0x156    sd a1,56(sp)          ; stack access
    0x840177b8    0x158    j ffffffff84017730 <fastpath_call+0xd0>
    0x840177ba    0x15a    li a2,10
    0x840177bc    0x15c    mv a0,a4
    0x840177be    0x15e    mv a1,a5
    0x840177c0    0x160    jal ra,ffffffff840103a6 <cap_capType_equals>
    0x840177c4    0x164    beqz a0,ffffffff84017728 <fastpath_call+0xc8>
    0x840177c6    0x166    j ffffffff840176c8 <fastpath_call+0x68>
    0x840177c8    0x168    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x840177cc    0x16c    sd a0,48(sp)          ; stack access
    0x840177ce    0x16e    sd a1,56(sp)          ; stack access
    0x840177d0    0x170    j ffffffff84017730 <fastpath_call+0xd0>
    0x840177d2    0x172    li a0,-1
    0x840177d4    0x174    jal ra,ffffffff84017648 <slowpath>
    0x840177d8    0x178    li a0,-1
    0x840177da    0x17a    jal ra,ffffffff84017648 <slowpath>
    0x840177de    0x17e    slli a4,s7,0x3
    0x840177e2    0x182    auipc a5,0x17
    0x840177e6    0x186    addi a5,a5,566 # ffffffff8402ea18 <ksReadyQueuesL1Bitmap>
    0x840177ea    0x18a    add a5,a5,a4
    0x840177ec    0x18c    ld a0,0(a5)
    0x840177ee    0x18e    beqz a0,ffffffff8401786a <fastpath_call+0x20a>
    0x840177f0    0x190    jal ra,ffffffff84017f02 <__clzdi2>
    0x840177f4    0x194    sext.w s4,a0
    0x840177f8    0x198    slli a5,s7,0x2
    0x840177fc    0x19c    addi a4,s4,-60
    0x84017800    0x1a0    add a5,a5,a4
    0x84017802    0x1a2    slli a5,a5,0x3
    0x84017804    0x1a4    auipc a4,0x17
    0x84017808    0x1a8    addi a4,a4,12 # ffffffff8402e810 <ksReadyQueuesL2Bitmap>
    0x8401780c    0x1ac    add a5,a5,a4
    0x8401780e    0x1ae    ld a0,0(a5)
    0x84017810    0x1b0    jal ra,ffffffff84017f02 <__clzdi2>
    0x84017814    0x1b4    sext.w a3,a0
    0x84017818    0x1b8    li a4,63
    0x8401781c    0x1bc    sub a5,a4,s4
    0x84017820    0x1c0    slli a5,a5,0x6
    0x84017822    0x1c2    sub a4,a4,a3
    0x84017824    0x1c4    or a5,a5,a4
    0x84017826    0x1c6    bgeu s9,a5,ffffffff8401786a <fastpath_call+0x20a>
    0x8401782a    0x1ca    li a0,-1
    0x8401782c    0x1cc    jal ra,ffffffff84017648 <slowpath>
    0x84017830    0x1d0    ld a0,32(sp)          ; stack access
    0x84017832    0x1d2    ld a1,40(sp)          ; stack access
    0x84017834    0x1d4    jal ra,ffffffff84010456 <cap_endpoint_cap_get_capCanGrantReply>
    0x84017838    0x1d8    bnez a0,ffffffff84017874 <fastpath_call+0x214>
    0x8401783a    0x1da    li a0,-1
    0x8401783c    0x1dc    jal ra,ffffffff84017648 <slowpath>
    0x84017840    0x1e0    li a0,-1
    0x84017842    0x1e2    jal ra,ffffffff84017648 <slowpath>
    0x84017846    0x1e6    sd zero,416(a5)
    0x8401784a    0x1ea    j ffffffff8401788c <fastpath_call+0x22c>
    0x8401784c    0x1ec    ld a0,16(sp)          ; stack access
    0x8401784e    0x1ee    ld a1,24(sp)          ; stack access
    0x84017850    0x1f0    jal ra,ffffffff84010714 <cap_page_table_cap_get_capPTMappedASID>
    0x84017854    0x1f4    mv s6,a0
    0x84017856    0x1f6    auipc s7,0x17
    0x8401785a    0x1fa    ld s7,-86(s7) # ffffffff8402e800 <ksCurDomain>
    0x8401785e    0x1fe    ld s9,360(s0)
    0x84017862    0x202    ld a5,360(s4)
    0x84017866    0x206    bltu s9,a5,ffffffff840177de <fastpath_call+0x17e>
    0x8401786a    0x20a    ld a0,32(sp)          ; stack access
    0x8401786c    0x20c    ld a1,40(sp)          ; stack access
    0x8401786e    0x20e    jal ra,ffffffff84010474 <cap_endpoint_cap_get_capCanGrant>
    0x84017872    0x212    beqz a0,ffffffff84017830 <fastpath_call+0x1d0>
    0x84017874    0x214    ld a5,344(s0)
    0x84017878    0x218    bne a5,s7,ffffffff84017840 <fastpath_call+0x1e0>
    0x8401787c    0x21c    ld a5,408(s0)
    0x84017880    0x220    sd a5,8(s1)
    0x84017882    0x222    ld a5,408(s0)
    0x84017886    0x226    bnez a5,ffffffff84017846 <fastpath_call+0x1e6>
    0x84017888    0x228    sd zero,0(s1)
    0x8401788c    0x22c    ld a0,32(sp)          ; stack access
    0x8401788e    0x22e    ld a1,40(sp)          ; stack access
    0x84017890    0x230    jal ra,ffffffff84010446 <cap_endpoint_cap_get_capEPBadge>
    0x84017894    0x234    mv s1,a0
    0x84017896    0x236    auipc s9,0x17
    0x8401789a    0x23a    addi s9,s9,514 # ffffffff8402ea98 <ksCurThread>
    0x8401789e    0x23e    ld s10,0(s9)
    0x840178a2    0x242    li a5,5
    0x840178a4    0x244    sd a5,280(s10)
    0x840178a8    0x248    andi s7,s10,-1024
    0x840178ac    0x24c    addi s7,s7,64
    0x840178b0    0x250    addi s4,s8,96
    0x840178b4    0x254    addi a0,s0,280
    0x840178b8    0x258    jal ra,ffffffff84010316 <thread_state_ptr_get_blockingIPCCanGrant>
    0x840178bc    0x25c    sd s10,104(s8)
    0x840178c0    0x260    slli a0,a0,0x1
    0x840178c2    0x262    li a5,1
    0x840178c4    0x264    slli a5,a5,0x3e
    0x840178c6    0x266    or a0,a0,a5
    0x840178c8    0x268    sd a0,96(s8)
    0x840178cc    0x26c    sd s7,112(s8)
    0x840178d0    0x270    ori s4,s4,3
    0x840178d4    0x274    sd s4,24(s7)
    0x840178d8    0x278    ld a3,0(s9)
    0x840178dc    0x27c    beqz s5,ffffffff840178f6 <fastpath_call+0x296>
    0x840178e0    0x280    mv a5,a3
    0x840178e2    0x282    addi a4,s0,88
    0x840178e6    0x286    slli s5,s5,0x3
    0x840178e8    0x288    add s5,s5,a3
    0x840178ea    0x28a    ld a3,88(a5)
    0x840178ec    0x28c    sd a3,0(a4)
    0x840178ee    0x28e    addi a5,a5,8
    0x840178f0    0x290    addi a4,a4,8
    0x840178f2    0x292    bne a5,s5,ffffffff840178ea <fastpath_call+0x28a>
    0x840178f6    0x296    li a2,1
    0x840178f8    0x298    sd a2,280(s0)
    0x840178fc    0x29c    slli a2,a2,0x26
    0x840178fe    0x29e    add a2,a2,s2
    0x84017900    0x2a0    srli a2,a2,0xc
    0x84017902    0x2a2    mv a1,s6
    0x84017904    0x2a4    li a0,8
    0x84017906    0x2a6    jal ra,ffffffff840102f6 <satp_new>
    0x8401790a    0x2aa    csrw satp,a0
    0x8401790e    0x2ae    sfence.vma
    0x84017912    0x2b2    auipc a5,0x17
    0x84017916    0x2b6    sd s0,390(a5) # ffffffff8402ea98 <ksCurThread>
    0x8401791a    0x2ba    li a1,0
    0x8401791c    0x2bc    mv a0,s3
    0x8401791e    0x2be    jal ra,ffffffff8401011c <seL4_MessageInfo_set_capsUnwrapped>
    0x84017922    0x2c2    mv a1,a0
    0x84017924    0x2c4    mv a0,s1
    0x84017926    0x2c6    mv t0,s0
    0x84017928    0x2c8    ld ra,0(t0)
    0x8401792c    0x2cc    ld sp,8(t0)
    0x84017930    0x2d0    ld gp,16(t0)
    0x84017934    0x2d4    ld t2,48(t0)
    0x84017938    0x2d8    ld s0,56(t0)
    0x8401793c    0x2dc    ld s1,64(t0)
    0x84017940    0x2e0    ld a2,88(t0)
    0x84017944    0x2e4    ld a3,96(t0)
    0x84017948    0x2e8    ld a4,104(t0)
    0x8401794c    0x2ec    ld a5,112(t0)
    0x84017950    0x2f0    ld a6,120(t0)
    0x84017954    0x2f4    ld a7,128(t0)
    0x84017958    0x2f8    ld s2,136(t0)
    0x8401795c    0x2fc    ld s3,144(t0)
    0x84017960    0x300    ld s4,152(t0)
    0x84017964    0x304    ld s5,160(t0)
    0x84017968    0x308    ld s6,168(t0)
    0x8401796c    0x30c    ld s7,176(t0)
    0x84017970    0x310    ld s8,184(t0)
    0x84017974    0x314    ld s9,192(t0)
    0x84017978    0x318    ld s10,200(t0)
    0x8401797c    0x31c    ld s11,208(t0)
    0x84017980    0x320    ld t3,216(t0)
    0x84017984    0x324    ld t4,224(t0)
    0x84017988    0x328    ld t5,232(t0)
    0x8401798c    0x32c    ld t6,240(t0)
    0x84017990    0x330    ld t1,24(t0)
    0x84017994    0x334    add tp,t1,zero
    0x84017998    0x338    ld t1,272(t0)
    0x8401799c    0x33c    csrw sepc,t1
    0x840179a0    0x340    csrw sscratch,t0
    0x840179a4    0x344    ld t1,256(t0)
    0x840179a8    0x348    csrw sstatus,t1
    0x840179ac    0x34c    ld t1,40(t0)
    0x840179b0    0x350    ld t0,32(t0)
    0x840179b4    0x354    sret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
286 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `fastpath_call` has 489 nodes.

Section receiveIPC (428 of 432)
===============================

Deriving specifications
-----------------------

Section `receiveIPC` consists of 143 instructions.


Stack analysis
---------------

22 stack accesses found. Annotated code for `receiveIPC`:

    0x840150c4      0x0    addi sp,sp,-96
    0x840150c6      0x2    sd ra,88(sp)          ; stack access
    0x840150c8      0x4    sd s0,80(sp)          ; stack access
    0x840150ca      0x6    sd s1,72(sp)          ; stack access
    0x840150cc      0x8    sd s2,64(sp)          ; stack access
    0x840150ce      0xa    sd s3,56(sp)          ; stack access
    0x840150d0      0xc    sd s4,48(sp)          ; stack access
    0x840150d2      0xe    sd s5,40(sp)          ; stack access
    0x840150d4     0x10    sd s6,32(sp)          ; stack access
    0x840150d6     0x12    mv s3,a0
    0x840150d8     0x14    sd a1,0(sp)           ; stack access
    0x840150da     0x16    sd a2,8(sp)           ; stack access
    0x840150dc     0x18    mv s1,a3
    0x840150de     0x1a    mv a0,a1
    0x840150e0     0x1c    mv a1,a2
    0x840150e2     0x1e    jal ra,ffffffff840109fe <cap_endpoint_cap_get_capEPPtr>
    0x840150e6     0x22    mv s0,a0
    0x840150e8     0x24    ld s2,304(s3)
    0x840150ec     0x28    beqz s2,ffffffff840150fc <receiveIPC+0x38>
    0x840150f0     0x2c    mv a0,s2
    0x840150f2     0x2e    jal ra,ffffffff84010258 <notification_ptr_get_state>
    0x840150f6     0x32    li a5,2
    0x840150f8     0x34    beq a0,a5,ffffffff84015122 <receiveIPC+0x5e>
    0x840150fc     0x38    mv a0,s0
    0x840150fe     0x3a    jal ra,ffffffff84010178 <endpoint_ptr_get_state>
    0x84015102     0x3e    li a5,1
    0x84015104     0x40    beq a0,a5,ffffffff84015198 <receiveIPC+0xd4>
    0x84015108     0x44    andi a5,a0,-3
    0x8401510c     0x48    beqz a5,ffffffff8401512c <receiveIPC+0x68>
    0x8401510e     0x4a    ld ra,88(sp)          ; stack access
    0x84015110     0x4c    ld s0,80(sp)          ; stack access
    0x84015112     0x4e    ld s1,72(sp)          ; stack access
    0x84015114     0x50    ld s2,64(sp)          ; stack access
    0x84015116     0x52    ld s3,56(sp)          ; stack access
    0x84015118     0x54    ld s4,48(sp)          ; stack access
    0x8401511a     0x56    ld s5,40(sp)          ; stack access
    0x8401511c     0x58    ld s6,32(sp)          ; stack access
    0x8401511e     0x5a    addi sp,sp,96
    0x84015120     0x5c    ret
    0x84015122     0x5e    mv a1,s3
    0x84015124     0x60    mv a0,s2
    0x84015126     0x62    jal ra,ffffffff840124a6 <completeSignal>
    0x8401512a     0x66    j ffffffff8401510e <receiveIPC+0x4a>
    0x8401512c     0x68    beqz s1,ffffffff84015192 <receiveIPC+0xce>
    0x8401512e     0x6a    addi s1,s3,280
    0x84015132     0x6e    li a1,3
    0x84015134     0x70    mv a0,s1
    0x84015136     0x72    jal ra,ffffffff8401038e <thread_state_ptr_set_tsType>
    0x8401513a     0x76    mv a1,s0
    0x8401513c     0x78    mv a0,s1
    0x8401513e     0x7a    jal ra,ffffffff8401036a <thread_state_ptr_set_blockingObject>
    0x84015142     0x7e    ld a0,0(sp)           ; stack access
    0x84015144     0x80    ld a1,8(sp)           ; stack access
    0x84015146     0x82    jal ra,ffffffff84010474 <cap_endpoint_cap_get_capCanGrant>
    0x8401514a     0x86    mv a1,a0
    0x8401514c     0x88    mv a0,s1
    0x8401514e     0x8a    jal ra,ffffffff8401031e <thread_state_ptr_set_blockingIPCCanGrant>
    0x84015152     0x8e    mv a0,s3
    0x84015154     0x90    jal ra,ffffffff84012fda <scheduleTCB>
    0x84015158     0x94    mv a0,s0
    0x8401515a     0x96    jal ra,ffffffff84010158 <endpoint_ptr_get_epQueue_head>
    0x8401515e     0x9a    mv s1,a0
    0x84015160     0x9c    mv a0,s0
    0x84015162     0x9e    jal ra,ffffffff84010aee <endpoint_ptr_get_epQueue_tail>
    0x84015166     0xa2    mv s2,s3
    0x84015168     0xa4    beqz s1,ffffffff84015170 <receiveIPC+0xac>
    0x8401516a     0xa6    mv s2,s1
    0x8401516c     0xa8    sd s3,408(a0)
    0x84015170     0xac    sd a0,416(s3)
    0x84015174     0xb0    sd zero,408(s3)
    0x84015178     0xb4    li a1,2
    0x8401517a     0xb6    mv a0,s0
    0x8401517c     0xb8    jal ra,ffffffff8401017e <endpoint_ptr_set_state>
    0x84015180     0xbc    mv a1,s2
    0x84015182     0xbe    mv a0,s0
    0x84015184     0xc0    jal ra,ffffffff8401015c <endpoint_ptr_set_epQueue_head>
    0x84015188     0xc4    mv a1,s3
    0x8401518a     0xc6    mv a0,s0
    0x8401518c     0xc8    jal ra,ffffffff84010160 <endpoint_ptr_set_epQueue_tail>
    0x84015190     0xcc    j ffffffff8401510e <receiveIPC+0x4a>
    0x84015192     0xce    sd zero,72(s3)
    0x84015196     0xd2    j ffffffff8401510e <receiveIPC+0x4a>
    0x84015198     0xd4    mv a0,s0
    0x8401519a     0xd6    jal ra,ffffffff84010158 <endpoint_ptr_get_epQueue_head>
    0x8401519e     0xda    mv s1,a0
    0x840151a0     0xdc    mv a0,s0
    0x840151a2     0xde    jal ra,ffffffff84010aee <endpoint_ptr_get_epQueue_tail>
    0x840151a6     0xe2    mv a2,a0
    0x840151a8     0xe4    mv a1,s1
    0x840151aa     0xe6    mv a0,s1
    0x840151ac     0xe8    jal ra,ffffffff840138b6 <tcbEPDequeue>
    0x840151b0     0xec    mv s2,a0
    0x840151b2     0xee    mv s4,a1
    0x840151b4     0xf0    mv a1,a0
    0x840151b6     0xf2    mv a0,s0
    0x840151b8     0xf4    jal ra,ffffffff8401015c <endpoint_ptr_set_epQueue_head>
    0x840151bc     0xf8    mv a1,s4
    0x840151be     0xfa    mv a0,s0
    0x840151c0     0xfc    jal ra,ffffffff84010160 <endpoint_ptr_set_epQueue_tail>
    0x840151c4    0x100    beqz s2,ffffffff84015216 <receiveIPC+0x152>
    0x840151c8    0x104    addi s4,s1,280
    0x840151cc    0x108    mv a0,s4
    0x840151ce    0x10a    jal ra,ffffffff8401030e <thread_state_ptr_get_blockingIPCBadge>
    0x840151d2    0x10e    mv s5,a0
    0x840151d4    0x110    mv a0,s4
    0x840151d6    0x112    jal ra,ffffffff84010316 <thread_state_ptr_get_blockingIPCCanGrant>
    0x840151da    0x116    mv s2,a0
    0x840151dc    0x118    mv a0,s4
    0x840151de    0x11a    jal ra,ffffffff8401032c <thread_state_ptr_get_blockingIPCCanGrantReply>
    0x840151e2    0x11e    mv s6,a0
    0x840151e4    0x120    mv a4,s3
    0x840151e6    0x122    mv a3,s2
    0x840151e8    0x124    mv a2,s5
    0x840151ea    0x126    mv a1,s0
    0x840151ec    0x128    mv a0,s1
    0x840151ee    0x12a    jal ra,ffffffff84014bf0 <doIPCTransfer>
    0x840151f2    0x12e    mv a0,s4
    0x840151f4    0x130    jal ra,ffffffff84010342 <thread_state_ptr_get_blockingIPCIsCall>
    0x840151f8    0x134    beqz a0,ffffffff8401522a <receiveIPC+0x166>
    0x840151fa    0x136    or s2,s2,s6
    0x840151fe    0x13a    beqz s2,ffffffff84015220 <receiveIPC+0x15c>
    0x84015202    0x13e    ld a0,0(sp)           ; stack access
    0x84015204    0x140    ld a1,8(sp)           ; stack access
    0x84015206    0x142    jal ra,ffffffff84010474 <cap_endpoint_cap_get_capCanGrant>
    0x8401520a    0x146    mv a2,a0
    0x8401520c    0x148    mv a1,s3
    0x8401520e    0x14a    mv a0,s1
    0x84015210    0x14c    jal ra,ffffffff84014912 <setupCallerCap>
    0x84015214    0x150    j ffffffff8401510e <receiveIPC+0x4a>
    0x84015216    0x152    li a1,0
    0x84015218    0x154    mv a0,s0
    0x8401521a    0x156    jal ra,ffffffff8401017e <endpoint_ptr_set_state>
    0x8401521e    0x15a    j ffffffff840151c8 <receiveIPC+0x104>
    0x84015220    0x15c    li a1,0
    0x84015222    0x15e    mv a0,s1
    0x84015224    0x160    jal ra,ffffffff84013020 <setThreadState>
    0x84015228    0x164    j ffffffff8401510e <receiveIPC+0x4a>
    0x8401522a    0x166    li a1,1
    0x8401522c    0x168    mv a0,s1
    0x8401522e    0x16a    jal ra,ffffffff84013020 <setThreadState>
    0x84015232    0x16e    mv a0,s1
    0x84015234    0x170    jal ra,ffffffff840132c6 <possibleSwitchTo>
    0x84015238    0x174    j ffffffff8401510e <receiveIPC+0x4a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
143 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `receiveIPC` has 219 nodes.

Section fastpath_reply_recv (429 of 432)
========================================

Deriving specifications
-----------------------

Section `fastpath_reply_recv` consists of 312 instructions.

Skipping 18051073 csrw satp,a0

Skipping 12000073 sfence.vma

Skipping 14131073 csrw sepc,t1

Skipping 14029073 csrw sscratch,t0

Skipping 10031073 csrw sstatus,t1

Skipping 10200073 sret


Stack analysis
---------------

58 stack accesses found. Annotated code for `fastpath_reply_recv`:

    0x840179b8      0x0    addi sp,sp,-176
    0x840179ba      0x2    sd ra,168(sp)         ; stack access
    0x840179bc      0x4    sd s0,160(sp)         ; stack access
    0x840179be      0x6    sd s1,152(sp)         ; stack access
    0x840179c0      0x8    sd s2,144(sp)         ; stack access
    0x840179c2      0xa    sd s3,136(sp)         ; stack access
    0x840179c4      0xc    sd s4,128(sp)         ; stack access
    0x840179c6      0xe    sd s5,120(sp)         ; stack access
    0x840179c8     0x10    sd s6,112(sp)         ; stack access
    0x840179ca     0x12    sd s7,104(sp)         ; stack access
    0x840179cc     0x14    sd s8,96(sp)          ; stack access
    0x840179ce     0x16    sd s9,88(sp)          ; stack access
    0x840179d0     0x18    sd s10,80(sp)         ; stack access
    0x840179d2     0x1a    mv s7,a0
    0x840179d4     0x1c    mv s3,a1
    0x840179d6     0x1e    auipc s2,0x17
    0x840179da     0x22    ld s2,194(s2) # ffffffff8402ea98 <ksCurThread>
    0x840179de     0x26    ld a0,312(s2)
    0x840179e2     0x2a    ld a1,320(s2)
    0x840179e6     0x2e    jal ra,ffffffff8401084a <seL4_Fault_get_seL4_FaultType>
    0x840179ea     0x32    andi a4,s3,511
    0x840179ee     0x36    li a5,4
    0x840179f0     0x38    bltu a5,a4,ffffffff84017b30 <fastpath_reply_recv+0x178>
    0x840179f4     0x3c    mv s1,a0
    0x840179f6     0x3e    bnez a0,ffffffff84017b30 <fastpath_reply_recv+0x178>
    0x840179fa     0x42    mv a0,s3
    0x840179fc     0x44    jal ra,ffffffff84010146 <seL4_MessageInfo_get_length>
    0x84017a00     0x48    mv s8,a0
    0x84017a02     0x4a    andi s6,s2,-1024
    0x84017a06     0x4e    ld a0,0(s6)
    0x84017a0a     0x52    sd a0,0(sp)           ; stack access
    0x84017a0c     0x54    ld a1,8(s6)
    0x84017a10     0x58    sd a1,8(sp)           ; stack access
    0x84017a12     0x5a    li a2,10
    0x84017a14     0x5c    jal ra,ffffffff840103a6 <cap_capType_equals>
    0x84017a18     0x60    li s9,64
    0x84017a1c     0x64    li s10,63
    0x84017a20     0x68    beqz a0,ffffffff84017b36 <fastpath_reply_recv+0x17e>
    0x84017a24     0x6c    ld a0,0(sp)           ; stack access
    0x84017a26     0x6e    ld a1,8(sp)           ; stack access
    0x84017a28     0x70    jal ra,ffffffff840105ae <cap_cnode_cap_get_capCNodeGuardSize>
    0x84017a2c     0x74    mv s4,a0
    0x84017a2e     0x76    ld a0,0(sp)           ; stack access
    0x84017a30     0x78    ld a1,8(sp)           ; stack access
    0x84017a32     0x7a    jal ra,ffffffff840105d2 <cap_cnode_cap_get_capCNodeRadix>
    0x84017a36     0x7e    mv s5,a0
    0x84017a38     0x80    sll s0,s7,s1
    0x84017a3c     0x84    ld a0,0(sp)           ; stack access
    0x84017a3e     0x86    ld a1,8(sp)           ; stack access
    0x84017a40     0x88    jal ra,ffffffff8401059e <cap_cnode_cap_get_capCNodeGuard>
    0x84017a44     0x8c    beqz s4,ffffffff84017a54 <fastpath_reply_recv+0x9c>
    0x84017a48     0x90    subw a5,s9,s4
    0x84017a4c     0x94    srl a5,s0,a5
    0x84017a50     0x98    bne a0,a5,ffffffff84017b40 <fastpath_reply_recv+0x188>
    0x84017a54     0x9c    ld a0,0(sp)           ; stack access
    0x84017a56     0x9e    ld a1,8(sp)           ; stack access
    0x84017a58     0xa0    jal ra,ffffffff84010a1c <cap_cnode_cap_get_capCNodePtr>
    0x84017a5c     0xa4    sll a5,s0,s4
    0x84017a60     0xa8    subw s0,s9,s5
    0x84017a64     0xac    srl a5,a5,s0
    0x84017a68     0xb0    slli a5,a5,0x5
    0x84017a6a     0xb2    add a5,a5,a0
    0x84017a6c     0xb4    ld a4,0(a5)
    0x84017a6e     0xb6    sd a4,0(sp)           ; stack access
    0x84017a70     0xb8    ld a5,8(a5)
    0x84017a72     0xba    sd a5,8(sp)           ; stack access
    0x84017a74     0xbc    add s4,s4,s5
    0x84017a76     0xbe    add s1,s1,s4
    0x84017a78     0xc0    bgeu s10,s1,ffffffff84017b4a <fastpath_reply_recv+0x192>
    0x84017a7c     0xc4    li a5,64
    0x84017a80     0xc8    bltu a5,s1,ffffffff84017b5a <fastpath_reply_recv+0x1a2>
    0x84017a84     0xcc    ld a5,0(sp)           ; stack access
    0x84017a86     0xce    sd a5,64(sp)          ; stack access
    0x84017a88     0xd0    ld a5,8(sp)           ; stack access
    0x84017a8a     0xd2    sd a5,72(sp)          ; stack access
    0x84017a8c     0xd4    ld a0,64(sp)          ; stack access
    0x84017a8e     0xd6    sd a0,48(sp)          ; stack access
    0x84017a90     0xd8    ld a1,72(sp)          ; stack access
    0x84017a92     0xda    sd a1,56(sp)          ; stack access
    0x84017a94     0xdc    li a2,4
    0x84017a96     0xde    jal ra,ffffffff840103a6 <cap_capType_equals>
    0x84017a9a     0xe2    beqz a0,ffffffff84017b64 <fastpath_reply_recv+0x1ac>
    0x84017a9e     0xe6    ld a0,48(sp)          ; stack access
    0x84017aa0     0xe8    ld a1,56(sp)          ; stack access
    0x84017aa2     0xea    jal ra,ffffffff84010492 <cap_endpoint_cap_get_capCanReceive>
    0x84017aa6     0xee    beqz a0,ffffffff84017b64 <fastpath_reply_recv+0x1ac>
    0x84017aa8     0xf0    ld a0,304(s2)
    0x84017aac     0xf4    bnez a0,ffffffff84017b6a <fastpath_reply_recv+0x1b2>
    0x84017aae     0xf6    ld a0,48(sp)          ; stack access
    0x84017ab0     0xf8    ld a1,56(sp)          ; stack access
    0x84017ab2     0xfa    jal ra,ffffffff840109fe <cap_endpoint_cap_get_capEPPtr>
    0x84017ab6     0xfe    mv s5,a0
    0x84017ab8    0x100    jal ra,ffffffff84010178 <endpoint_ptr_get_state>
    0x84017abc    0x104    li a5,1
    0x84017abe    0x106    beq a0,a5,ffffffff84017b7a <fastpath_reply_recv+0x1c2>
    0x84017ac2    0x10a    addi s7,s6,96
    0x84017ac6    0x10e    ld a0,96(s6)
    0x84017aca    0x112    sd a0,16(sp)          ; stack access
    0x84017acc    0x114    ld a1,8(s7)
    0x84017ad0    0x118    sd a1,24(sp)          ; stack access
    0x84017ad2    0x11a    sd a0,0(sp)           ; stack access
    0x84017ad4    0x11c    sd a1,8(sp)           ; stack access
    0x84017ad6    0x11e    li a2,8
    0x84017ad8    0x120    jal ra,ffffffff840103a6 <cap_capType_equals>
    0x84017adc    0x124    beqz a0,ffffffff84017b80 <fastpath_reply_recv+0x1c8>
    0x84017ade    0x126    ld a0,16(sp)          ; stack access
    0x84017ae0    0x128    ld a1,24(sp)          ; stack access
    0x84017ae2    0x12a    jal ra,ffffffff84010554 <cap_reply_cap_get_capTCBPtr>
    0x84017ae6    0x12e    mv s0,a0
    0x84017ae8    0x130    ld a0,312(a0)
    0x84017aec    0x134    ld a1,320(s0)
    0x84017af0    0x138    jal ra,ffffffff8401084a <seL4_Fault_get_seL4_FaultType>
    0x84017af4    0x13c    bnez a0,ffffffff84017b86 <fastpath_reply_recv+0x1ce>
    0x84017af6    0x13e    andi a5,s0,-1024
    0x84017afa    0x142    ld s9,32(a5)
    0x84017afe    0x146    sd s9,32(sp)          ; stack access
    0x84017b00    0x148    ld s4,40(a5)
    0x84017b04    0x14c    sd s4,40(sp)          ; stack access
    0x84017b06    0x14e    mv a0,s9
    0x84017b08    0x150    mv a1,s4
    0x84017b0a    0x152    jal ra,ffffffff84010a76 <cap_page_table_cap_get_capPTBasePtr>
    0x84017b0e    0x156    mv s1,a0
    0x84017b10    0x158    sd s9,0(sp)           ; stack access
    0x84017b12    0x15a    sd s4,8(sp)           ; stack access
    0x84017b14    0x15c    li a2,3
    0x84017b16    0x15e    mv a0,s9
    0x84017b18    0x160    mv a1,s4
    0x84017b1a    0x162    jal ra,ffffffff840103a6 <cap_capType_equals>
    0x84017b1e    0x166    beqz a0,ffffffff84017b2a <fastpath_reply_recv+0x172>
    0x84017b20    0x168    ld a0,0(sp)           ; stack access
    0x84017b22    0x16a    ld a1,8(sp)           ; stack access
    0x84017b24    0x16c    jal ra,ffffffff8401072c <cap_page_table_cap_get_capPTIsMapped>
    0x84017b28    0x170    bnez a0,ffffffff84017bb6 <fastpath_reply_recv+0x1fe>
    0x84017b2a    0x172    li a0,-2
    0x84017b2c    0x174    jal ra,ffffffff84017648 <slowpath>
    0x84017b30    0x178    li a0,-2
    0x84017b32    0x17a    jal ra,ffffffff84017648 <slowpath>
    0x84017b36    0x17e    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84017b3a    0x182    sd a0,64(sp)          ; stack access
    0x84017b3c    0x184    sd a1,72(sp)          ; stack access
    0x84017b3e    0x186    j ffffffff84017a8c <fastpath_reply_recv+0xd4>
    0x84017b40    0x188    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84017b44    0x18c    sd a0,64(sp)          ; stack access
    0x84017b46    0x18e    sd a1,72(sp)          ; stack access
    0x84017b48    0x190    j ffffffff84017a8c <fastpath_reply_recv+0xd4>
    0x84017b4a    0x192    li a2,10
    0x84017b4c    0x194    mv a0,a4
    0x84017b4e    0x196    mv a1,a5
    0x84017b50    0x198    jal ra,ffffffff840103a6 <cap_capType_equals>
    0x84017b54    0x19c    beqz a0,ffffffff84017a84 <fastpath_reply_recv+0xcc>
    0x84017b58    0x1a0    j ffffffff84017a24 <fastpath_reply_recv+0x6c>
    0x84017b5a    0x1a2    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84017b5e    0x1a6    sd a0,64(sp)          ; stack access
    0x84017b60    0x1a8    sd a1,72(sp)          ; stack access
    0x84017b62    0x1aa    j ffffffff84017a8c <fastpath_reply_recv+0xd4>
    0x84017b64    0x1ac    li a0,-2
    0x84017b66    0x1ae    jal ra,ffffffff84017648 <slowpath>
    0x84017b6a    0x1b2    jal ra,ffffffff84010258 <notification_ptr_get_state>
    0x84017b6e    0x1b6    li a5,2
    0x84017b70    0x1b8    bne a0,a5,ffffffff84017aae <fastpath_reply_recv+0xf6>
    0x84017b74    0x1bc    li a0,-2
    0x84017b76    0x1be    jal ra,ffffffff84017648 <slowpath>
    0x84017b7a    0x1c2    li a0,-2
    0x84017b7c    0x1c4    jal ra,ffffffff84017648 <slowpath>
    0x84017b80    0x1c8    li a0,-2
    0x84017b82    0x1ca    jal ra,ffffffff84017648 <slowpath>
    0x84017b86    0x1ce    li a0,-2
    0x84017b88    0x1d0    jal ra,ffffffff84017648 <slowpath>
    0x84017b8c    0x1d4    li a0,-2
    0x84017b8e    0x1d6    jal ra,ffffffff84017648 <slowpath>
    0x84017b92    0x1da    li a0,-2
    0x84017b94    0x1dc    jal ra,ffffffff84017648 <slowpath>
    0x84017b98    0x1e0    auipc a5,0x17
    0x84017b9c    0x1e4    ld a5,-256(a5) # ffffffff8402ea98 <ksCurThread>
    0x84017ba0    0x1e8    sd a5,408(a0)
    0x84017ba4    0x1ec    sd a0,416(a5)
    0x84017ba8    0x1f0    sd zero,408(a5)
    0x84017bac    0x1f4    ori a5,a5,2
    0x84017bb0    0x1f8    sd a5,0(s5)
    0x84017bb4    0x1fc    j ffffffff84017c5e <fastpath_reply_recv+0x2a6>
    0x84017bb6    0x1fe    auipc s9,0x17
    0x84017bba    0x202    ld s9,-950(s9) # ffffffff8402e800 <ksCurDomain>
    0x84017bbe    0x206    slli a4,s9,0x3
    0x84017bc2    0x20a    auipc a5,0x17
    0x84017bc6    0x20e    addi a5,a5,-426 # ffffffff8402ea18 <ksReadyQueuesL1Bitmap>
    0x84017bca    0x212    add a5,a5,a4
    0x84017bcc    0x214    ld a0,0(a5)
    0x84017bce    0x216    beqz a0,ffffffff84017c0e <fastpath_reply_recv+0x256>
    0x84017bd0    0x218    jal ra,ffffffff84017f02 <__clzdi2>
    0x84017bd4    0x21c    sext.w s4,a0
    0x84017bd8    0x220    slli a5,s9,0x2
    0x84017bdc    0x224    addi a4,s4,-60
    0x84017be0    0x228    add a5,a5,a4
    0x84017be2    0x22a    slli a5,a5,0x3
    0x84017be4    0x22c    auipc a4,0x17
    0x84017be8    0x230    addi a4,a4,-980 # ffffffff8402e810 <ksReadyQueuesL2Bitmap>
    0x84017bec    0x234    add a5,a5,a4
    0x84017bee    0x236    ld a0,0(a5)
    0x84017bf0    0x238    jal ra,ffffffff84017f02 <__clzdi2>
    0x84017bf4    0x23c    sext.w a0,a0
    0x84017bf6    0x23e    li a5,63
    0x84017bfa    0x242    sub s4,a5,s4
    0x84017bfe    0x246    slli s4,s4,0x6
    0x84017c00    0x248    sub a5,a5,a0
    0x84017c02    0x24a    or s4,s4,a5
    0x84017c06    0x24e    ld a5,360(s0)
    0x84017c0a    0x252    bltu a5,s4,ffffffff84017b8c <fastpath_reply_recv+0x1d4>
    0x84017c0e    0x256    ld a5,344(s0)
    0x84017c12    0x25a    bne a5,s9,ffffffff84017b92 <fastpath_reply_recv+0x1da>
    0x84017c16    0x25e    ld a0,32(sp)          ; stack access
    0x84017c18    0x260    ld a1,40(sp)          ; stack access
    0x84017c1a    0x262    jal ra,ffffffff84010714 <cap_page_table_cap_get_capPTMappedASID>
    0x84017c1e    0x266    mv s4,a0
    0x84017c20    0x268    ori a5,s5,3
    0x84017c24    0x26c    sd a5,280(s2)
    0x84017c28    0x270    ld a0,48(sp)          ; stack access
    0x84017c2a    0x272    ld a1,56(sp)          ; stack access
    0x84017c2c    0x274    jal ra,ffffffff84010474 <cap_endpoint_cap_get_capCanGrant>
    0x84017c30    0x278    mv a1,a0
    0x84017c32    0x27a    addi a0,s2,280
    0x84017c36    0x27e    jal ra,ffffffff8401031e <thread_state_ptr_set_blockingIPCCanGrant>
    0x84017c3a    0x282    mv a0,s5
    0x84017c3c    0x284    jal ra,ffffffff84010aee <endpoint_ptr_get_epQueue_tail>
    0x84017c40    0x288    bnez a0,ffffffff84017b98 <fastpath_reply_recv+0x1e0>
    0x84017c42    0x28a    auipc a5,0x17
    0x84017c46    0x28e    ld a5,-426(a5) # ffffffff8402ea98 <ksCurThread>
    0x84017c4a    0x292    sd zero,416(a5)
    0x84017c4e    0x296    sd zero,408(a5)
    0x84017c52    0x29a    sd a5,8(s5)
    0x84017c56    0x29e    ori a5,a5,2
    0x84017c5a    0x2a2    sd a5,0(s5)
    0x84017c5e    0x2a6    ld a0,16(s7)
    0x84017c62    0x2aa    ld a1,24(s7)
    0x84017c66    0x2ae    jal ra,ffffffff84010208 <mdb_node_get_mdbPrev>
    0x84017c6a    0x2b2    li a5,3
    0x84017c6c    0x2b4    sd a5,24(a0)
    0x84017c6e    0x2b6    jal ra,ffffffff840103b4 <cap_null_cap_new>
    0x84017c72    0x2ba    sd a0,96(s6)
    0x84017c76    0x2be    sd a1,8(s7)
    0x84017c7a    0x2c2    li a3,0
    0x84017c7c    0x2c4    li a2,0
    0x84017c7e    0x2c6    li a1,0
    0x84017c80    0x2c8    li a0,0
    0x84017c82    0x2ca    jal ra,ffffffff8401018a <mdb_node_new>
    0x84017c86    0x2ce    sd a0,16(s7)
    0x84017c8a    0x2d2    sd a1,24(s7)
    0x84017c8e    0x2d6    auipc a3,0x17
    0x84017c92    0x2da    ld a3,-502(a3) # ffffffff8402ea98 <ksCurThread>
    0x84017c96    0x2de    beqz s8,ffffffff84017cb0 <fastpath_reply_recv+0x2f8>
    0x84017c9a    0x2e2    mv a5,a3
    0x84017c9c    0x2e4    addi a4,s0,88
    0x84017ca0    0x2e8    slli s8,s8,0x3
    0x84017ca2    0x2ea    add s8,s8,a3
    0x84017ca4    0x2ec    ld a3,88(a5)
    0x84017ca6    0x2ee    sd a3,0(a4)
    0x84017ca8    0x2f0    addi a5,a5,8
    0x84017caa    0x2f2    addi a4,a4,8
    0x84017cac    0x2f4    bne a5,s8,ffffffff84017ca4 <fastpath_reply_recv+0x2ec>
    0x84017cb0    0x2f8    li a2,1
    0x84017cb2    0x2fa    sd a2,280(s0)
    0x84017cb6    0x2fe    slli a2,a2,0x26
    0x84017cb8    0x300    add a2,a2,s1
    0x84017cba    0x302    srli a2,a2,0xc
    0x84017cbc    0x304    mv a1,s4
    0x84017cbe    0x306    li a0,8
    0x84017cc0    0x308    jal ra,ffffffff840102f6 <satp_new>
    0x84017cc4    0x30c    csrw satp,a0
    0x84017cc8    0x310    sfence.vma
    0x84017ccc    0x314    auipc a5,0x17
    0x84017cd0    0x318    sd s0,-564(a5) # ffffffff8402ea98 <ksCurThread>
    0x84017cd4    0x31c    li a1,0
    0x84017cd6    0x31e    mv a0,s3
    0x84017cd8    0x320    jal ra,ffffffff8401011c <seL4_MessageInfo_set_capsUnwrapped>
    0x84017cdc    0x324    mv a1,a0
    0x84017cde    0x326    li a0,0
    0x84017ce0    0x328    mv t0,s0
    0x84017ce2    0x32a    ld ra,0(t0)
    0x84017ce6    0x32e    ld sp,8(t0)
    0x84017cea    0x332    ld gp,16(t0)
    0x84017cee    0x336    ld t2,48(t0)
    0x84017cf2    0x33a    ld s0,56(t0)
    0x84017cf6    0x33e    ld s1,64(t0)
    0x84017cfa    0x342    ld a2,88(t0)
    0x84017cfe    0x346    ld a3,96(t0)
    0x84017d02    0x34a    ld a4,104(t0)
    0x84017d06    0x34e    ld a5,112(t0)
    0x84017d0a    0x352    ld a6,120(t0)
    0x84017d0e    0x356    ld a7,128(t0)
    0x84017d12    0x35a    ld s2,136(t0)
    0x84017d16    0x35e    ld s3,144(t0)
    0x84017d1a    0x362    ld s4,152(t0)
    0x84017d1e    0x366    ld s5,160(t0)
    0x84017d22    0x36a    ld s6,168(t0)
    0x84017d26    0x36e    ld s7,176(t0)
    0x84017d2a    0x372    ld s8,184(t0)
    0x84017d2e    0x376    ld s9,192(t0)
    0x84017d32    0x37a    ld s10,200(t0)
    0x84017d36    0x37e    ld s11,208(t0)
    0x84017d3a    0x382    ld t3,216(t0)
    0x84017d3e    0x386    ld t4,224(t0)
    0x84017d42    0x38a    ld t5,232(t0)
    0x84017d46    0x38e    ld t6,240(t0)
    0x84017d4a    0x392    ld t1,24(t0)
    0x84017d4e    0x396    add tp,t1,zero
    0x84017d52    0x39a    ld t1,272(t0)
    0x84017d56    0x39e    csrw sepc,t1
    0x84017d5a    0x3a2    csrw sscratch,t0
    0x84017d5e    0x3a6    ld t1,256(t0)
    0x84017d62    0x3aa    csrw sstatus,t1
    0x84017d66    0x3ae    ld t1,40(t0)
    0x84017d6a    0x3b2    ld t0,32(t0)
    0x84017d6e    0x3b6    sret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
312 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `fastpath_reply_recv` has 537 nodes.

Section decodeInvocation (430 of 432)
=====================================

Deriving specifications
-----------------------

Section `decodeInvocation` consists of 211 instructions.


Stack analysis
---------------

23 stack accesses found. Annotated code for `decodeInvocation`:

    0x840171b4      0x0    addi sp,sp,-96
    0x840171b6      0x2    sd ra,88(sp)          ; stack access
    0x840171b8      0x4    sd s0,80(sp)          ; stack access
    0x840171ba      0x6    sd s1,72(sp)          ; stack access
    0x840171bc      0x8    sd s2,64(sp)          ; stack access
    0x840171be      0xa    sd s3,56(sp)          ; stack access
    0x840171c0      0xc    sd s4,48(sp)          ; stack access
    0x840171c2      0xe    sd s5,40(sp)          ; stack access
    0x840171c4     0x10    sd s6,32(sp)          ; stack access
    0x840171c6     0x12    mv s1,a0
    0x840171c8     0x14    mv s2,a1
    0x840171ca     0x16    mv s5,a2
    0x840171cc     0x18    mv s3,a3
    0x840171ce     0x1a    sd a4,0(sp)           ; stack access
    0x840171d0     0x1c    sd a5,8(sp)           ; stack access
    0x840171d2     0x1e    mv s6,a6
    0x840171d4     0x20    mv s4,a7
    0x840171d6     0x22    mv a0,a4
    0x840171d8     0x24    mv a1,a5
    0x840171da     0x26    jal ra,ffffffff8401039e <cap_get_capType>
    0x840171de     0x2a    andi s0,a0,1
    0x840171e2     0x2e    bnez s0,ffffffff84017206 <decodeInvocation+0x52>
    0x840171e4     0x30    ld a0,0(sp)           ; stack access
    0x840171e6     0x32    ld a1,8(sp)           ; stack access
    0x840171e8     0x34    jal ra,ffffffff8401039e <cap_get_capType>
    0x840171ec     0x38    li a5,20
    0x840171ee     0x3a    bltu a5,a0,ffffffff840173c2 <decodeInvocation+0x20e>
    0x840171f2     0x3e    slli a5,a0,0x2
    0x840171f6     0x42    auipc a4,0x1
    0x840171fa     0x46    addi a4,a4,102 # ffffffff8401825c <ksDomScheduleLength+0x314>
    0x840171fe     0x4a    add a5,a5,a4
    0x84017200     0x4c    lw a5,0(a5)
    0x84017202     0x4e    add a5,a5,a4
    0x84017204     0x50    jr a5
    0x84017206     0x52    ld a6,96(sp)          ; stack access
    0x84017208     0x54    ld a4,0(sp)           ; stack access
    0x8401720a     0x56    ld a5,8(sp)           ; stack access
    0x8401720c     0x58    mv a3,s3
    0x8401720e     0x5a    mv a2,s5
    0x84017210     0x5c    mv a1,s2
    0x84017212     0x5e    mv a0,s1
    0x84017214     0x60    jal ra,ffffffff8401654a <decodeRISCVMMUInvocation>
    0x84017218     0x64    mv s0,a0
    0x8401721a     0x66    mv a0,s0
    0x8401721c     0x68    ld ra,88(sp)          ; stack access
    0x8401721e     0x6a    ld s0,80(sp)          ; stack access
    0x84017220     0x6c    ld s1,72(sp)          ; stack access
    0x84017222     0x6e    ld s2,64(sp)          ; stack access
    0x84017224     0x70    ld s3,56(sp)          ; stack access
    0x84017226     0x72    ld s4,48(sp)          ; stack access
    0x84017228     0x74    ld s5,40(sp)          ; stack access
    0x8401722a     0x76    ld s6,32(sp)          ; stack access
    0x8401722c     0x78    addi sp,sp,96
    0x8401722e     0x7a    ret
    0x84017230     0x7c    auipc a5,0x7
    0x84017234     0x80    addi a5,a5,-1512 # ffffffff8401dc48 <current_syscall_error>
    0x84017238     0x84    li a4,2
    0x8401723a     0x86    sd a4,48(a5)
    0x8401723c     0x88    sd zero,8(a5)
    0x84017240     0x8c    li s0,3
    0x84017242     0x8e    j ffffffff8401721a <decodeInvocation+0x66>
    0x84017244     0x90    auipc a5,0x7
    0x84017248     0x94    addi a5,a5,-1532 # ffffffff8401dc48 <current_syscall_error>
    0x8401724c     0x98    li a4,2
    0x8401724e     0x9a    sd a4,48(a5)
    0x84017250     0x9c    sd zero,8(a5)
    0x84017254     0xa0    li s0,3
    0x84017256     0xa2    j ffffffff8401721a <decodeInvocation+0x66>
    0x84017258     0xa4    ld a0,0(sp)
    0x8401725a     0xa6    ld a1,8(sp)
    0x8401725c     0xa8    jal ra,ffffffff840104b0 <cap_endpoint_cap_get_capCanSend>
    0x84017260     0xac    beqz a0,ffffffff840172aa <decodeInvocation+0xf6>
    0x84017262     0xae    li a1,2
    0x84017264     0xb0    auipc a0,0x18
    0x84017268     0xb4    ld a0,-1996(a0) # ffffffff8402ea98 <ksCurThread>
    0x8401726c     0xb8    jal ra,ffffffff84013020 <setThreadState>
    0x84017270     0xbc    ld a0,0(sp)
    0x84017272     0xbe    ld a1,8(sp)
    0x84017274     0xc0    jal ra,ffffffff840109fe <cap_endpoint_cap_get_capEPPtr>
    0x84017278     0xc4    mv s0,a0
    0x8401727a     0xc6    ld a0,0(sp)
    0x8401727c     0xc8    ld a1,8(sp)
    0x8401727e     0xca    jal ra,ffffffff84010446 <cap_endpoint_cap_get_capEPBadge>
    0x84017282     0xce    mv s1,a0
    0x84017284     0xd0    ld a0,0(sp)
    0x84017286     0xd2    ld a1,8(sp)
    0x84017288     0xd4    jal ra,ffffffff84010474 <cap_endpoint_cap_get_capCanGrant>
    0x8401728c     0xd8    mv s2,a0
    0x8401728e     0xda    ld a0,0(sp)
    0x84017290     0xdc    ld a1,8(sp)
    0x84017292     0xde    jal ra,ffffffff84010456 <cap_endpoint_cap_get_capCanGrantReply>
    0x84017296     0xe2    mv a3,a0
    0x84017298     0xe4    mv a5,s4
    0x8401729a     0xe6    mv a4,s6
    0x8401729c     0xe8    mv a2,s2
    0x8401729e     0xea    mv a1,s1
    0x840172a0     0xec    mv a0,s0
    0x840172a2     0xee    jal ra,ffffffff8401509e <performInvocation_Endpoint>
    0x840172a6     0xf2    mv s0,a0
    0x840172a8     0xf4    j ffffffff8401721a <decodeInvocation+0x66>
    0x840172aa     0xf6    auipc a5,0x7
    0x840172ae     0xfa    addi a5,a5,-1634 # ffffffff8401dc48 <current_syscall_error>
    0x840172b2     0xfe    li a4,2
    0x840172b4    0x100    sd a4,48(a5)
    0x840172b6    0x102    sd zero,8(a5)
    0x840172ba    0x106    li s0,3
    0x840172bc    0x108    j ffffffff8401721a <decodeInvocation+0x66>
    0x840172be    0x10a    ld a0,0(sp)
    0x840172c0    0x10c    ld a1,8(sp)
    0x840172c2    0x10e    jal ra,ffffffff8401051e <cap_notification_cap_get_capNtfnCanSend>
    0x840172c6    0x112    beqz a0,ffffffff840172f2 <decodeInvocation+0x13e>
    0x840172c8    0x114    li a1,2
    0x840172ca    0x116    auipc a0,0x17
    0x840172ce    0x11a    ld a0,1998(a0) # ffffffff8402ea98 <ksCurThread>
    0x840172d2    0x11e    jal ra,ffffffff84013020 <setThreadState>
    0x840172d6    0x122    ld a0,0(sp)
    0x840172d8    0x124    ld a1,8(sp)
    0x840172da    0x126    jal ra,ffffffff840109aa <cap_notification_cap_get_capNtfnPtr>
    0x840172de    0x12a    mv s1,a0
    0x840172e0    0x12c    ld a0,0(sp)
    0x840172e2    0x12e    ld a1,8(sp)
    0x840172e4    0x130    jal ra,ffffffff840104f0 <cap_notification_cap_get_capNtfnBadge>
    0x840172e8    0x134    mv a1,a0
    0x840172ea    0x136    mv a0,s1
    0x840172ec    0x138    jal ra,ffffffff84014696 <sendSignal>
    0x840172f0    0x13c    j ffffffff8401721a <decodeInvocation+0x66>
    0x840172f2    0x13e    auipc a5,0x7
    0x840172f6    0x142    addi a5,a5,-1706 # ffffffff8401dc48 <current_syscall_error>
    0x840172fa    0x146    li a4,2
    0x840172fc    0x148    sd a4,48(a5)
    0x840172fe    0x14a    sd zero,8(a5)
    0x84017302    0x14e    li s0,3
    0x84017304    0x150    j ffffffff8401721a <decodeInvocation+0x66>
    0x84017306    0x152    ld a0,0(sp)
    0x84017308    0x154    ld a1,8(sp)
    0x8401730a    0x156    jal ra,ffffffff84010574 <cap_reply_cap_get_capReplyMaster>
    0x8401730e    0x15a    bnez a0,ffffffff8401733e <decodeInvocation+0x18a>
    0x84017310    0x15c    li a1,2
    0x84017312    0x15e    auipc a0,0x17
    0x84017316    0x162    ld a0,1926(a0) # ffffffff8402ea98 <ksCurThread>
    0x8401731a    0x166    jal ra,ffffffff84013020 <setThreadState>
    0x8401731e    0x16a    ld a0,0(sp)
    0x84017320    0x16c    ld a1,8(sp)
    0x84017322    0x16e    jal ra,ffffffff84010554 <cap_reply_cap_get_capTCBPtr>
    0x84017326    0x172    mv s0,a0
    0x84017328    0x174    ld a0,0(sp)
    0x8401732a    0x176    ld a1,8(sp)
    0x8401732c    0x178    jal ra,ffffffff8401055c <cap_reply_cap_get_capReplyCanGrant>
    0x84017330    0x17c    mv a2,a0
    0x84017332    0x17e    mv a1,s3
    0x84017334    0x180    mv a0,s0
    0x84017336    0x182    jal ra,ffffffff84014d4a <performInvocation_Reply>
    0x8401733a    0x186    mv s0,a0
    0x8401733c    0x188    j ffffffff8401721a <decodeInvocation+0x66>
    0x8401733e    0x18a    auipc a5,0x7
    0x84017342    0x18e    addi a5,a5,-1782 # ffffffff8401dc48 <current_syscall_error>
    0x84017346    0x192    li a4,2
    0x84017348    0x194    sd a4,48(a5)
    0x8401734a    0x196    sd zero,8(a5)
    0x8401734e    0x19a    li s0,3
    0x84017350    0x19c    j ffffffff8401721a <decodeInvocation+0x66>
    0x84017352    0x19e    ld a6,96(sp)
    0x84017354    0x1a0    mv a5,s4
    0x84017356    0x1a2    mv a4,s3
    0x84017358    0x1a4    ld a2,0(sp)
    0x8401735a    0x1a6    ld a3,8(sp)
    0x8401735c    0x1a8    mv a1,s2
    0x8401735e    0x1aa    mv a0,s1
    0x84017360    0x1ac    jal ra,ffffffff8401619e <decodeTCBInvocation>
    0x84017364    0x1b0    mv s0,a0
    0x84017366    0x1b2    j ffffffff8401721a <decodeInvocation+0x66>
    0x84017368    0x1b4    ld a2,96(sp)
    0x8401736a    0x1b6    mv a1,s2
    0x8401736c    0x1b8    mv a0,s1
    0x8401736e    0x1ba    jal ra,ffffffff84015398 <decodeDomainInvocation>
    0x84017372    0x1be    mv s0,a0
    0x84017374    0x1c0    j ffffffff8401721a <decodeInvocation+0x66>
    0x84017376    0x1c2    ld a4,96(sp)
    0x84017378    0x1c4    ld a2,0(sp)
    0x8401737a    0x1c6    ld a3,8(sp)
    0x8401737c    0x1c8    mv a1,s2
    0x8401737e    0x1ca    mv a0,s1
    0x84017380    0x1cc    jal ra,ffffffff84014044 <decodeCNodeInvocation>
    0x84017384    0x1d0    mv s0,a0
    0x84017386    0x1d2    j ffffffff8401721a <decodeInvocation+0x66>
    0x84017388    0x1d4    ld a6,96(sp)
    0x8401738a    0x1d6    mv a5,s4
    0x8401738c    0x1d8    ld a3,0(sp)
    0x8401738e    0x1da    ld a4,8(sp)
    0x84017390    0x1dc    mv a2,s3
    0x84017392    0x1de    mv a1,s2
    0x84017394    0x1e0    mv a0,s1
    0x84017396    0x1e2    jal ra,ffffffff84016ee4 <decodeUntypedInvocation>
    0x8401739a    0x1e6    mv s0,a0
    0x8401739c    0x1e8    j ffffffff8401721a <decodeInvocation+0x66>
    0x8401739e    0x1ea    ld a3,96(sp)
    0x840173a0    0x1ec    mv a2,s3
    0x840173a2    0x1ee    mv a1,s2
    0x840173a4    0x1f0    mv a0,s1
    0x840173a6    0x1f2    jal ra,ffffffff84013166 <decodeIRQControlInvocation>
    0x840173aa    0x1f6    mv s0,a0
    0x840173ac    0x1f8    j ffffffff8401721a <decodeInvocation+0x66>
    0x840173ae    0x1fa    ld a0,0(sp)
    0x840173b0    0x1fc    ld a1,8(sp)
    0x840173b2    0x1fe    jal ra,ffffffff8401060e <cap_irq_handler_cap_get_capIRQ>
    0x840173b6    0x202    mv a1,a0
    0x840173b8    0x204    mv a0,s1
    0x840173ba    0x206    jal ra,ffffffff8401455e <decodeIRQHandlerInvocation>
    0x840173be    0x20a    mv s0,a0
    0x840173c0    0x20c    j ffffffff8401721a <decodeInvocation+0x66>
    0x840173c2    0x20e    jal ra,ffffffff84010cec <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
211 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeInvocation` has 323 nodes.

Section init_kernel (431 of 432)
================================

Deriving specifications
-----------------------

Section `init_kernel` consists of 220 instructions.

RVC_FTTFT____FFFT_FT.
Skipping 10579073 csrw stvec,a5

RVC_FTTFFT___FFT__FT.
Skipping 1007b073 csrc sstatus,a5

RVC_FFFFFFFFFFF___FFdfn'UnknownInstruction (s with c_Skip := s.c_Skip(|s.procID |-> 2w|))

Skipping 0000 unimp


Stack analysis
---------------

79 stack accesses found. Annotated code for `init_kernel`:

    0x840012a6      0x0    addi sp,sp,-272
    0x840012a8      0x2    sd ra,264(sp)         ; stack access
    0x840012aa      0x4    sd s0,256(sp)         ; stack access
    0x840012ac      0x6    sd s1,248(sp)         ; stack access
    0x840012ae      0x8    sd s2,240(sp)         ; stack access
    0x840012b0      0xa    sd s3,232(sp)         ; stack access
    0x840012b2      0xc    sd s4,224(sp)         ; stack access
    0x840012b4      0xe    sd s5,216(sp)         ; stack access
    0x840012b6     0x10    sd s6,208(sp)         ; stack access
    0x840012b8     0x12    sd s7,200(sp)         ; stack access
    0x840012ba     0x14    mv s5,a3
    0x840012bc     0x16    li s0,-1
    0x840012be     0x18    slli s0,s0,0x26
    0x840012c0     0x1a    add s6,a0,s0
    0x840012c4     0x1e    add s0,s0,a1
    0x840012c6     0x20    sd s6,88(sp)          ; stack access
    0x840012c8     0x22    sd s0,96(sp)          ; stack access
    0x840012ca     0x24    slli s3,a2,0x20
    0x840012ce     0x28    srli s3,s3,0x20
    0x840012d2     0x2c    sub s2,a0,s3
    0x840012d6     0x30    sub s1,a1,s3
    0x840012da     0x34    lui s4,0x2
    0x840012dc     0x36    add s4,s4,s1
    0x840012de     0x38    jal ra,ffffffff840004a0 <map_kernel_window>
    0x840012e2     0x3c    jal ra,ffffffff8400013c <activate_kernel_vspace>
    0x840012e6     0x40    auipc a5,0xf
    0x840012ea     0x44    addi a5,a5,-742 # ffffffff84010000 <ki_boot_end>
    0x840012ee     0x48    csrw stvec,a5
    0x840012f2     0x4c    jal ra,ffffffff840002f0 <initLocalIRQController>
    0x840012f6     0x50    jal ra,ffffffff840002da <initTimer>
    0x840012fa     0x54    lui a5,0x6
    0x840012fc     0x56    csrc sstatus,a5
    0x84001300     0x5a    jal ra,ffffffff84000334 <initIRQController>
    0x84001304     0x5e    auipc a5,0x0
    0x84001308     0x62    addi a5,a5,524 # ffffffff84001510 <ndks_boot>
    0x8400130c     0x66    lui a4,0xff021
    0x84001310     0x6a    slli a4,a4,0xe
    0x84001312     0x6c    sd a4,952(a5)
    0x84001316     0x70    auipc a4,0x2e
    0x8400131a     0x74    addi a4,a4,-790 # ffffffff8402f000 <ki_end>
    0x8400131e     0x78    li a3,-63
    0x84001322     0x7c    slli a3,a3,0x20
    0x84001324     0x7e    add a4,a4,a3
    0x84001326     0x80    sd a4,960(a5)
    0x8400132a     0x84    sd s6,968(a5)
    0x8400132e     0x88    sd s0,976(a5)
    0x84001332     0x8c    li a6,0
    0x84001334     0x8e    mv a4,s2
    0x84001336     0x90    mv a5,s4
    0x84001338     0x92    auipc a3,0x0
    0x8400133c     0x96    addi a3,a3,1424 # ffffffff840018c8 <res_reg>
    0x84001340     0x9a    li a2,2
    0x84001342     0x9c    auipc a1,0x0
    0x84001346     0xa0    addi a1,a1,446 # ffffffff84001500 <avail_p_regs>
    0x8400134a     0xa4    li a0,1
    0x8400134c     0xa6    jal ra,ffffffff84000f4e <init_freemem>
    0x84001350     0xaa    jal ra,ffffffff840005f2 <create_root_cnode>
    0x84001354     0xae    sd a0,24(sp)          ; stack access
    0x84001356     0xb0    sd a1,32(sp)          ; stack access
    0x84001358     0xb2    jal ra,ffffffff8401039e <cap_get_capType>
    0x8400135c     0xb6    bnez a0,ffffffff84001362 <init_kernel+0xbc>
    0x8400135e     0xb8    jal ra,ffffffff84010cec <halt>
    0x84001362     0xbc    ld a0,24(sp)          ; stack access
    0x84001364     0xbe    ld a1,32(sp)          ; stack access
    0x84001366     0xc0    jal ra,ffffffff84000636 <create_domain_cap>
    0x8400136a     0xc4    ld a5,24(sp)          ; stack access
    0x8400136c     0xc6    sd a5,152(sp)         ; stack access
    0x8400136e     0xc8    ld a5,32(sp)          ; stack access
    0x84001370     0xca    sd a5,160(sp)         ; stack access
    0x84001372     0xcc    li s6,1
    0x84001374     0xce    li s0,0
    0x84001376     0xd0    li s7,54
    0x8400137a     0xd4    j ffffffff84001380 <init_kernel+0xda>
    0x8400137c     0xd6    addi s0,s0,1
    0x8400137e     0xd8    addi s6,s6,1
    0x84001380     0xda    beqz s0,ffffffff8400137c <init_kernel+0xd6>
    0x84001382     0xdc    mv a1,s0
    0x84001384     0xde    li a0,0
    0x84001386     0xe0    jal ra,ffffffff8401233c <setIRQState>
    0x8400138a     0xe4    bgeu s7,s6,ffffffff8400137c <init_kernel+0xd6>
    0x8400138e     0xe8    li a1,54
    0x84001392     0xec    li a0,2
    0x84001394     0xee    jal ra,ffffffff8401233c <setIRQState>
    0x84001398     0xf2    ld a0,152(sp)         ; stack access
    0x8400139a     0xf4    ld a1,160(sp)         ; stack access
    0x8400139c     0xf6    jal ra,ffffffff84010b68 <cap_get_capPtr>
    0x840013a0     0xfa    mv s0,a0
    0x840013a2     0xfc    jal ra,ffffffff840105f2 <cap_irq_control_cap_new>
    0x840013a6    0x100    mv a2,a1
    0x840013a8    0x102    mv a1,a0
    0x840013aa    0x104    addi a0,s0,128
    0x840013ae    0x108    jal ra,ffffffff840005bc <write_slot>
    0x840013b2    0x10c    li a3,0
    0x840013b4    0x10e    mv a2,s1
    0x840013b6    0x110    li a1,1
    0x840013b8    0x112    li a0,0
    0x840013ba    0x114    jal ra,ffffffff84000d6a <populate_bi_frame>
    0x840013be    0x118    mv a2,s2
    0x840013c0    0x11a    mv a3,s4
    0x840013c2    0x11c    ld a0,24(sp)          ; stack access
    0x840013c4    0x11e    ld a1,32(sp)          ; stack access
    0x840013c6    0x120    jal ra,ffffffff84000740 <create_it_address_space>
    0x840013ca    0x124    sd a0,40(sp)          ; stack access
    0x840013cc    0x126    sd a1,48(sp)          ; stack access
    0x840013ce    0x128    jal ra,ffffffff8401039e <cap_get_capType>
    0x840013d2    0x12c    beqz a0,ffffffff8400135e <init_kernel+0xb8>
    0x840013d4    0x12e    lui s0,0x1
    0x840013d6    0x130    add s0,s0,s1
    0x840013d8    0x132    mv a4,s0
    0x840013da    0x134    ld a2,40(sp)          ; stack access
    0x840013dc    0x136    ld a3,48(sp)          ; stack access
    0x840013de    0x138    ld a0,24(sp)          ; stack access
    0x840013e0    0x13a    ld a1,32(sp)          ; stack access
    0x840013e2    0x13c    jal ra,ffffffff84000670 <create_bi_frame_cap>
    0x840013e6    0x140    mv a4,s1
    0x840013e8    0x142    ld a2,40(sp)          ; stack access
    0x840013ea    0x144    ld a3,48(sp)          ; stack access
    0x840013ec    0x146    ld a0,24(sp)          ; stack access
    0x840013ee    0x148    ld a1,32(sp)          ; stack access
    0x840013f0    0x14a    jal ra,ffffffff84000d08 <create_ipcbuf_frame_cap>
    0x840013f4    0x14e    sd a0,72(sp)          ; stack access
    0x840013f6    0x150    sd a1,80(sp)          ; stack access
    0x840013f8    0x152    jal ra,ffffffff8401039e <cap_get_capType>
    0x840013fc    0x156    beqz a0,ffffffff8400135e <init_kernel+0xb8>
    0x840013fe    0x158    sd s3,0(sp)           ; stack access
    0x84001400    0x15a    li a7,1
    0x84001402    0x15c    ld a5,88(sp)          ; stack access
    0x84001404    0x15e    ld a6,96(sp)          ; stack access
    0x84001406    0x160    ld a3,40(sp)          ; stack access
    0x84001408    0x162    ld a4,48(sp)          ; stack access
    0x8400140a    0x164    ld a1,24(sp)          ; stack access
    0x8400140c    0x166    ld a2,32(sp)          ; stack access
    0x8400140e    0x168    addi a0,sp,152
    0x84001410    0x16a    jal ra,ffffffff8400083e <create_frames_of_region>
    0x84001414    0x16e    ld a5,168(sp)         ; stack access
    0x84001416    0x170    beqz a5,ffffffff8400135e <init_kernel+0xb8>
    0x84001418    0x172    auipc a5,0x0
    0x8400141c    0x176    ld a5,832(a5) # ffffffff84001758 <ndks_boot+0x248>
    0x84001420    0x17a    ld a4,152(sp)         ; stack access
    0x84001422    0x17c    sd a4,72(a5)
    0x84001424    0x17e    ld a4,160(sp)         ; stack access
    0x84001426    0x180    sd a4,80(a5)
    0x84001428    0x182    ld a0,24(sp)          ; stack access
    0x8400142a    0x184    ld a1,32(sp)          ; stack access
    0x8400142c    0x186    jal ra,ffffffff840008f8 <create_it_asid_pool>
    0x84001430    0x18a    sd a0,56(sp)          ; stack access
    0x84001432    0x18c    sd a1,64(sp)          ; stack access
    0x84001434    0x18e    jal ra,ffffffff8401039e <cap_get_capType>
    0x84001438    0x192    beqz a0,ffffffff8400135e <init_kernel+0xb8>
    0x8400143c    0x196    ld a2,40(sp)          ; stack access
    0x8400143e    0x198    ld a3,48(sp)          ; stack access
    0x84001440    0x19a    ld a0,56(sp)          ; stack access
    0x84001442    0x19c    ld a1,64(sp)          ; stack access
    0x84001444    0x19e    jal ra,ffffffff84000166 <write_it_asid_pool>
    0x84001448    0x1a2    jal ra,ffffffff84000ce8 <create_idle_thread>
    0x8400144c    0x1a6    beqz a0,ffffffff8400135e <init_kernel+0xb8>
    0x84001450    0x1aa    ld a5,80(sp)          ; stack access
    0x84001452    0x1ac    sd a5,0(sp)           ; stack access
    0x84001454    0x1ae    ld a7,72(sp)          ; stack access
    0x84001456    0x1b0    mv a6,s1
    0x84001458    0x1b2    mv a5,s0
    0x8400145a    0x1b4    mv a4,s5
    0x8400145c    0x1b6    ld a2,40(sp)          ; stack access
    0x8400145e    0x1b8    ld a3,48(sp)          ; stack access
    0x84001460    0x1ba    ld a0,24(sp)          ; stack access
    0x84001462    0x1bc    ld a1,32(sp)          ; stack access
    0x84001464    0x1be    jal ra,ffffffff84000b8a <create_initial_thread>
    0x84001468    0x1c2    beqz a0,ffffffff8400135e <init_kernel+0xb8>
    0x8400146c    0x1c6    jal ra,ffffffff84000962 <init_core_state>
    0x84001470    0x1ca    ld a0,24(sp)          ; stack access
    0x84001472    0x1cc    sd a0,120(sp)         ; stack access
    0x84001474    0x1ce    ld a1,32(sp)          ; stack access
    0x84001476    0x1d0    sd a1,128(sp)         ; stack access
    0x84001478    0x1d2    lui a5,0xff021
    0x8400147c    0x1d6    slli a5,a5,0xe
    0x8400147e    0x1d8    sd a5,136(sp)         ; stack access
    0x84001480    0x1da    auipc a5,0xf
    0x84001484    0x1de    addi a5,a5,-1152 # ffffffff84010000 <ki_boot_end>
    0x84001488    0x1e2    li a4,-63
    0x8400148c    0x1e6    slli a4,a4,0x20
    0x8400148e    0x1e8    add a5,a5,a4
    0x84001490    0x1ea    sd a5,144(sp)         ; stack access
    0x84001492    0x1ec    auipc s1,0x0
    0x84001496    0x1f0    addi s1,s1,126 # ffffffff84001510 <ndks_boot>
    0x8400149a    0x1f4    ld s0,592(s1)
    0x8400149e    0x1f8    mv a2,s0
    0x840014a0    0x1fa    jal ra,ffffffff84000a78 <create_device_untypeds>
    0x840014a4    0x1fe    mv a4,s0
    0x840014a6    0x200    ld a2,136(sp)         ; stack access
    0x840014a8    0x202    ld a3,144(sp)         ; stack access
    0x840014aa    0x204    ld a0,120(sp)         ; stack access
    0x840014ac    0x206    ld a1,128(sp)         ; stack access
    0x840014ae    0x208    jal ra,ffffffff84000b12 <create_kernel_untypeds>
    0x840014b2    0x20c    ld a4,592(s1)
    0x840014b6    0x210    ld a5,584(s1)
    0x840014ba    0x214    sd s0,152(a5)
    0x840014bc    0x216    sd a4,160(a5)
    0x840014be    0x218    beqz a0,ffffffff8400135e <init_kernel+0xb8>
    0x840014c2    0x21c    auipc a5,0x0
    0x840014c6    0x220    ld a5,662(a5) # ffffffff84001758 <ndks_boot+0x248>
    0x840014ca    0x224    sd zero,56(a5)
    0x840014ce    0x228    sd zero,64(a5)
    0x840014d2    0x22c    jal ra,ffffffff84000b70 <bi_finalise>
    0x840014d6    0x230    li a5,1
    0x840014d8    0x232    auipc a4,0x1d
    0x840014dc    0x236    sd a5,-1672(a4) # ffffffff8401de50 <ksNumCPUs>
    0x840014e0    0x23a    jal ra,ffffffff840136b0 <schedule>
    0x840014e4    0x23e    jal ra,ffffffff84013112 <activateThread>
    0x840014e8    0x242    ld ra,264(sp)         ; stack access
    0x840014ea    0x244    ld s0,256(sp)         ; stack access
    0x840014ec    0x246    ld s1,248(sp)         ; stack access
    0x840014ee    0x248    ld s2,240(sp)         ; stack access
    0x840014f0    0x24a    ld s3,232(sp)         ; stack access
    0x840014f2    0x24c    ld s4,224(sp)         ; stack access
    0x840014f4    0x24e    ld s5,216(sp)         ; stack access
    0x840014f6    0x250    ld s6,208(sp)         ; stack access
    0x840014f8    0x252    ld s7,200(sp)         ; stack access
    0x840014fa    0x254    addi sp,sp,272
    0x840014fc    0x256    ret
    0x840014fe    0x258    unimp

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
220 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `init_kernel` has 372 nodes.

Section decodeRISCVMMUInvocation (432 of 432)
=============================================

Deriving specifications
-----------------------

Section `decodeRISCVMMUInvocation` consists of 769 instructions.

Skipping 12000073 sfence.vma

Skipping 12000073 sfence.vma


Stack analysis
---------------

132 stack accesses found. Annotated code for `decodeRISCVMMUInvocation`:

    0x8401654a      0x0    addi sp,sp,-208
    0x8401654c      0x2    sd ra,200(sp)         ; stack access
    0x8401654e      0x4    sd s0,192(sp)         ; stack access
    0x84016550      0x6    sd s1,184(sp)         ; stack access
    0x84016552      0x8    sd s2,176(sp)         ; stack access
    0x84016554      0xa    sd s3,168(sp)         ; stack access
    0x84016556      0xc    sd s4,160(sp)         ; stack access
    0x84016558      0xe    sd s5,152(sp)         ; stack access
    0x8401655a     0x10    sd s6,144(sp)         ; stack access
    0x8401655c     0x12    sd s7,136(sp)         ; stack access
    0x8401655e     0x14    sd s8,128(sp)         ; stack access
    0x84016560     0x16    sd s9,120(sp)         ; stack access
    0x84016562     0x18    sd s10,112(sp)        ; stack access
    0x84016564     0x1a    mv s1,a0
    0x84016566     0x1c    mv s2,a1
    0x84016568     0x1e    mv s3,a3
    0x8401656a     0x20    sd a4,16(sp)          ; stack access
    0x8401656c     0x22    sd a5,24(sp)          ; stack access
    0x8401656e     0x24    mv a0,a4
    0x84016570     0x26    mv a1,a5
    0x84016572     0x28    jal ra,ffffffff8401039e <cap_get_capType>
    0x84016576     0x2c    li a5,11
    0x84016578     0x2e    beq a0,a5,ffffffff84016aa8 <decodeRISCVMMUInvocation+0x55e>
    0x8401657c     0x32    mv s0,a0
    0x8401657e     0x34    bltu a5,a0,ffffffff840166b0 <decodeRISCVMMUInvocation+0x166>
    0x84016582     0x38    li a5,1
    0x84016584     0x3a    beq a0,a5,ffffffff840167b6 <decodeRISCVMMUInvocation+0x26c>
    0x84016588     0x3e    li a5,3
    0x8401658a     0x40    bne a0,a5,ffffffff84016d5e <decodeRISCVMMUInvocation+0x814>
    0x8401658e     0x44    ld a5,16(sp)          ; stack access
    0x84016590     0x46    sd a5,32(sp)          ; stack access
    0x84016592     0x48    ld a5,24(sp)          ; stack access
    0x84016594     0x4a    sd a5,40(sp)          ; stack access
    0x84016596     0x4c    li a5,31
    0x84016598     0x4e    beq s1,a5,ffffffff840166cc <decodeRISCVMMUInvocation+0x182>
    0x8401659c     0x52    li a5,30
    0x8401659e     0x54    bne s1,a5,ffffffff84016730 <decodeRISCVMMUInvocation+0x1e6>
    0x840165a2     0x58    li a5,1
    0x840165a4     0x5a    bgeu a5,s2,ffffffff8401673c <decodeRISCVMMUInvocation+0x1f2>
    0x840165a8     0x5e    auipc s1,0x7
    0x840165ac     0x62    ld s1,1752(s1) # ffffffff8401dc80 <current_extra_caps>
    0x840165b0     0x66    beqz s1,ffffffff8401673c <decodeRISCVMMUInvocation+0x1f2>
    0x840165b4     0x6a    ld a0,32(sp)          ; stack access
    0x840165b6     0x6c    ld a1,40(sp)          ; stack access
    0x840165b8     0x6e    jal ra,ffffffff8401072c <cap_page_table_cap_get_capPTIsMapped>
    0x840165bc     0x72    bnez a0,ffffffff84016748 <decodeRISCVMMUInvocation+0x1fe>
    0x840165c0     0x76    auipc a5,0x18
    0x840165c4     0x7a    ld a5,1240(a5) # ffffffff8402ea98 <ksCurThread>
    0x840165c8     0x7e    ld s4,88(a5)
    0x840165cc     0x82    ld a0,0(s1)
    0x840165ce     0x84    sd a0,48(sp)          ; stack access
    0x840165d0     0x86    ld a1,8(s1)
    0x840165d2     0x88    sd a1,56(sp)          ; stack access
    0x840165d4     0x8a    jal ra,ffffffff8401039e <cap_get_capType>
    0x840165d8     0x8e    mv s1,a0
    0x840165da     0x90    li a5,3
    0x840165dc     0x92    bne a0,a5,ffffffff8401675a <decodeRISCVMMUInvocation+0x210>
    0x840165e0     0x96    ld a0,48(sp)          ; stack access
    0x840165e2     0x98    ld a1,56(sp)          ; stack access
    0x840165e4     0x9a    jal ra,ffffffff8401072c <cap_page_table_cap_get_capPTIsMapped>
    0x840165e8     0x9e    beqz a0,ffffffff8401675a <decodeRISCVMMUInvocation+0x210>
    0x840165ec     0xa2    ld a0,48(sp)          ; stack access
    0x840165ee     0xa4    ld a1,56(sp)          ; stack access
    0x840165f0     0xa6    jal ra,ffffffff84010a76 <cap_page_table_cap_get_capPTBasePtr>
    0x840165f4     0xaa    mv s0,a0
    0x840165f6     0xac    ld a0,48(sp)          ; stack access
    0x840165f8     0xae    ld a1,56(sp)          ; stack access
    0x840165fa     0xb0    jal ra,ffffffff84010714 <cap_page_table_cap_get_capPTMappedASID>
    0x840165fe     0xb4    mv s2,a0
    0x84016600     0xb6    lui a5,0xfefff
    0x84016604     0xba    slli a5,a5,0xe
    0x84016606     0xbc    srli a5,a5,0x1a
    0x84016608     0xbe    bltu a5,s4,ffffffff8401676c <decodeRISCVMMUInvocation+0x222>
    0x8401660c     0xc2    jal ra,ffffffff84010922 <findVSpaceForASID>
    0x84016610     0xc6    sd a0,80(sp)          ; stack access
    0x84016612     0xc8    sd a1,88(sp)          ; stack access
    0x84016614     0xca    bnez a0,ffffffff84016780 <decodeRISCVMMUInvocation+0x236>
    0x84016618     0xce    ld a5,88(sp)          ; stack access
    0x8401661a     0xd0    bne s0,a5,ffffffff84016794 <decodeRISCVMMUInvocation+0x24a>
    0x8401661e     0xd4    mv a1,s4
    0x84016620     0xd6    mv a0,s0
    0x84016622     0xd8    jal ra,ffffffff84011116 <lookupPTSlot>
    0x84016626     0xdc    mv s6,a0
    0x84016628     0xde    mv s5,a1
    0x8401662a     0xe0    sd a0,64(sp)          ; stack access
    0x8401662c     0xe2    sd a1,72(sp)          ; stack access
    0x8401662e     0xe4    li a5,12
    0x84016630     0xe6    beq a1,a5,ffffffff840167a8 <decodeRISCVMMUInvocation+0x25e>
    0x84016634     0xea    jal ra,ffffffff840102f0 <pte_ptr_get_valid>
    0x84016638     0xee    mv s0,a0
    0x8401663a     0xf0    bnez a0,ffffffff840167a8 <decodeRISCVMMUInvocation+0x25e>
    0x8401663e     0xf4    ld a0,32(sp)          ; stack access
    0x84016640     0xf6    ld a1,40(sp)          ; stack access
    0x84016642     0xf8    jal ra,ffffffff84010a76 <cap_page_table_cap_get_capPTBasePtr>
    0x84016646     0xfc    li s1,1
    0x84016648     0xfe    slli a5,s1,0x26
    0x8401664c    0x102    add a0,a0,a5
    0x8401664e    0x104    sd s1,8(sp)           ; stack access
    0x84016650    0x106    sd zero,0(sp)         ; stack access
    0x84016652    0x108    li a7,0
    0x84016654    0x10a    li a6,0
    0x84016656    0x10c    li a5,0
    0x84016658    0x10e    li a4,0
    0x8401665a    0x110    li a3,1
    0x8401665c    0x112    li a2,1
    0x8401665e    0x114    li a1,0
    0x84016660    0x116    srli a0,a0,0xc
    0x84016662    0x118    jal ra,ffffffff8401026a <pte_new>
    0x84016666    0x11c    mv s7,a0
    0x84016668    0x11e    li a2,1
    0x8401666a    0x120    ld a0,32(sp)          ; stack access
    0x8401666c    0x122    ld a1,40(sp)          ; stack access
    0x8401666e    0x124    jal ra,ffffffff84010736 <cap_page_table_cap_set_capPTIsMapped>
    0x84016672    0x128    mv a2,s2
    0x84016674    0x12a    jal ra,ffffffff8401071e <cap_page_table_cap_set_capPTMappedASID>
    0x84016678    0x12e    sll s5,s1,s5
    0x8401667c    0x132    neg a2,s5
    0x84016680    0x136    and a2,a2,s4
    0x84016684    0x13a    jal ra,ffffffff8401075e <cap_page_table_cap_set_capPTMappedAddress>
    0x84016688    0x13e    sd a0,32(sp)          ; stack access
    0x8401668a    0x140    sd a1,40(sp)          ; stack access
    0x8401668c    0x142    li a1,2
    0x8401668e    0x144    auipc a0,0x18
    0x84016692    0x148    ld a0,1034(a0) # ffffffff8402ea98 <ksCurThread>
    0x84016696    0x14c    jal ra,ffffffff84013020 <setThreadState>
    0x8401669a    0x150    ld a5,32(sp)          ; stack access
    0x8401669c    0x152    sd a5,0(s3)
    0x840166a0    0x156    ld a5,40(sp)          ; stack access
    0x840166a2    0x158    sd a5,8(s3)
    0x840166a6    0x15c    sd s7,0(s6)
    0x840166aa    0x160    sfence.vma
    0x840166ae    0x164    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x840166b0    0x166    li a5,13
    0x840166b2    0x168    bne a0,a5,ffffffff84016d5e <decodeRISCVMMUInvocation+0x814>
    0x840166b6    0x16c    li a5,36
    0x840166ba    0x170    beq s1,a5,ffffffff84016c22 <decodeRISCVMMUInvocation+0x6d8>
    0x840166be    0x174    li a5,3
    0x840166c0    0x176    auipc a4,0x7
    0x840166c4    0x17a    sd a5,1464(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840166c8    0x17e    li s0,3
    0x840166ca    0x180    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x840166cc    0x182    mv a0,s3
    0x840166ce    0x184    jal ra,ffffffff84012af4 <isFinalCapability>
    0x840166d2    0x188    beqz a0,ffffffff8401670a <decodeRISCVMMUInvocation+0x1c0>
    0x840166d4    0x18a    ld a0,32(sp)          ; stack access
    0x840166d6    0x18c    ld a1,40(sp)          ; stack access
    0x840166d8    0x18e    jal ra,ffffffff8401072c <cap_page_table_cap_get_capPTIsMapped>
    0x840166dc    0x192    beqz a0,ffffffff840166ee <decodeRISCVMMUInvocation+0x1a4>
    0x840166de    0x194    ld a0,32(sp)          ; stack access
    0x840166e0    0x196    ld a1,40(sp)          ; stack access
    0x840166e2    0x198    jal ra,ffffffff84010714 <cap_page_table_cap_get_capPTMappedASID>
    0x840166e6    0x19c    jal ra,ffffffff84010922 <findVSpaceForASID>
    0x840166ea    0x1a0    sd a1,88(sp)          ; stack access
    0x840166ec    0x1a2    beqz a0,ffffffff84016716 <decodeRISCVMMUInvocation+0x1cc>
    0x840166ee    0x1a4    li a1,2
    0x840166f0    0x1a6    auipc a0,0x18
    0x840166f4    0x1aa    ld a0,936(a0) # ffffffff8402ea98 <ksCurThread>
    0x840166f8    0x1ae    jal ra,ffffffff84013020 <setThreadState>
    0x840166fc    0x1b2    mv a2,s3
    0x840166fe    0x1b4    ld a0,32(sp)          ; stack access
    0x84016700    0x1b6    ld a1,40(sp)          ; stack access
    0x84016702    0x1b8    jal ra,ffffffff840164ee <performPageTableInvocationUnmap>
    0x84016706    0x1bc    mv s0,a0
    0x84016708    0x1be    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x8401670a    0x1c0    li a5,9
    0x8401670c    0x1c2    auipc a4,0x7
    0x84016710    0x1c6    sd a5,1388(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016714    0x1ca    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016716    0x1cc    ld a0,32(sp)          ; stack access
    0x84016718    0x1ce    ld a1,40(sp)          ; stack access
    0x8401671a    0x1d0    jal ra,ffffffff84010a76 <cap_page_table_cap_get_capPTBasePtr>
    0x8401671e    0x1d4    ld a5,88(sp)          ; stack access
    0x84016720    0x1d6    bne a5,a0,ffffffff840166ee <decodeRISCVMMUInvocation+0x1a4>
    0x84016724    0x1da    li a5,9
    0x84016726    0x1dc    auipc a4,0x7
    0x8401672a    0x1e0    sd a5,1362(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x8401672e    0x1e4    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016730    0x1e6    li a5,3
    0x84016732    0x1e8    auipc a4,0x7
    0x84016736    0x1ec    sd a5,1350(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x8401673a    0x1f0    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x8401673c    0x1f2    li a5,7
    0x8401673e    0x1f4    auipc a4,0x7
    0x84016742    0x1f8    sd a5,1338(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016746    0x1fc    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016748    0x1fe    auipc a5,0x7
    0x8401674c    0x202    addi a5,a5,1280 # ffffffff8401dc48 <current_syscall_error>
    0x84016750    0x206    li a4,2
    0x84016752    0x208    sd a4,48(a5)
    0x84016754    0x20a    sd zero,8(a5)
    0x84016758    0x20e    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x8401675a    0x210    auipc a5,0x7
    0x8401675e    0x214    addi a5,a5,1262 # ffffffff8401dc48 <current_syscall_error>
    0x84016762    0x218    li a4,2
    0x84016764    0x21a    sd a4,48(a5)
    0x84016766    0x21c    li a4,1
    0x84016768    0x21e    sd a4,8(a5)
    0x8401676a    0x220    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x8401676c    0x222    auipc a5,0x7
    0x84016770    0x226    addi a5,a5,1244 # ffffffff8401dc48 <current_syscall_error>
    0x84016774    0x22a    li a4,1
    0x84016776    0x22c    sd a4,48(a5)
    0x84016778    0x22e    sd zero,0(a5)
    0x8401677c    0x232    mv s0,s1
    0x8401677e    0x234    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016780    0x236    auipc a5,0x7
    0x84016784    0x23a    addi a5,a5,1224 # ffffffff8401dc48 <current_syscall_error>
    0x84016788    0x23e    li a4,6
    0x8401678a    0x240    sd a4,48(a5)
    0x8401678c    0x242    sd zero,40(a5)
    0x84016790    0x246    mv s0,s1
    0x84016792    0x248    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016794    0x24a    auipc a5,0x7
    0x84016798    0x24e    addi a5,a5,1204 # ffffffff8401dc48 <current_syscall_error>
    0x8401679c    0x252    li a4,2
    0x8401679e    0x254    sd a4,48(a5)
    0x840167a0    0x256    li a4,1
    0x840167a2    0x258    sd a4,8(a5)
    0x840167a4    0x25a    mv s0,s1
    0x840167a6    0x25c    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x840167a8    0x25e    li a5,8
    0x840167aa    0x260    auipc a4,0x7
    0x840167ae    0x264    sd a5,1230(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840167b2    0x268    mv s0,s1
    0x840167b4    0x26a    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x840167b6    0x26c    ld a5,16(sp)          ; stack access
    0x840167b8    0x26e    sd a5,32(sp)          ; stack access
    0x840167ba    0x270    ld a5,24(sp)          ; stack access
    0x840167bc    0x272    sd a5,40(sp)          ; stack access
    0x840167be    0x274    li a5,33
    0x840167c2    0x278    beq s1,a5,ffffffff84016a58 <decodeRISCVMMUInvocation+0x50e>
    0x840167c6    0x27c    li a5,34
    0x840167ca    0x280    beq s1,a5,ffffffff84016a74 <decodeRISCVMMUInvocation+0x52a>
    0x840167ce    0x284    li a5,32
    0x840167d2    0x288    beq s1,a5,ffffffff840167e4 <decodeRISCVMMUInvocation+0x29a>
    0x840167d6    0x28c    li a5,3
    0x840167d8    0x28e    auipc a4,0x7
    0x840167dc    0x292    sd a5,1184(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840167e0    0x296    li s0,3
    0x840167e2    0x298    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x840167e4    0x29a    li a5,2
    0x840167e6    0x29c    bgeu a5,s2,ffffffff84016876 <decodeRISCVMMUInvocation+0x32c>
    0x840167ea    0x2a0    auipc a5,0x7
    0x840167ee    0x2a4    ld a5,1174(a5) # ffffffff8401dc80 <current_extra_caps>
    0x840167f2    0x2a8    beqz a5,ffffffff84016876 <decodeRISCVMMUInvocation+0x32c>
    0x840167f4    0x2aa    auipc a4,0x18
    0x840167f8    0x2ae    ld a4,676(a4) # ffffffff8402ea98 <ksCurThread>
    0x840167fc    0x2b2    ld s5,88(a4)
    0x84016800    0x2b6    ld s7,96(a4)
    0x84016804    0x2ba    ld s8,104(a4)
    0x84016808    0x2be    ld a0,0(a5)
    0x8401680a    0x2c0    sd a0,48(sp)          ; stack access
    0x8401680c    0x2c2    ld a1,8(a5)
    0x8401680e    0x2c4    sd a1,56(sp)          ; stack access
    0x84016810    0x2c6    jal ra,ffffffff8401039e <cap_get_capType>
    0x84016814    0x2ca    mv s4,a0
    0x84016816    0x2cc    li a5,3
    0x84016818    0x2ce    bne a0,a5,ffffffff84016884 <decodeRISCVMMUInvocation+0x33a>
    0x8401681c    0x2d2    ld a0,48(sp)          ; stack access
    0x8401681e    0x2d4    ld a1,56(sp)          ; stack access
    0x84016820    0x2d6    jal ra,ffffffff8401072c <cap_page_table_cap_get_capPTIsMapped>
    0x84016824    0x2da    beqz a0,ffffffff84016884 <decodeRISCVMMUInvocation+0x33a>
    0x84016826    0x2dc    ld a0,32(sp)          ; stack access
    0x84016828    0x2de    ld a1,40(sp)          ; stack access
    0x8401682a    0x2e0    jal ra,ffffffff840106a8 <cap_frame_cap_get_capFSize>
    0x8401682e    0x2e4    mv s2,a0
    0x84016830    0x2e6    ld a0,32(sp)          ; stack access
    0x84016832    0x2e8    ld a1,40(sp)          ; stack access
    0x84016834    0x2ea    jal ra,ffffffff840106b2 <cap_frame_cap_get_capFVMRights>
    0x84016838    0x2ee    mv s9,a0
    0x8401683a    0x2f0    ld a0,48(sp)          ; stack access
    0x8401683c    0x2f2    ld a1,56(sp)          ; stack access
    0x8401683e    0x2f4    jal ra,ffffffff84010a76 <cap_page_table_cap_get_capPTBasePtr>
    0x84016842    0x2f8    mv s10,a0
    0x84016844    0x2fa    ld a0,48(sp)          ; stack access
    0x84016846    0x2fc    ld a1,56(sp)          ; stack access
    0x84016848    0x2fe    jal ra,ffffffff84010714 <cap_page_table_cap_get_capPTMappedASID>
    0x8401684c    0x302    mv s6,a0
    0x8401684e    0x304    jal ra,ffffffff84010922 <findVSpaceForASID>
    0x84016852    0x308    mv s1,a0
    0x84016854    0x30a    sd a0,64(sp)          ; stack access
    0x84016856    0x30c    sd a1,72(sp)          ; stack access
    0x84016858    0x30e    mv s0,a0
    0x8401685a    0x310    bnez a0,ffffffff84016898 <decodeRISCVMMUInvocation+0x34e>
    0x8401685c    0x312    ld a5,72(sp)          ; stack access
    0x8401685e    0x314    bne s10,a5,ffffffff840168ac <decodeRISCVMMUInvocation+0x362>
    0x84016862    0x318    li a5,1
    0x84016864    0x31a    beq s2,a5,ffffffff84016d62 <decodeRISCVMMUInvocation+0x818>
    0x84016868    0x31e    li a5,2
    0x8401686a    0x320    beq s2,a5,ffffffff84016d90 <decodeRISCVMMUInvocation+0x846>
    0x8401686e    0x324    beqz s2,ffffffff840168c0 <decodeRISCVMMUInvocation+0x376>
    0x84016872    0x328    jal ra,ffffffff84010cec <halt>
    0x84016876    0x32c    li a5,7
    0x84016878    0x32e    auipc a4,0x7
    0x8401687c    0x332    sd a5,1024(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016880    0x336    li s0,3
    0x84016882    0x338    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016884    0x33a    auipc a5,0x7
    0x84016888    0x33e    addi a5,a5,964 # ffffffff8401dc48 <current_syscall_error>
    0x8401688c    0x342    li a4,2
    0x8401688e    0x344    sd a4,48(a5)
    0x84016890    0x346    li a4,1
    0x84016892    0x348    sd a4,8(a5)
    0x84016894    0x34a    li s0,3
    0x84016896    0x34c    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016898    0x34e    auipc a5,0x7
    0x8401689c    0x352    addi a5,a5,944 # ffffffff8401dc48 <current_syscall_error>
    0x840168a0    0x356    li a4,6
    0x840168a2    0x358    sd a4,48(a5)
    0x840168a4    0x35a    sd zero,40(a5)
    0x840168a8    0x35e    mv s0,s4
    0x840168aa    0x360    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x840168ac    0x362    auipc a5,0x7
    0x840168b0    0x366    addi a5,a5,924 # ffffffff8401dc48 <current_syscall_error>
    0x840168b4    0x36a    li a4,2
    0x840168b6    0x36c    sd a4,48(a5)
    0x840168b8    0x36e    li a4,1
    0x840168ba    0x370    sd a4,8(a5)
    0x840168bc    0x372    mv s0,s4
    0x840168be    0x374    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x840168c0    0x376    lui a4,0x1
    0x840168c2    0x378    addi a4,a4,-1
    0x840168c4    0x37a    add a4,a4,s5
    0x840168c6    0x37c    lui a5,0xfefff
    0x840168ca    0x380    slli a5,a5,0xe
    0x840168cc    0x382    srli a5,a5,0x1a
    0x840168ce    0x384    bltu a5,a4,ffffffff8401698e <decodeRISCVMMUInvocation+0x444>
    0x840168d2    0x388    slli a5,s5,0x34
    0x840168d6    0x38c    bnez a5,ffffffff840169a2 <decodeRISCVMMUInvocation+0x458>
    0x840168d8    0x38e    mv a1,s5
    0x840168da    0x390    mv a0,s10
    0x840168dc    0x392    jal ra,ffffffff84011116 <lookupPTSlot>
    0x840168e0    0x396    mv s2,a0
    0x840168e2    0x398    sd a0,80(sp)          ; stack access
    0x840168e4    0x39a    sd a1,88(sp)          ; stack access
    0x840168e6    0x39c    li a5,12
    0x840168e8    0x39e    bne a1,a5,ffffffff840169b0 <decodeRISCVMMUInvocation+0x466>
    0x840168ec    0x3a2    ld a0,32(sp)          ; stack access
    0x840168ee    0x3a4    ld a1,40(sp)          ; stack access
    0x840168f0    0x3a6    jal ra,ffffffff84010690 <cap_frame_cap_get_capFMappedASID>
    0x840168f4    0x3aa    bnez a0,ffffffff840169d6 <decodeRISCVMMUInvocation+0x48c>
    0x840168f8    0x3ae    mv a0,s2
    0x840168fa    0x3b0    jal ra,ffffffff840102f0 <pte_ptr_get_valid>
    0x840168fe    0x3b4    bnez a0,ffffffff84016a44 <decodeRISCVMMUInvocation+0x4fa>
    0x84016902    0x3b8    mv a1,s7
    0x84016904    0x3ba    mv a0,s9
    0x84016906    0x3bc    jal ra,ffffffff8401150a <maskVMRights>
    0x8401690a    0x3c0    mv s4,a0
    0x8401690c    0x3c2    ld a0,32(sp)          ; stack access
    0x8401690e    0x3c4    ld a1,40(sp)          ; stack access
    0x84016910    0x3c6    jal ra,ffffffff84010a5a <cap_frame_cap_get_capFBasePtr>
    0x84016914    0x3ca    li a5,1
    0x84016916    0x3cc    slli a5,a5,0x26
    0x84016918    0x3ce    add s7,a0,a5
    0x8401691c    0x3d2    mv a2,s6
    0x8401691e    0x3d4    ld a0,32(sp)          ; stack access
    0x84016920    0x3d6    ld a1,40(sp)          ; stack access
    0x84016922    0x3d8    jal ra,ffffffff8401069a <cap_frame_cap_set_capFMappedASID>
    0x84016926    0x3dc    mv a2,s5
    0x84016928    0x3de    jal ra,ffffffff840106da <cap_frame_cap_set_capFMappedAddress>
    0x8401692c    0x3e2    sd a0,32(sp)          ; stack access
    0x8401692e    0x3e4    sd a1,40(sp)          ; stack access
    0x84016930    0x3e6    mv a0,s8
    0x84016932    0x3e8    jal ra,ffffffff8401039a <vm_attributes_get_riscvExecuteNever>
    0x84016936    0x3ec    seqz a6,a0
    0x8401693a    0x3f0    addi a7,s4,-3
    0x8401693e    0x3f4    seqz a7,a7
    0x84016942    0x3f8    addi s4,s4,-1
    0x84016944    0x3fa    snez a5,s4
    0x84016948    0x3fe    bnez s4,ffffffff84016950 <decodeRISCVMMUInvocation+0x406>
    0x8401694c    0x402    beqz a7,ffffffff84016a52 <decodeRISCVMMUInvocation+0x508>
    0x84016950    0x406    li a4,1
    0x84016952    0x408    sd a4,8(sp)           ; stack access
    0x84016954    0x40a    sd a5,0(sp)           ; stack access
    0x84016956    0x40c    li a5,1
    0x84016958    0x40e    li a4,0
    0x8401695a    0x410    li a3,1
    0x8401695c    0x412    li a2,1
    0x8401695e    0x414    li a1,0
    0x84016960    0x416    srli a0,s7,0xc
    0x84016964    0x41a    jal ra,ffffffff8401026a <pte_new>
    0x84016968    0x41e    mv s1,a0
    0x8401696a    0x420    li a1,2
    0x8401696c    0x422    auipc a0,0x18
    0x84016970    0x426    ld a0,300(a0) # ffffffff8402ea98 <ksCurThread>
    0x84016974    0x42a    jal ra,ffffffff84013020 <setThreadState>
    0x84016978    0x42e    ld a5,32(sp)          ; stack access
    0x8401697a    0x430    sd a5,0(s3)
    0x8401697e    0x434    ld a5,40(sp)          ; stack access
    0x84016980    0x436    sd a5,8(s3)
    0x84016984    0x43a    sd s1,0(s2)
    0x84016988    0x43e    sfence.vma
    0x8401698c    0x442    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x8401698e    0x444    auipc a5,0x7
    0x84016992    0x448    addi a5,a5,698 # ffffffff8401dc48 <current_syscall_error>
    0x84016996    0x44c    li a4,1
    0x84016998    0x44e    sd a4,48(a5)
    0x8401699a    0x450    sd zero,0(a5)
    0x8401699e    0x454    mv s0,s4
    0x840169a0    0x456    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x840169a2    0x458    li a5,5
    0x840169a4    0x45a    auipc a4,0x7
    0x840169a8    0x45e    sd a5,724(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x840169ac    0x462    mv s0,s4
    0x840169ae    0x464    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x840169b0    0x466    mv a0,a1
    0x840169b2    0x468    jal ra,ffffffff840107ba <lookup_fault_missing_capability_new>
    0x840169b6    0x46c    auipc a5,0x7
    0x840169ba    0x470    addi a5,a5,634 # ffffffff8401dc30 <current_lookup_fault>
    0x840169be    0x474    sd a0,0(a5)
    0x840169c0    0x476    sd a1,8(a5)
    0x840169c2    0x478    auipc a5,0x7
    0x840169c6    0x47c    addi a5,a5,646 # ffffffff8401dc48 <current_syscall_error>
    0x840169ca    0x480    li a4,6
    0x840169cc    0x482    sd a4,48(a5)
    0x840169ce    0x484    sd zero,40(a5)
    0x840169d2    0x488    mv s0,s4
    0x840169d4    0x48a    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x840169d6    0x48c    beq s6,a0,ffffffff840169ee <decodeRISCVMMUInvocation+0x4a4>
    0x840169da    0x490    auipc a5,0x7
    0x840169de    0x494    addi a5,a5,622 # ffffffff8401dc48 <current_syscall_error>
    0x840169e2    0x498    li a4,2
    0x840169e4    0x49a    sd a4,48(a5)
    0x840169e6    0x49c    li a4,1
    0x840169e8    0x49e    sd a4,8(a5)
    0x840169ea    0x4a0    mv s0,s4
    0x840169ec    0x4a2    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x840169ee    0x4a4    ld a0,32(sp)          ; stack access
    0x840169f0    0x4a6    ld a1,40(sp)          ; stack access
    0x840169f2    0x4a8    jal ra,ffffffff84010ad0 <cap_frame_cap_get_capFMappedAddress>
    0x840169f6    0x4ac    bne s5,a0,ffffffff84016a30 <decodeRISCVMMUInvocation+0x4e6>
    0x840169fa    0x4b0    mv a0,s2
    0x840169fc    0x4b2    jal ra,ffffffff840102f0 <pte_ptr_get_valid>
    0x84016a00    0x4b6    beqz a0,ffffffff84016902 <decodeRISCVMMUInvocation+0x3b8>
    0x84016a04    0x4ba    mv a0,s2
    0x84016a06    0x4bc    jal ra,ffffffff840102e8 <pte_ptr_get_read>
    0x84016a0a    0x4c0    bnez a0,ffffffff84016902 <decodeRISCVMMUInvocation+0x3b8>
    0x84016a0e    0x4c4    mv a0,s2
    0x84016a10    0x4c6    jal ra,ffffffff840102e0 <pte_ptr_get_write>
    0x84016a14    0x4ca    bnez a0,ffffffff84016902 <decodeRISCVMMUInvocation+0x3b8>
    0x84016a18    0x4ce    mv a0,s2
    0x84016a1a    0x4d0    jal ra,ffffffff840102d8 <pte_ptr_get_execute>
    0x84016a1e    0x4d4    bnez a0,ffffffff84016902 <decodeRISCVMMUInvocation+0x3b8>
    0x84016a22    0x4d8    li a5,8
    0x84016a24    0x4da    auipc a4,0x7
    0x84016a28    0x4de    sd a5,596(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016a2c    0x4e2    mv s0,s4
    0x84016a2e    0x4e4    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016a30    0x4e6    auipc a5,0x7
    0x84016a34    0x4ea    addi a5,a5,536 # ffffffff8401dc48 <current_syscall_error>
    0x84016a38    0x4ee    li a4,1
    0x84016a3a    0x4f0    sd a4,48(a5)
    0x84016a3c    0x4f2    sd zero,0(a5)
    0x84016a40    0x4f6    mv s0,s4
    0x84016a42    0x4f8    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016a44    0x4fa    li a5,8
    0x84016a46    0x4fc    auipc a4,0x7
    0x84016a4a    0x500    sd a5,562(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016a4e    0x504    mv s0,s4
    0x84016a50    0x506    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016a52    0x508    beqz a0,ffffffff84016950 <decodeRISCVMMUInvocation+0x406>
    0x84016a56    0x50c    j ffffffff8401696a <decodeRISCVMMUInvocation+0x420>
    0x84016a58    0x50e    li a1,2
    0x84016a5a    0x510    auipc a0,0x18
    0x84016a5e    0x514    ld a0,62(a0) # ffffffff8402ea98 <ksCurThread>
    0x84016a62    0x518    jal ra,ffffffff84013020 <setThreadState>
    0x84016a66    0x51c    mv a2,s3
    0x84016a68    0x51e    ld a0,32(sp)          ; stack access
    0x84016a6a    0x520    ld a1,40(sp)          ; stack access
    0x84016a6c    0x522    jal ra,ffffffff84011586 <performPageInvocationUnmap>
    0x84016a70    0x526    mv s0,a0
    0x84016a72    0x528    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016a74    0x52a    auipc s0,0x18
    0x84016a78    0x52e    addi s0,s0,36 # ffffffff8402ea98 <ksCurThread>
    0x84016a7c    0x532    li a1,2
    0x84016a7e    0x534    ld a0,0(s0)
    0x84016a80    0x536    jal ra,ffffffff84013020 <setThreadState>
    0x84016a84    0x53a    ld a0,32(sp)          ; stack access
    0x84016a86    0x53c    ld a1,40(sp)          ; stack access
    0x84016a88    0x53e    jal ra,ffffffff84010a5a <cap_frame_cap_get_capFBasePtr>
    0x84016a8c    0x542    ld s0,0(s0)
    0x84016a8e    0x544    li a5,1
    0x84016a90    0x546    slli a5,a5,0x26
    0x84016a92    0x548    add a0,a0,a5
    0x84016a94    0x54a    sd a0,88(s0)
    0x84016a96    0x54c    li a3,1
    0x84016a98    0x54e    li a2,0
    0x84016a9a    0x550    li a1,0
    0x84016a9c    0x552    li a0,0
    0x84016a9e    0x554    jal ra,ffffffff840100f4 <seL4_MessageInfo_new>
    0x84016aa2    0x558    sd a0,80(s0)
    0x84016aa4    0x55a    li s0,0
    0x84016aa6    0x55c    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016aa8    0x55e    li a5,35
    0x84016aac    0x562    beq s1,a5,ffffffff84016ada <decodeRISCVMMUInvocation+0x590>
    0x84016ab0    0x566    li a5,3
    0x84016ab2    0x568    auipc a4,0x7
    0x84016ab6    0x56c    sd a5,454(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016aba    0x570    li s0,3
    0x84016abc    0x572    mv a0,s0
    0x84016abe    0x574    ld ra,200(sp)         ; stack access
    0x84016ac0    0x576    ld s0,192(sp)         ; stack access
    0x84016ac2    0x578    ld s1,184(sp)         ; stack access
    0x84016ac4    0x57a    ld s2,176(sp)         ; stack access
    0x84016ac6    0x57c    ld s3,168(sp)         ; stack access
    0x84016ac8    0x57e    ld s4,160(sp)         ; stack access
    0x84016aca    0x580    ld s5,152(sp)         ; stack access
    0x84016acc    0x582    ld s6,144(sp)         ; stack access
    0x84016ace    0x584    ld s7,136(sp)         ; stack access
    0x84016ad0    0x586    ld s8,128(sp)         ; stack access
    0x84016ad2    0x588    ld s9,120(sp)         ; stack access
    0x84016ad4    0x58a    ld s10,112(sp)        ; stack access
    0x84016ad6    0x58c    addi sp,sp,208
    0x84016ad8    0x58e    ret
    0x84016ada    0x590    li a5,1
    0x84016adc    0x592    bgeu a5,s2,ffffffff84016b42 <decodeRISCVMMUInvocation+0x5f8>
    0x84016ae0    0x596    auipc s2,0x7
    0x84016ae4    0x59a    ld s2,416(s2) # ffffffff8401dc80 <current_extra_caps>
    0x84016ae8    0x59e    beqz s2,ffffffff84016b42 <decodeRISCVMMUInvocation+0x5f8>
    0x84016aec    0x5a2    auipc a5,0x7
    0x84016af0    0x5a6    ld a5,412(a5) # ffffffff8401dc88 <current_extra_caps+0x8>
    0x84016af4    0x5aa    beqz a5,ffffffff84016b42 <decodeRISCVMMUInvocation+0x5f8>
    0x84016af6    0x5ac    auipc a4,0x18
    0x84016afa    0x5b0    ld a4,-94(a4) # ffffffff8402ea98 <ksCurThread>
    0x84016afe    0x5b4    ld s3,88(a4)
    0x84016b02    0x5b8    ld s4,96(a4)
    0x84016b06    0x5bc    ld a4,0(s2)
    0x84016b0a    0x5c0    sd a4,48(sp)          ; stack access
    0x84016b0c    0x5c2    ld a4,8(s2)
    0x84016b10    0x5c6    sd a4,56(sp)          ; stack access
    0x84016b12    0x5c8    ld a4,0(a5)
    0x84016b14    0x5ca    sd a4,64(sp)          ; stack access
    0x84016b16    0x5cc    ld a5,8(a5)
    0x84016b18    0x5ce    sd a5,72(sp)          ; stack access
    0x84016b1a    0x5d0    auipc a5,0x6
    0x84016b1e    0x5d4    addi a5,a5,-754 # ffffffff8401c828 <riscvKSASIDTable>
    0x84016b22    0x5d8    li s1,0
    0x84016b24    0x5da    li a3,128
    0x84016b28    0x5de    ld a4,0(a5)
    0x84016b2a    0x5e0    beqz a4,ffffffff84016b50 <decodeRISCVMMUInvocation+0x606>
    0x84016b2c    0x5e2    addi s1,s1,1
    0x84016b2e    0x5e4    addi a5,a5,8
    0x84016b30    0x5e6    bne s1,a3,ffffffff84016b28 <decodeRISCVMMUInvocation+0x5de>
    0x84016b34    0x5ea    li a5,8
    0x84016b36    0x5ec    auipc a4,0x7
    0x84016b3a    0x5f0    sd a5,322(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016b3e    0x5f4    li s0,3
    0x84016b40    0x5f6    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016b42    0x5f8    li a5,7
    0x84016b44    0x5fa    auipc a4,0x7
    0x84016b48    0x5fe    sd a5,308(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016b4c    0x602    li s0,3
    0x84016b4e    0x604    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016b50    0x606    li a5,128
    0x84016b54    0x60a    beq s1,a5,ffffffff84016b34 <decodeRISCVMMUInvocation+0x5ea>
    0x84016b58    0x60e    ld a0,48(sp)          ; stack access
    0x84016b5a    0x610    ld a1,56(sp)          ; stack access
    0x84016b5c    0x612    jal ra,ffffffff8401039e <cap_get_capType>
    0x84016b60    0x616    li a5,2
    0x84016b62    0x618    bne a0,a5,ffffffff84016b7e <decodeRISCVMMUInvocation+0x634>
    0x84016b66    0x61c    ld a0,48(sp)          ; stack access
    0x84016b68    0x61e    ld a1,56(sp)          ; stack access
    0x84016b6a    0x620    jal ra,ffffffff84010410 <cap_untyped_cap_get_capBlockSize>
    0x84016b6e    0x624    li a5,12
    0x84016b70    0x626    bne a0,a5,ffffffff84016b7e <decodeRISCVMMUInvocation+0x634>
    0x84016b74    0x62a    ld a0,48(sp)          ; stack access
    0x84016b76    0x62c    ld a1,56(sp)          ; stack access
    0x84016b78    0x62e    jal ra,ffffffff84010404 <cap_untyped_cap_get_capIsDevice>
    0x84016b7c    0x632    beqz a0,ffffffff84016b92 <decodeRISCVMMUInvocation+0x648>
    0x84016b7e    0x634    auipc a5,0x7
    0x84016b82    0x638    addi a5,a5,202 # ffffffff8401dc48 <current_syscall_error>
    0x84016b86    0x63c    li a4,2
    0x84016b88    0x63e    sd a4,48(a5)
    0x84016b8a    0x640    li a4,1
    0x84016b8c    0x642    sd a4,8(a5)
    0x84016b8e    0x644    li s0,3
    0x84016b90    0x646    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016b92    0x648    mv a0,s2
    0x84016b94    0x64a    jal ra,ffffffff840129a8 <ensureNoChildren>
    0x84016b98    0x64e    mv s0,a0
    0x84016b9a    0x650    bnez a0,ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016b9c    0x652    ld a0,48(sp)          ; stack access
    0x84016b9e    0x654    ld a1,56(sp)          ; stack access
    0x84016ba0    0x656    jal ra,ffffffff840109e0 <cap_untyped_cap_get_capPtr>
    0x84016ba4    0x65a    mv s5,a0
    0x84016ba6    0x65c    mv a3,s4
    0x84016ba8    0x65e    mv a2,s3
    0x84016baa    0x660    ld a0,64(sp)          ; stack access
    0x84016bac    0x662    ld a1,72(sp)          ; stack access
    0x84016bae    0x664    jal ra,ffffffff84011d7a <lookupTargetSlot>
    0x84016bb2    0x668    sd a0,80(sp)          ; stack access
    0x84016bb4    0x66a    sd a1,88(sp)          ; stack access
    0x84016bb6    0x66c    mv s0,a0
    0x84016bb8    0x66e    bnez a0,ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016bbc    0x672    mv s3,a1
    0x84016bbe    0x674    mv a0,a1
    0x84016bc0    0x676    jal ra,ffffffff8401225c <ensureEmptySlot>
    0x84016bc4    0x67a    mv s0,a0
    0x84016bc6    0x67c    bnez a0,ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016bca    0x680    li a1,2
    0x84016bcc    0x682    auipc a0,0x18
    0x84016bd0    0x686    ld a0,-308(a0) # ffffffff8402ea98 <ksCurThread>
    0x84016bd4    0x68a    jal ra,ffffffff84013020 <setThreadState>
    0x84016bd8    0x68e    ld a0,0(s2)
    0x84016bdc    0x692    ld a1,8(s2)
    0x84016be0    0x696    jal ra,ffffffff84010410 <cap_untyped_cap_get_capBlockSize>
    0x84016be4    0x69a    addiw a0,a0,-4
    0x84016be6    0x69c    li a1,1
    0x84016be8    0x69e    sll a1,a1,a0
    0x84016bec    0x6a2    mv a0,s2
    0x84016bee    0x6a4    jal ra,ffffffff840103f6 <cap_untyped_cap_ptr_set_capFreeIndex>
    0x84016bf2    0x6a8    lui a1,0x1
    0x84016bf4    0x6aa    mv a0,s5
    0x84016bf6    0x6ac    jal ra,ffffffff840164dc <memzero>
    0x84016bfa    0x6b0    mv a1,s5
    0x84016bfc    0x6b2    slli a0,s1,0x9
    0x84016c00    0x6b6    jal ra,ffffffff8401077e <cap_asid_pool_cap_new>
    0x84016c04    0x6ba    mv a3,s3
    0x84016c06    0x6bc    mv a2,s2
    0x84016c08    0x6be    jal ra,ffffffff84011e56 <cteInsert>
    0x84016c0c    0x6c2    slli a5,s1,0x9
    0x84016c10    0x6c6    srli a5,a5,0x6
    0x84016c12    0x6c8    auipc a4,0x6
    0x84016c16    0x6cc    addi a4,a4,-1002 # ffffffff8401c828 <riscvKSASIDTable>
    0x84016c1a    0x6d0    add a5,a5,a4
    0x84016c1c    0x6d2    sd s5,0(a5)
    0x84016c20    0x6d6    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016c22    0x6d8    auipc s4,0x7
    0x84016c26    0x6dc    ld s4,94(s4) # ffffffff8401dc80 <current_extra_caps>
    0x84016c2a    0x6e0    beqz s4,ffffffff84016c94 <decodeRISCVMMUInvocation+0x74a>
    0x84016c2e    0x6e4    ld a0,0(s4)
    0x84016c32    0x6e8    sd a0,64(sp)          ; stack access
    0x84016c34    0x6ea    ld a1,8(s4)
    0x84016c38    0x6ee    sd a1,72(sp)          ; stack access
    0x84016c3a    0x6f0    jal ra,ffffffff8401039e <cap_get_capType>
    0x84016c3e    0x6f4    mv s0,a0
    0x84016c40    0x6f6    li a5,3
    0x84016c42    0x6f8    bne a0,a5,ffffffff84016ca2 <decodeRISCVMMUInvocation+0x758>
    0x84016c46    0x6fc    ld a0,64(sp)          ; stack access
    0x84016c48    0x6fe    ld a1,72(sp)          ; stack access
    0x84016c4a    0x700    jal ra,ffffffff8401072c <cap_page_table_cap_get_capPTIsMapped>
    0x84016c4e    0x704    mv s3,a0
    0x84016c50    0x706    bnez a0,ffffffff84016ca2 <decodeRISCVMMUInvocation+0x758>
    0x84016c52    0x708    ld a0,16(sp)          ; stack access
    0x84016c54    0x70a    ld a1,24(sp)          ; stack access
    0x84016c56    0x70c    jal ra,ffffffff8401079c <cap_asid_pool_cap_get_capASIDBase>
    0x84016c5a    0x710    mv s1,a0
    0x84016c5c    0x712    srli a5,a0,0x9
    0x84016c60    0x716    slli a4,a5,0x3
    0x84016c64    0x71a    auipc a5,0x6
    0x84016c68    0x71e    addi a5,a5,-1084 # ffffffff8401c828 <riscvKSASIDTable>
    0x84016c6c    0x722    add a5,a5,a4
    0x84016c6e    0x724    ld s2,0(a5)
    0x84016c72    0x728    beqz s2,ffffffff84016cb6 <decodeRISCVMMUInvocation+0x76c>
    0x84016c76    0x72c    ld a0,16(sp)          ; stack access
    0x84016c78    0x72e    ld a1,24(sp)          ; stack access
    0x84016c7a    0x730    jal ra,ffffffff84010a92 <cap_asid_pool_cap_get_capASIDPool>
    0x84016c7e    0x734    beq s2,a0,ffffffff84016d4a <decodeRISCVMMUInvocation+0x800>
    0x84016c82    0x738    auipc a5,0x7
    0x84016c86    0x73c    addi a5,a5,-58 # ffffffff8401dc48 <current_syscall_error>
    0x84016c8a    0x740    li a4,2
    0x84016c8c    0x742    sd a4,48(a5)
    0x84016c8e    0x744    sd zero,8(a5)
    0x84016c92    0x748    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016c94    0x74a    li a5,7
    0x84016c96    0x74c    auipc a4,0x7
    0x84016c9a    0x750    sd a5,-30(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016c9e    0x754    li s0,3
    0x84016ca0    0x756    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016ca2    0x758    auipc a5,0x7
    0x84016ca6    0x75c    addi a5,a5,-90 # ffffffff8401dc48 <current_syscall_error>
    0x84016caa    0x760    li a4,2
    0x84016cac    0x762    sd a4,48(a5)
    0x84016cae    0x764    li a4,1
    0x84016cb0    0x766    sd a4,8(a5)
    0x84016cb2    0x768    li s0,3
    0x84016cb4    0x76a    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016cb6    0x76c    auipc a5,0x7
    0x84016cba    0x770    addi a5,a5,-110 # ffffffff8401dc48 <current_syscall_error>
    0x84016cbe    0x774    li a4,6
    0x84016cc0    0x776    sd a4,48(a5)
    0x84016cc2    0x778    sd zero,40(a5)
    0x84016cc6    0x77c    jal ra,ffffffff840107b0 <lookup_fault_invalid_root_new>
    0x84016cca    0x780    auipc a5,0x7
    0x84016cce    0x784    addi a5,a5,-154 # ffffffff8401dc30 <current_lookup_fault>
    0x84016cd2    0x788    sd a0,0(a5)
    0x84016cd4    0x78a    sd a1,8(a5)
    0x84016cd6    0x78c    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016cd8    0x78e    addi a5,a5,1
    0x84016cda    0x790    beq a5,a3,ffffffff84016d52 <decodeRISCVMMUInvocation+0x808>
    0x84016cde    0x794    add a4,s1,a5
    0x84016ce2    0x798    beqz a4,ffffffff84016cd8 <decodeRISCVMMUInvocation+0x78e>
    0x84016ce4    0x79a    slli a4,a5,0x3
    0x84016ce8    0x79e    add a4,a4,s2
    0x84016cea    0x7a0    ld a4,0(a4)
    0x84016cec    0x7a2    bnez a4,ffffffff84016cd8 <decodeRISCVMMUInvocation+0x78e>
    0x84016cee    0x7a4    li a4,512
    0x84016cf2    0x7a8    beq a5,a4,ffffffff84016d52 <decodeRISCVMMUInvocation+0x808>
    0x84016cf6    0x7ac    add s1,s1,a5
    0x84016cf8    0x7ae    li a1,2
    0x84016cfa    0x7b0    auipc a0,0x18
    0x84016cfe    0x7b4    ld a0,-610(a0) # ffffffff8402ea98 <ksCurThread>
    0x84016d02    0x7b8    jal ra,ffffffff84013020 <setThreadState>
    0x84016d06    0x7bc    ld s6,0(s4)
    0x84016d0a    0x7c0    ld s5,8(s4)
    0x84016d0e    0x7c4    mv a0,s6
    0x84016d10    0x7c6    mv a1,s5
    0x84016d12    0x7c8    jal ra,ffffffff84010a76 <cap_page_table_cap_get_capPTBasePtr>
    0x84016d16    0x7cc    mv s0,a0
    0x84016d18    0x7ce    mv a2,s1
    0x84016d1a    0x7d0    mv a0,s6
    0x84016d1c    0x7d2    mv a1,s5
    0x84016d1e    0x7d4    jal ra,ffffffff8401071e <cap_page_table_cap_set_capPTMappedASID>
    0x84016d22    0x7d8    li a2,0
    0x84016d24    0x7da    jal ra,ffffffff8401075e <cap_page_table_cap_set_capPTMappedAddress>
    0x84016d28    0x7de    li a2,1
    0x84016d2a    0x7e0    jal ra,ffffffff84010736 <cap_page_table_cap_set_capPTIsMapped>
    0x84016d2e    0x7e4    sd a0,0(s4)
    0x84016d32    0x7e8    sd a1,8(s4)
    0x84016d36    0x7ec    mv a0,s0
    0x84016d38    0x7ee    jal ra,ffffffff84010ee8 <copyGlobalMappings>
    0x84016d3c    0x7f2    andi s1,s1,511
    0x84016d40    0x7f6    slli s1,s1,0x3
    0x84016d42    0x7f8    add s1,s1,s2
    0x84016d44    0x7fa    sd s0,0(s1)
    0x84016d46    0x7fc    mv s0,s3
    0x84016d48    0x7fe    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016d4a    0x800    mv a5,s3
    0x84016d4c    0x802    li a3,512
    0x84016d50    0x806    j ffffffff84016cde <decodeRISCVMMUInvocation+0x794>
    0x84016d52    0x808    li a5,8
    0x84016d54    0x80a    auipc a4,0x7
    0x84016d58    0x80e    sd a5,-220(a4) # ffffffff8401dc78 <current_syscall_error+0x30>
    0x84016d5c    0x812    j ffffffff84016abc <decodeRISCVMMUInvocation+0x572>
    0x84016d5e    0x814    jal ra,ffffffff84010cec <halt>
    0x84016d62    0x818    lui a4,0x200
    0x84016d66    0x81c    addi a4,a4,-1
    0x84016d68    0x81e    add a4,a4,s5
    0x84016d6a    0x820    lui a5,0xfefff
    0x84016d6e    0x824    slli a5,a5,0xe
    0x84016d70    0x826    srli a5,a5,0x1a
    0x84016d72    0x828    bltu a5,a4,ffffffff8401698e <decodeRISCVMMUInvocation+0x444>
    0x84016d76    0x82c    slli a5,s5,0x2b
    0x84016d7a    0x830    bnez a5,ffffffff840169a2 <decodeRISCVMMUInvocation+0x458>
    0x84016d7e    0x834    mv a1,s5
    0x84016d80    0x836    mv a0,s10
    0x84016d82    0x838    jal ra,ffffffff84011116 <lookupPTSlot>
    0x84016d86    0x83c    mv s2,a0
    0x84016d88    0x83e    sd a0,80(sp)          ; stack access
    0x84016d8a    0x840    sd a1,88(sp)          ; stack access
    0x84016d8c    0x842    li a5,21
    0x84016d8e    0x844    j ffffffff840168e8 <decodeRISCVMMUInvocation+0x39e>
    0x84016d90    0x846    lui a4,0x40000
    0x84016d94    0x84a    addi a4,a4,-1
    0x84016d96    0x84c    add a4,a4,s5
    0x84016d98    0x84e    lui a5,0xfefff
    0x84016d9c    0x852    slli a5,a5,0xe
    0x84016d9e    0x854    srli a5,a5,0x1a
    0x84016da0    0x856    bltu a5,a4,ffffffff8401698e <decodeRISCVMMUInvocation+0x444>
    0x84016da4    0x85a    slli a5,s5,0x22
    0x84016da8    0x85e    bnez a5,ffffffff840169a2 <decodeRISCVMMUInvocation+0x458>
    0x84016dac    0x862    mv a1,s5
    0x84016dae    0x864    mv a0,s10
    0x84016db0    0x866    jal ra,ffffffff84011116 <lookupPTSlot>
    0x84016db4    0x86a    mv s2,a0
    0x84016db6    0x86c    sd a0,80(sp)          ; stack access
    0x84016db8    0x86e    sd a1,88(sp)          ; stack access
    0x84016dba    0x870    li a5,30
    0x84016dbc    0x872    j ffffffff840168e8 <decodeRISCVMMUInvocation+0x39e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
769 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeRISCVMMUInvocation` has 1233 nodes.

Completing graph
-----------------

Evaluating graph
----------------

The graph for `instruction'csrrc_a5_sie_a5_84012386` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrrs_a5_sie_a5_84012390` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrr_a0_sip_84011E46` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_8401157C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_84011566` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ecall_84010CF4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sscratch_t0_84010CD4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sstatus_t1_84010CDC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sepc_t1_84010CD0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sret_84010CE8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrr_a0_sip_84010986` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'wfi_840108F6` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrrs_a5_sie_a5_8400032E` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ecall_840002E8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'rdtime_a0_840002DA` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_zero_a0_8401146C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_satp_a0_84000158` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_8400015C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sscratch_zero_84000014` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'fence_i_84000000` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrr_a0_stval_84011196` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrr_s0_scause_8401008C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrr_ra_sscratch_8401007C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrr_ra_sstatus_84010084` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrr_ra_sepc_840100A0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrrw_t0_sscratch_t0_84010000` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrr_a0_scause_84015070` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_8400027A` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_84000204` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_satp_a0_840113D6` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_satp_a0_840113B4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_satp_a0_8401136E` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_84011372` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_840113DA` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_840113B8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrrc_a5_sie_a5_84014886` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ecall_84014846` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'rdtime_a5_84014836` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'rdtime_a4_8401484A` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_8401129E` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_8401132C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sscratch_t0_840179A0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sstatus_t1_840179A8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_satp_a0_8401790A` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sepc_t1_8401799C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sret_840179B4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_8401790E` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sscratch_t0_84017D5A` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sstatus_t1_84017D62` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_satp_a0_84017CC4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sepc_t1_84017D56` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sret_84017D6E` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_84017CC8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_stvec_a5_840012EE` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrc_sstatus_a5_840012FC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'unimp_840014FE` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_84016988` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_840166AA` has 0 nodes.

Proving correctness of call offsets
===================================

Offsets proved correct.

Summary
=======

No stack intro failures.
No graph spec failures.
No export failures.
No call offset failures.
> 