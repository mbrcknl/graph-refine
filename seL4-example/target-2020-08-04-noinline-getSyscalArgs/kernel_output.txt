
---------------------------------------------------------------------
       HOL-4 [Kananaskis 13 (stdknl, built Tue Jun 16 16:11:50 2020)]

       For introductory HOL help, type: help "hol";
       To exit type <Control>-D
---------------------------------------------------------------------
** Load path (see loadPath variable) now contains 18 entries
** after consulting Holmakefiles

[In non-standard heap: /home/matthewb/verification/bv/HOL4/examples/machine-code/graph/local-hol-heap]
> > 
Resetting specifications database.

Specializing fetch: 4 -> 1(1)
Specializing decode ARM (cond = 14): 95 -> 95(95)
Specializing decode ARM (cond = 15): 5 -> 5(5)
Specializing decode ARM (cond not in {14, 15}): 95 -> 95(95)
Specializing decode ARM (fallback): 1 -> 1(1)
Specializing eval: 374 -> 348(348)
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
val it = (): unit
> ======================================================================
  Base name: /home/matthewb/verification/bv/graph-refine-master/seL4-example/target/RISCV64-O1/kernel
  Poly/ML: 580
  HOL: Kananaskis 13 (stdknl) commit 08998e3c2
======================================================================
  Reading /home/matthewb/verification/bv/graph-refine-master/seL4-example/target/RISCV64-O1/kernel.elf.txt, done.
  Reading /home/matthewb/verification/bv/graph-refine-master/seL4-example/target/RISCV64-O1/kernel.elf.txt, done.
  Reading /home/matthewb/verification/bv/graph-refine-master/seL4-example/target/RISCV64-O1/kernel.sigs, done.
No signature info for section: _start
No signature info for section: avail_p_regs
No signature info for section: ndks_boot
No signature info for section: rootserver
No signature info for section: rootserver_mem
No signature info for section: avail_reg
No signature info for section: res_reg
No signature info for section: trap_entry
No signature info for section: syscall
No signature info for section: exception
No signature info for section: interrupt
No signature info for section: __clzsi2
No signature info for section: __ctzsi2
No signature info for section: __clzdi2
No signature info for section: __ctzdi2
======================================================================
  Total: 271 functions, 13093 RISC-V instructions
  Longest function: decodeRISCVMMUInvocation (768 instructions)
  0 deps: 90 functions (avail_p_regs, ndks_boot, rootserver, ...)
  1 deps: 78 functions (str_to_long, memset, ...)
  2 deps: 38 functions (fastpath_reply_recv, fastpath_call, ...)
  3 deps: 32 functions (c_handle_syscall, slowpath, ...)
  4 deps: 6 functions (invokeUntyped_Retype, handleVMFaultEvent, ...)
  5 deps: 11 functions (decodeSetIPCBuffer, ...)
  6 deps: 3 functions (sendIPC, cteDelete, ...)
  7 deps: 5 functions (handleInvocation, decodeUntypedInvocation, ...)
  8 deps: 2 functions (decodeTCBConfigure, finaliseCap)
  11 deps: 1 functions (handleSyscall)
  12 deps: 1 functions (decodeInvocation)
  15 deps: 1 functions (decodeRISCVMMUInvocation)
  16 deps: 1 functions (decodeTCBInvocation)
  17 deps: 1 functions (decodeCNodeInvocation)
  26 deps: 1 functions (init_kernel)
======================================================================

Section avail_p_regs (1 of 271)
===============================

Deriving specifications
-----------------------

Section `avail_p_regs` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `avail_p_regs` has 0 nodes.

Section ndks_boot (2 of 271)
============================

Deriving specifications
-----------------------

Section `ndks_boot` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `ndks_boot` has 0 nodes.

Section rootserver (3 of 271)
=============================

Deriving specifications
-----------------------

Section `rootserver` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `rootserver` has 0 nodes.

Section rootserver_mem (4 of 271)
=================================

Deriving specifications
-----------------------

Section `rootserver_mem` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `rootserver_mem` has 0 nodes.

Section avail_reg (5 of 271)
============================

Deriving specifications
-----------------------

Section `avail_reg` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `avail_reg` has 0 nodes.

Section res_reg (6 of 271)
==========================

Deriving specifications
-----------------------

Section `res_reg` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `res_reg` has 0 nodes.

Section __ctzdi2 (7 of 271)
===========================

Deriving specifications
-----------------------

Section `__ctzdi2` consists of 13 instructions.

RVC_TFFFFT___FT___TF..
ANDI..
RVC_TTT___________FT.
RVC_FTF___________FT.
ADDI..
RVC_TFF_FF________FT.
RVC_FFT___________FT.
BNE..
RVC_TFFFFFFFTFFFFFTF.

Stack analysis
---------------

No stack accesses found. Code for `__ctzdi2`:

    0x8401752e     0x0    mv a5,a0
    0x84017530     0x2    andi a4,a0,1
    0x84017534     0x6    bnez a4,ffffffff8401754c <__ctzdi2+0x1e>
    0x84017536     0x8    li a0,0
    0x84017538     0xa    li a3,65
    0x8401753c     0xe    srli a5,a5,0x1
    0x8401753e    0x10    addiw a0,a0,1
    0x84017540    0x12    andi a4,a5,1
    0x84017544    0x16    bnez a4,ffffffff8401754e <__ctzdi2+0x20>
    0x84017546    0x18    bne a0,a3,ffffffff8401753c <__ctzdi2+0xe>
    0x8401754a    0x1c    ret
    0x8401754c    0x1e    li a0,0
    0x8401754e    0x20    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `__ctzdi2` has 21 nodes.

Section __clzdi2 (8 of 271)
===========================

Deriving specifications
-----------------------

Section `__clzdi2` consists of 11 instructions.

BLT..
RVC_FFF___________TF.

Stack analysis
---------------

No stack accesses found. Code for `__clzdi2`:

    0x84017510     0x0    mv a5,a0
    0x84017512     0x2    bltz a0,ffffffff8401752a <__clzdi2+0x1a>
    0x84017516     0x6    li a0,0
    0x84017518     0x8    li a4,65
    0x8401751c     0xc    slli a5,a5,0x1
    0x8401751e     0xe    addiw a0,a0,1
    0x84017520    0x10    bltz a5,ffffffff8401752c <__clzdi2+0x1c>
    0x84017524    0x14    bne a0,a4,ffffffff8401751c <__clzdi2+0xc>
    0x84017528    0x18    ret
    0x8401752a    0x1a    li a0,0
    0x8401752c    0x1c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `__clzdi2` has 19 nodes.

Section __ctzsi2 (9 of 271)
===========================

Deriving specifications
-----------------------

Section `__ctzsi2` consists of 13 instructions.

RVC_TFF_TF________FT.
SRLIW..
ADDIW..

Stack analysis
---------------

No stack accesses found. Code for `__ctzsi2`:

    0x840174ee     0x0    mv a4,a0
    0x840174f0     0x2    andi a0,a0,1
    0x840174f2     0x4    bnez a0,ffffffff8401750c <__ctzsi2+0x1e>
    0x840174f4     0x6    li a3,33
    0x840174f8     0xa    srliw a5,a4,0x1
    0x840174fc     0xe    sext.w a4,a5
    0x84017500    0x12    addiw a0,a0,1
    0x84017502    0x14    andi a5,a5,1
    0x84017504    0x16    bnez a5,ffffffff8401750e <__ctzsi2+0x20>
    0x84017506    0x18    bne a0,a3,ffffffff840174f8 <__ctzsi2+0xa>
    0x8401750a    0x1c    ret
    0x8401750c    0x1e    li a0,0
    0x8401750e    0x20    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `__ctzsi2` has 21 nodes.

Section __clzsi2 (10 of 271)
============================

Deriving specifications
-----------------------

Section `__clzsi2` consists of 12 instructions.

SLLIW..

Stack analysis
---------------

No stack accesses found. Code for `__clzsi2`:

    0x840174ca     0x0    mv a4,a0
    0x840174cc     0x2    bltz a0,ffffffff840174ea <__clzsi2+0x20>
    0x840174d0     0x6    li a0,0
    0x840174d2     0x8    li a3,34
    0x840174d6     0xc    slliw a5,a4,0x1
    0x840174da    0x10    sext.w a4,a5
    0x840174de    0x14    addiw a0,a0,1
    0x840174e0    0x16    bltz a4,ffffffff840174ec <__clzsi2+0x22>
    0x840174e4    0x1a    bne a0,a3,ffffffff840174d6 <__clzsi2+0xc>
    0x840174e8    0x1e    ret
    0x840174ea    0x20    li a0,0
    0x840174ec    0x22    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `__clzsi2` has 20 nodes.

Section char_to_long (11 of 271)
================================

Deriving specifications
-----------------------

Section `char_to_long` consists of 20 instructions.

BGEU..
BLTU..

Stack analysis
---------------

No stack accesses found. Code for `char_to_long`:

    0x84017416     0x0    addiw a5,a0,-48
    0x8401741a     0x4    andi a5,a5,255
    0x8401741e     0x8    li a4,9
    0x84017420     0xa    bgeu a4,a5,ffffffff84017446 <char_to_long+0x30>
    0x84017424     0xe    addiw a5,a0,-65
    0x84017428    0x12    andi a5,a5,255
    0x8401742c    0x16    li a4,5
    0x8401742e    0x18    bgeu a4,a5,ffffffff8401744c <char_to_long+0x36>
    0x84017432    0x1c    addiw a5,a0,-97
    0x84017436    0x20    andi a5,a5,255
    0x8401743a    0x24    li a4,5
    0x8401743c    0x26    bltu a4,a5,ffffffff84017452 <char_to_long+0x3c>
    0x84017440    0x2a    addiw a0,a0,-87
    0x84017444    0x2e    ret
    0x84017446    0x30    addiw a0,a0,-48
    0x8401744a    0x34    ret
    0x8401744c    0x36    addiw a0,a0,-55
    0x84017450    0x3a    ret
    0x84017452    0x3c    li a0,-1
    0x84017454    0x3e    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `char_to_long` has 30 nodes.

Section strncmp (12 of 271)
===========================

Deriving specifications
-----------------------

Section `strncmp` consists of 14 instructions.

RVC_TTF___________FT.
RVC_TFFTFT___FT___TF..
LBU..
SUBW.....
RVC_FFFFFT________FT.

Stack analysis
---------------

No stack accesses found. Code for `strncmp`:

    0x840173f2     0x0    beqz a2,ffffffff84017412 <strncmp+0x20>
    0x840173f4     0x2    mv a5,a0
    0x840173f6     0x4    add a2,a2,a0
    0x840173f8     0x6    lbu a4,0(a5)
    0x840173fc     0xa    lbu a0,0(a1)
    0x84017400     0xe    subw a0,a4,a0
    0x84017404    0x12    bnez a0,ffffffff84017414 <strncmp+0x22>
    0x84017406    0x14    beqz a4,ffffffff84017414 <strncmp+0x22>
    0x84017408    0x16    addi a5,a5,1
    0x8401740a    0x18    addi a1,a1,1
    0x8401740c    0x1a    bne a5,a2,ffffffff840173f8 <strncmp+0x6>
    0x84017410    0x1e    ret
    0x84017412    0x20    li a0,0
    0x84017414    0x22    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `strncmp` has 26 nodes.

Section memcpy (13 of 271)
==========================

Deriving specifications
-----------------------

Section `memcpy` consists of 9 instructions.

SB..

Stack analysis
---------------

No stack accesses found. Code for `memcpy`:

    0x840173da     0x0    beqz a2,ffffffff840173f0 <memcpy+0x16>
    0x840173dc     0x2    add a2,a2,a0
    0x840173de     0x4    mv a5,a0
    0x840173e0     0x6    lbu a4,0(a1)
    0x840173e4     0xa    sb a4,0(a5)
    0x840173e8     0xe    addi a5,a5,1
    0x840173ea    0x10    addi a1,a1,1
    0x840173ec    0x12    bne a2,a5,ffffffff840173e0 <memcpy+0x6>
    0x840173f0    0x16    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `memcpy` has 16 nodes.

Section memzero (14 of 271)
===========================

Deriving specifications
-----------------------

Section `memzero` consists of 7 instructions.

SD..

Stack analysis
---------------

No stack accesses found. Code for `memzero`:

    0x84015b8a     0x0    beqz a1,ffffffff84015b9a <memzero+0x10>
    0x84015b8c     0x2    mv a5,a0
    0x84015b8e     0x4    add a1,a1,a0
    0x84015b90     0x6    sd zero,0(a5)
    0x84015b94     0xa    addi a5,a5,8
    0x84015b96     0xc    bne a5,a1,ffffffff84015b90 <memzero+0x6>
    0x84015b9a    0x10    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `memzero` has 13 nodes.

Section strlcat (15 of 271)
===========================

Deriving specifications
-----------------------

Section `strlcat` consists of 31 instructions.

ADD.....
RVC_TFT___________FT.
SUB.....
RVC_TFFFFT___T____TF.

Stack analysis
---------------

No stack accesses found. Code for `strlcat`:

    0x84015b30     0x0    mv a3,a0
    0x84015b32     0x2    li a0,0
    0x84015b34     0x4    beqz a2,ffffffff84015b48 <strlcat+0x18>
    0x84015b36     0x6    add a5,a3,a0
    0x84015b3a     0xa    lbu a5,0(a5)
    0x84015b3e     0xe    beqz a5,ffffffff84015b4c <strlcat+0x1c>
    0x84015b40    0x10    addi a0,a0,1
    0x84015b42    0x12    bne a2,a0,ffffffff84015b36 <strlcat+0x6>
    0x84015b46    0x16    j ffffffff84015b84 <strlcat+0x54>
    0x84015b48    0x18    mv a0,a2
    0x84015b4a    0x1a    ret
    0x84015b4c    0x1c    bgeu a0,a2,ffffffff84015b84 <strlcat+0x54>
    0x84015b50    0x20    addi a5,a0,1
    0x84015b54    0x24    bgeu a5,a2,ffffffff84015b7e <strlcat+0x4e>
    0x84015b58    0x28    addi a6,a5,-1
    0x84015b5c    0x2c    sub a4,a5,a0
    0x84015b60    0x30    add a4,a4,a1
    0x84015b62    0x32    lbu a4,-1(a4)
    0x84015b66    0x36    beqz a4,ffffffff84015b7c <strlcat+0x4c>
    0x84015b68    0x38    add a6,a3,a5
    0x84015b6c    0x3c    sb a4,-1(a6)
    0x84015b70    0x40    addi a4,a5,1
    0x84015b74    0x44    bgeu a4,a2,ffffffff84015b86 <strlcat+0x56>
    0x84015b78    0x48    mv a5,a4
    0x84015b7a    0x4a    j ffffffff84015b58 <strlcat+0x28>
    0x84015b7c    0x4c    mv a0,a6
    0x84015b7e    0x4e    add a3,a3,a0
    0x84015b80    0x50    sb zero,0(a3)
    0x84015b84    0x54    ret
    0x84015b86    0x56    mv a0,a5
    0x84015b88    0x58    j ffffffff84015b7e <strlcat+0x4e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
31 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `strlcat` has 51 nodes.

Section strlcpy (16 of 271)
===========================

Deriving specifications
-----------------------

Section `strlcpy` consists of 19 instructions.

RVC_FFFT__________FT.

Stack analysis
---------------

No stack accesses found. Code for `strlcpy`:

    0x84015afe     0x0    mv a3,a0
    0x84015b00     0x2    li a5,1
    0x84015b02     0x4    bgeu a5,a2,ffffffff84015b2c <strlcpy+0x2e>
    0x84015b06     0x8    addi a2,a2,-1
    0x84015b08     0xa    li a5,0
    0x84015b0a     0xc    mv a0,a5
    0x84015b0c     0xe    addi a5,a5,1
    0x84015b0e    0x10    add a4,a1,a0
    0x84015b12    0x14    lbu a4,0(a4)
    0x84015b16    0x18    beqz a4,ffffffff84015b24 <strlcpy+0x26>
    0x84015b18    0x1a    add a0,a0,a3
    0x84015b1a    0x1c    sb a4,0(a0)
    0x84015b1e    0x20    bne a5,a2,ffffffff84015b0a <strlcpy+0xc>
    0x84015b22    0x24    mv a0,a5
    0x84015b24    0x26    add a3,a3,a0
    0x84015b26    0x28    sb zero,0(a3)
    0x84015b2a    0x2c    ret
    0x84015b2c    0x2e    li a0,0
    0x84015b2e    0x30    j ffffffff84015b24 <strlcpy+0x26>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
19 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `strlcpy` has 29 nodes.

Section strnlen (17 of 271)
===========================

Deriving specifications
-----------------------

Section `strnlen` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `strnlen`:

    0x84015ae2     0x0    mv a4,a0
    0x84015ae4     0x2    li a0,0
    0x84015ae6     0x4    beqz a1,ffffffff84015afa <strnlen+0x18>
    0x84015ae8     0x6    add a5,a4,a0
    0x84015aec     0xa    lbu a5,0(a5)
    0x84015af0     0xe    beqz a5,ffffffff84015af8 <strnlen+0x16>
    0x84015af2    0x10    addi a0,a0,1
    0x84015af4    0x12    bne a1,a0,ffffffff84015ae8 <strnlen+0x6>
    0x84015af8    0x16    ret
    0x84015afa    0x18    mv a0,a1
    0x84015afc    0x1a    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `strnlen` has 20 nodes.

Section copyMRs (18 of 271)
===========================

Deriving specifications
-----------------------

Section `copyMRs` consists of 46 instructions.

RVC_FTT___________FF..
RVC_TTT___________FF..
LD..

Stack analysis
---------------

No stack accesses found. Code for `copyMRs`:

    0x84013f90     0x0    mv a5,a0
    0x84013f92     0x2    mv a0,a4
    0x84013f94     0x4    beqz a4,ffffffff84013ff0 <copyMRs+0x60>
    0x84013f96     0x6    ld a4,88(a5)
    0x84013f98     0x8    sd a4,88(a2)
    0x84013f9a     0xa    li a4,1
    0x84013f9c     0xc    bgeu a4,a0,ffffffff84013fe4 <copyMRs+0x54>
    0x84013fa0    0x10    ld a4,96(a5)
    0x84013fa2    0x12    sd a4,96(a2)
    0x84013fa4    0x14    li a4,2
    0x84013fa6    0x16    bgeu a4,a0,ffffffff84013fe8 <copyMRs+0x58>
    0x84013faa    0x1a    ld a4,104(a5)
    0x84013fac    0x1c    sd a4,104(a2)
    0x84013fae    0x1e    li a4,3
    0x84013fb0    0x20    bgeu a4,a0,ffffffff84013fec <copyMRs+0x5c>
    0x84013fb4    0x24    ld a5,112(a5)
    0x84013fb6    0x26    sd a5,112(a2)
    0x84013fb8    0x28    li a5,4
    0x84013fba    0x2a    beqz a3,ffffffff84013ff4 <copyMRs+0x64>
    0x84013fbc    0x2c    beqz a1,ffffffff84013ff8 <copyMRs+0x68>
    0x84013fbe    0x2e    bgeu a5,a0,ffffffff84013ffc <copyMRs+0x6c>
    0x84013fc2    0x32    addi a5,a5,1
    0x84013fc4    0x34    slli a5,a5,0x3
    0x84013fc6    0x36    addi a4,a0,1
    0x84013fca    0x3a    slli a4,a4,0x3
    0x84013fcc    0x3c    add a2,a1,a5
    0x84013fd0    0x40    ld a6,0(a2)
    0x84013fd4    0x44    add a2,a3,a5
    0x84013fd8    0x48    sd a6,0(a2)
    0x84013fdc    0x4c    addi a5,a5,8
    0x84013fde    0x4e    bne a5,a4,ffffffff84013fcc <copyMRs+0x3c>
    0x84013fe2    0x52    ret
    0x84013fe4    0x54    li a5,1
    0x84013fe6    0x56    j ffffffff84013fba <copyMRs+0x2a>
    0x84013fe8    0x58    li a5,2
    0x84013fea    0x5a    j ffffffff84013fba <copyMRs+0x2a>
    0x84013fec    0x5c    li a5,3
    0x84013fee    0x5e    j ffffffff84013fba <copyMRs+0x2a>
    0x84013ff0    0x60    mv a5,a4
    0x84013ff2    0x62    j ffffffff84013fba <copyMRs+0x2a>
    0x84013ff4    0x64    mv a0,a5
    0x84013ff6    0x66    ret
    0x84013ff8    0x68    mv a0,a5
    0x84013ffa    0x6a    ret
    0x84013ffc    0x6c    mv a0,a5
    0x84013ffe    0x6e    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
46 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `copyMRs` has 76 nodes.

Section setExtraBadge (19 of 271)
=================================

Deriving specifications
-----------------------

Section `setExtraBadge` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setExtraBadge`:

    0x84013e96    0x0    addi a2,a2,122 # fffffffff800007a <ki_end+0x73fd107a>
    0x84013e9a    0x4    slli a2,a2,0x3
    0x84013e9c    0x6    add a0,a0,a2
    0x84013e9e    0x8    sd a1,0(a0)
    0x84013ea0    0xa    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setExtraBadge` has 7 nodes.

Section getExtraCPtr (20 of 271)
================================

Deriving specifications
-----------------------

Section `getExtraCPtr` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `getExtraCPtr`:

    0x84013e8a    0x0    addi a1,a1,122
    0x84013e8e    0x4    slli a1,a1,0x3
    0x84013e90    0x6    add a0,a0,a1
    0x84013e92    0x8    ld a0,0(a0)
    0x84013e94    0xa    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getExtraCPtr` has 7 nodes.

Section tcbEPDequeue (21 of 271)
================================

Deriving specifications
-----------------------

Section `tcbEPDequeue` consists of 19 instructions.

RVC_TTT___________TF..
RVC_FTT_FT________TF.
RVC_FTTFFFFTFFFFFTFT.

Stack analysis
---------------

2 stack accesses found. Annotated code for `tcbEPDequeue`:

    0x84012ec2     0x0    addi sp,sp,-32
    0x84012ec4     0x2    mv a5,a0
    0x84012ec6     0x4    sd a1,0(sp)           ; stack access
    0x84012ec8     0x6    mv a1,a2
    0x84012eca     0x8    ld a4,416(a0)
    0x84012ece     0xc    beqz a4,ffffffff84012eec <tcbEPDequeue+0x2a>
    0x84012ed0     0xe    ld a0,0(sp)           ; stack access
    0x84012ed2    0x10    ld a3,408(a5)
    0x84012ed6    0x14    sd a3,408(a4)
    0x84012eda    0x18    ld a4,408(a5)
    0x84012ede    0x1c    beqz a4,ffffffff84012ef2 <tcbEPDequeue+0x30>
    0x84012ee0    0x1e    ld a5,416(a5)
    0x84012ee4    0x22    sd a5,416(a4)
    0x84012ee8    0x26    addi sp,sp,32
    0x84012eea    0x28    ret
    0x84012eec    0x2a    ld a0,408(a0)
    0x84012ef0    0x2e    j ffffffff84012eda <tcbEPDequeue+0x18>
    0x84012ef2    0x30    ld a1,416(a5)
    0x84012ef6    0x34    j ffffffff84012ee8 <tcbEPDequeue+0x26>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
19 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbEPDequeue` has 34 nodes.

Section tcbEPAppend (22 of 271)
===============================

Deriving specifications
-----------------------

Section `tcbEPAppend` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `tcbEPAppend`:

    0x84012ea8     0x0    addi sp,sp,-32
    0x84012eaa     0x2    mv a5,a0
    0x84012eac     0x4    beqz a1,ffffffff84012eb4 <tcbEPAppend+0xc>
    0x84012eae     0x6    mv a0,a1
    0x84012eb0     0x8    sd a5,408(a2)
    0x84012eb4     0xc    sd a2,416(a5)
    0x84012eb8    0x10    sd zero,408(a5)
    0x84012ebc    0x14    mv a1,a5
    0x84012ebe    0x16    addi sp,sp,32
    0x84012ec0    0x18    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbEPAppend` has 16 nodes.

Section tcbSchedDequeue (23 of 271)
===================================

Deriving specifications
-----------------------

Section `tcbSchedDequeue` consists of 68 instructions.

SLLI..
AUIPC.
SRLI..
SLL.....
XORI..
RVC_TFFFTT___TT___FT..

Stack analysis
---------------

No stack accesses found. Code for `tcbSchedDequeue`:

    0x84012b0c     0x0    ld a5,288(a0)
    0x84012b10     0x4    andi a5,a5,1
    0x84012b12     0x6    beqz a5,ffffffff84012b80 <tcbSchedDequeue+0x74>
    0x84012b14     0x8    ld a1,344(a0)
    0x84012b18     0xc    ld a2,360(a0)
    0x84012b1c    0x10    slli a5,a1,0x8
    0x84012b20    0x14    add a5,a5,a2
    0x84012b22    0x16    slli a3,a5,0x4
    0x84012b26    0x1a    auipc a4,0x7
    0x84012b2a    0x1e    addi a4,a4,-806 # ffffffff84019800 <ksReadyQueues>
    0x84012b2e    0x22    add a4,a4,a3
    0x84012b30    0x24    ld a7,8(a4)
    0x84012b34    0x28    ld a3,400(a0)
    0x84012b38    0x2c    beqz a3,ffffffff84012b82 <tcbSchedDequeue+0x76>
    0x84012b3a    0x2e    slli a2,a5,0x4
    0x84012b3e    0x32    auipc a4,0x7
    0x84012b42    0x36    addi a4,a4,-830 # ffffffff84019800 <ksReadyQueues>
    0x84012b46    0x3a    add a4,a4,a2
    0x84012b48    0x3c    ld a6,0(a4)
    0x84012b4c    0x40    ld a4,392(a0)
    0x84012b50    0x44    sd a4,392(a3)
    0x84012b54    0x48    ld a4,392(a0)
    0x84012b58    0x4c    beqz a4,ffffffff84012be2 <tcbSchedDequeue+0xd6>
    0x84012b5a    0x4e    ld a3,400(a0)
    0x84012b5e    0x52    sd a3,400(a4)
    0x84012b62    0x56    slli a5,a5,0x4
    0x84012b64    0x58    auipc a4,0x7
    0x84012b68    0x5c    addi a4,a4,-868 # ffffffff84019800 <ksReadyQueues>
    0x84012b6c    0x60    add a5,a5,a4
    0x84012b6e    0x62    sd a6,0(a5)
    0x84012b72    0x66    sd a7,8(a5)
    0x84012b76    0x6a    ld a5,288(a0)
    0x84012b7a    0x6e    andi a5,a5,-2
    0x84012b7c    0x70    sd a5,288(a0)
    0x84012b80    0x74    ret
    0x84012b82    0x76    ld a6,392(a0)
    0x84012b86    0x7a    bnez a6,ffffffff84012bde <tcbSchedDequeue+0xd2>
    0x84012b8a    0x7e    srli t1,a2,0x6
    0x84012b8e    0x82    li a4,3
    0x84012b90    0x84    sub a3,a4,t1
    0x84012b94    0x88    li a4,1
    0x84012b96    0x8a    sll a2,a4,a2
    0x84012b9a    0x8e    not a2,a2
    0x84012b9e    0x92    slli a4,a1,0x2
    0x84012ba2    0x96    add a4,a4,a3
    0x84012ba4    0x98    slli a4,a4,0x3
    0x84012ba6    0x9a    auipc a3,0x5
    0x84012baa    0x9e    addi a3,a3,1114 # ffffffff84018000 <riscvKSASIDTable>
    0x84012bae    0xa2    add a4,a4,a3
    0x84012bb0    0xa4    ld a3,1168(a4)
    0x84012bb4    0xa8    and a2,a2,a3
    0x84012bb6    0xaa    sd a2,1168(a4)
    0x84012bba    0xae    bnez a2,ffffffff84012b54 <tcbSchedDequeue+0x48>
    0x84012bbc    0xb0    slli a1,a1,0x3
    0x84012bbe    0xb2    auipc a4,0x5
    0x84012bc2    0xb6    addi a4,a4,1090 # ffffffff84018000 <riscvKSASIDTable>
    0x84012bc6    0xba    add a1,a1,a4
    0x84012bc8    0xbc    li a4,1
    0x84012bca    0xbe    sll a4,a4,t1
    0x84012bce    0xc2    not a4,a4
    0x84012bd2    0xc6    ld a3,1040(a1)
    0x84012bd6    0xca    and a4,a4,a3
    0x84012bd8    0xcc    sd a4,1040(a1)
    0x84012bdc    0xd0    j ffffffff84012b54 <tcbSchedDequeue+0x48>
    0x84012bde    0xd2    mv a4,a6
    0x84012be0    0xd4    j ffffffff84012b5a <tcbSchedDequeue+0x4e>
    0x84012be2    0xd6    ld a7,400(a0)
    0x84012be6    0xda    j ffffffff84012b62 <tcbSchedDequeue+0x56>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
68 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbSchedDequeue` has 100 nodes.

Section tcbSchedAppend (24 of 271)
==================================

Deriving specifications
-----------------------

Section `tcbSchedAppend` consists of 49 instructions.

ORI..
RVC_TFFTT____T____TF..
OR.....
RVC_TFFTFT___T____TF.
RVC_TFFFTT___TF___FT..

Stack analysis
---------------

No stack accesses found. Code for `tcbSchedAppend`:

    0x84012a22     0x0    ld a5,288(a0)
    0x84012a26     0x4    andi a5,a5,1
    0x84012a28     0x6    bnez a5,ffffffff84012a74 <tcbSchedAppend+0x52>
    0x84012a2a     0x8    ld a3,344(a0)
    0x84012a2e     0xc    ld a1,360(a0)
    0x84012a32    0x10    slli a5,a3,0x8
    0x84012a36    0x14    add a5,a5,a1
    0x84012a38    0x16    slli a2,a5,0x4
    0x84012a3c    0x1a    auipc a4,0x7
    0x84012a40    0x1e    addi a4,a4,-572 # ffffffff84019800 <ksReadyQueues>
    0x84012a44    0x22    add a4,a4,a2
    0x84012a46    0x24    ld a2,0(a4)
    0x84012a48    0x26    ld a4,8(a4)
    0x84012a4a    0x28    beqz a2,ffffffff84012a76 <tcbSchedAppend+0x54>
    0x84012a4c    0x2a    sd a0,392(a4)
    0x84012a50    0x2e    sd a4,400(a0)
    0x84012a54    0x32    sd zero,392(a0)
    0x84012a58    0x36    slli a5,a5,0x4
    0x84012a5a    0x38    auipc a4,0x7
    0x84012a5e    0x3c    addi a4,a4,-602 # ffffffff84019800 <ksReadyQueues>
    0x84012a62    0x40    add a5,a5,a4
    0x84012a64    0x42    sd a2,0(a5)
    0x84012a66    0x44    sd a0,8(a5)
    0x84012a68    0x46    ld a5,288(a0)
    0x84012a6c    0x4a    ori a5,a5,1
    0x84012a70    0x4e    sd a5,288(a0)
    0x84012a74    0x52    ret
    0x84012a76    0x54    srli t1,a1,0x6
    0x84012a7a    0x58    li t3,3
    0x84012a7c    0x5a    sub t3,t3,t1
    0x84012a80    0x5e    auipc a6,0x5
    0x84012a84    0x62    addi a6,a6,1408 # ffffffff84018000 <riscvKSASIDTable>
    0x84012a88    0x66    slli a7,a3,0x3
    0x84012a8c    0x6a    add a7,a7,a6
    0x84012a8e    0x6c    li a2,1
    0x84012a90    0x6e    sll t1,a2,t1
    0x84012a94    0x72    ld t4,1040(a7)
    0x84012a98    0x76    or t1,t4,t1
    0x84012a9c    0x7a    sd t1,1040(a7)
    0x84012aa0    0x7e    slli a3,a3,0x2
    0x84012aa2    0x80    add a3,a3,t3
    0x84012aa4    0x82    slli a3,a3,0x3
    0x84012aa6    0x84    add a3,a3,a6
    0x84012aa8    0x86    sll a2,a2,a1
    0x84012aac    0x8a    ld a1,1168(a3) # ffffffffe0000490 <ki_end+0x5bfd1490>
    0x84012ab0    0x8e    or a2,a2,a1
    0x84012ab2    0x90    sd a2,1168(a3)
    0x84012ab6    0x94    mv a2,a0
    0x84012ab8    0x96    j ffffffff84012a50 <tcbSchedAppend+0x2e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
49 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbSchedAppend` has 70 nodes.

Section tcbSchedEnqueue (25 of 271)
===================================

Deriving specifications
-----------------------

Section `tcbSchedEnqueue` consists of 49 instructions.

RVC_TFFTT____FT___TF.

Stack analysis
---------------

No stack accesses found. Code for `tcbSchedEnqueue`:

    0x8401253a     0x0    ld a5,288(a0) # 2120 <KERNEL_OFFSET-0xfffffffeffffdee0>
    0x8401253e     0x4    andi a5,a5,1
    0x84012540     0x6    bnez a5,ffffffff8401258c <tcbSchedEnqueue+0x52>
    0x84012542     0x8    ld a3,344(a0)
    0x84012546     0xc    ld a6,360(a0)
    0x8401254a    0x10    slli a5,a3,0x8
    0x8401254e    0x14    add a5,a5,a6
    0x84012550    0x16    slli a2,a5,0x4
    0x84012554    0x1a    auipc a4,0x7
    0x84012558    0x1e    addi a4,a4,684 # ffffffff84019800 <ksReadyQueues>
    0x8401255c    0x22    add a4,a4,a2
    0x8401255e    0x24    ld a1,0(a4)
    0x84012560    0x26    ld a2,8(a4)
    0x84012562    0x28    beqz a2,ffffffff8401258e <tcbSchedEnqueue+0x54>
    0x84012564    0x2a    sd a0,400(a1)
    0x84012568    0x2e    sd zero,400(a0)
    0x8401256c    0x32    sd a1,392(a0)
    0x84012570    0x36    slli a5,a5,0x4
    0x84012572    0x38    auipc a4,0x7
    0x84012576    0x3c    addi a4,a4,654 # ffffffff84019800 <ksReadyQueues>
    0x8401257a    0x40    add a5,a5,a4
    0x8401257c    0x42    sd a0,0(a5)
    0x8401257e    0x44    sd a2,8(a5)
    0x84012580    0x46    ld a5,288(a0)
    0x84012584    0x4a    ori a5,a5,1
    0x84012588    0x4e    sd a5,288(a0)
    0x8401258c    0x52    ret
    0x8401258e    0x54    srli t1,a6,0x6
    0x84012592    0x58    li t3,3
    0x84012594    0x5a    sub t3,t3,t1
    0x84012598    0x5e    auipc a2,0x6
    0x8401259c    0x62    addi a2,a2,-1432 # ffffffff84018000 <riscvKSASIDTable>
    0x840125a0    0x66    slli a7,a3,0x3
    0x840125a4    0x6a    add a7,a7,a2
    0x840125a6    0x6c    li a4,1
    0x840125a8    0x6e    sll t1,a4,t1
    0x840125ac    0x72    ld t4,1040(a7)
    0x840125b0    0x76    or t1,t4,t1
    0x840125b4    0x7a    sd t1,1040(a7)
    0x840125b8    0x7e    slli a3,a3,0x2
    0x840125ba    0x80    add a3,a3,t3
    0x840125bc    0x82    slli a3,a3,0x3
    0x840125be    0x84    add a3,a3,a2
    0x840125c0    0x86    sll a4,a4,a6
    0x840125c4    0x8a    ld a6,1168(a3) # fffffffffc000490 <ki_end+0x77fd1490>
    0x840125c8    0x8e    or a4,a4,a6
    0x840125cc    0x92    sd a4,1168(a3)
    0x840125d0    0x96    mv a2,a0
    0x840125d2    0x98    j ffffffff84012568 <tcbSchedEnqueue+0x2e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
49 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbSchedEnqueue` has 70 nodes.

Section updateCapData (26 of 271)
=================================

Deriving specifications
-----------------------

Section `updateCapData` consists of 58 instructions.

BEQ..

Stack analysis
---------------

18 stack accesses found. Annotated code for `updateCapData`:

    0x8401224e     0x0    addi sp,sp,-32
    0x84012250     0x2    srli a5,a2,0x3b
    0x84012254     0x6    andi a4,a5,1
    0x84012258     0xa    bnez a4,ffffffff84012272 <updateCapData+0x24>
    0x8401225a     0xc    li a4,6
    0x8401225c     0xe    beq a5,a4,ffffffff8401228e <updateCapData+0x40>
    0x84012260    0x12    li a4,10
    0x84012262    0x14    beq a5,a4,ffffffff8401229e <updateCapData+0x50>
    0x84012266    0x18    li a4,4
    0x84012268    0x1a    beq a5,a4,ffffffff8401227e <updateCapData+0x30>
    0x8401226c    0x1e    sd a2,16(sp)          ; stack access
    0x8401226e    0x20    sd a3,24(sp)          ; stack access
    0x84012270    0x22    j ffffffff84012276 <updateCapData+0x28>
    0x84012272    0x24    sd a2,16(sp)          ; stack access
    0x84012274    0x26    sd a3,24(sp)          ; stack access
    0x84012276    0x28    ld a0,16(sp)          ; stack access
    0x84012278    0x2a    ld a1,24(sp)          ; stack access
    0x8401227a    0x2c    addi sp,sp,32
    0x8401227c    0x2e    ret
    0x8401227e    0x30    or a3,a3,a0
    0x84012280    0x32    bnez a3,ffffffff84012288 <updateCapData+0x3a>
    0x84012282    0x34    sd a2,16(sp)          ; stack access
    0x84012284    0x36    sd a1,24(sp)          ; stack access
    0x84012286    0x38    j ffffffff84012276 <updateCapData+0x28>
    0x84012288    0x3a    sd zero,16(sp)        ; stack access
    0x8401228a    0x3c    sd zero,24(sp)        ; stack access
    0x8401228c    0x3e    j ffffffff84012276 <updateCapData+0x28>
    0x8401228e    0x40    or a3,a3,a0
    0x84012290    0x42    bnez a3,ffffffff84012298 <updateCapData+0x4a>
    0x84012292    0x44    sd a2,16(sp)          ; stack access
    0x84012294    0x46    sd a1,24(sp)          ; stack access
    0x84012296    0x48    j ffffffff84012276 <updateCapData+0x28>
    0x84012298    0x4a    sd zero,16(sp)        ; stack access
    0x8401229a    0x4c    sd zero,24(sp)        ; stack access
    0x8401229c    0x4e    j ffffffff84012276 <updateCapData+0x28>
    0x8401229e    0x50    andi a4,a1,63
    0x840122a2    0x54    srli a5,a2,0x2f
    0x840122a6    0x58    andi a5,a5,63
    0x840122aa    0x5c    add a5,a5,a4
    0x840122ac    0x5e    li a3,64
    0x840122b0    0x62    bgeu a3,a5,ffffffff840122ba <updateCapData+0x6c>
    0x840122b4    0x66    sd zero,16(sp)        ; stack access
    0x840122b6    0x68    sd zero,24(sp)        ; stack access
    0x840122b8    0x6a    j ffffffff84012276 <updateCapData+0x28>
    0x840122ba    0x6c    li a5,-63
    0x840122be    0x70    slli a5,a5,0x35
    0x840122c0    0x72    addi a5,a5,-1
    0x840122c2    0x74    and a2,a2,a5
    0x840122c4    0x76    slli a5,a4,0x35
    0x840122c8    0x7a    or a2,a2,a5
    0x840122ca    0x7c    sd a2,16(sp)          ; stack access
    0x840122cc    0x7e    li a5,-1
    0x840122ce    0x80    sll a5,a5,a4
    0x840122d2    0x84    not a5,a5
    0x840122d6    0x88    srli a1,a1,0x6
    0x840122d8    0x8a    and a1,a1,a5
    0x840122da    0x8c    sd a1,24(sp)          ; stack access
    0x840122dc    0x8e    j ffffffff84012276 <updateCapData+0x28>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
58 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `updateCapData` has 91 nodes.

Section hasCancelSendRights (27 of 271)
=======================================

Deriving specifications
-----------------------

Section `hasCancelSendRights` consists of 20 instructions.

RVC_FFFFFFFT______FT.
AND.....
RVC_TFFFTT___FF___FT..
SLTIU..

Stack analysis
---------------

No stack accesses found. Code for `hasCancelSendRights`:

    0x84011cac     0x0    addi sp,sp,-16
    0x84011cae     0x2    srli a4,a0,0x3b
    0x84011cb2     0x6    li a5,4
    0x84011cb4     0x8    beq a4,a5,ffffffff84011cbe <hasCancelSendRights+0x12>
    0x84011cb8     0xc    li a0,0
    0x84011cba     0xe    addi sp,sp,16
    0x84011cbc    0x10    ret
    0x84011cbe    0x12    li a4,3
    0x84011cc0    0x14    slli a4,a4,0x37
    0x84011cc2    0x16    and a3,a0,a4
    0x84011cc6    0x1a    li a5,0
    0x84011cc8    0x1c    beq a3,a4,ffffffff84011cd0 <hasCancelSendRights+0x24>
    0x84011ccc    0x20    mv a0,a5
    0x84011cce    0x22    j ffffffff84011cba <hasCancelSendRights+0xe>
    0x84011cd0    0x24    li a5,3
    0x84011cd2    0x26    slli a5,a5,0x39
    0x84011cd4    0x28    and a0,a0,a5
    0x84011cd6    0x2a    sub a0,a0,a5
    0x84011cd8    0x2c    seqz a5,a0
    0x84011cdc    0x30    j ffffffff84011ccc <hasCancelSendRights+0x20>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `hasCancelSendRights` has 25 nodes.

Section bindNotification (28 of 271)
====================================

Deriving specifications
-----------------------

Section `bindNotification` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `bindNotification`:

    0x84011c4e     0x0    ld a4,24(a1)
    0x84011c50     0x2    li a5,-1
    0x84011c52     0x4    slli a3,a5,0x27
    0x84011c56     0x8    and a4,a4,a3
    0x84011c58     0xa    srli a5,a5,0x19
    0x84011c5a     0xc    and a5,a5,a0
    0x84011c5c     0xe    or a5,a5,a4
    0x84011c5e    0x10    sd a5,24(a1)
    0x84011c60    0x12    sd a1,304(a0)
    0x84011c64    0x16    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `bindNotification` has 14 nodes.

Section unbindNotification (29 of 271)
======================================

Deriving specifications
-----------------------

Section `unbindNotification` consists of 8 instructions.


Stack analysis
---------------

No stack accesses found. Code for `unbindNotification`:

    0x84011c3a     0x0    ld a4,304(a0)
    0x84011c3e     0x4    beqz a4,ffffffff84011c4c <unbindNotification+0x12>
    0x84011c40     0x6    ld a5,24(a4)
    0x84011c42     0x8    srli a5,a5,0x27
    0x84011c44     0xa    slli a5,a5,0x27
    0x84011c46     0xc    sd a5,24(a4)
    0x84011c48     0xe    sd zero,304(a0)
    0x84011c4c    0x12    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `unbindNotification` has 15 nodes.

Section unbindMaybeNotification (30 of 271)
===========================================

Deriving specifications
-----------------------

Section `unbindMaybeNotification` consists of 16 instructions.


Stack analysis
---------------

No stack accesses found. Code for `unbindMaybeNotification`:

    0x84011c14     0x0    ld a4,24(a0)
    0x84011c16     0x2    slli a5,a4,0x19
    0x84011c1a     0x6    srli a5,a5,0x19
    0x84011c1c     0x8    srli a3,a4,0x26
    0x84011c20     0xc    andi a3,a3,1
    0x84011c22     0xe    beqz a3,ffffffff84011c36 <unbindMaybeNotification+0x22>
    0x84011c24    0x10    li a3,-1
    0x84011c26    0x12    slli a3,a3,0x27
    0x84011c28    0x14    or a5,a5,a3
    0x84011c2a    0x16    srli a4,a4,0x27
    0x84011c2c    0x18    slli a4,a4,0x27
    0x84011c2e    0x1a    sd a4,24(a0)
    0x84011c30    0x1c    sd zero,304(a5) # fffffffff8000130 <ki_end+0x73fd1130>
    0x84011c34    0x20    ret
    0x84011c36    0x22    beqz a5,ffffffff84011c34 <unbindMaybeNotification+0x20>
    0x84011c38    0x24    j ffffffff84011c2a <unbindMaybeNotification+0x16>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `unbindMaybeNotification` has 24 nodes.

Section setIRQState (31 of 271)
===============================

Deriving specifications
-----------------------

Section `setIRQState` consists of 35 instructions.

Skipping 1047b7f3 csrrc a5,sie,a5

Skipping 1047a7f3 csrrs a5,sie,a5

LUI.
RVC_FTF___________FF..
RVC_TTF___________FF..

Stack analysis
---------------

No stack accesses found. Code for `setIRQState`:

    0x84011ac2     0x0    slli a4,a1,0x3
    0x84011ac6     0x4    auipc a5,0x6
    0x84011aca     0x8    addi a5,a5,1338 # ffffffff84018000 <riscvKSASIDTable>
    0x84011ace     0xc    add a5,a5,a4
    0x84011ad0     0xe    sd a0,1752(a5)
    0x84011ad4    0x12    li a5,54
    0x84011ad8    0x16    bne a1,a5,ffffffff84011af2 <setIRQState+0x30>
    0x84011adc    0x1a    bnez a0,ffffffff84011ae8 <setIRQState+0x26>
    0x84011ade    0x1c    li a5,32
    0x84011ae2    0x20    csrrc a5,sie,a5
    0x84011ae6    0x24    ret
    0x84011ae8    0x26    li a5,32
    0x84011aec    0x2a    csrrs a5,sie,a5
    0x84011af0    0x2e    ret
    0x84011af2    0x30    andi a3,a1,31
    0x84011af6    0x34    srli a1,a1,0x5
    0x84011af8    0x36    slli a1,a1,0x2
    0x84011afa    0x38    lui a4,0xcc002
    0x84011afe    0x3c    addi a4,a4,256 # ffffffffcc002100 <ki_end+0x47fd3100>
    0x84011b02    0x40    add a1,a1,a4
    0x84011b04    0x42    lw a5,0(a1)
    0x84011b06    0x44    sext.w a4,a5
    0x84011b0a    0x48    bnez a0,ffffffff84011b1e <setIRQState+0x5c>
    0x84011b0c    0x4a    li a5,1
    0x84011b0e    0x4c    sll a5,a5,a3
    0x84011b12    0x50    not a5,a5
    0x84011b16    0x54    and a5,a5,a4
    0x84011b18    0x56    sext.w a5,a5
    0x84011b1a    0x58    sw a5,0(a1)
    0x84011b1c    0x5a    ret
    0x84011b1e    0x5c    li a5,1
    0x84011b20    0x5e    sll a5,a5,a3
    0x84011b24    0x62    or a5,a5,a4
    0x84011b26    0x64    sext.w a5,a5
    0x84011b28    0x66    j ffffffff84011b1a <setIRQState+0x58>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
35 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setIRQState` has 49 nodes.

Section isIRQActive (32 of 271)
===============================

Deriving specifications
-----------------------

Section `isIRQActive` consists of 7 instructions.

SLTU.....

Stack analysis
---------------

No stack accesses found. Code for `isIRQActive`:

    0x84011aaa     0x0    slli a5,a0,0x3
    0x84011aae     0x4    auipc a0,0x6
    0x84011ab2     0x8    addi a0,a0,1362 # ffffffff84018000 <riscvKSASIDTable>
    0x84011ab6     0xc    add a0,a0,a5
    0x84011ab8     0xe    ld a0,1752(a0)
    0x84011abc    0x12    snez a0,a0
    0x84011ac0    0x16    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isIRQActive` has 9 nodes.

Section invokeIRQHandler_AckIRQ (33 of 271)
===========================================

Deriving specifications
-----------------------

Section `invokeIRQHandler_AckIRQ` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `invokeIRQHandler_AckIRQ`:

    0x84011aa0    0x0    sext.w a0,a0
    0x84011aa2    0x2    lui a5,0xcc202
    0x84011aa6    0x6    sw a0,4(a5)
    0x84011aa8    0x8    ret

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeIRQHandler_AckIRQ` has 6 nodes.

Section replyFromKernel_success_empty (34 of 271)
=================================================

Deriving specifications
-----------------------

Section `replyFromKernel_success_empty` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `replyFromKernel_success_empty`:

    0x84011a96    0x0    sd zero,72(a0)
    0x84011a9a    0x4    sd zero,80(a0)
    0x84011a9e    0x8    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `replyFromKernel_success_empty` has 6 nodes.

Section loadCapTransfer (35 of 271)
===================================

Deriving specifications
-----------------------

Section `loadCapTransfer` consists of 7 instructions.


Stack analysis
---------------

Section `loadCapTransfer` expects pointer to stack in a0.
3 stack accesses found. Annotated code for `loadCapTransfer`:

    0x84011a82     0x0    ld a3,1008(a1)
    0x84011a86     0x4    ld a4,1016(a1)
    0x84011a8a     0x8    ld a2,1000(a1)
    0x84011a8e     0xc    sd a2,0(a0)           ; stack access
    0x84011a90     0xe    sd a3,8(a0)           ; stack access
    0x84011a92    0x10    sd a4,16(a0)          ; stack access
    0x84011a94    0x12    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `loadCapTransfer` has 14 nodes.

Section ensureEmptySlot (36 of 271)
===================================

Deriving specifications
-----------------------

Section `ensureEmptySlot` consists of 9 instructions.


Stack analysis
---------------

No stack accesses found. Code for `ensureEmptySlot`:

    0x84011a10     0x0    ld a0,0(a0)
    0x84011a12     0x2    srli a0,a0,0x3b
    0x84011a14     0x4    bnez a0,ffffffff84011a18 <ensureEmptySlot+0x8>
    0x84011a16     0x6    ret
    0x84011a18     0x8    li a5,8
    0x84011a1a     0xa    auipc a4,0x7
    0x84011a1e     0xe    sd a5,-842(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84011a22    0x12    li a0,3
    0x84011a24    0x14    j ffffffff84011a16 <ensureEmptySlot+0x6>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `ensureEmptySlot` has 14 nodes.

Section setupReplyMaster (37 of 271)
====================================

Deriving specifications
-----------------------

Section `setupReplyMaster` consists of 13 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setupReplyMaster`:

    0x840119f2     0x0    andi a4,a0,-1024
    0x840119f6     0x4    ld a5,64(a4)
    0x840119f8     0x6    srli a5,a5,0x3b
    0x840119fa     0x8    bnez a5,ffffffff84011a0e <setupReplyMaster+0x1c>
    0x840119fc     0xa    li a5,1
    0x840119fe     0xc    slli a5,a5,0x3e
    0x84011a00     0xe    addi a5,a5,3
    0x84011a02    0x10    sd a5,64(a4)
    0x84011a04    0x12    sd a0,72(a4)
    0x84011a06    0x14    sd zero,80(a4) # fffffffff8000050 <ki_end+0x73fd1050>
    0x84011a0a    0x18    li a5,3
    0x84011a0c    0x1a    sd a5,88(a4)
    0x84011a0e    0x1c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setupReplyMaster` has 21 nodes.

Section insertNewCap (38 of 271)
================================

Deriving specifications
-----------------------

Section `insertNewCap` consists of 42 instructions.


Stack analysis
---------------

5 stack accesses found. Annotated code for `insertNewCap`:

    0x84011996     0x0    addi sp,sp,-16
    0x84011998     0x2    sd a2,0(sp)           ; stack access
    0x8401199a     0x4    sd a3,8(sp)           ; stack access
    0x8401199c     0x6    ld a4,24(a0)
    0x8401199e     0x8    lui a5,0xf8000
    0x840119a2     0xc    srli a5,a5,0x19
    0x840119a4     0xe    and a5,a5,a4
    0x840119a6    0x10    srli a4,a4,0x26
    0x840119a8    0x12    andi a4,a4,1
    0x840119aa    0x14    beqz a4,ffffffff840119dc <insertNewCap+0x46>
    0x840119ac    0x16    li a4,-1
    0x840119ae    0x18    slli a4,a4,0x27
    0x840119b0    0x1a    or a4,a4,a5
    0x840119b2    0x1c    sd a2,0(a1)
    0x840119b4    0x1e    ld a3,8(sp)           ; stack access
    0x840119b6    0x20    sd a3,8(a1)
    0x840119b8    0x22    sd a0,16(a1)
    0x840119ba    0x24    ori a5,a5,3
    0x840119be    0x28    sd a5,24(a1)
    0x840119c0    0x2a    sd a1,16(a4)
    0x840119c2    0x2c    ld a5,24(a0)
    0x840119c4    0x2e    li a4,-1
    0x840119c6    0x30    slli a4,a4,0x27
    0x840119c8    0x32    addi a4,a4,3
    0x840119ca    0x34    and a5,a5,a4
    0x840119cc    0x36    lui a4,0xf8000
    0x840119d0    0x3a    srli a4,a4,0x19
    0x840119d2    0x3c    and a1,a1,a4
    0x840119d4    0x3e    or a1,a1,a5
    0x840119d6    0x40    sd a1,24(a0)
    0x840119d8    0x42    addi sp,sp,16
    0x840119da    0x44    ret
    0x840119dc    0x46    ld a4,0(sp)           ; stack access
    0x840119de    0x48    sd a4,0(a1)
    0x840119e0    0x4a    ld a4,8(sp)           ; stack access
    0x840119e2    0x4c    sd a4,8(a1)
    0x840119e4    0x4e    sd a0,16(a1)
    0x840119e6    0x50    ori a4,a5,3
    0x840119ea    0x54    sd a4,24(a1)
    0x840119ec    0x56    beqz a5,ffffffff840119c2 <insertNewCap+0x2c>
    0x840119ee    0x58    mv a4,a5
    0x840119f0    0x5a    j ffffffff840119c0 <insertNewCap+0x2a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
42 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `insertNewCap` has 64 nodes.

Section cteSwap (39 of 271)
===========================

Deriving specifications
-----------------------

Section `cteSwap` consists of 65 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `cteSwap`:

    0x840118a2     0x0    addi sp,sp,-32
    0x840118a4     0x2    sd a0,16(sp)          ; stack access
    0x840118a6     0x4    sd a1,24(sp)          ; stack access
    0x840118a8     0x6    sd a3,0(sp)           ; stack access
    0x840118aa     0x8    sd a4,8(sp)           ; stack access
    0x840118ac     0xa    sd a3,0(a2)
    0x840118ae     0xc    sd a4,8(a2)
    0x840118b0     0xe    sd a0,0(a5)
    0x840118b2    0x10    sd a1,8(a5)
    0x840118b4    0x12    ld a0,16(a2)
    0x840118b6    0x14    ld a1,24(a2)
    0x840118b8    0x16    beqz a0,ffffffff840118d0 <cteSwap+0x2e>
    0x840118ba    0x18    ld a4,24(a0)
    0x840118bc    0x1a    li a3,-1
    0x840118be    0x1c    slli a3,a3,0x27
    0x840118c0    0x1e    addi a3,a3,3
    0x840118c2    0x20    and a4,a4,a3
    0x840118c4    0x22    lui a3,0xf8000
    0x840118c8    0x26    srli a3,a3,0x19
    0x840118ca    0x28    and a3,a3,a5
    0x840118cc    0x2a    or a4,a4,a3
    0x840118ce    0x2c    sd a4,24(a0)
    0x840118d0    0x2e    lui a4,0xf8000
    0x840118d4    0x32    srli a4,a4,0x19
    0x840118d6    0x34    and a4,a4,a1
    0x840118d8    0x36    srli a3,a1,0x26
    0x840118dc    0x3a    andi a3,a3,1
    0x840118de    0x3c    beqz a3,ffffffff84011926 <cteSwap+0x84>
    0x840118e0    0x3e    li a3,-1
    0x840118e2    0x40    slli a3,a3,0x27
    0x840118e4    0x42    or a4,a4,a3
    0x840118e6    0x44    sd a5,16(a4)
    0x840118e8    0x46    ld a3,16(a5)
    0x840118ea    0x48    ld a4,24(a5)
    0x840118ec    0x4a    sd a3,16(a2)
    0x840118ee    0x4c    sd a4,24(a2)
    0x840118f0    0x4e    sd a0,16(a5)
    0x840118f2    0x50    sd a1,24(a5)
    0x840118f4    0x52    beqz a3,ffffffff8401190c <cteSwap+0x6a>
    0x840118f6    0x54    ld a5,24(a3)
    0x840118f8    0x56    li a1,-1
    0x840118fa    0x58    slli a1,a1,0x27
    0x840118fc    0x5a    addi a1,a1,3
    0x840118fe    0x5c    and a5,a5,a1
    0x84011900    0x5e    lui a1,0xf8000
    0x84011904    0x62    srli a1,a1,0x19
    0x84011906    0x64    and a1,a1,a2
    0x84011908    0x66    or a5,a5,a1
    0x8401190a    0x68    sd a5,24(a3)
    0x8401190c    0x6a    lui a5,0xf8000
    0x84011910    0x6e    srli a5,a5,0x19
    0x84011912    0x70    and a5,a5,a4
    0x84011914    0x72    srli a4,a4,0x26
    0x84011916    0x74    andi a4,a4,1
    0x84011918    0x76    beqz a4,ffffffff8401192a <cteSwap+0x88>
    0x8401191a    0x78    li a4,-1
    0x8401191c    0x7a    slli a4,a4,0x27
    0x8401191e    0x7c    or a5,a5,a4
    0x84011920    0x7e    sd a2,16(a5)
    0x84011922    0x80    addi sp,sp,32
    0x84011924    0x82    ret
    0x84011926    0x84    beqz a4,ffffffff840118e8 <cteSwap+0x46>
    0x84011928    0x86    j ffffffff840118e6 <cteSwap+0x44>
    0x8401192a    0x88    beqz a5,ffffffff84011922 <cteSwap+0x80>
    0x8401192c    0x8a    j ffffffff84011920 <cteSwap+0x7e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
65 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteSwap` has 100 nodes.

Section cteMove (40 of 271)
===========================

Deriving specifications
-----------------------

Section `cteMove` consists of 38 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `cteMove`:

    0x840117f6     0x0    addi sp,sp,-16
    0x840117f8     0x2    sd a0,0(sp)           ; stack access
    0x840117fa     0x4    sd a1,8(sp)           ; stack access
    0x840117fc     0x6    ld a4,16(a2)
    0x840117fe     0x8    ld a5,24(a2)
    0x84011800     0xa    sd a0,0(a3)
    0x84011802     0xc    sd a1,8(a3)
    0x84011804     0xe    sd zero,0(a2)
    0x84011808    0x12    sd zero,8(a2)
    0x8401180c    0x16    sd a4,16(a3)
    0x8401180e    0x18    sd a5,24(a3)
    0x84011810    0x1a    sd zero,16(a2)
    0x84011814    0x1e    sd zero,24(a2)
    0x84011818    0x22    beqz a4,ffffffff84011830 <cteMove+0x3a>
    0x8401181a    0x24    ld a2,24(a4)
    0x8401181c    0x26    li a1,-1
    0x8401181e    0x28    slli a1,a1,0x27
    0x84011820    0x2a    addi a1,a1,3
    0x84011822    0x2c    and a2,a2,a1
    0x84011824    0x2e    lui a1,0xf8000
    0x84011828    0x32    srli a1,a1,0x19
    0x8401182a    0x34    and a1,a1,a3
    0x8401182c    0x36    or a2,a2,a1
    0x8401182e    0x38    sd a2,24(a4)
    0x84011830    0x3a    lui a4,0xf8000
    0x84011834    0x3e    srli a4,a4,0x19
    0x84011836    0x40    and a4,a4,a5
    0x84011838    0x42    srli a5,a5,0x26
    0x8401183a    0x44    andi a5,a5,1
    0x8401183c    0x46    beqz a5,ffffffff8401184a <cteMove+0x54>
    0x8401183e    0x48    li a5,-1
    0x84011840    0x4a    slli a5,a5,0x27
    0x84011842    0x4c    or a4,a4,a5
    0x84011844    0x4e    sd a3,16(a4)
    0x84011846    0x50    addi sp,sp,16
    0x84011848    0x52    ret
    0x8401184a    0x54    beqz a4,ffffffff84011846 <cteMove+0x50>
    0x8401184c    0x56    j ffffffff84011844 <cteMove+0x4e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
38 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteMove` has 60 nodes.

Section cteInsert (41 of 271)
=============================

Deriving specifications
-----------------------

Section `cteInsert` consists of 108 instructions.

RVC_TFFFFFT__FT___TF.

Stack analysis
---------------

4 stack accesses found. Annotated code for `cteInsert`:

    0x840116ba      0x0    addi sp,sp,-16
    0x840116bc      0x2    sd a0,0(sp)           ; stack access
    0x840116be      0x4    sd a1,8(sp)           ; stack access
    0x840116c0      0x6    ld a5,24(a2)
    0x840116c2      0x8    ld a7,0(a2)
    0x840116c6      0xc    ld t3,8(a2)
    0x840116ca     0x10    srli a4,a0,0x3b
    0x840116ce     0x14    andi a6,a4,1
    0x840116d2     0x18    bnez a6,ffffffff84011758 <cteInsert+0x9e>
    0x840116d6     0x1c    li t1,6
    0x840116d8     0x1e    beq a4,t1,ffffffff8401174e <cteInsert+0x94>
    0x840116dc     0x22    bltu t1,a4,ffffffff8401173c <cteInsert+0x82>
    0x840116e0     0x26    li t1,2
    0x840116e2     0x28    beq a4,t1,ffffffff84011780 <cteInsert+0xc6>
    0x840116e6     0x2c    li a0,4
    0x840116e8     0x2e    bne a4,a0,ffffffff840116f4 <cteInsert+0x3a>
    0x840116ec     0x32    sub a6,t3,a1
    0x840116f0     0x36    snez a6,a6
    0x840116f4     0x3a    mv t1,a2
    0x840116f6     0x3c    slli a4,a6,0x1
    0x840116fa     0x40    andi a5,a5,-4
    0x840116fc     0x42    or a5,a5,a4
    0x840116fe     0x44    or a5,a5,a6
    0x84011702     0x48    ld a4,0(sp)           ; stack access
    0x84011704     0x4a    sd a4,0(a3)
    0x84011706     0x4c    ld a4,8(sp)           ; stack access
    0x84011708     0x4e    sd a4,8(a3)
    0x8401170a     0x50    sd t1,16(a3)
    0x8401170e     0x54    sd a5,24(a3)
    0x84011710     0x56    ld a1,24(a2)
    0x84011712     0x58    li a4,-1
    0x84011714     0x5a    slli a4,a4,0x27
    0x84011716     0x5c    addi a4,a4,3
    0x84011718     0x5e    and a1,a1,a4
    0x8401171a     0x60    lui a4,0xf8000
    0x8401171e     0x64    srli a4,a4,0x19
    0x84011720     0x66    and a0,a3,a4
    0x84011724     0x6a    or a1,a1,a0
    0x84011726     0x6c    sd a1,24(a2)
    0x84011728     0x6e    and a4,a4,a5
    0x8401172a     0x70    srli a5,a5,0x26
    0x8401172c     0x72    andi a5,a5,1
    0x8401172e     0x74    beqz a5,ffffffff8401177c <cteInsert+0xc2>
    0x84011730     0x76    li a5,-1
    0x84011732     0x78    slli a5,a5,0x27
    0x84011734     0x7a    or a4,a4,a5
    0x84011736     0x7c    sd a3,16(a4)
    0x84011738     0x7e    addi sp,sp,16
    0x8401173a     0x80    ret
    0x8401173c     0x82    li a1,16
    0x8401173e     0x84    bne a4,a1,ffffffff840116f4 <cteInsert+0x3a>
    0x84011742     0x88    srli a6,a7,0x3b
    0x84011746     0x8c    addi a6,a6,-14
    0x84011748     0x8e    seqz a6,a6
    0x8401174c     0x92    j ffffffff840116f4 <cteInsert+0x3a>
    0x8401174e     0x94    sub a6,t3,a1
    0x84011752     0x98    snez a6,a6
    0x84011756     0x9c    j ffffffff840116f4 <cteInsert+0x3a>
    0x84011758     0x9e    mv t1,a2
    0x8401175a     0xa0    andi a5,a5,-4
    0x8401175c     0xa2    srli a6,a7,0x3b
    0x84011760     0xa6    li t4,2
    0x84011762     0xa8    bne a6,t4,ffffffff84011702 <cteInsert+0x48>
    0x84011766     0xac    li a6,2
    0x84011768     0xae    beq a4,a6,ffffffff84011790 <cteInsert+0xd6>
    0x8401176c     0xb2    j ffffffff84011702 <cteInsert+0x48>
    0x8401176e     0xb4    slli a4,a0,0x19
    0x84011772     0xb8    srli a4,a4,0x19
    0x84011774     0xba    srli a0,a0,0x26
    0x84011776     0xbc    andi a0,a0,1
    0x84011778     0xbe    bnez a0,ffffffff840117b8 <cteInsert+0xfe>
    0x8401177a     0xc0    j ffffffff840117be <cteInsert+0x104>
    0x8401177c     0xc2    beqz a4,ffffffff84011738 <cteInsert+0x7e>
    0x8401177e     0xc4    j ffffffff84011736 <cteInsert+0x7c>
    0x84011780     0xc6    mv t1,a2
    0x84011782     0xc8    ori a5,a5,3
    0x84011786     0xcc    srli a4,a7,0x3b
    0x8401178a     0xd0    li a6,2
    0x8401178c     0xd2    bne a4,a6,ffffffff84011702 <cteInsert+0x48>
    0x84011790     0xd6    slli t4,a7,0x19
    0x84011794     0xda    srli t4,t4,0x19
    0x84011798     0xde    srli a6,a7,0x26
    0x8401179c     0xe2    andi a6,a6,1
    0x840117a0     0xe6    beqz a6,ffffffff8401176e <cteInsert+0xb4>
    0x840117a4     0xea    li a4,-1
    0x840117a6     0xec    slli a6,a4,0x27
    0x840117aa     0xf0    or t4,t4,a6
    0x840117ae     0xf4    srli a4,a4,0x19
    0x840117b0     0xf6    and a4,a4,a0
    0x840117b2     0xf8    srli a0,a0,0x26
    0x840117b4     0xfa    andi a0,a0,1
    0x840117b6     0xfc    beqz a0,ffffffff84011702 <cteInsert+0x48>
    0x840117b8     0xfe    li a0,-1
    0x840117ba    0x100    slli a0,a0,0x27
    0x840117bc    0x102    or a4,a4,a0
    0x840117be    0x104    bne a4,t4,ffffffff84011702 <cteInsert+0x48>
    0x840117c2    0x108    andi t3,t3,63
    0x840117c6    0x10c    andi a6,a1,63
    0x840117ca    0x110    bne a6,t3,ffffffff84011702 <cteInsert+0x48>
    0x840117ce    0x114    addiw t3,t3,-4
    0x840117d0    0x116    lui a4,0x2000
    0x840117d4    0x11a    sll t3,a4,t3
    0x840117d8    0x11e    ld a4,8(a2)
    0x840117da    0x120    slli a4,a4,0x27
    0x840117dc    0x122    srli a4,a4,0x27
    0x840117de    0x124    or a4,t3,a4
    0x840117e2    0x128    sd a4,8(a2)
    0x840117e4    0x12a    j ffffffff84011702 <cteInsert+0x48>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
108 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteInsert` has 157 nodes.

Section preemptionPoint (42 of 271)
===================================

Deriving specifications
-----------------------

Section `preemptionPoint` consists of 17 instructions.

Skipping 14402573 csrr a0,sip


Stack analysis
---------------

No stack accesses found. Code for `preemptionPoint`:

    0x84011684     0x0    auipc a5,0x19
    0x84011688     0x4    ld a5,412(a5) # ffffffff8402a820 <ksWorkUnitsCompleted>
    0x8401168c     0x8    addi a5,a5,1
    0x8401168e     0xa    li a4,99
    0x84011692     0xe    bltu a4,a5,ffffffff840116a2 <preemptionPoint+0x1e>
    0x84011696    0x12    auipc a4,0x19
    0x8401169a    0x16    sd a5,394(a4) # ffffffff8402a820 <ksWorkUnitsCompleted>
    0x8401169e    0x1a    li a0,0
    0x840116a0    0x1c    ret
    0x840116a2    0x1e    auipc a5,0x19
    0x840116a6    0x22    sd zero,382(a5) # ffffffff8402a820 <ksWorkUnitsCompleted>
    0x840116aa    0x26    csrr a0,sip
    0x840116ae    0x2a    andi a0,a0,544
    0x840116b2    0x2e    bnez a0,ffffffff840116b6 <preemptionPoint+0x32>
    0x840116b4    0x30    ret
    0x840116b6    0x32    li a0,4
    0x840116b8    0x34    j ffffffff840116b4 <preemptionPoint+0x30>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `preemptionPoint` has 27 nodes.

Section setMCPriority (43 of 271)
=================================

Deriving specifications
-----------------------

Section `setMCPriority` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setMCPriority`:

    0x8401167e    0x0    sd a1,352(a0)
    0x84011682    0x4    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setMCPriority` has 4 nodes.

Section doNBRecvFailedTransfer (44 of 271)
==========================================

Deriving specifications
-----------------------

Section `doNBRecvFailedTransfer` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `doNBRecvFailedTransfer`:

    0x8401165a    0x0    sd zero,72(a0)
    0x8401165e    0x4    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doNBRecvFailedTransfer` has 4 nodes.

Section resolveAddressBits (45 of 271)
======================================

Deriving specifications
-----------------------

Section `resolveAddressBits` consists of 97 instructions.

RVC_TFFFT____FT___TF.
SRL.....
RVC_TFFTTT___FF___FT..
RVC_FTTFFT___T____FT.

Stack analysis
---------------

Section `resolveAddressBits` expects pointer to stack in a0.
21 stack accesses found. Annotated code for `resolveAddressBits`:

    0x84011338      0x0    addi sp,sp,-32
    0x8401133a      0x2    sd s0,24(sp)          ; stack access
    0x8401133c      0x4    sd s1,16(sp)          ; stack access
    0x8401133e      0x6    sd a1,0(sp)           ; stack access
    0x84011340      0x8    sd a2,8(sp)           ; stack access
    0x84011342      0xa    srli a7,a1,0x3b
    0x84011346      0xe    li a5,10
    0x84011348     0x10    bne a7,a5,ffffffff840113d6 <resolveAddressBits+0x9e>
    0x8401134c     0x14    mv a6,a4
    0x8401134e     0x16    li t5,-1
    0x84011350     0x18    lui t0,0xfc000
    0x84011354     0x1c    srli t0,t0,0x19
    0x84011358     0x20    li t6,1
    0x8401135a     0x22    slli t6,t6,0x26
    0x8401135c     0x24    slli t2,t5,0x27
    0x84011360     0x28    li s0,10
    0x84011362     0x2a    srli a7,a1,0x2f
    0x84011366     0x2e    andi a7,a7,63
    0x8401136a     0x32    srli t1,a1,0x35
    0x8401136e     0x36    andi t1,t1,63
    0x84011372     0x3a    add s1,t1,a7
    0x84011376     0x3e    sext.w a5,a6
    0x8401137a     0x42    subw t3,a6,t1
    0x8401137e     0x46    srl t3,a3,t3
    0x84011382     0x4a    sll t4,t5,t1
    0x84011386     0x4e    not t4,t4
    0x8401138a     0x52    and t3,t3,t4
    0x8401138e     0x56    bltu a6,t1,ffffffff840113f2 <resolveAddressBits+0xba>
    0x84011392     0x5a    bne a2,t3,ffffffff840113f2 <resolveAddressBits+0xba>
    0x84011396     0x5e    bltu a6,s1,ffffffff84011422 <resolveAddressBits+0xea>
    0x8401139a     0x62    subw a5,a5,s1
    0x8401139c     0x64    srl a5,a3,a5
    0x840113a0     0x68    sll a7,t5,a7
    0x840113a4     0x6c    not a7,a7
    0x840113a8     0x70    and a5,a5,a7
    0x840113ac     0x74    slli a5,a5,0x5
    0x840113ae     0x76    slli a1,a1,0x1
    0x840113b0     0x78    and a2,a1,t0
    0x840113b4     0x7c    and a1,a1,t6
    0x840113b8     0x80    beqz a1,ffffffff840113be <resolveAddressBits+0x86>
    0x840113ba     0x82    or a2,a2,t2
    0x840113be     0x86    add a5,a5,a2
    0x840113c0     0x88    bne a6,s1,ffffffff8401144a <resolveAddressBits+0x112>
    0x840113c4     0x8c    sd zero,0(a0) # fffffffff8000000 <ki_end+0x73fd1000>  ; stack access
    0x840113c8     0x90    sd a5,8(a0)           ; stack access
    0x840113ca     0x92    sd zero,16(a0)        ; stack access
    0x840113ce     0x96    ld s0,24(sp)          ; stack access
    0x840113d0     0x98    ld s1,16(sp)          ; stack access
    0x840113d2     0x9a    addi sp,sp,32
    0x840113d4     0x9c    ret
    0x840113d6     0x9e    auipc a5,0x7
    0x840113da     0xa2    addi a5,a5,-982 # ffffffff84018000 <riscvKSASIDTable>
    0x840113de     0xa6    sd zero,1024(a5)
    0x840113e2     0xaa    sd zero,1032(a5)
    0x840113e6     0xae    li a5,2
    0x840113e8     0xb0    sd a5,0(a0)           ; stack access
    0x840113ea     0xb2    sd zero,8(a0)         ; stack access
    0x840113ee     0xb6    sd a4,16(a0)          ; stack access
    0x840113f0     0xb8    j ffffffff840113ce <resolveAddressBits+0x96>
    0x840113f2     0xba    auipc a3,0x7
    0x840113f6     0xbe    addi a3,a3,-1010 # ffffffff84018000 <riscvKSASIDTable>
    0x840113fa     0xc2    slli a6,a6,0x9
    0x840113fc     0xc4    lui a5,0x10
    0x840113fe     0xc6    addi a5,a5,-1
    0x84011400     0xc8    and a6,a6,a5
    0x84011404     0xcc    slli t1,t1,0x2
    0x84011406     0xce    or t1,a6,t1
    0x8401140a     0xd2    ori t1,t1,3
    0x8401140e     0xd6    sd t1,1024(a3)
    0x84011412     0xda    sd a2,1032(a3)
    0x84011416     0xde    li a5,2
    0x84011418     0xe0    sd a5,0(a0)           ; stack access
    0x8401141a     0xe2    sd zero,8(a0)         ; stack access
    0x8401141e     0xe6    sd a4,16(a0)          ; stack access
    0x84011420     0xe8    j ffffffff840113ce <resolveAddressBits+0x96>
    0x84011422     0xea    auipc a5,0x7
    0x84011426     0xee    addi a5,a5,-1058 # ffffffff84018000 <riscvKSASIDTable>
    0x8401142a     0xf2    slli s1,s1,0x9
    0x8401142c     0xf4    slli a6,a6,0x2
    0x8401142e     0xf6    or a6,s1,a6
    0x84011432     0xfa    ori a6,a6,2
    0x84011436     0xfe    sd a6,1024(a5)
    0x8401143a    0x102    sd zero,1032(a5)
    0x8401143e    0x106    li a5,2
    0x84011440    0x108    sd a5,0(a0)           ; stack access
    0x84011442    0x10a    sd zero,8(a0)         ; stack access
    0x84011446    0x10e    sd a4,16(a0)          ; stack access
    0x84011448    0x110    j ffffffff840113ce <resolveAddressBits+0x96>
    0x8401144a    0x112    sub a6,a6,s1
    0x8401144e    0x116    ld a1,0(a5)
    0x84011450    0x118    ld a2,8(a5)
    0x84011452    0x11a    srli a7,a1,0x3b
    0x84011456    0x11e    beq a7,s0,ffffffff84011362 <resolveAddressBits+0x2a>
    0x8401145a    0x122    sd zero,0(a0)         ; stack access
    0x8401145e    0x126    sd a5,8(a0)           ; stack access
    0x84011460    0x128    sd a6,16(a0)          ; stack access
    0x84011464    0x12c    j ffffffff840113ce <resolveAddressBits+0x96>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
97 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `resolveAddressBits` has 141 nodes.

Section Arch_performTransfer (46 of 271)
========================================

Deriving specifications
-----------------------

Section `Arch_performTransfer` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_performTransfer`:

    0x84011334    0x0    li a0,0
    0x84011336    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_performTransfer` has 3 nodes.

Section Arch_decodeTransfer (47 of 271)
=======================================

Deriving specifications
-----------------------

Section `Arch_decodeTransfer` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_decodeTransfer`:

    0x84011330    0x0    li a0,0
    0x84011332    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_decodeTransfer` has 3 nodes.

Section Arch_isFrameType (48 of 271)
====================================

Deriving specifications
-----------------------

Section `Arch_isFrameType` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_isFrameType`:

    0x84011328    0x0    addi a0,a0,-5
    0x8401132a    0x2    sltiu a0,a0,3
    0x8401132e    0x6    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_isFrameType` has 4 nodes.

Section Arch_prepareThreadDelete (49 of 271)
============================================

Deriving specifications
-----------------------

Section `Arch_prepareThreadDelete` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_prepareThreadDelete`:

    0x84011326    0x0    ret

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_prepareThreadDelete` has 2 nodes.

Section Arch_updateCapData (50 of 271)
======================================

Deriving specifications
-----------------------

Section `Arch_updateCapData` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_updateCapData`:

    0x84010f02    0x0    addi sp,sp,-32
    0x84010f04    0x2    mv a0,a2
    0x84010f06    0x4    mv a1,a3
    0x84010f08    0x6    addi sp,sp,32
    0x84010f0a    0x8    ret

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_updateCapData` has 6 nodes.

Section Arch_checkIRQ (51 of 271)
=================================

Deriving specifications
-----------------------

Section `Arch_checkIRQ` consists of 15 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_checkIRQ`:

    0x84010e70     0x0    addi a0,a0,-1
    0x84010e72     0x2    li a5,53
    0x84010e76     0x6    bltu a5,a0,ffffffff84010e7e <Arch_checkIRQ+0xe>
    0x84010e7a     0xa    li a0,0
    0x84010e7c     0xc    ret
    0x84010e7e     0xe    auipc a5,0x7
    0x84010e82    0x12    addi a5,a5,386 # ffffffff84018000 <riscvKSASIDTable>
    0x84010e86    0x16    li a4,4
    0x84010e88    0x18    sd a4,1744(a5)
    0x84010e8c    0x1c    li a4,1
    0x84010e8e    0x1e    sd a4,1712(a5)
    0x84010e92    0x22    li a4,54
    0x84010e96    0x26    sd a4,1720(a5)
    0x84010e9a    0x2a    li a0,3
    0x84010e9c    0x2c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_checkIRQ` has 22 nodes.

Section plat_cleanInvalidateL2Range (52 of 271)
===============================================

Deriving specifications
-----------------------

Section `plat_cleanInvalidateL2Range` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `plat_cleanInvalidateL2Range`:

    0x84010e6e    0x0    ret

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `plat_cleanInvalidateL2Range` has 2 nodes.

Section plat_invalidateL2Range (53 of 271)
==========================================

Deriving specifications
-----------------------

Section `plat_invalidateL2Range` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `plat_invalidateL2Range`:

    0x84010e6c    0x0    ret

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `plat_invalidateL2Range` has 2 nodes.

Section plat_cleanL2Range (54 of 271)
=====================================

Deriving specifications
-----------------------

Section `plat_cleanL2Range` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `plat_cleanL2Range`:

    0x84010e6a    0x0    ret

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `plat_cleanL2Range` has 2 nodes.

Section setIRQTrigger (55 of 271)
=================================

Deriving specifications
-----------------------

Section `setIRQTrigger` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setIRQTrigger`:

    0x84010e68    0x0    ret

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setIRQTrigger` has 2 nodes.

Section setNextPC (56 of 271)
=============================

Deriving specifications
-----------------------

Section `setNextPC` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setNextPC`:

    0x84010e62    0x0    sd a1,272(a0)
    0x84010e66    0x4    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setNextPC` has 4 nodes.

Section getRestartPC (57 of 271)
================================

Deriving specifications
-----------------------

Section `getRestartPC` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `getRestartPC`:

    0x84010e5c    0x0    ld a0,264(a0)
    0x84010e60    0x4    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getRestartPC` has 4 nodes.

Section performPageInvocationMapPTE (58 of 271)
===============================================

Deriving specifications
-----------------------

Section `performPageInvocationMapPTE` consists of 10 instructions.

Skipping 12000073 sfence.vma


Stack analysis
---------------

2 stack accesses found. Annotated code for `performPageInvocationMapPTE`:

    0x84010de8     0x0    addi sp,sp,-16
    0x84010dea     0x2    sd a0,0(sp)           ; stack access
    0x84010dec     0x4    sd a1,8(sp)           ; stack access
    0x84010dee     0x6    sd a0,0(a2)
    0x84010df0     0x8    sd a1,8(a2)
    0x84010df2     0xa    sd a3,0(a4)
    0x84010df4     0xc    sfence.vma
    0x84010df8    0x10    li a0,0
    0x84010dfa    0x12    addi sp,sp,16
    0x84010dfc    0x14    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performPageInvocationMapPTE` has 17 nodes.

Section performPageTableInvocationMap (59 of 271)
=================================================

Deriving specifications
-----------------------

Section `performPageTableInvocationMap` consists of 10 instructions.

Skipping 12000073 sfence.vma


Stack analysis
---------------

2 stack accesses found. Annotated code for `performPageTableInvocationMap`:

    0x84010dd2     0x0    addi sp,sp,-16
    0x84010dd4     0x2    sd a0,0(sp)           ; stack access
    0x84010dd6     0x4    sd a1,8(sp)           ; stack access
    0x84010dd8     0x6    sd a0,0(a2)
    0x84010dda     0x8    sd a1,8(a2)
    0x84010ddc     0xa    sd a3,0(a4)
    0x84010dde     0xc    sfence.vma
    0x84010de2    0x10    li a0,0
    0x84010de4    0x12    addi sp,sp,16
    0x84010de6    0x14    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performPageTableInvocationMap` has 17 nodes.

Section maskVMRights (60 of 271)
================================

Deriving specifications
-----------------------

Section `maskVMRights` consists of 17 instructions.


Stack analysis
---------------

No stack accesses found. Code for `maskVMRights`:

    0x84010da6     0x0    mv a5,a0
    0x84010da8     0x2    li a4,2
    0x84010daa     0x4    beq a0,a4,ffffffff84010db8 <maskVMRights+0x12>
    0x84010dae     0x8    li a4,3
    0x84010db0     0xa    li a0,1
    0x84010db2     0xc    beq a5,a4,ffffffff84010dc2 <maskVMRights+0x1c>
    0x84010db6    0x10    ret
    0x84010db8    0x12    srli a1,a1,0x1
    0x84010dba    0x14    andi a1,a1,1
    0x84010dbc    0x16    addi a0,a1,1
    0x84010dc0    0x1a    ret
    0x84010dc2    0x1c    srli a5,a1,0x1
    0x84010dc6    0x20    andi a5,a5,1
    0x84010dc8    0x22    beqz a5,ffffffff84010db6 <maskVMRights+0x10>
    0x84010dca    0x24    andi a1,a1,1
    0x84010dcc    0x26    addi a0,a1,2
    0x84010dd0    0x2a    j ffffffff84010db6 <maskVMRights+0x10>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `maskVMRights` has 25 nodes.

Section checkValidIPCBuffer (61 of 271)
=======================================

Deriving specifications
-----------------------

Section `checkValidIPCBuffer` consists of 26 instructions.


Stack analysis
---------------

No stack accesses found. Code for `checkValidIPCBuffer`:

    0x84010d60     0x0    addi sp,sp,-16
    0x84010d62     0x2    srli a4,a1,0x3b
    0x84010d66     0x6    li a5,1
    0x84010d68     0x8    bne a4,a5,ffffffff84010d7c <checkValidIPCBuffer+0x1c>
    0x84010d6c     0xc    srli a1,a1,0x36
    0x84010d6e     0xe    andi a1,a1,1
    0x84010d70    0x10    bnez a1,ffffffff84010d8a <checkValidIPCBuffer+0x2a>
    0x84010d72    0x12    andi a0,a0,1023
    0x84010d76    0x16    bnez a0,ffffffff84010d98 <checkValidIPCBuffer+0x38>
    0x84010d78    0x18    addi sp,sp,16
    0x84010d7a    0x1a    ret
    0x84010d7c    0x1c    li a5,3
    0x84010d7e    0x1e    auipc a4,0x8
    0x84010d82    0x22    sd a5,-1710(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84010d86    0x26    li a0,3
    0x84010d88    0x28    j ffffffff84010d78 <checkValidIPCBuffer+0x18>
    0x84010d8a    0x2a    li a5,3
    0x84010d8c    0x2c    auipc a4,0x8
    0x84010d90    0x30    sd a5,-1724(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84010d94    0x34    li a0,3
    0x84010d96    0x36    j ffffffff84010d78 <checkValidIPCBuffer+0x18>
    0x84010d98    0x38    li a5,5
    0x84010d9a    0x3a    auipc a4,0x8
    0x84010d9e    0x3e    sd a5,-1738(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84010da2    0x42    li a0,3
    0x84010da4    0x44    j ffffffff84010d78 <checkValidIPCBuffer+0x18>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
26 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `checkValidIPCBuffer` has 36 nodes.

Section isValidVTableRoot (62 of 271)
=====================================

Deriving specifications
-----------------------

Section `isValidVTableRoot` consists of 9 instructions.


Stack analysis
---------------

No stack accesses found. Code for `isValidVTableRoot`:

    0x84010d4a     0x0    addi sp,sp,-16
    0x84010d4c     0x2    srli a4,a0,0x3b
    0x84010d50     0x6    li a5,3
    0x84010d52     0x8    srli a0,a0,0x27
    0x84010d54     0xa    andi a0,a0,1
    0x84010d56     0xc    beq a4,a5,ffffffff84010d5c <isValidVTableRoot+0x12>
    0x84010d5a    0x10    li a0,0
    0x84010d5c    0x12    addi sp,sp,16
    0x84010d5e    0x14    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isValidVTableRoot` has 12 nodes.

Section lookupPTSlot (63 of 271)
================================

Deriving specifications
-----------------------

Section `lookupPTSlot` consists of 36 instructions.


Stack analysis
---------------

No stack accesses found. Code for `lookupPTSlot`:

    0x840109c6     0x0    addi sp,sp,-16
    0x840109c8     0x2    mv a3,a1
    0x840109ca     0x4    srli a5,a1,0x1e
    0x840109ce     0x8    andi a5,a5,511
    0x840109d2     0xc    slli a5,a5,0x3
    0x840109d4     0xe    add a0,a0,a5
    0x840109d6    0x10    li a1,30
    0x840109d8    0x12    li a7,3
    0x840109da    0x14    lui a6,0xfff00
    0x840109de    0x18    srli a6,a6,0x8
    0x840109e2    0x1c    li a2,-1
    0x840109e4    0x1e    slli a2,a2,0x26
    0x840109e6    0x20    j ffffffff84010a04 <lookupPTSlot+0x3e>
    0x840109e8    0x22    addi a1,a1,-9
    0x840109ea    0x24    beq a1,a7,ffffffff84010a28 <lookupPTSlot+0x62>
    0x840109ee    0x28    slli a0,a5,0x2
    0x840109f2    0x2c    and a0,a0,a6
    0x840109f6    0x30    add a0,a0,a2
    0x840109f8    0x32    srl a5,a3,a1
    0x840109fc    0x36    andi a5,a5,511
    0x84010a00    0x3a    slli a5,a5,0x3
    0x84010a02    0x3c    add a0,a0,a5
    0x84010a04    0x3e    ld a5,0(a0)
    0x84010a06    0x40    andi a4,a5,1
    0x84010a0a    0x44    beqz a4,ffffffff84010a24 <lookupPTSlot+0x5e>
    0x84010a0c    0x46    srli a4,a5,0x1
    0x84010a10    0x4a    srli t1,a5,0x2
    0x84010a14    0x4e    or a4,a4,t1
    0x84010a18    0x52    srli t1,a5,0x3
    0x84010a1c    0x56    or a4,a4,t1
    0x84010a20    0x5a    andi a4,a4,1
    0x84010a22    0x5c    beqz a4,ffffffff840109e8 <lookupPTSlot+0x22>
    0x84010a24    0x5e    addi sp,sp,16
    0x84010a26    0x60    ret
    0x84010a28    0x62    li a1,12
    0x84010a2a    0x64    j ffffffff84010a24 <lookupPTSlot+0x5e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
36 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupPTSlot` has 44 nodes.

Section copyGlobalMappings (64 of 271)
======================================

Deriving specifications
-----------------------

Section `copyGlobalMappings` consists of 13 instructions.

RVC_FTTFFT___FFFFTFT.

Stack analysis
---------------

No stack accesses found. Code for `copyGlobalMappings`:

    0x840107c0     0x0    auipc a5,0x1d
    0x840107c4     0x4    addi a5,a5,64 # ffffffff8402d800 <kernel_root_pageTable+0x800>
    0x840107c8     0x8    lui a4,0x1
    0x840107ca     0xa    addi a4,a4,-2048 # 800 <KERNEL_OFFSET-0xfffffffefffff800>
    0x840107ce     0xe    add a4,a4,a0
    0x840107d0    0x10    auipc a2,0x1e
    0x840107d4    0x14    addi a2,a2,-2000 # ffffffff8402e000 <kernel_root_pageTable+0x1000>
    0x840107d8    0x18    ld a3,0(a5)
    0x840107da    0x1a    sd a3,0(a4)
    0x840107dc    0x1c    addi a5,a5,8
    0x840107de    0x1e    addi a4,a4,8
    0x840107e0    0x20    bne a5,a2,ffffffff840107d8 <copyGlobalMappings+0x18>
    0x840107e4    0x24    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `copyGlobalMappings` has 18 nodes.

Section Arch_postModifyRegisters (65 of 271)
============================================

Deriving specifications
-----------------------

Section `Arch_postModifyRegisters` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_postModifyRegisters`:

    0x840107be    0x0    ret

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_postModifyRegisters` has 2 nodes.

Section Arch_activateIdleThread (66 of 271)
===========================================

Deriving specifications
-----------------------

Section `Arch_activateIdleThread` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_activateIdleThread`:

    0x840107bc    0x0    ret

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_activateIdleThread` has 2 nodes.

Section halt (67 of 271)
========================

Deriving specifications
-----------------------

Section `halt` consists of 5 instructions.

Skipping 00000073 ecall


Stack analysis
---------------

No stack accesses found. Code for `halt`:

    0x8401041e    0x0    li a0,0
    0x84010420    0x2    li a1,0
    0x84010422    0x4    li a2,0
    0x84010424    0x6    li a7,8
    0x84010426    0x8    ecall

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `halt` has 6 nodes.

Section restore_user_context (68 of 271)
========================================

Deriving specifications
-----------------------

Section `restore_user_context` consists of 41 instructions.

Skipping 14131073 csrw sepc,t1

Skipping 14029073 csrw sscratch,t0

Skipping 10031073 csrw sstatus,t1

Skipping 10200073 sret


Stack analysis
---------------

No stack accesses found. Code for `restore_user_context`:

    0x8401037c     0x0    auipc a5,0x1a
    0x84010380     0x4    ld a5,1212(a5) # ffffffff8402a838 <ksCurThread>
    0x84010384     0x8    mv t0,a5
    0x84010386     0xa    ld ra,0(t0)
    0x8401038a     0xe    ld sp,8(t0)
    0x8401038e    0x12    ld gp,16(t0)
    0x84010392    0x16    ld t2,48(t0)
    0x84010396    0x1a    ld s0,56(t0)
    0x8401039a    0x1e    ld s1,64(t0)
    0x8401039e    0x22    ld a0,72(t0)
    0x840103a2    0x26    ld a1,80(t0)
    0x840103a6    0x2a    ld a2,88(t0)
    0x840103aa    0x2e    ld a3,96(t0)
    0x840103ae    0x32    ld a4,104(t0)
    0x840103b2    0x36    ld a5,112(t0)
    0x840103b6    0x3a    ld a6,120(t0)
    0x840103ba    0x3e    ld a7,128(t0)
    0x840103be    0x42    ld s2,136(t0)
    0x840103c2    0x46    ld s3,144(t0)
    0x840103c6    0x4a    ld s4,152(t0)
    0x840103ca    0x4e    ld s5,160(t0)
    0x840103ce    0x52    ld s6,168(t0)
    0x840103d2    0x56    ld s7,176(t0)
    0x840103d6    0x5a    ld s8,184(t0)
    0x840103da    0x5e    ld s9,192(t0)
    0x840103de    0x62    ld s10,200(t0)
    0x840103e2    0x66    ld s11,208(t0)
    0x840103e6    0x6a    ld t3,216(t0)
    0x840103ea    0x6e    ld t4,224(t0)
    0x840103ee    0x72    ld t5,232(t0)
    0x840103f2    0x76    ld t6,240(t0)
    0x840103f6    0x7a    ld t1,24(t0)
    0x840103fa    0x7e    add tp,t1,zero
    0x840103fe    0x82    ld t1,272(t0)
    0x84010402    0x86    csrw sepc,t1
    0x84010406    0x8a    csrw sscratch,t0
    0x8401040a    0x8e    ld t1,256(t0)
    0x8401040e    0x92    csrw sstatus,t1
    0x84010412    0x96    ld t1,40(t0)
    0x84010416    0x9a    ld t0,32(t0)
    0x8401041a    0x9e    sret

Proving inst theorems
---------------------

41 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `restore_user_context` has 79 nodes.

Section cap_get_capPtr (69 of 271)
==================================

Deriving specifications
-----------------------

Section `cap_get_capPtr` consists of 129 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cap_get_capPtr`:

    0x840101c8      0x0    addi sp,sp,-16
    0x840101ca      0x2    mv a4,a0
    0x840101cc      0x4    srli a5,a0,0x3b
    0x840101d0      0x8    li a3,10
    0x840101d2      0xa    beq a5,a3,ffffffff84010292 <cap_get_capPtr+0xca>
    0x840101d6      0xe    bltu a3,a5,ffffffff84010220 <cap_get_capPtr+0x58>
    0x840101da     0x12    li a3,4
    0x840101dc     0x14    beq a5,a3,ffffffff8401027a <cap_get_capPtr+0xb2>
    0x840101e0     0x18    bgeu a3,a5,ffffffff84010202 <cap_get_capPtr+0x3a>
    0x840101e4     0x1c    li a3,6
    0x840101e6     0x1e    li a0,0
    0x840101e8     0x20    bne a5,a3,ffffffff84010276 <cap_get_capPtr+0xae>
    0x840101ec     0x24    slli a5,a4,0x19
    0x840101f0     0x28    srli a5,a5,0x19
    0x840101f2     0x2a    srli a4,a4,0x26
    0x840101f4     0x2c    andi a4,a4,1
    0x840101f6     0x2e    beqz a4,ffffffff840101fe <cap_get_capPtr+0x36>
    0x840101f8     0x30    li a4,-1
    0x840101fa     0x32    slli a4,a4,0x27
    0x840101fc     0x34    or a5,a5,a4
    0x840101fe     0x36    mv a0,a5
    0x84010200     0x38    j ffffffff84010276 <cap_get_capPtr+0xae>
    0x84010202     0x3a    li a3,2
    0x84010204     0x3c    bne a5,a3,ffffffff840102e8 <cap_get_capPtr+0x120>
    0x84010208     0x40    slli a5,a0,0x19
    0x8401020c     0x44    srli a5,a5,0x19
    0x8401020e     0x46    srli a4,a0,0x26
    0x84010212     0x4a    andi a4,a4,1
    0x84010214     0x4c    beqz a4,ffffffff8401021c <cap_get_capPtr+0x54>
    0x84010216     0x4e    li a4,-1
    0x84010218     0x50    slli a4,a4,0x27
    0x8401021a     0x52    or a5,a5,a4
    0x8401021c     0x54    mv a0,a5
    0x8401021e     0x56    j ffffffff84010276 <cap_get_capPtr+0xae>
    0x84010220     0x58    li a3,16
    0x84010222     0x5a    beq a5,a3,ffffffff840102e4 <cap_get_capPtr+0x11c>
    0x84010226     0x5e    bgeu a3,a5,ffffffff8401024e <cap_get_capPtr+0x86>
    0x8401022a     0x62    li a3,18
    0x8401022c     0x64    li a0,0
    0x8401022e     0x66    bne a5,a3,ffffffff84010276 <cap_get_capPtr+0xae>
    0x84010232     0x6a    andi a5,a4,127
    0x84010236     0x6e    li a3,64
    0x8401023a     0x72    beq a5,a3,ffffffff840102ac <cap_get_capPtr+0xe4>
    0x8401023e     0x76    andi a4,a4,63
    0x84010242     0x7a    addiw a4,a4,1
    0x84010244     0x7c    li a0,-1
    0x84010246     0x7e    sll a0,a0,a4
    0x8401024a     0x82    and a0,a0,a1
    0x8401024c     0x84    j ffffffff84010276 <cap_get_capPtr+0xae>
    0x8401024e     0x86    li a3,12
    0x84010250     0x88    bne a5,a3,ffffffff8401026e <cap_get_capPtr+0xa6>
    0x84010254     0x8c    slli a5,a0,0x19
    0x84010258     0x90    srli a5,a5,0x19
    0x8401025a     0x92    srli a4,a0,0x26
    0x8401025e     0x96    andi a4,a4,1
    0x84010260     0x98    beqz a4,ffffffff84010268 <cap_get_capPtr+0xa0>
    0x84010262     0x9a    li a4,-1
    0x84010264     0x9c    slli a4,a4,0x27
    0x84010266     0x9e    or a5,a5,a4
    0x84010268     0xa0    andi a0,a5,-1024
    0x8401026c     0xa4    j ffffffff84010276 <cap_get_capPtr+0xae>
    0x8401026e     0xa6    li a3,14
    0x84010270     0xa8    li a0,0
    0x84010272     0xaa    bne a5,a3,ffffffff840102b0 <cap_get_capPtr+0xe8>
    0x84010276     0xae    addi sp,sp,16
    0x84010278     0xb0    ret
    0x8401027a     0xb2    slli a5,a0,0x19
    0x8401027e     0xb6    srli a5,a5,0x19
    0x84010280     0xb8    srli a4,a0,0x26
    0x84010284     0xbc    andi a4,a4,1
    0x84010286     0xbe    beqz a4,ffffffff8401028e <cap_get_capPtr+0xc6>
    0x84010288     0xc0    li a4,-1
    0x8401028a     0xc2    slli a4,a4,0x27
    0x8401028c     0xc4    or a5,a5,a4
    0x8401028e     0xc6    mv a0,a5
    0x84010290     0xc8    j ffffffff84010276 <cap_get_capPtr+0xae>
    0x84010292     0xca    slli a4,a0,0x1
    0x84010296     0xce    lui a0,0xfc000
    0x8401029a     0xd2    srli a0,a0,0x19
    0x8401029c     0xd4    and a0,a0,a4
    0x8401029e     0xd6    srli a4,a4,0x26
    0x840102a0     0xd8    andi a4,a4,1
    0x840102a2     0xda    beqz a4,ffffffff84010276 <cap_get_capPtr+0xae>
    0x840102a4     0xdc    li a5,-1
    0x840102a6     0xde    slli a5,a5,0x27
    0x840102a8     0xe0    or a0,a0,a5
    0x840102aa     0xe2    j ffffffff84010276 <cap_get_capPtr+0xae>
    0x840102ac     0xe4    li a4,4
    0x840102ae     0xe6    j ffffffff84010242 <cap_get_capPtr+0x7a>
    0x840102b0     0xe8    li a3,13
    0x840102b2     0xea    bne a5,a3,ffffffff840102ee <cap_get_capPtr+0x126>
    0x840102b6     0xee    slli a4,a4,0x2
    0x840102b8     0xf0    lui a0,0xf8000
    0x840102bc     0xf4    srli a0,a0,0x19
    0x840102be     0xf6    and a0,a0,a4
    0x840102c0     0xf8    srli a4,a4,0x26
    0x840102c2     0xfa    andi a4,a4,1
    0x840102c4     0xfc    beqz a4,ffffffff84010276 <cap_get_capPtr+0xae>
    0x840102c6     0xfe    li a5,-1
    0x840102c8    0x100    slli a5,a5,0x27
    0x840102ca    0x102    or a0,a0,a5
    0x840102cc    0x104    j ffffffff84010276 <cap_get_capPtr+0xae>
    0x840102ce    0x106    srli a1,a1,0x9
    0x840102d0    0x108    slli a0,a1,0x19
    0x840102d4    0x10c    srli a0,a0,0x19
    0x840102d6    0x10e    srli a1,a1,0x26
    0x840102d8    0x110    andi a1,a1,1
    0x840102da    0x112    beqz a1,ffffffff84010276 <cap_get_capPtr+0xae>
    0x840102dc    0x114    li a5,-1
    0x840102de    0x116    slli a5,a5,0x27
    0x840102e0    0x118    or a0,a0,a5
    0x840102e2    0x11a    j ffffffff84010276 <cap_get_capPtr+0xae>
    0x840102e4    0x11c    li a0,0
    0x840102e6    0x11e    j ffffffff84010276 <cap_get_capPtr+0xae>
    0x840102e8    0x120    li a4,3
    0x840102ea    0x122    beq a5,a4,ffffffff840102ce <cap_get_capPtr+0x106>
    0x840102ee    0x126    li a4,1
    0x840102f0    0x128    li a0,0
    0x840102f2    0x12a    bne a5,a4,ffffffff84010276 <cap_get_capPtr+0xae>
    0x840102f6    0x12e    srli a1,a1,0x9
    0x840102f8    0x130    slli a0,a1,0x19
    0x840102fc    0x134    srli a0,a0,0x19
    0x840102fe    0x136    srli a1,a1,0x26
    0x84010300    0x138    andi a1,a1,1
    0x84010302    0x13a    beqz a1,ffffffff84010276 <cap_get_capPtr+0xae>
    0x84010304    0x13c    li a5,-1
    0x84010306    0x13e    slli a5,a5,0x27
    0x84010308    0x140    or a0,a0,a5
    0x8401030a    0x142    j ffffffff84010276 <cap_get_capPtr+0xae>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
129 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cap_get_capPtr` has 176 nodes.

Section getNewActiveIRQ (70 of 271)
===================================

Deriving specifications
-----------------------

Section `getNewActiveIRQ` consists of 13 instructions.

Skipping 14402573 csrr a0,sip


Stack analysis
---------------

No stack accesses found. Code for `getNewActiveIRQ`:

    0x840101a4     0x0    csrr a0,sip
    0x840101a8     0x4    andi a5,a0,512
    0x840101ac     0x8    bnez a5,ffffffff840101b6 <getNewActiveIRQ+0x12>
    0x840101ae     0xa    andi a0,a0,32
    0x840101b2     0xe    bnez a0,ffffffff840101c2 <getNewActiveIRQ+0x1e>
    0x840101b4    0x10    ret
    0x840101b6    0x12    lui a5,0xcc202
    0x840101ba    0x16    lw a0,4(a5)
    0x840101bc    0x18    slli a0,a0,0x20
    0x840101be    0x1a    srli a0,a0,0x20
    0x840101c0    0x1c    ret
    0x840101c2    0x1e    li a0,54
    0x840101c6    0x22    j ffffffff840101b4 <getNewActiveIRQ+0x10>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getNewActiveIRQ` has 21 nodes.

Section findVSpaceForASID (71 of 271)
=====================================

Deriving specifications
-----------------------

Section `findVSpaceForASID` consists of 35 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `findVSpaceForASID`:

    0x84010144     0x0    addi sp,sp,-16
    0x84010146     0x2    srli a5,a0,0x9
    0x8401014a     0x6    slli a4,a5,0x3
    0x8401014e     0xa    auipc a5,0x8
    0x84010152     0xe    addi a5,a5,-334 # ffffffff84018000 <riscvKSASIDTable>
    0x84010156    0x12    add a5,a5,a4
    0x84010158    0x14    ld a5,0(a5)
    0x8401015a    0x16    beqz a5,ffffffff84010174 <findVSpaceForASID+0x30>
    0x8401015c    0x18    andi a0,a0,511
    0x84010160    0x1c    slli a0,a0,0x3
    0x84010162    0x1e    add a0,a0,a5
    0x84010164    0x20    ld a5,0(a0)
    0x84010166    0x22    beqz a5,ffffffff8401018c <findVSpaceForASID+0x48>
    0x84010168    0x24    sd zero,0(sp)         ; stack access
    0x8401016a    0x26    sd a5,8(sp)           ; stack access
    0x8401016c    0x28    ld a0,0(sp)           ; stack access
    0x8401016e    0x2a    ld a1,8(sp)           ; stack access
    0x84010170    0x2c    addi sp,sp,16
    0x84010172    0x2e    ret
    0x84010174    0x30    auipc a5,0x8
    0x84010178    0x34    addi a5,a5,-372 # ffffffff84018000 <riscvKSASIDTable>
    0x8401017c    0x38    sd zero,1024(a5)
    0x84010180    0x3c    sd zero,1032(a5)
    0x84010184    0x40    li a5,2
    0x84010186    0x42    sd a5,0(sp)           ; stack access
    0x84010188    0x44    sd zero,8(sp)         ; stack access
    0x8401018a    0x46    j ffffffff8401016c <findVSpaceForASID+0x28>
    0x8401018c    0x48    auipc a5,0x8
    0x84010190    0x4c    addi a5,a5,-396 # ffffffff84018000 <riscvKSASIDTable>
    0x84010194    0x50    sd zero,1024(a5)
    0x84010198    0x54    sd zero,1032(a5)
    0x8401019c    0x58    li a5,2
    0x8401019e    0x5a    sd a5,0(sp)           ; stack access
    0x840101a0    0x5c    sd zero,8(sp)         ; stack access
    0x840101a2    0x5e    j ffffffff8401016c <findVSpaceForASID+0x28>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
35 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `findVSpaceForASID` has 54 nodes.

Section pte_next (72 of 271)
============================

Deriving specifications
-----------------------

Section `pte_next` consists of 13 instructions.


Stack analysis
---------------

No stack accesses found. Code for `pte_next`:

    0x84010120     0x0    snez a1,a1
    0x84010124     0x4    srli a0,a0,0x2
    0x84010126     0x6    lui a5,0xfff00
    0x8401012a     0xa    srli a5,a5,0xa
    0x8401012c     0xc    and a0,a0,a5
    0x8401012e     0xe    slli a5,a1,0x3
    0x84010132    0x12    slli a4,a1,0x2
    0x84010136    0x16    or a5,a5,a4
    0x84010138    0x18    or a0,a0,a5
    0x8401013a    0x1a    slli a1,a1,0x1
    0x8401013c    0x1c    or a0,a0,a1
    0x8401013e    0x1e    ori a0,a0,225
    0x84010142    0x22    ret

Proving inst theorems
---------------------

13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `pte_next` has 14 nodes.

Section idle_thread (73 of 271)
===============================

Deriving specifications
-----------------------

Section `idle_thread` consists of 2 instructions.

Skipping 10500073 wfi


Stack analysis
---------------

No stack accesses found. Code for `idle_thread`:

    0x8401011a    0x0    wfi
    0x8401011e    0x4    j ffffffff8401011a <idle_thread>

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `idle_thread` has 3 nodes.

Section getSyscallArg (74 of 271)
=================================

Deriving specifications
-----------------------

Section `getSyscallArg` consists of 18 instructions.


Stack analysis
---------------

No stack accesses found. Code for `getSyscallArg`:

    0x840100ea     0x0    li a5,3
    0x840100ec     0x2    bgeu a5,a0,ffffffff840100fa <getSyscallArg+0x10>
    0x840100f0     0x6    addi a0,a0,1
    0x840100f2     0x8    slli a0,a0,0x3
    0x840100f4     0xa    add a1,a1,a0
    0x840100f6     0xc    ld a0,0(a1)
    0x840100f8     0xe    ret
    0x840100fa    0x10    slli a0,a0,0x3
    0x840100fc    0x12    auipc a5,0x7
    0x84010100    0x16    addi a5,a5,1116 # ffffffff84017558 <msgRegisters>
    0x84010104    0x1a    add a0,a0,a5
    0x84010106    0x1c    ld a5,0(a0)
    0x84010108    0x1e    slli a4,a5,0x3
    0x8401010c    0x22    auipc a5,0x1a
    0x84010110    0x26    ld a5,1836(a5) # ffffffff8402a838 <ksCurThread>
    0x84010114    0x2a    add a5,a5,a4
    0x84010116    0x2c    ld a0,0(a5)
    0x84010118    0x2e    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getSyscallArg` has 26 nodes.

Section clzl (75 of 271)
========================

Deriving specifications
-----------------------

Section `clzl` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `clzl`:

    0x840100cc     0x0    mv a5,a0
    0x840100ce     0x2    bltz a0,ffffffff840100e6 <clzl+0x1a>
    0x840100d2     0x6    li a0,0
    0x840100d4     0x8    li a4,65
    0x840100d8     0xc    slli a5,a5,0x1
    0x840100da     0xe    addi a0,a0,1
    0x840100dc    0x10    bltz a5,ffffffff840100e8 <clzl+0x1c>
    0x840100e0    0x14    bne a0,a4,ffffffff840100d8 <clzl+0xc>
    0x840100e4    0x18    ret
    0x840100e6    0x1a    li a0,0
    0x840100e8    0x1c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `clzl` has 19 nodes.

Section bi_finalise (76 of 271)
===============================

Deriving specifications
-----------------------

Section `bi_finalise` consists of 8 instructions.


Stack analysis
---------------

No stack accesses found. Code for `bi_finalise`:

    0x84000b84     0x0    auipc a5,0x1
    0x84000b88     0x4    addi a5,a5,-1628 # ffffffff84001528 <ndks_boot>
    0x84000b8c     0x8    ld a3,592(a5)
    0x84000b90     0xc    ld a4,600(a5)
    0x84000b94    0x10    ld a5,584(a5)
    0x84000b98    0x14    sd a3,40(a5)
    0x84000b9a    0x16    sd a4,48(a5)
    0x84000b9c    0x18    ret

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `bi_finalise` has 14 nodes.

Section init_core_state (77 of 271)
===================================

Deriving specifications
-----------------------

Section `init_core_state` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `init_core_state`:

    0x8400095a     0x0    auipc a5,0x2a
    0x8400095e     0x4    sd a0,-306(a5) # ffffffff8402a828 <ksSchedulerAction>
    0x84000962     0x8    auipc a5,0x2a
    0x84000966     0xc    ld a5,-306(a5) # ffffffff8402a830 <ksIdleThread>
    0x8400096a    0x10    auipc a4,0x2a
    0x8400096e    0x14    sd a5,-306(a4) # ffffffff8402a838 <ksCurThread>
    0x84000972    0x18    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `init_core_state` has 11 nodes.

Section create_root_cnode (78 of 271)
=====================================

Deriving specifications
-----------------------

Section `create_root_cnode` consists of 20 instructions.


Stack analysis
---------------

No stack accesses found. Code for `create_root_cnode`:

    0x840005a2     0x0    addi sp,sp,-16
    0x840005a4     0x2    auipc a5,0x1
    0x840005a8     0x6    addi a5,a5,-124 # ffffffff84001528 <ndks_boot>
    0x840005ac     0xa    lui a4,0x80
    0x840005b0     0xe    sd a4,600(a5)
    0x840005b4    0x12    ld a4,608(a5)
    0x840005b8    0x16    slli a0,a4,0x19
    0x840005bc    0x1a    srli a0,a0,0x1a
    0x840005be    0x1c    lui a5,0xab53
    0x840005c2    0x20    slli a5,a5,0x23
    0x840005c4    0x22    or a0,a0,a5
    0x840005c6    0x24    addi a5,a4,64 # 80040 <KERNEL_OFFSET-0xfffffffefff7ffc0>
    0x840005ca    0x28    sd a0,64(a4)
    0x840005cc    0x2a    sd zero,72(a4)
    0x840005d0    0x2e    sd zero,80(a4)
    0x840005d4    0x32    li a4,3
    0x840005d6    0x34    sd a4,24(a5)
    0x840005d8    0x36    li a1,0
    0x840005da    0x38    addi sp,sp,16
    0x840005dc    0x3a    ret

Proving inst theorems
---------------------

20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_root_cnode` has 27 nodes.

Section write_slot (79 of 271)
==============================

Deriving specifications
-----------------------

Section `write_slot` consists of 8 instructions.


Stack analysis
---------------

No stack accesses found. Code for `write_slot`:

    0x84000590     0x0    addi sp,sp,-16
    0x84000592     0x2    sd a1,0(a0)
    0x84000594     0x4    sd a2,8(a0)
    0x84000596     0x6    sd zero,16(a0) # c000010 <KERNEL_OFFSET-0xfffffffef3fffff0>
    0x8400059a     0xa    li a5,3
    0x8400059c     0xc    sd a5,24(a0)
    0x8400059e     0xe    addi sp,sp,16
    0x840005a0    0x10    ret

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `write_slot` has 13 nodes.

Section initIRQController (80 of 271)
=====================================

Deriving specifications
-----------------------

Section `initIRQController` consists of 30 instructions.

LW..
SW..

Stack analysis
---------------

No stack accesses found. Code for `initIRQController`:

    0x8400030e     0x0    li a4,1
    0x84000310     0x2    lui a0,0xcc001
    0x84000314     0x6    lui a6,0xcc202
    0x84000318     0xa    li a1,54
    0x8400031c     0xe    j ffffffff84000324 <initIRQController+0x16>
    0x8400031e    0x10    addi a4,a4,1
    0x84000320    0x12    beq a4,a1,ffffffff8400034c <initIRQController+0x3e>
    0x84000324    0x16    sext.w a2,a4
    0x84000328    0x1a    srli a5,a4,0x5
    0x8400032c    0x1e    slli a5,a5,0x2
    0x8400032e    0x20    add a5,a5,a0
    0x84000330    0x22    lw a5,0(a5)
    0x84000332    0x24    slli a5,a5,0x20
    0x84000334    0x26    srli a5,a5,0x20
    0x84000336    0x28    andi a3,a4,31
    0x8400033a    0x2c    srl a5,a5,a3
    0x8400033e    0x30    andi a5,a5,1
    0x84000340    0x32    beqz a5,ffffffff8400031e <initIRQController+0x10>
    0x84000342    0x34    lw a5,4(a6) # ffffffffcc202004 <ki_end+0x481d3004>
    0x84000346    0x38    sw a2,4(a6)
    0x8400034a    0x3c    j ffffffff8400031e <initIRQController+0x10>
    0x8400034c    0x3e    lui a5,0xcc000
    0x84000350    0x42    addi a5,a5,4
    0x84000352    0x44    li a3,2
    0x84000354    0x46    lui a4,0xcc000
    0x84000358    0x4a    addi a4,a4,220 # ffffffffcc0000dc <ki_end+0x47fd10dc>
    0x8400035c    0x4e    sw a3,0(a5)
    0x8400035e    0x50    addi a5,a5,4
    0x84000360    0x52    bne a5,a4,ffffffff8400035c <initIRQController+0x4e>
    0x84000364    0x56    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
30 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `initIRQController` has 41 nodes.

Section initLocalIRQController (81 of 271)
==========================================

Deriving specifications
-----------------------

Section `initLocalIRQController` consists of 22 instructions.

Skipping 1047a7f3 csrrs a5,sie,a5


Stack analysis
---------------

No stack accesses found. Code for `initLocalIRQController`:

    0x840002ca     0x0    li a3,1
    0x840002cc     0x2    lui a1,0xcc002
    0x840002d0     0x6    addi a1,a1,256 # ffffffffcc002100 <ki_end+0x47fd3100>
    0x840002d4     0xa    li a6,1
    0x840002d6     0xc    li a0,54
    0x840002da    0x10    srli a4,a3,0x5
    0x840002de    0x14    slli a4,a4,0x2
    0x840002e0    0x16    add a4,a4,a1
    0x840002e2    0x18    lw a2,0(a4)
    0x840002e4    0x1a    andi a5,a3,31
    0x840002e8    0x1e    sll a5,a6,a5
    0x840002ec    0x22    not a5,a5
    0x840002f0    0x26    and a5,a5,a2
    0x840002f2    0x28    sext.w a5,a5
    0x840002f4    0x2a    sw a5,0(a4)
    0x840002f6    0x2c    addi a3,a3,1
    0x840002f8    0x2e    bne a3,a0,ffffffff840002da <initLocalIRQController+0x10>
    0x840002fc    0x32    lui a5,0xcc202
    0x84000300    0x36    sw zero,0(a5) # ffffffffcc202000 <ki_end+0x481d3000>
    0x84000304    0x3a    li a5,544
    0x84000308    0x3e    csrrs a5,sie,a5
    0x8400030c    0x42    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `initLocalIRQController` has 29 nodes.

Section initL2Cache (82 of 271)
===============================

Deriving specifications
-----------------------

Section `initL2Cache` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `initL2Cache`:

    0x840002c8    0x0    ret

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `initL2Cache` has 2 nodes.

Section initTimer (83 of 271)
=============================

Deriving specifications
-----------------------

Section `initTimer` consists of 7 instructions.

Skipping c0102573 rdtime a0

Skipping 00000073 ecall


Stack analysis
---------------

No stack accesses found. Code for `initTimer`:

    0x840002b4     0x0    rdtime a0
    0x840002b8     0x4    addi a0,a0,2000
    0x840002bc     0x8    li a1,0
    0x840002be     0xa    li a2,0
    0x840002c0     0xc    li a7,0
    0x840002c2     0xe    ecall
    0x840002c6    0x12    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `initTimer` has 10 nodes.

Section get_avail_p_regs (84 of 271)
====================================

Deriving specifications
-----------------------

Section `get_avail_p_regs` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `get_avail_p_regs`:

    0x840002aa    0x0    auipc a0,0x1
    0x840002ae    0x4    addi a0,a0,622 # ffffffff84001518 <avail_p_regs>
    0x840002b2    0x8    ret

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `get_avail_p_regs` has 4 nodes.

Section get_num_avail_p_regs (85 of 271)
========================================

Deriving specifications
-----------------------

Section `get_num_avail_p_regs` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `get_num_avail_p_regs`:

    0x840002a6    0x0    li a0,1
    0x840002a8    0x2    ret

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `get_num_avail_p_regs` has 3 nodes.

Section activate_kernel_vspace (86 of 271)
==========================================

Deriving specifications
-----------------------

Section `activate_kernel_vspace` consists of 14 instructions.

Skipping 18079073 csrw satp,a5

Skipping 12000073 sfence.vma


Stack analysis
---------------

No stack accesses found. Code for `activate_kernel_vspace`:

    0x84000138     0x0    auipc a5,0x2d
    0x8400013c     0x4    addi a5,a5,-312 # ffffffff8402d000 <kernel_root_pageTable>
    0x84000140     0x8    li a4,1
    0x84000142     0xa    slli a4,a4,0x20
    0x84000144     0xc    add a5,a5,a4
    0x84000146     0xe    srli a5,a5,0xc
    0x84000148    0x10    li a4,-1
    0x8400014a    0x12    srli a3,a4,0x14
    0x8400014e    0x16    and a5,a5,a3
    0x84000150    0x18    slli a4,a4,0x3f
    0x84000152    0x1a    or a5,a5,a4
    0x84000154    0x1c    csrw satp,a5
    0x84000158    0x20    sfence.vma
    0x8400015c    0x24    ret

Proving inst theorems
---------------------

14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `activate_kernel_vspace` has 17 nodes.

Section arch_get_n_paging (87 of 271)
=====================================

Deriving specifications
-----------------------

Section `arch_get_n_paging` consists of 19 instructions.


Stack analysis
---------------

No stack accesses found. Code for `arch_get_n_paging`:

    0x84000108     0x0    addi sp,sp,-16
    0x8400010a     0x2    addi a1,a1,-1
    0x8400010c     0x4    srli a4,a1,0x15
    0x84000110     0x8    addi a4,a4,1
    0x84000112     0xa    slli a4,a4,0x15
    0x84000114     0xc    lui a5,0xffe00
    0x84000118    0x10    and a5,a5,a0
    0x8400011a    0x12    sub a4,a4,a5
    0x8400011c    0x14    srli a4,a4,0x15
    0x8400011e    0x16    srli a5,a1,0x1e
    0x84000122    0x1a    addi a5,a5,1
    0x84000124    0x1c    slli a5,a5,0x1e
    0x84000126    0x1e    lui a3,0xc0000
    0x8400012a    0x22    and a0,a0,a3
    0x8400012c    0x24    sub a5,a5,a0
    0x8400012e    0x26    srli a5,a5,0x1e
    0x84000130    0x28    add a0,a4,a5
    0x84000134    0x2c    addi sp,sp,16
    0x84000136    0x2e    ret

Proving inst theorems
---------------------

19 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arch_get_n_paging` has 20 nodes.

Section create_unmapped_it_frame_cap (88 of 271)
================================================

Deriving specifications
-----------------------

Section `create_unmapped_it_frame_cap` consists of 9 instructions.


Stack analysis
---------------

No stack accesses found. Code for `create_unmapped_it_frame_cap`:

    0x840000f2     0x0    addi sp,sp,-16
    0x840000f4     0x2    slli a1,a0,0x9
    0x840000f8     0x6    li a0,1
    0x840000fa     0x8    slli a0,a0,0x3b
    0x840000fc     0xa    lui a5,0xfe000
    0x84000100     0xe    srli a5,a5,0x10
    0x84000102    0x10    and a1,a1,a5
    0x84000104    0x12    addi sp,sp,16
    0x84000106    0x14    ret

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_unmapped_it_frame_cap` has 10 nodes.

Section Arch_configureIdleThread (89 of 271)
============================================

Deriving specifications
-----------------------

Section `Arch_configureIdleThread` consists of 9 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_configureIdleThread`:

    0x840000a4     0x0    auipc a5,0x10
    0x840000a8     0x4    addi a5,a5,118 # ffffffff8401011a <idle_thread>
    0x840000ac     0x8    sd a5,272(a0)
    0x840000b0     0xc    li a5,288
    0x840000b4    0x10    sd a5,256(a0)
    0x840000b8    0x14    auipc a5,0x2a
    0x840000bc    0x18    addi a5,a5,1864 # ffffffff8402a800 <tlbLockCount>
    0x840000c0    0x1c    sd a5,8(a0)
    0x840000c2    0x1e    ret

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_configureIdleThread` has 13 nodes.

Section merge_regions (90 of 271)
=================================

Deriving specifications
-----------------------

Section `merge_regions` consists of 43 instructions.


Stack analysis
---------------

No stack accesses found. Code for `merge_regions`:

    0x84000026     0x0    auipc a1,0x1
    0x8400002a     0x4    ld a1,1602(a1) # ffffffff84001668 <ndks_boot+0x140>
    0x8400002e     0x8    li a5,1
    0x84000030     0xa    bgeu a5,a1,ffffffff840000a2 <merge_regions+0x7c>
    0x84000034     0xe    li a4,1
    0x84000036    0x10    auipc a2,0x1
    0x8400003a    0x14    addi a2,a2,1266 # ffffffff84001528 <ndks_boot>
    0x8400003e    0x18    auipc a6,0x1
    0x84000042    0x1c    addi a6,a6,1242 # ffffffff84001518 <avail_p_regs>
    0x84000046    0x20    j ffffffff84000086 <merge_regions+0x60>
    0x84000048    0x22    slli a5,a4,0x4
    0x8400004c    0x26    add a5,a5,a2
    0x8400004e    0x28    ld a5,8(a5)
    0x84000050    0x2a    slli a0,a0,0x4
    0x84000052    0x2c    add a0,a0,a2
    0x84000054    0x2e    sd a5,8(a0)
    0x84000056    0x30    addi a5,a4,1
    0x8400005a    0x34    bgeu a5,a1,ffffffff84000078 <merge_regions+0x52>
    0x8400005e    0x38    slli a5,a4,0x4
    0x84000062    0x3c    add a5,a5,a2
    0x84000064    0x3e    slli a0,a1,0x4
    0x84000068    0x42    add a0,a0,a6
    0x8400006a    0x44    ld a3,16(a5)
    0x8400006c    0x46    sd a3,0(a5)
    0x8400006e    0x48    ld a3,24(a5)
    0x84000070    0x4a    sd a3,8(a5)
    0x84000072    0x4c    addi a5,a5,16
    0x84000074    0x4e    bne a5,a0,ffffffff8400006a <merge_regions+0x44>
    0x84000078    0x52    addi a1,a1,-1
    0x8400007a    0x54    sd a1,320(a2)
    0x8400007e    0x58    ld a1,320(a2)
    0x84000082    0x5c    bgeu a4,a1,ffffffff840000a2 <merge_regions+0x7c>
    0x84000086    0x60    addi a0,a4,-1
    0x8400008a    0x64    slli a3,a0,0x4
    0x8400008e    0x68    add a3,a3,a2
    0x84000090    0x6a    slli a5,a4,0x4
    0x84000094    0x6e    add a5,a5,a2
    0x84000096    0x70    ld a3,8(a3)
    0x84000098    0x72    ld a5,0(a5)
    0x8400009a    0x74    beq a3,a5,ffffffff84000048 <merge_regions+0x22>
    0x8400009e    0x78    addi a4,a4,1
    0x840000a0    0x7a    j ffffffff8400007e <merge_regions+0x58>
    0x840000a2    0x7c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
43 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `merge_regions` has 65 nodes.

Section str_to_long (91 of 271)
===============================

Deriving specifications
-----------------------

Section `str_to_long` consists of 44 instructions.

RVC_FTTTFFFTF_____FT.
JAL.
BGE..
MUL.....
RVC_FTT_FFFFT_____TF.
RVC_FTT_T_________TF.
RVC_FTTFFFFTFT____FT.

Stack analysis
---------------

10 stack accesses found. Annotated code for `str_to_long`:

    0x84017456     0x0    addi sp,sp,-48
    0x84017458     0x2    sd ra,40(sp)          ; stack access
    0x8401745a     0x4    sd s0,32(sp)          ; stack access
    0x8401745c     0x6    sd s1,24(sp)          ; stack access
    0x8401745e     0x8    sd s2,16(sp)          ; stack access
    0x84017460     0xa    sd s3,8(sp)           ; stack access
    0x84017462     0xc    mv s1,a0
    0x84017464     0xe    lbu a0,0(a0)
    0x84017468    0x12    li a5,48
    0x8401746c    0x16    li s2,10
    0x8401746e    0x18    beq a0,a5,ffffffff840174a0 <str_to_long+0x4a>
    0x84017472    0x1c    lbu a0,0(s1)
    0x84017476    0x20    beqz a0,ffffffff840174b6 <str_to_long+0x60>
    0x84017478    0x22    li s0,0
    0x8401747a    0x24    li s3,-1
    0x8401747c    0x26    slli s2,s2,0x20
    0x8401747e    0x28    srli s2,s2,0x20
    0x84017482    0x2c    jal ra,ffffffff84017416 <char_to_long>
    0x84017486    0x30    beq a0,s3,ffffffff840174bc <str_to_long+0x66>
    0x8401748a    0x34    bge a0,s2,ffffffff840174ba <str_to_long+0x64>
    0x8401748e    0x38    mul s0,s2,s0
    0x84017492    0x3c    add s0,s0,a0
    0x84017494    0x3e    addi s1,s1,1
    0x84017496    0x40    lbu a0,0(s1)
    0x8401749a    0x44    bnez a0,ffffffff84017482 <str_to_long+0x2c>
    0x8401749c    0x46    mv a0,s0
    0x8401749e    0x48    j ffffffff840174bc <str_to_long+0x66>
    0x840174a0    0x4a    lbu a5,1(s1)
    0x840174a4    0x4e    andi a5,a5,223
    0x840174a8    0x52    li a4,88
    0x840174ac    0x56    bne a5,a4,ffffffff84017478 <str_to_long+0x22>
    0x840174b0    0x5a    addi s1,s1,2
    0x840174b2    0x5c    li s2,16
    0x840174b4    0x5e    j ffffffff84017472 <str_to_long+0x1c>
    0x840174b6    0x60    li a0,-1
    0x840174b8    0x62    j ffffffff840174bc <str_to_long+0x66>
    0x840174ba    0x64    li a0,-1
    0x840174bc    0x66    ld ra,40(sp)          ; stack access
    0x840174be    0x68    ld s0,32(sp)          ; stack access
    0x840174c0    0x6a    ld s1,24(sp)          ; stack access
    0x840174c2    0x6c    ld s2,16(sp)          ; stack access
    0x840174c4    0x6e    ld s3,8(sp)           ; stack access
    0x840174c6    0x70    addi sp,sp,48
    0x840174c8    0x72    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
44 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `str_to_long` has 72 nodes.

Section memset (92 of 271)
==========================

Deriving specifications
-----------------------

Section `memset` consists of 23 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `memset`:

    0x840173a2     0x0    addi sp,sp,-16
    0x840173a4     0x2    sd ra,8(sp)           ; stack access
    0x840173a6     0x4    sd s0,0(sp)           ; stack access
    0x840173a8     0x6    mv s0,a0
    0x840173aa     0x8    mv a4,a1
    0x840173ac     0xa    mv a1,a2
    0x840173ae     0xc    or a5,a0,a2
    0x840173b2    0x10    andi a5,a5,7
    0x840173b4    0x12    or a5,a5,a4
    0x840173b6    0x14    bnez a5,ffffffff840173c6 <memset+0x24>
    0x840173b8    0x16    jal ra,ffffffff84015b8a <memzero>
    0x840173bc    0x1a    mv a0,s0
    0x840173be    0x1c    ld ra,8(sp)           ; stack access
    0x840173c0    0x1e    ld s0,0(sp)           ; stack access
    0x840173c2    0x20    addi sp,sp,16
    0x840173c4    0x22    ret
    0x840173c6    0x24    add a3,a0,a2
    0x840173ca    0x28    mv a5,a0
    0x840173cc    0x2a    beqz a2,ffffffff840173bc <memset+0x1a>
    0x840173ce    0x2c    sb a4,0(a5)
    0x840173d2    0x30    addi a5,a5,1
    0x840173d4    0x32    bne a3,a5,ffffffff840173ce <memset+0x2c>
    0x840173d8    0x36    j ffffffff840173bc <memset+0x1a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `memset` has 36 nodes.

Section Arch_decodeInvocation (93 of 271)
=========================================

Deriving specifications
-----------------------

Section `Arch_decodeInvocation` consists of 7 instructions.

RVC_TFFFT____T____TF..

Stack analysis
---------------

2 stack accesses found. Annotated code for `Arch_decodeInvocation`:

    0x840164d2    0x0    addi sp,sp,-32
    0x840164d4    0x2    sd ra,24(sp)          ; stack access
    0x840164d6    0x4    mv a6,a7
    0x840164d8    0x6    jal ra,ffffffff84015c08 <decodeRISCVMMUInvocation>
    0x840164dc    0xa    ld ra,24(sp)          ; stack access
    0x840164de    0xc    addi sp,sp,32
    0x840164e0    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_decodeInvocation` has 11 nodes.

Section invokeTCB_Resume (94 of 271)
====================================

Deriving specifications
-----------------------

Section `invokeTCB_Resume` consists of 7 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeTCB_Resume`:

    0x840149fa    0x0    addi sp,sp,-16
    0x840149fc    0x2    sd ra,8(sp)           ; stack access
    0x840149fe    0x4    jal ra,ffffffff84013be4 <restart>
    0x84014a02    0x8    li a0,0
    0x84014a04    0xa    ld ra,8(sp)           ; stack access
    0x84014a06    0xc    addi sp,sp,16
    0x84014a08    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_Resume` has 11 nodes.

Section invokeTCB_Suspend (95 of 271)
=====================================

Deriving specifications
-----------------------

Section `invokeTCB_Suspend` consists of 7 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeTCB_Suspend`:

    0x840149ea    0x0    addi sp,sp,-16
    0x840149ec    0x2    sd ra,8(sp)           ; stack access
    0x840149ee    0x4    jal ra,ffffffff84013144 <suspend>
    0x840149f2    0x8    li a0,0
    0x840149f4    0xa    ld ra,8(sp)           ; stack access
    0x840149f6    0xc    addi sp,sp,16
    0x840149f8    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_Suspend` has 11 nodes.

Section performInvocation_Endpoint (96 of 271)
==============================================

Deriving specifications
-----------------------

Section `performInvocation_Endpoint` consists of 16 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `performInvocation_Endpoint`:

    0x84014606     0x0    addi sp,sp,-16
    0x84014608     0x2    sd ra,8(sp)           ; stack access
    0x8401460a     0x4    mv a6,a0
    0x8401460c     0x6    mv a7,a1
    0x8401460e     0x8    mv a0,a4
    0x84014610     0xa    mv a1,a5
    0x84014612     0xc    auipc a5,0x16
    0x84014616    0x10    ld a5,550(a5) # ffffffff8402a838 <ksCurThread>
    0x8401461a    0x14    mv a4,a3
    0x8401461c    0x16    mv a3,a2
    0x8401461e    0x18    mv a2,a7
    0x84014620    0x1a    jal ra,ffffffff840142b4 <sendIPC>
    0x84014624    0x1e    li a0,0
    0x84014626    0x20    ld ra,8(sp)           ; stack access
    0x84014628    0x22    addi sp,sp,16
    0x8401462a    0x24    ret

Proving inst theorems
---------------------

16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performInvocation_Endpoint` has 21 nodes.

Section performInvocation_Reply (97 of 271)
===========================================

Deriving specifications
-----------------------

Section `performInvocation_Reply` consists of 12 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `performInvocation_Reply`:

    0x84014296     0x0    addi sp,sp,-16
    0x84014298     0x2    sd ra,8(sp)           ; stack access
    0x8401429a     0x4    mv a3,a2
    0x8401429c     0x6    mv a2,a1
    0x8401429e     0x8    mv a1,a0
    0x840142a0     0xa    auipc a0,0x16
    0x840142a4     0xe    ld a0,1432(a0) # ffffffff8402a838 <ksCurThread>
    0x840142a8    0x12    jal ra,ffffffff840141e4 <doReplyTransfer>
    0x840142ac    0x16    li a0,0
    0x840142ae    0x18    ld ra,8(sp)           ; stack access
    0x840142b0    0x1a    addi sp,sp,16
    0x840142b2    0x1c    ret

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performInvocation_Reply` has 17 nodes.

Section lookupExtraCaps (98 of 271)
===================================

Deriving specifications
-----------------------

Section `lookupExtraCaps` consists of 56 instructions.

RVC_FFFFT_________FT.

Stack analysis
---------------

16 stack accesses found. Annotated code for `lookupExtraCaps`:

    0x84013efa     0x0    beqz a1,ffffffff84013f60 <lookupExtraCaps+0x66>
    0x84013efc     0x2    addi sp,sp,-80
    0x84013efe     0x4    sd ra,72(sp)          ; stack access
    0x84013f00     0x6    sd s0,64(sp)          ; stack access
    0x84013f02     0x8    sd s1,56(sp)          ; stack access
    0x84013f04     0xa    sd s2,48(sp)          ; stack access
    0x84013f06     0xc    sd s3,40(sp)          ; stack access
    0x84013f08     0xe    sd s4,32(sp)          ; stack access
    0x84013f0a    0x10    sd s5,24(sp)          ; stack access
    0x84013f0c    0x12    mv s4,a0
    0x84013f0e    0x14    srli a2,a2,0x7
    0x84013f10    0x16    andi s3,a2,3
    0x84013f14    0x1a    beqz s3,ffffffff84013f4c <lookupExtraCaps+0x52>
    0x84013f18    0x1e    addi s0,a1,976
    0x84013f1c    0x22    auipc s2,0x5
    0x84013f20    0x26    addi s2,s2,-1676 # ffffffff84018890 <current_extra_caps>
    0x84013f24    0x2a    li s1,0
    0x84013f26    0x2c    ld s5,0(s0)
    0x84013f2a    0x30    mv a1,s5
    0x84013f2c    0x32    mv a0,s4
    0x84013f2e    0x34    jal ra,ffffffff84011466 <lookupSlot>
    0x84013f32    0x38    sd a1,8(sp)           ; stack access
    0x84013f34    0x3a    bnez a0,ffffffff84013f6c <lookupExtraCaps+0x72>
    0x84013f36    0x3c    ld a5,8(sp)           ; stack access
    0x84013f38    0x3e    sd a5,0(s2)
    0x84013f3c    0x42    addi s1,s1,1
    0x84013f3e    0x44    addi s0,s0,8
    0x84013f40    0x46    addi s2,s2,8
    0x84013f42    0x48    bne s1,s3,ffffffff84013f26 <lookupExtraCaps+0x2c>
    0x84013f46    0x4c    li a5,2
    0x84013f48    0x4e    bltu a5,s3,ffffffff84013f7e <lookupExtraCaps+0x84>
    0x84013f4c    0x52    slli s3,s3,0x3
    0x84013f4e    0x54    auipc a5,0x5
    0x84013f52    0x58    addi a5,a5,178 # ffffffff84019000 <intStateIRQNode>
    0x84013f56    0x5c    add s3,s3,a5
    0x84013f58    0x5e    sd zero,-1904(s3)
    0x84013f5c    0x62    li a0,0
    0x84013f5e    0x64    j ffffffff84013f7e <lookupExtraCaps+0x84>
    0x84013f60    0x66    auipc a5,0x5
    0x84013f64    0x6a    sd zero,-1744(a5) # ffffffff84018890 <current_extra_caps>
    0x84013f68    0x6e    li a0,0
    0x84013f6a    0x70    ret
    0x84013f6c    0x72    auipc a5,0x4
    0x84013f70    0x76    addi a5,a5,148 # ffffffff84018000 <riscvKSASIDTable>
    0x84013f74    0x7a    li a4,1
    0x84013f76    0x7c    sd a4,1680(a5)
    0x84013f7a    0x80    sd s5,1688(a5)
    0x84013f7e    0x84    ld ra,72(sp)          ; stack access
    0x84013f80    0x86    ld s0,64(sp)          ; stack access
    0x84013f82    0x88    ld s1,56(sp)          ; stack access
    0x84013f84    0x8a    ld s2,48(sp)          ; stack access
    0x84013f86    0x8c    ld s3,40(sp)          ; stack access
    0x84013f88    0x8e    ld s4,32(sp)          ; stack access
    0x84013f8a    0x90    ld s5,24(sp)          ; stack access
    0x84013f8c    0x92    addi sp,sp,80
    0x84013f8e    0x94    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
56 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupExtraCaps` has 91 nodes.

Section deleteCallerCap (99 of 271)
===================================

Deriving specifications
-----------------------

Section `deleteCallerCap` consists of 8 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `deleteCallerCap`:

    0x84013ee4     0x0    addi sp,sp,-16
    0x84013ee6     0x2    sd ra,8(sp)           ; stack access
    0x84013ee8     0x4    andi a0,a0,-1024
    0x84013eec     0x8    addi a0,a0,96
    0x84013ef0     0xc    jal ra,ffffffff84013a7c <cteDeleteOne>
    0x84013ef4    0x10    ld ra,8(sp)           ; stack access
    0x84013ef6    0x12    addi sp,sp,16
    0x84013ef8    0x14    ret

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deleteCallerCap` has 12 nodes.

Section performInvocation_Notification (100 of 271)
===================================================

Deriving specifications
-----------------------

Section `performInvocation_Notification` consists of 7 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `performInvocation_Notification`:

    0x84013e7a    0x0    addi sp,sp,-16
    0x84013e7c    0x2    sd ra,8(sp)           ; stack access
    0x84013e7e    0x4    jal ra,ffffffff84013c24 <sendSignal>
    0x84013e82    0x8    li a0,0
    0x84013e84    0xa    ld ra,8(sp)           ; stack access
    0x84013e86    0xc    addi sp,sp,16
    0x84013e88    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performInvocation_Notification` has 11 nodes.

Section deletingIRQHandler (101 of 271)
=======================================

Deriving specifications
-----------------------

Section `deletingIRQHandler` consists of 10 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `deletingIRQHandler`:

    0x84013bca     0x0    addi sp,sp,-16
    0x84013bcc     0x2    sd ra,8(sp)           ; stack access
    0x84013bce     0x4    slli a0,a0,0x5
    0x84013bd0     0x6    auipc a5,0x5
    0x84013bd4     0xa    addi a5,a5,1072 # ffffffff84019000 <intStateIRQNode>
    0x84013bd8     0xe    add a0,a0,a5
    0x84013bda    0x10    jal ra,ffffffff84013a7c <cteDeleteOne>
    0x84013bde    0x14    ld ra,8(sp)           ; stack access
    0x84013be0    0x16    addi sp,sp,16
    0x84013be2    0x18    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deletingIRQHandler` has 14 nodes.

Section invokeIRQHandler_ClearIRQHandler (102 of 271)
=====================================================

Deriving specifications
-----------------------

Section `invokeIRQHandler_ClearIRQHandler` consists of 10 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeIRQHandler_ClearIRQHandler`:

    0x84013ae6     0x0    addi sp,sp,-16
    0x84013ae8     0x2    sd ra,8(sp)           ; stack access
    0x84013aea     0x4    slli a0,a0,0x5
    0x84013aec     0x6    auipc a5,0x5
    0x84013af0     0xa    addi a5,a5,1300 # ffffffff84019000 <intStateIRQNode>
    0x84013af4     0xe    add a0,a0,a5
    0x84013af6    0x10    jal ra,ffffffff84013a7c <cteDeleteOne>
    0x84013afa    0x14    ld ra,8(sp)           ; stack access
    0x84013afc    0x16    addi sp,sp,16
    0x84013afe    0x18    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeIRQHandler_ClearIRQHandler` has 14 nodes.

Section invokeCNodeRevoke (103 of 271)
======================================

Deriving specifications
-----------------------

Section `invokeCNodeRevoke` consists of 6 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeCNodeRevoke`:

    0x84013590    0x0    addi sp,sp,-16
    0x84013592    0x2    sd ra,8(sp)           ; stack access
    0x84013594    0x4    jal ra,ffffffff8401350c <cteRevoke>
    0x84013598    0x8    ld ra,8(sp)           ; stack access
    0x8401359a    0xa    addi sp,sp,16
    0x8401359c    0xc    ret

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeRevoke` has 10 nodes.

Section invokeCNodeDelete (104 of 271)
======================================

Deriving specifications
-----------------------

Section `invokeCNodeDelete` consists of 7 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeCNodeDelete`:

    0x840134fc    0x0    addi sp,sp,-16
    0x840134fe    0x2    sd ra,8(sp)           ; stack access
    0x84013500    0x4    li a1,1
    0x84013502    0x6    jal ra,ffffffff8401333c <cteDelete>
    0x84013506    0xa    ld ra,8(sp)           ; stack access
    0x84013508    0xc    addi sp,sp,16
    0x8401350a    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeDelete` has 11 nodes.

Section invokeCNodeCancelBadgedSends (105 of 271)
=================================================

Deriving specifications
-----------------------

Section `invokeCNodeCancelBadgedSends` consists of 18 instructions.


Stack analysis
---------------

3 stack accesses found. Annotated code for `invokeCNodeCancelBadgedSends`:

    0x84012fd4     0x0    addi sp,sp,-32
    0x84012fd6     0x2    sd ra,24(sp)          ; stack access
    0x84012fd8     0x4    sd a0,0(sp)           ; stack access
    0x84012fda     0x6    beqz a1,ffffffff84012ff2 <invokeCNodeCancelBadgedSends+0x1e>
    0x84012fdc     0x8    mv a5,a0
    0x84012fde     0xa    slli a0,a0,0x19
    0x84012fe0     0xc    srli a0,a0,0x19
    0x84012fe2     0xe    srli a5,a5,0x26
    0x84012fe4    0x10    andi a5,a5,1
    0x84012fe6    0x12    beqz a5,ffffffff84012fee <invokeCNodeCancelBadgedSends+0x1a>
    0x84012fe8    0x14    li a5,-1
    0x84012fea    0x16    slli a5,a5,0x27
    0x84012fec    0x18    or a0,a0,a5
    0x84012fee    0x1a    jal ra,ffffffff84012ef8 <cancelBadgedSends>
    0x84012ff2    0x1e    li a0,0
    0x84012ff4    0x20    ld ra,24(sp)          ; stack access
    0x84012ff6    0x22    addi sp,sp,32
    0x84012ff8    0x24    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeCancelBadgedSends` has 27 nodes.

Section scheduleChooseNewThread (106 of 271)
============================================

Deriving specifications
-----------------------

Section `scheduleChooseNewThread` consists of 34 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `scheduleChooseNewThread`:

    0x84012c86     0x0    addi sp,sp,-16
    0x84012c88     0x2    sd ra,8(sp)           ; stack access
    0x84012c8a     0x4    auipc a5,0x18
    0x84012c8e     0x8    ld a5,-1146(a5) # ffffffff8402a810 <ksDomainTime>
    0x84012c92     0xc    beqz a5,ffffffff84012c9e <scheduleChooseNewThread+0x18>
    0x84012c94     0xe    jal ra,ffffffff84012c0a <chooseThread>
    0x84012c98    0x12    ld ra,8(sp)           ; stack access
    0x84012c9a    0x14    addi sp,sp,16
    0x84012c9c    0x16    ret
    0x84012c9e    0x18    auipc a5,0x18
    0x84012ca2    0x1c    ld a5,-1174(a5) # ffffffff8402a808 <ksDomScheduleIdx>
    0x84012ca6    0x20    addi a5,a5,1
    0x84012ca8    0x22    li a4,2
    0x84012caa    0x24    bltu a4,a5,ffffffff84012cea <scheduleChooseNewThread+0x64>
    0x84012cae    0x28    auipc a4,0x18
    0x84012cb2    0x2c    sd a5,-1190(a4) # ffffffff8402a808 <ksDomScheduleIdx>
    0x84012cb6    0x30    auipc a5,0x18
    0x84012cba    0x34    sd zero,-1174(a5) # ffffffff8402a820 <ksWorkUnitsCompleted>
    0x84012cbe    0x38    auipc a5,0x18
    0x84012cc2    0x3c    ld a5,-1206(a5) # ffffffff8402a808 <ksDomScheduleIdx>
    0x84012cc6    0x40    slli a4,a5,0x4
    0x84012cca    0x44    auipc a5,0x5
    0x84012cce    0x48    addi a5,a5,-1906 # ffffffff84017558 <msgRegisters>
    0x84012cd2    0x4c    add a5,a5,a4
    0x84012cd4    0x4e    ld a4,192(a5)
    0x84012cd6    0x50    auipc a3,0x18
    0x84012cda    0x54    sd a4,-1214(a3) # ffffffff8402a818 <ksCurDomain>
    0x84012cde    0x58    ld a5,200(a5)
    0x84012ce0    0x5a    auipc a4,0x18
    0x84012ce4    0x5e    sd a5,-1232(a4) # ffffffff8402a810 <ksDomainTime>
    0x84012ce8    0x62    j ffffffff84012c94 <scheduleChooseNewThread+0xe>
    0x84012cea    0x64    auipc a5,0x18
    0x84012cee    0x68    sd zero,-1250(a5) # ffffffff8402a808 <ksDomScheduleIdx>
    0x84012cf2    0x6c    j ffffffff84012cb6 <scheduleChooseNewThread+0x30>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
34 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `scheduleChooseNewThread` has 52 nodes.

Section receiveSignal (107 of 271)
==================================

Deriving specifications
-----------------------

Section `receiveSignal` consists of 91 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `receiveSignal`:

    0x84012854     0x0    addi sp,sp,-48
    0x84012856     0x2    sd ra,40(sp)          ; stack access
    0x84012858     0x4    sd s0,32(sp)          ; stack access
    0x8401285a     0x6    sd s1,24(sp)          ; stack access
    0x8401285c     0x8    sd s2,16(sp)          ; stack access
    0x8401285e     0xa    mv s0,a0
    0x84012860     0xc    sd a1,0(sp)           ; stack access
    0x84012862     0xe    sd a2,8(sp)           ; stack access
    0x84012864    0x10    slli a5,a1,0x19
    0x84012868    0x14    srli a5,a5,0x19
    0x8401286a    0x16    srli a1,a1,0x26
    0x8401286c    0x18    andi a1,a1,1
    0x8401286e    0x1a    beqz a1,ffffffff84012876 <receiveSignal+0x22>
    0x84012870    0x1c    li a4,-1
    0x84012872    0x1e    slli a4,a4,0x27
    0x84012874    0x20    or a5,a5,a4
    0x84012876    0x22    mv s1,a5
    0x84012878    0x24    ld a4,0(a5)
    0x8401287a    0x26    andi a2,a4,3
    0x8401287e    0x2a    andi a4,a4,2
    0x84012880    0x2c    beqz a4,ffffffff8401289e <receiveSignal+0x4a>
    0x84012882    0x2e    li a5,2
    0x84012884    0x30    bne a2,a5,ffffffff84012892 <receiveSignal+0x3e>
    0x84012888    0x34    ld a5,16(s1)
    0x8401288a    0x36    sd a5,72(s0)
    0x8401288c    0x38    ld a5,0(s1)
    0x8401288e    0x3a    andi a5,a5,-4
    0x84012890    0x3c    sd a5,0(s1)
    0x84012892    0x3e    ld ra,40(sp)          ; stack access
    0x84012894    0x40    ld s0,32(sp)          ; stack access
    0x84012896    0x42    ld s1,24(sp)          ; stack access
    0x84012898    0x44    ld s2,16(sp)          ; stack access
    0x8401289a    0x46    addi sp,sp,48
    0x8401289c    0x48    ret
    0x8401289e    0x4a    beqz a3,ffffffff8401292e <receiveSignal+0xda>
    0x840128a0    0x4c    ld a4,280(s0)
    0x840128a4    0x50    li s2,-1
    0x840128a6    0x52    slli a3,s2,0x27
    0x840128aa    0x56    and a4,a4,a3
    0x840128ac    0x58    lui a3,0xe0000
    0x840128b0    0x5c    srli a3,a3,0x19
    0x840128b2    0x5e    and a5,a5,a3
    0x840128b4    0x60    or a5,a5,a4
    0x840128b6    0x62    ori a5,a5,6
    0x840128ba    0x66    sd a5,280(s0)
    0x840128be    0x6a    mv a0,s0
    0x840128c0    0x6c    jal ra,ffffffff84012606 <scheduleTCB>
    0x840128c4    0x70    ld a4,8(s1)
    0x840128c6    0x72    srli a5,s2,0x19
    0x840128ca    0x76    and a5,a5,a4
    0x840128cc    0x78    srli a4,a4,0x26
    0x840128ce    0x7a    andi a4,a4,1
    0x840128d0    0x7c    beqz a4,ffffffff8401291e <receiveSignal+0xca>
    0x840128d2    0x7e    li a4,-1
    0x840128d4    0x80    slli a4,a4,0x27
    0x840128d6    0x82    or a5,a5,a4
    0x840128d8    0x84    ld a3,0(s1)
    0x840128da    0x86    srli a4,a3,0x19
    0x840128de    0x8a    bgez a3,ffffffff840128ea <receiveSignal+0x96>
    0x840128e2    0x8e    li a3,-1
    0x840128e4    0x90    slli a3,a3,0x27
    0x840128e6    0x92    or a4,a4,a3
    0x840128e8    0x94    beqz a5,ffffffff8401292a <receiveSignal+0xd6>
    0x840128ea    0x96    sd s0,408(a4)
    0x840128ee    0x9a    sd a4,416(s0)
    0x840128f2    0x9e    sd zero,408(s0)
    0x840128f6    0xa2    ld a4,0(s1)
    0x840128f8    0xa4    ld a3,8(s1)
    0x840128fa    0xa6    li a2,-1
    0x840128fc    0xa8    slli a1,a2,0x27
    0x84012900    0xac    and a3,a3,a1
    0x84012902    0xae    srli a2,a2,0x19
    0x84012904    0xb0    and a5,a5,a2
    0x84012906    0xb2    or a5,a5,a3
    0x84012908    0xb4    sd a5,8(s1)
    0x8401290a    0xb6    lui a5,0x2000
    0x8401290e    0xba    addi a5,a5,-4
    0x84012910    0xbc    and a5,a5,a4
    0x84012912    0xbe    slli s0,s0,0x19
    0x84012914    0xc0    or s0,s0,a5
    0x84012916    0xc2    ori s0,s0,1
    0x8401291a    0xc6    sd s0,0(s1)
    0x8401291c    0xc8    j ffffffff84012892 <receiveSignal+0x3e>
    0x8401291e    0xca    ld a3,0(s1)
    0x84012920    0xcc    srli a4,a3,0x19
    0x84012924    0xd0    bltz a3,ffffffff840128e2 <receiveSignal+0x8e>
    0x84012928    0xd4    j ffffffff840128e8 <receiveSignal+0x94>
    0x8401292a    0xd6    mv a5,s0
    0x8401292c    0xd8    j ffffffff840128ee <receiveSignal+0x9a>
    0x8401292e    0xda    sd zero,72(s0)
    0x84012932    0xde    j ffffffff84012892 <receiveSignal+0x3e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
91 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `receiveSignal` has 137 nodes.

Section handleDoubleFault (108 of 271)
======================================

Deriving specifications
-----------------------

Section `handleDoubleFault` consists of 7 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleDoubleFault`:

    0x84012734    0x0    addi sp,sp,-32
    0x84012736    0x2    sd ra,24(sp)          ; stack access
    0x84012738    0x4    li a1,0
    0x8401273a    0x6    jal ra,ffffffff8401263a <setThreadState>
    0x8401273e    0xa    ld ra,24(sp)          ; stack access
    0x84012740    0xc    addi sp,sp,32
    0x84012742    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleDoubleFault` has 11 nodes.

Section setThreadState (109 of 271)
===================================

Deriving specifications
-----------------------

Section `setThreadState` consists of 11 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `setThreadState`:

    0x8401263a     0x0    addi sp,sp,-16
    0x8401263c     0x2    sd ra,8(sp)           ; stack access
    0x8401263e     0x4    ld a5,280(a0)
    0x84012642     0x8    andi a5,a5,-16
    0x84012644     0xa    andi a1,a1,15
    0x84012646     0xc    or a5,a5,a1
    0x84012648     0xe    sd a5,280(a0)
    0x8401264c    0x12    jal ra,ffffffff84012606 <scheduleTCB>
    0x84012650    0x16    ld ra,8(sp)           ; stack access
    0x84012652    0x18    addi sp,sp,16
    0x84012654    0x1a    ret

Proving inst theorems
---------------------

11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setThreadState` has 17 nodes.

Section scheduleTCB (110 of 271)
================================

Deriving specifications
-----------------------

Section `scheduleTCB` consists of 18 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `scheduleTCB`:

    0x84012606     0x0    auipc a5,0x18
    0x8401260a     0x4    ld a5,562(a5) # ffffffff8402a838 <ksCurThread>
    0x8401260e     0x8    beq a5,a0,ffffffff84012614 <scheduleTCB+0xe>
    0x84012612     0xc    ret
    0x84012614     0xe    auipc a5,0x18
    0x84012618    0x12    ld a5,532(a5) # ffffffff8402a828 <ksSchedulerAction>
    0x8401261c    0x16    bnez a5,ffffffff84012612 <scheduleTCB+0xc>
    0x8401261e    0x18    ld a5,280(a0)
    0x84012622    0x1c    andi a5,a5,15
    0x84012624    0x1e    addi a5,a5,-1
    0x84012626    0x20    li a4,1
    0x84012628    0x22    bgeu a4,a5,ffffffff84012612 <scheduleTCB+0xc>
    0x8401262c    0x26    addi sp,sp,-16
    0x8401262e    0x28    sd ra,8(sp)           ; stack access
    0x84012630    0x2a    jal ra,ffffffff840125d4 <rescheduleRequired>
    0x84012634    0x2e    ld ra,8(sp)           ; stack access
    0x84012636    0x30    addi sp,sp,16
    0x84012638    0x32    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `scheduleTCB` has 32 nodes.

Section rescheduleRequired (111 of 271)
=======================================

Deriving specifications
-----------------------

Section `rescheduleRequired` consists of 17 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `rescheduleRequired`:

    0x840125d4     0x0    auipc a0,0x18
    0x840125d8     0x4    ld a0,596(a0) # ffffffff8402a828 <ksSchedulerAction>
    0x840125dc     0x8    li a5,1
    0x840125de     0xa    bltu a5,a0,ffffffff840125ee <rescheduleRequired+0x1a>
    0x840125e2     0xe    li a5,1
    0x840125e4    0x10    auipc a4,0x18
    0x840125e8    0x14    sd a5,580(a4) # ffffffff8402a828 <ksSchedulerAction>
    0x840125ec    0x18    ret
    0x840125ee    0x1a    addi sp,sp,-16
    0x840125f0    0x1c    sd ra,8(sp)           ; stack access
    0x840125f2    0x1e    jal ra,ffffffff8401253a <tcbSchedEnqueue>
    0x840125f6    0x22    li a5,1
    0x840125f8    0x24    auipc a4,0x18
    0x840125fc    0x28    sd a5,560(a4) # ffffffff8402a828 <ksSchedulerAction>
    0x84012600    0x2c    ld ra,8(sp)           ; stack access
    0x84012602    0x2e    addi sp,sp,16
    0x84012604    0x30    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `rescheduleRequired` has 27 nodes.

Section slotCapLongRunningDelete (112 of 271)
=============================================

Deriving specifications
-----------------------

Section `slotCapLongRunningDelete` consists of 24 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `slotCapLongRunningDelete`:

    0x84012214     0x0    addi sp,sp,-16
    0x84012216     0x2    sd ra,8(sp)           ; stack access
    0x84012218     0x4    sd s0,0(sp)           ; stack access
    0x8401221a     0x6    ld s0,0(a0)
    0x8401221c     0x8    srli s0,s0,0x3b
    0x8401221e     0xa    beqz s0,ffffffff8401223c <slotCapLongRunningDelete+0x28>
    0x84012220     0xc    jal ra,ffffffff840121be <isFinalCapability>
    0x84012224    0x10    beqz a0,ffffffff84012246 <slotCapLongRunningDelete+0x32>
    0x84012226    0x12    addi s0,s0,-10
    0x84012228    0x14    li a5,8
    0x8401222a    0x16    bltu a5,s0,ffffffff8401224a <slotCapLongRunningDelete+0x36>
    0x8401222e    0x1a    li a5,1
    0x84012230    0x1c    sll s0,a5,s0
    0x84012234    0x20    andi s0,s0,261
    0x84012238    0x24    snez s0,s0
    0x8401223c    0x28    mv a0,s0
    0x8401223e    0x2a    ld ra,8(sp)           ; stack access
    0x84012240    0x2c    ld s0,0(sp)           ; stack access
    0x84012242    0x2e    addi sp,sp,16
    0x84012244    0x30    ret
    0x84012246    0x32    mv s0,a0
    0x84012248    0x34    j ffffffff8401223c <slotCapLongRunningDelete+0x28>
    0x8401224a    0x36    li s0,0
    0x8401224c    0x38    j ffffffff8401223c <slotCapLongRunningDelete+0x28>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
24 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `slotCapLongRunningDelete` has 37 nodes.

Section isFinalCapability (113 of 271)
======================================

Deriving specifications
-----------------------

Section `isFinalCapability` consists of 39 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `isFinalCapability`:

    0x840121be     0x0    addi sp,sp,-32
    0x840121c0     0x2    sd ra,24(sp)          ; stack access
    0x840121c2     0x4    sd s0,16(sp)          ; stack access
    0x840121c4     0x6    sd s1,8(sp)           ; stack access
    0x840121c6     0x8    mv s0,a0
    0x840121c8     0xa    ld a5,16(a0)
    0x840121ca     0xc    ld s1,24(a0)
    0x840121cc     0xe    beqz a5,ffffffff840121e0 <isFinalCapability+0x22>
    0x840121ce    0x10    ld a2,0(a0)
    0x840121d0    0x12    ld a3,8(a0)
    0x840121d2    0x14    ld a0,0(a5)
    0x840121d4    0x16    ld a1,8(a5)
    0x840121d6    0x18    jal ra,ffffffff84012166 <sameObjectAs>
    0x840121da    0x1c    mv a5,a0
    0x840121dc    0x1e    li a0,0
    0x840121de    0x20    bnez a5,ffffffff8401220a <isFinalCapability+0x4c>
    0x840121e0    0x22    lui a5,0xf8000
    0x840121e4    0x26    srli a5,a5,0x19
    0x840121e6    0x28    and a5,a5,s1
    0x840121e8    0x2a    srli s1,s1,0x26
    0x840121ea    0x2c    andi s1,s1,1
    0x840121ec    0x2e    beqz s1,ffffffff84012206 <isFinalCapability+0x48>
    0x840121ee    0x30    li a4,-1
    0x840121f0    0x32    slli a4,a4,0x27
    0x840121f2    0x34    or a5,a5,a4
    0x840121f4    0x36    ld a2,0(a5)
    0x840121f6    0x38    ld a3,8(a5)
    0x840121f8    0x3a    ld a0,0(s0)
    0x840121fa    0x3c    ld a1,8(s0)
    0x840121fc    0x3e    jal ra,ffffffff84012166 <sameObjectAs>
    0x84012200    0x42    seqz a0,a0
    0x84012204    0x46    j ffffffff8401220a <isFinalCapability+0x4c>
    0x84012206    0x48    li a0,1
    0x84012208    0x4a    bnez a5,ffffffff840121f4 <isFinalCapability+0x36>
    0x8401220a    0x4c    ld ra,24(sp)          ; stack access
    0x8401220c    0x4e    ld s0,16(sp)          ; stack access
    0x8401220e    0x50    ld s1,8(sp)           ; stack access
    0x84012210    0x52    addi sp,sp,32
    0x84012212    0x54    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
39 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isFinalCapability` has 66 nodes.

Section ensureNoChildren (114 of 271)
=====================================

Deriving specifications
-----------------------

Section `ensureNoChildren` consists of 27 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `ensureNoChildren`:

    0x840120ae     0x0    ld a5,24(a0)
    0x840120b0     0x2    lui a1,0xf8000
    0x840120b4     0x6    srli a1,a1,0x19
    0x840120b6     0x8    and a1,a1,a5
    0x840120b8     0xa    srli a5,a5,0x26
    0x840120ba     0xc    andi a5,a5,1
    0x840120bc     0xe    beqz a5,ffffffff840120d8 <ensureNoChildren+0x2a>
    0x840120be    0x10    li a5,-1
    0x840120c0    0x12    slli a5,a5,0x27
    0x840120c2    0x14    or a1,a1,a5
    0x840120c4    0x16    addi sp,sp,-16
    0x840120c6    0x18    sd ra,8(sp)           ; stack access
    0x840120c8    0x1a    jal ra,ffffffff84012036 <isMDBParentOf>
    0x840120cc    0x1e    mv a1,a0
    0x840120ce    0x20    bnez a0,ffffffff840120de <ensureNoChildren+0x30>
    0x840120d0    0x22    mv a0,a1
    0x840120d2    0x24    ld ra,8(sp)           ; stack access
    0x840120d4    0x26    addi sp,sp,16
    0x840120d6    0x28    ret
    0x840120d8    0x2a    bnez a1,ffffffff840120c4 <ensureNoChildren+0x16>
    0x840120da    0x2c    mv a0,a1
    0x840120dc    0x2e    ret
    0x840120de    0x30    li a5,9
    0x840120e0    0x32    auipc a4,0x6
    0x840120e4    0x36    sd a5,1520(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840120e8    0x3a    li a1,3
    0x840120ea    0x3c    j ffffffff840120d0 <ensureNoChildren+0x22>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
27 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `ensureNoChildren` has 40 nodes.

Section isMDBParentOf (115 of 271)
==================================

Deriving specifications
-----------------------

Section `isMDBParentOf` consists of 49 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `isMDBParentOf`:

    0x84012036     0x0    addi sp,sp,-32
    0x84012038     0x2    sd ra,24(sp)          ; stack access
    0x8401203a     0x4    sd s0,16(sp)          ; stack access
    0x8401203c     0x6    sd s1,8(sp)           ; stack access
    0x8401203e     0x8    sd s2,0(sp)           ; stack access
    0x84012040     0xa    ld s0,24(a0)
    0x84012042     0xc    srli s0,s0,0x1
    0x84012044     0xe    andi s0,s0,1
    0x84012046    0x10    beqz s0,ffffffff840120a0 <isMDBParentOf+0x6a>
    0x84012048    0x12    mv s1,a0
    0x8401204a    0x14    mv s2,a1
    0x8401204c    0x16    ld a2,0(a1)
    0x8401204e    0x18    ld a3,8(a1)
    0x84012050    0x1a    ld a0,0(a0)
    0x84012052    0x1c    ld a1,8(s1)
    0x84012054    0x1e    jal ra,ffffffff84011cde <sameRegionAs>
    0x84012058    0x22    beqz a0,ffffffff8401209e <isMDBParentOf+0x68>
    0x8401205a    0x24    ld a5,0(s1)
    0x8401205c    0x26    srli a5,a5,0x3b
    0x8401205e    0x28    li a4,4
    0x84012060    0x2a    beq a5,a4,ffffffff84012084 <isMDBParentOf+0x4e>
    0x84012064    0x2e    li a4,6
    0x84012066    0x30    bne a5,a4,ffffffff840120a0 <isMDBParentOf+0x6a>
    0x8401206a    0x34    ld a5,8(s1)
    0x8401206c    0x36    beqz a5,ffffffff840120a0 <isMDBParentOf+0x6a>
    0x8401206e    0x38    ld a4,8(s2)
    0x84012072    0x3c    li s0,0
    0x84012074    0x3e    bne a5,a4,ffffffff840120a0 <isMDBParentOf+0x6a>
    0x84012078    0x42    ld s0,24(s2)
    0x8401207c    0x46    xori s0,s0,1
    0x84012080    0x4a    andi s0,s0,1
    0x84012082    0x4c    j ffffffff840120a0 <isMDBParentOf+0x6a>
    0x84012084    0x4e    ld a5,8(s1)
    0x84012086    0x50    beqz a5,ffffffff840120a0 <isMDBParentOf+0x6a>
    0x84012088    0x52    ld a4,8(s2)
    0x8401208c    0x56    li s0,0
    0x8401208e    0x58    bne a4,a5,ffffffff840120a0 <isMDBParentOf+0x6a>
    0x84012092    0x5c    ld s0,24(s2)
    0x84012096    0x60    xori s0,s0,1
    0x8401209a    0x64    andi s0,s0,1
    0x8401209c    0x66    j ffffffff840120a0 <isMDBParentOf+0x6a>
    0x8401209e    0x68    mv s0,a0
    0x840120a0    0x6a    mv a0,s0
    0x840120a2    0x6c    ld ra,24(sp)          ; stack access
    0x840120a4    0x6e    ld s0,16(sp)          ; stack access
    0x840120a6    0x70    ld s1,8(sp)           ; stack access
    0x840120a8    0x72    ld s2,0(sp)           ; stack access
    0x840120aa    0x74    addi sp,sp,32
    0x840120ac    0x76    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
49 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isMDBParentOf` has 87 nodes.

Section completeSignal (116 of 271)
===================================

Deriving specifications
-----------------------

Section `completeSignal` consists of 14 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `completeSignal`:

    0x84011bf4     0x0    beqz a1,ffffffff84011c0c <completeSignal+0x18>
    0x84011bf6     0x2    ld a5,0(a0)
    0x84011bf8     0x4    andi a5,a5,3
    0x84011bfa     0x6    li a4,2
    0x84011bfc     0x8    bne a5,a4,ffffffff84011c0c <completeSignal+0x18>
    0x84011c00     0xc    ld a5,16(a0)
    0x84011c02     0xe    sd a5,72(a1)
    0x84011c04    0x10    ld a5,0(a0)
    0x84011c06    0x12    andi a5,a5,-4
    0x84011c08    0x14    sd a5,0(a0)
    0x84011c0a    0x16    ret
    0x84011c0c    0x18    addi sp,sp,-16
    0x84011c0e    0x1a    sd ra,8(sp)           ; stack access
    0x84011c10    0x1c    jal ra,ffffffff8401041e <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `completeSignal` has 26 nodes.

Section emptySlot (117 of 271)
==============================

Deriving specifications
-----------------------

Section `emptySlot` consists of 55 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `emptySlot`:

    0x84011b74     0x0    addi sp,sp,-32
    0x84011b76     0x2    sd ra,24(sp)          ; stack access
    0x84011b78     0x4    sd a1,0(sp)           ; stack access
    0x84011b7a     0x6    sd a2,8(sp)           ; stack access
    0x84011b7c     0x8    ld a5,0(a0)
    0x84011b7e     0xa    srli a5,a5,0x3b
    0x84011b80     0xc    beqz a5,ffffffff84011bc6 <emptySlot+0x52>
    0x84011b82     0xe    ld a2,16(a0)
    0x84011b84    0x10    ld a4,24(a0)
    0x84011b86    0x12    lui a5,0xf8000
    0x84011b8a    0x16    srli a5,a5,0x19
    0x84011b8c    0x18    and a5,a5,a4
    0x84011b8e    0x1a    srli a3,a4,0x26
    0x84011b92    0x1e    andi a3,a3,1
    0x84011b94    0x20    beqz a3,ffffffff84011bcc <emptySlot+0x58>
    0x84011b96    0x22    li a3,-1
    0x84011b98    0x24    slli a3,a3,0x27
    0x84011b9a    0x26    or a5,a5,a3
    0x84011b9c    0x28    bnez a2,ffffffff84011bce <emptySlot+0x5a>
    0x84011b9e    0x2a    sd a2,16(a5)
    0x84011ba0    0x2c    ld a3,24(a5)
    0x84011ba2    0x2e    or a4,a4,a3
    0x84011ba4    0x30    andi a4,a4,1
    0x84011ba6    0x32    andi a3,a3,-2
    0x84011ba8    0x34    or a4,a4,a3
    0x84011baa    0x36    sd a4,24(a5)
    0x84011bac    0x38    sd zero,0(a0)
    0x84011bb0    0x3c    sd zero,8(a0)
    0x84011bb4    0x40    sd zero,16(a0)
    0x84011bb8    0x44    sd zero,24(a0)
    0x84011bbc    0x48    ld a5,0(sp)           ; stack access
    0x84011bbe    0x4a    srli a5,a5,0x3b
    0x84011bc0    0x4c    li a4,16
    0x84011bc2    0x4e    beq a5,a4,ffffffff84011be8 <emptySlot+0x74>
    0x84011bc6    0x52    ld ra,24(sp)          ; stack access
    0x84011bc8    0x54    addi sp,sp,32
    0x84011bca    0x56    ret
    0x84011bcc    0x58    beqz a2,ffffffff84011be4 <emptySlot+0x70>
    0x84011bce    0x5a    ld a3,24(a2)
    0x84011bd0    0x5c    li a1,-1
    0x84011bd2    0x5e    slli a1,a1,0x27
    0x84011bd4    0x60    addi a1,a1,3
    0x84011bd6    0x62    and a3,a3,a1
    0x84011bd8    0x64    lui a1,0xf8000
    0x84011bdc    0x68    srli a1,a1,0x19
    0x84011bde    0x6a    and a1,a1,a5
    0x84011be0    0x6c    or a3,a3,a1
    0x84011be2    0x6e    sd a3,24(a2)
    0x84011be4    0x70    beqz a5,ffffffff84011bac <emptySlot+0x38>
    0x84011be6    0x72    j ffffffff84011b9e <emptySlot+0x2a>
    0x84011be8    0x74    ld a0,8(sp)           ; stack access
    0x84011bea    0x76    slli a0,a0,0x34
    0x84011bec    0x78    srli a0,a0,0x34
    0x84011bee    0x7a    jal ra,ffffffff84011b62 <deletedIRQHandler>
    0x84011bf2    0x7e    j ffffffff84011bc6 <emptySlot+0x52>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
55 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `emptySlot` has 87 nodes.

Section deletedIRQHandler (118 of 271)
======================================

Deriving specifications
-----------------------

Section `deletedIRQHandler` consists of 8 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `deletedIRQHandler`:

    0x84011b62     0x0    addi sp,sp,-16
    0x84011b64     0x2    sd ra,8(sp)           ; stack access
    0x84011b66     0x4    mv a1,a0
    0x84011b68     0x6    li a0,0
    0x84011b6a     0x8    jal ra,ffffffff84011ac2 <setIRQState>
    0x84011b6e     0xc    ld ra,8(sp)           ; stack access
    0x84011b70     0xe    addi sp,sp,16
    0x84011b72    0x10    ret

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deletedIRQHandler` has 12 nodes.

Section capSwapForDelete (119 of 271)
=====================================

Deriving specifications
-----------------------

Section `capSwapForDelete` consists of 14 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `capSwapForDelete`:

    0x84011976     0x0    beq a0,a1,ffffffff84011994 <capSwapForDelete+0x1e>
    0x8401197a     0x4    addi sp,sp,-48
    0x8401197c     0x6    sd ra,40(sp)          ; stack access
    0x8401197e     0x8    mv a2,a0
    0x84011980     0xa    mv a5,a1
    0x84011982     0xc    ld a3,0(a1)
    0x84011984     0xe    ld a4,8(a1)
    0x84011986    0x10    ld a0,0(a0)
    0x84011988    0x12    ld a1,8(a2)
    0x8401198a    0x14    jal ra,ffffffff840118a2 <cteSwap>
    0x8401198e    0x18    ld ra,40(sp)          ; stack access
    0x84011990    0x1a    addi sp,sp,48
    0x84011992    0x1c    ret
    0x84011994    0x1e    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `capSwapForDelete` has 25 nodes.

Section invokeCNodeMove (120 of 271)
====================================

Deriving specifications
-----------------------

Section `invokeCNodeMove` consists of 7 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeCNodeMove`:

    0x8401184e    0x0    addi sp,sp,-32
    0x84011850    0x2    sd ra,24(sp)          ; stack access
    0x84011852    0x4    jal ra,ffffffff840117f6 <cteMove>
    0x84011856    0x8    li a0,0
    0x84011858    0xa    ld ra,24(sp)          ; stack access
    0x8401185a    0xc    addi sp,sp,32
    0x8401185c    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeMove` has 11 nodes.

Section invokeCNodeInsert (121 of 271)
======================================

Deriving specifications
-----------------------

Section `invokeCNodeInsert` consists of 7 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeCNodeInsert`:

    0x840117e6    0x0    addi sp,sp,-32
    0x840117e8    0x2    sd ra,24(sp)          ; stack access
    0x840117ea    0x4    jal ra,ffffffff840116ba <cteInsert>
    0x840117ee    0x8    li a0,0
    0x840117f0    0xa    ld ra,24(sp)          ; stack access
    0x840117f2    0xc    addi sp,sp,32
    0x840117f4    0xe    ret

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeInsert` has 11 nodes.

Section switchToIdleThread (122 of 271)
=======================================

Deriving specifications
-----------------------

Section `switchToIdleThread` consists of 10 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `switchToIdleThread`:

    0x84011660     0x0    addi sp,sp,-16
    0x84011662     0x2    sd ra,8(sp)           ; stack access
    0x84011664     0x4    jal ra,ffffffff84010cb2 <Arch_switchToIdleThread>
    0x84011668     0x8    auipc a5,0x19
    0x8401166c     0xc    ld a5,456(a5) # ffffffff8402a830 <ksIdleThread>
    0x84011670    0x10    auipc a4,0x19
    0x84011674    0x14    sd a5,456(a4) # ffffffff8402a838 <ksCurThread>
    0x84011678    0x18    ld ra,8(sp)           ; stack access
    0x8401167a    0x1a    addi sp,sp,16
    0x8401167c    0x1c    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `switchToIdleThread` has 16 nodes.

Section doFaultTransfer (123 of 271)
====================================

Deriving specifications
-----------------------

Section `doFaultTransfer` consists of 26 instructions.

RVC_FTTFFT___FT___FT.

Stack analysis
---------------

8 stack accesses found. Annotated code for `doFaultTransfer`:

    0x8401161e     0x0    addi sp,sp,-32
    0x84011620     0x2    sd ra,24(sp)          ; stack access
    0x84011622     0x4    sd s0,16(sp)          ; stack access
    0x84011624     0x6    sd s1,8(sp)           ; stack access
    0x84011626     0x8    sd s2,0(sp)           ; stack access
    0x84011628     0xa    mv s2,a0
    0x8401162a     0xc    mv s1,a1
    0x8401162c     0xe    mv s0,a2
    0x8401162e    0x10    mv a2,a3
    0x84011630    0x12    mv a1,s0
    0x84011632    0x14    mv a0,s1
    0x84011634    0x16    jal ra,ffffffff840106fc <setMRs_fault>
    0x84011638    0x1a    ld a5,312(s1)
    0x8401163c    0x1e    slli a5,a5,0xc
    0x8401163e    0x20    lui a4,0xf
    0x84011640    0x22    and a5,a5,a4
    0x84011642    0x24    andi a0,a0,127
    0x84011646    0x28    or a5,a5,a0
    0x84011648    0x2a    sd a5,80(s0)
    0x8401164a    0x2c    sd s2,72(s0)
    0x8401164e    0x30    ld ra,24(sp)          ; stack access
    0x84011650    0x32    ld s0,16(sp)          ; stack access
    0x84011652    0x34    ld s1,8(sp)           ; stack access
    0x84011654    0x36    ld s2,0(sp)           ; stack access
    0x84011656    0x38    addi sp,sp,32
    0x84011658    0x3a    ret

Proving inst theorems
---------------------

26 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doFaultTransfer` has 39 nodes.

Section lookupPivotSlot (124 of 271)
====================================

Deriving specifications
-----------------------

Section `lookupPivotSlot` consists of 12 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `lookupPivotSlot`:

    0x84011604     0x0    addi sp,sp,-48
    0x84011606     0x2    sd ra,40(sp)          ; stack access
    0x84011608     0x4    mv a5,a1
    0x8401160a     0x6    mv a4,a3
    0x8401160c     0x8    mv a3,a2
    0x8401160e     0xa    mv a1,a0
    0x84011610     0xc    mv a2,a5
    0x84011612     0xe    li a0,1
    0x84011614    0x10    jal ra,ffffffff84011500 <lookupSlotForCNodeOp>
    0x84011618    0x14    ld ra,40(sp)          ; stack access
    0x8401161a    0x16    addi sp,sp,48
    0x8401161c    0x18    ret

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupPivotSlot` has 16 nodes.

Section lookupTargetSlot (125 of 271)
=====================================

Deriving specifications
-----------------------

Section `lookupTargetSlot` consists of 12 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `lookupTargetSlot`:

    0x840115ea     0x0    addi sp,sp,-48
    0x840115ec     0x2    sd ra,40(sp)          ; stack access
    0x840115ee     0x4    mv a5,a1
    0x840115f0     0x6    mv a4,a3
    0x840115f2     0x8    mv a3,a2
    0x840115f4     0xa    mv a1,a0
    0x840115f6     0xc    mv a2,a5
    0x840115f8     0xe    li a0,0
    0x840115fa    0x10    jal ra,ffffffff84011500 <lookupSlotForCNodeOp>
    0x840115fe    0x14    ld ra,40(sp)          ; stack access
    0x84011600    0x16    addi sp,sp,48
    0x84011602    0x18    ret

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupTargetSlot` has 16 nodes.

Section lookupSourceSlot (126 of 271)
=====================================

Deriving specifications
-----------------------

Section `lookupSourceSlot` consists of 12 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `lookupSourceSlot`:

    0x840115d0     0x0    addi sp,sp,-48
    0x840115d2     0x2    sd ra,40(sp)          ; stack access
    0x840115d4     0x4    mv a5,a1
    0x840115d6     0x6    mv a4,a3
    0x840115d8     0x8    mv a3,a2
    0x840115da     0xa    mv a1,a0
    0x840115dc     0xc    mv a2,a5
    0x840115de     0xe    li a0,1
    0x840115e0    0x10    jal ra,ffffffff84011500 <lookupSlotForCNodeOp>
    0x840115e4    0x14    ld ra,40(sp)          ; stack access
    0x840115e6    0x16    addi sp,sp,48
    0x840115e8    0x18    ret

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupSourceSlot` has 16 nodes.

Section lookupSlotForCNodeOp (127 of 271)
=========================================

Deriving specifications
-----------------------

Section `lookupSlotForCNodeOp` consists of 75 instructions.

RVC_FFFFT_________FF.

Stack analysis
---------------

23 stack accesses found. Annotated code for `lookupSlotForCNodeOp`:

    0x84011500     0x0    addi sp,sp,-80
    0x84011502     0x2    sd ra,72(sp)          ; stack access
    0x84011504     0x4    sd s0,64(sp)          ; stack access
    0x84011506     0x6    mv s0,a0
    0x84011508     0x8    sd a1,0(sp)           ; stack access
    0x8401150a     0xa    sd a2,8(sp)           ; stack access
    0x8401150c     0xc    srli a1,a1,0x3b
    0x8401150e     0xe    li a5,10
    0x84011510    0x10    bne a1,a5,ffffffff84011544 <lookupSlotForCNodeOp+0x44>
    0x84011514    0x14    addi a5,a4,-1
    0x84011518    0x18    li a2,63
    0x8401151c    0x1c    bltu a2,a5,ffffffff84011566 <lookupSlotForCNodeOp+0x66>
    0x84011520    0x20    ld a1,0(sp)           ; stack access
    0x84011522    0x22    ld a2,8(sp)           ; stack access
    0x84011524    0x24    addi a0,sp,24
    0x84011526    0x26    jal ra,ffffffff84011338 <resolveAddressBits>
    0x8401152a    0x2a    ld a5,40(sp)          ; stack access
    0x8401152c    0x2c    ld a4,24(sp)          ; stack access
    0x8401152e    0x2e    bnez a4,ffffffff8401158a <lookupSlotForCNodeOp+0x8a>
    0x84011530    0x30    bnez a5,ffffffff840115a4 <lookupSlotForCNodeOp+0xa4>
    0x84011532    0x32    sd zero,48(sp)        ; stack access
    0x84011534    0x34    ld a5,32(sp)          ; stack access
    0x84011536    0x36    sd a5,56(sp)          ; stack access
    0x84011538    0x38    ld a0,48(sp)          ; stack access
    0x8401153a    0x3a    ld a1,56(sp)          ; stack access
    0x8401153c    0x3c    ld ra,72(sp)          ; stack access
    0x8401153e    0x3e    ld s0,64(sp)          ; stack access
    0x84011540    0x40    addi sp,sp,80
    0x84011542    0x42    ret
    0x84011544    0x44    auipc a5,0x7
    0x84011548    0x48    addi a5,a5,-1348 # ffffffff84018000 <riscvKSASIDTable>
    0x8401154c    0x4c    li a4,6
    0x8401154e    0x4e    sd a4,1744(a5)
    0x84011552    0x52    sd a0,1736(a5)
    0x84011556    0x56    sd zero,1024(a5)
    0x8401155a    0x5a    sd zero,1032(a5)
    0x8401155e    0x5e    li a5,3
    0x84011560    0x60    sd a5,48(sp)          ; stack access
    0x84011562    0x62    sd zero,56(sp)        ; stack access
    0x84011564    0x64    j ffffffff84011538 <lookupSlotForCNodeOp+0x38>
    0x84011566    0x66    auipc a5,0x7
    0x8401156a    0x6a    addi a5,a5,-1382 # ffffffff84018000 <riscvKSASIDTable>
    0x8401156e    0x6e    li a4,4
    0x84011570    0x70    sd a4,1744(a5)
    0x84011574    0x74    li a4,1
    0x84011576    0x76    sd a4,1712(a5)
    0x8401157a    0x7a    li a4,64
    0x8401157e    0x7e    sd a4,1720(a5)
    0x84011582    0x82    li a5,3
    0x84011584    0x84    sd a5,48(sp)          ; stack access
    0x84011586    0x86    sd zero,56(sp)        ; stack access
    0x84011588    0x88    j ffffffff84011538 <lookupSlotForCNodeOp+0x38>
    0x8401158a    0x8a    auipc a5,0x7
    0x8401158e    0x8e    addi a5,a5,-1418 # ffffffff84018000 <riscvKSASIDTable>
    0x84011592    0x92    li a4,6
    0x84011594    0x94    sd a4,1744(a5)
    0x84011598    0x98    sd s0,1736(a5)
    0x8401159c    0x9c    li a5,3
    0x8401159e    0x9e    sd a5,48(sp)          ; stack access
    0x840115a0    0xa0    sd zero,56(sp)        ; stack access
    0x840115a2    0xa2    j ffffffff84011538 <lookupSlotForCNodeOp+0x38>
    0x840115a4    0xa4    auipc a4,0x7
    0x840115a8    0xa8    addi a4,a4,-1444 # ffffffff84018000 <riscvKSASIDTable>
    0x840115ac    0xac    li a3,6
    0x840115ae    0xae    sd a3,1744(a4)
    0x840115b2    0xb2    sd s0,1736(a4)
    0x840115b6    0xb6    slli a5,a5,0x2
    0x840115b8    0xb8    andi a5,a5,508
    0x840115bc    0xbc    ori a5,a5,2
    0x840115c0    0xc0    sd a5,1024(a4)
    0x840115c4    0xc4    sd zero,1032(a4)
    0x840115c8    0xc8    li a5,3
    0x840115ca    0xca    sd a5,48(sp)          ; stack access
    0x840115cc    0xcc    sd zero,56(sp)        ; stack access
    0x840115ce    0xce    j ffffffff84011538 <lookupSlotForCNodeOp+0x38>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
75 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupSlotForCNodeOp` has 121 nodes.

Section lookupCapAndSlot (128 of 271)
=====================================

Deriving specifications
-----------------------

Section `lookupCapAndSlot` consists of 26 instructions.


Stack analysis
---------------

Section `lookupCapAndSlot` expects pointer to stack in a0.
14 stack accesses found. Annotated code for `lookupCapAndSlot`:

    0x840114c2     0x0    addi sp,sp,-32
    0x840114c4     0x2    sd ra,24(sp)          ; stack access
    0x840114c6     0x4    sd s0,16(sp)          ; stack access
    0x840114c8     0x6    mv s0,a0
    0x840114ca     0x8    mv a0,a1
    0x840114cc     0xa    mv a1,a2
    0x840114ce     0xc    jal ra,ffffffff84011466 <lookupSlot>
    0x840114d2    0x10    sd a0,0(sp)           ; stack access
    0x840114d4    0x12    sd a1,8(sp)           ; stack access
    0x840114d6    0x14    bnez a0,ffffffff840114f0 <lookupCapAndSlot+0x2e>
    0x840114d8    0x16    ld a4,0(a1)
    0x840114da    0x18    ld a5,8(a1)
    0x840114dc    0x1a    sd zero,0(s0)         ; stack access
    0x840114e0    0x1e    sd a4,8(s0)           ; stack access
    0x840114e2    0x20    sd a5,16(s0)          ; stack access
    0x840114e4    0x22    sd a1,24(s0)          ; stack access
    0x840114e6    0x24    mv a0,s0
    0x840114e8    0x26    ld ra,24(sp)          ; stack access
    0x840114ea    0x28    ld s0,16(sp)          ; stack access
    0x840114ec    0x2a    addi sp,sp,32
    0x840114ee    0x2c    ret
    0x840114f0    0x2e    sd a0,0(s0)           ; stack access
    0x840114f2    0x30    sd zero,8(s0)         ; stack access
    0x840114f6    0x34    sd zero,16(s0)        ; stack access
    0x840114fa    0x38    sd zero,24(s0)        ; stack access
    0x840114fe    0x3c    j ffffffff840114e6 <lookupCapAndSlot+0x24>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
26 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupCapAndSlot` has 46 nodes.

Section lookupCap (129 of 271)
==============================

Deriving specifications
-----------------------

Section `lookupCap` consists of 25 instructions.


Stack analysis
---------------

Section `lookupCap` expects pointer to stack in a0.
13 stack accesses found. Annotated code for `lookupCap`:

    0x84011488     0x0    addi sp,sp,-32
    0x8401148a     0x2    sd ra,24(sp)          ; stack access
    0x8401148c     0x4    sd s0,16(sp)          ; stack access
    0x8401148e     0x6    mv s0,a0
    0x84011490     0x8    mv a0,a1
    0x84011492     0xa    mv a1,a2
    0x84011494     0xc    jal ra,ffffffff84011466 <lookupSlot>
    0x84011498    0x10    sd a0,0(sp)           ; stack access
    0x8401149a    0x12    sd a1,8(sp)           ; stack access
    0x8401149c    0x14    bnez a0,ffffffff840114b6 <lookupCap+0x2e>
    0x8401149e    0x16    ld a5,8(sp)           ; stack access
    0x840114a0    0x18    ld a4,0(a5)
    0x840114a2    0x1a    ld a5,8(a5)
    0x840114a4    0x1c    sd zero,0(s0)         ; stack access
    0x840114a8    0x20    sd a4,8(s0)           ; stack access
    0x840114aa    0x22    sd a5,16(s0)          ; stack access
    0x840114ac    0x24    mv a0,s0
    0x840114ae    0x26    ld ra,24(sp)          ; stack access
    0x840114b0    0x28    ld s0,16(sp)          ; stack access
    0x840114b2    0x2a    addi sp,sp,32
    0x840114b4    0x2c    ret
    0x840114b6    0x2e    sd a0,0(s0)           ; stack access
    0x840114b8    0x30    sd zero,8(s0)         ; stack access
    0x840114bc    0x34    sd zero,16(s0)        ; stack access
    0x840114c0    0x38    j ffffffff840114ac <lookupCap+0x24>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
25 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupCap` has 44 nodes.

Section lookupSlot (130 of 271)
===============================

Deriving specifications
-----------------------

Section `lookupSlot` consists of 14 instructions.

RVC_FFFFFFFFFFT___FF.

Stack analysis
---------------

4 stack accesses found. Annotated code for `lookupSlot`:

    0x84011466     0x0    addi sp,sp,-80
    0x84011468     0x2    sd ra,72(sp)          ; stack access
    0x8401146a     0x4    mv a3,a1
    0x8401146c     0x6    andi a0,a0,-1024
    0x84011470     0xa    li a4,64
    0x84011474     0xe    ld a1,0(a0)
    0x84011476    0x10    ld a2,8(a0)
    0x84011478    0x12    addi a0,sp,8
    0x8401147a    0x14    jal ra,ffffffff84011338 <resolveAddressBits>
    0x8401147e    0x18    ld a0,8(sp)           ; stack access
    0x84011480    0x1a    ld a1,16(sp)          ; stack access
    0x84011482    0x1c    ld ra,72(sp)          ; stack access
    0x84011484    0x1e    addi sp,sp,80
    0x84011486    0x20    ret

Proving inst theorems
---------------------

14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupSlot` has 22 nodes.

Section Arch_createObject (131 of 271)
======================================

Deriving specifications
-----------------------

Section `Arch_createObject` consists of 61 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `Arch_createObject`:

    0x84011298     0x0    addi sp,sp,-32
    0x8401129a     0x2    sd ra,24(sp)          ; stack access
    0x8401129c     0x4    li a5,7
    0x8401129e     0x6    beq a0,a5,ffffffff840112ee <Arch_createObject+0x56>
    0x840112a2     0xa    bltu a5,a0,ffffffff840112d4 <Arch_createObject+0x3c>
    0x840112a6     0xe    li a5,5
    0x840112a8    0x10    beq a0,a5,ffffffff84011308 <Arch_createObject+0x70>
    0x840112ac    0x14    li a5,6
    0x840112ae    0x16    bne a0,a5,ffffffff84011322 <Arch_createObject+0x8a>
    0x840112b2    0x1a    andi a3,a3,1
    0x840112b4    0x1c    slli a3,a3,0x36
    0x840112b6    0x1e    li a5,19
    0x840112b8    0x20    slli a5,a5,0x37
    0x840112ba    0x22    or a3,a3,a5
    0x840112bc    0x24    sd a3,0(sp)           ; stack access
    0x840112be    0x26    slli a1,a1,0x9
    0x840112c0    0x28    lui a5,0xfe000
    0x840112c4    0x2c    srli a5,a5,0x10
    0x840112c6    0x2e    and a1,a1,a5
    0x840112c8    0x30    sd a1,8(sp)           ; stack access
    0x840112ca    0x32    ld a0,0(sp)           ; stack access
    0x840112cc    0x34    ld a1,8(sp)           ; stack access
    0x840112ce    0x36    ld ra,24(sp)          ; stack access
    0x840112d0    0x38    addi sp,sp,32
    0x840112d2    0x3a    ret
    0x840112d4    0x3c    li a5,8
    0x840112d6    0x3e    bne a0,a5,ffffffff84011322 <Arch_createObject+0x8a>
    0x840112da    0x42    li a5,3
    0x840112dc    0x44    slli a5,a5,0x3b
    0x840112de    0x46    sd a5,0(sp)           ; stack access
    0x840112e0    0x48    slli a1,a1,0x9
    0x840112e2    0x4a    lui a5,0xfe000
    0x840112e6    0x4e    srli a5,a5,0x10
    0x840112e8    0x50    and a1,a1,a5
    0x840112ea    0x52    sd a1,8(sp)           ; stack access
    0x840112ec    0x54    j ffffffff840112ca <Arch_createObject+0x32>
    0x840112ee    0x56    andi a3,a3,1
    0x840112f0    0x58    slli a3,a3,0x36
    0x840112f2    0x5a    li a5,23
    0x840112f4    0x5c    slli a5,a5,0x37
    0x840112f6    0x5e    or a3,a3,a5
    0x840112f8    0x60    sd a3,0(sp)           ; stack access
    0x840112fa    0x62    slli a1,a1,0x9
    0x840112fc    0x64    lui a5,0xfe000
    0x84011300    0x68    srli a5,a5,0x10
    0x84011302    0x6a    and a1,a1,a5
    0x84011304    0x6c    sd a1,8(sp)           ; stack access
    0x84011306    0x6e    j ffffffff840112ca <Arch_createObject+0x32>
    0x84011308    0x70    andi a3,a3,1
    0x8401130a    0x72    slli a3,a3,0x36
    0x8401130c    0x74    li a5,27
    0x8401130e    0x76    slli a5,a5,0x37
    0x84011310    0x78    or a3,a3,a5
    0x84011312    0x7a    sd a3,0(sp)           ; stack access
    0x84011314    0x7c    slli a1,a1,0x9
    0x84011316    0x7e    lui a5,0xfe000
    0x8401131a    0x82    srli a5,a5,0x10
    0x8401131c    0x84    and a1,a1,a5
    0x8401131e    0x86    sd a1,8(sp)           ; stack access
    0x84011320    0x88    j ffffffff840112ca <Arch_createObject+0x32>
    0x84011322    0x8a    jal ra,ffffffff8401041e <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
61 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_createObject` has 85 nodes.

Section Arch_getObjectSize (132 of 271)
=======================================

Deriving specifications
-----------------------

Section `Arch_getObjectSize` consists of 19 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `Arch_getObjectSize`:

    0x84011266     0x0    li a4,7
    0x84011268     0x2    beq a0,a4,ffffffff84011294 <Arch_getObjectSize+0x2e>
    0x8401126c     0x6    mv a5,a0
    0x8401126e     0x8    bltu a4,a0,ffffffff84011284 <Arch_getObjectSize+0x1e>
    0x84011272     0xc    li a4,5
    0x84011274     0xe    li a0,30
    0x84011276    0x10    beq a5,a4,ffffffff84011282 <Arch_getObjectSize+0x1c>
    0x8401127a    0x14    li a4,6
    0x8401127c    0x16    li a0,12
    0x8401127e    0x18    bne a5,a4,ffffffff8401128c <Arch_getObjectSize+0x26>
    0x84011282    0x1c    ret
    0x84011284    0x1e    li a4,8
    0x84011286    0x20    li a0,12
    0x84011288    0x22    beq a5,a4,ffffffff84011282 <Arch_getObjectSize+0x1c>
    0x8401128c    0x26    addi sp,sp,-16
    0x8401128e    0x28    sd ra,8(sp)           ; stack access
    0x84011290    0x2a    jal ra,ffffffff8401041e <halt>
    0x84011294    0x2e    li a0,21
    0x84011296    0x30    j ffffffff84011282 <Arch_getObjectSize+0x1c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
19 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_getObjectSize` has 32 nodes.

Section Arch_sameObjectAs (133 of 271)
======================================

Deriving specifications
-----------------------

Section `Arch_sameObjectAs` consists of 64 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `Arch_sameObjectAs`:

    0x840111c6     0x0    addi sp,sp,-48
    0x840111c8     0x2    sd ra,40(sp)          ; stack access
    0x840111ca     0x4    sd a0,16(sp)          ; stack access
    0x840111cc     0x6    sd a1,24(sp)          ; stack access
    0x840111ce     0x8    sd a2,0(sp)           ; stack access
    0x840111d0     0xa    sd a3,8(sp)           ; stack access
    0x840111d2     0xc    srli a4,a0,0x3b
    0x840111d6    0x10    li a5,1
    0x840111d8    0x12    beq a4,a5,ffffffff840111ee <Arch_sameObjectAs+0x28>
    0x840111dc    0x16    ld a2,0(sp)           ; stack access
    0x840111de    0x18    ld a3,8(sp)           ; stack access
    0x840111e0    0x1a    ld a0,16(sp)          ; stack access
    0x840111e2    0x1c    ld a1,24(sp)          ; stack access
    0x840111e4    0x1e    jal ra,ffffffff84011068 <Arch_sameRegionAs>
    0x840111e8    0x22    ld ra,40(sp)          ; stack access
    0x840111ea    0x24    addi sp,sp,48
    0x840111ec    0x26    ret
    0x840111ee    0x28    mv a4,a2
    0x840111f0    0x2a    srli a3,a2,0x3b
    0x840111f4    0x2e    bne a3,a5,ffffffff840111dc <Arch_sameObjectAs+0x16>
    0x840111f8    0x32    srli a5,a1,0x9
    0x840111fc    0x36    slli a2,a5,0x19
    0x84011200    0x3a    srli a2,a2,0x19
    0x84011202    0x3c    srli a5,a5,0x26
    0x84011204    0x3e    andi a5,a5,1
    0x84011206    0x40    beqz a5,ffffffff8401122e <Arch_sameObjectAs+0x68>
    0x84011208    0x42    li a3,-1
    0x8401120a    0x44    slli a5,a3,0x27
    0x8401120e    0x48    or a2,a2,a5
    0x84011210    0x4a    ld a5,8(sp)           ; stack access
    0x84011212    0x4c    srli a5,a5,0x9
    0x84011214    0x4e    srli a3,a3,0x19
    0x84011216    0x50    and a3,a3,a5
    0x84011218    0x52    srli a5,a5,0x26
    0x8401121a    0x54    andi a5,a5,1
    0x8401121c    0x56    beqz a5,ffffffff8401122a <Arch_sameObjectAs+0x64>
    0x8401121e    0x58    li a5,-1
    0x84011220    0x5a    slli a5,a5,0x27
    0x84011222    0x5c    or a3,a3,a5
    0x84011224    0x5e    li a5,0
    0x84011226    0x60    beq a3,a2,ffffffff84011240 <Arch_sameObjectAs+0x7a>
    0x8401122a    0x64    mv a0,a5
    0x8401122c    0x66    j ffffffff840111e8 <Arch_sameObjectAs+0x22>
    0x8401122e    0x68    ld a5,8(sp)           ; stack access
    0x84011230    0x6a    srli a5,a5,0x9
    0x84011232    0x6c    slli a3,a5,0x19
    0x84011236    0x70    srli a3,a3,0x19
    0x84011238    0x72    srli a5,a5,0x26
    0x8401123a    0x74    andi a5,a5,1
    0x8401123c    0x76    bnez a5,ffffffff8401121e <Arch_sameObjectAs+0x58>
    0x8401123e    0x78    j ffffffff84011224 <Arch_sameObjectAs+0x5e>
    0x84011240    0x7a    srli a2,a4,0x39
    0x84011244    0x7e    andi a2,a2,3
    0x84011246    0x80    srli a3,a0,0x39
    0x8401124a    0x84    andi a3,a3,3
    0x8401124c    0x86    bne a2,a3,ffffffff8401122a <Arch_sameObjectAs+0x64>
    0x84011250    0x8a    srli a5,a0,0x36
    0x84011254    0x8e    srli a4,a4,0x36
    0x84011256    0x90    xori a4,a4,1
    0x8401125a    0x94    andi a5,a5,1
    0x8401125c    0x96    andi a4,a4,1
    0x8401125e    0x98    sub a5,a5,a4
    0x84011260    0x9a    snez a5,a5
    0x84011264    0x9e    j ffffffff8401122a <Arch_sameObjectAs+0x64>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
64 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_sameObjectAs` has 92 nodes.

Section Arch_sameRegionAs (134 of 271)
======================================

Deriving specifications
-----------------------

Section `Arch_sameRegionAs` consists of 138 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `Arch_sameRegionAs`:

    0x84011068      0x0    srli a5,a0,0x3b
    0x8401106c      0x4    li a6,11
    0x8401106e      0x6    beq a5,a6,ffffffff840111ba <Arch_sameRegionAs+0x152>
    0x84011072      0xa    mv a4,a0
    0x84011074      0xc    bltu a6,a5,ffffffff840110c4 <Arch_sameRegionAs+0x5c>
    0x84011078     0x10    li a6,1
    0x8401107a     0x12    beq a5,a6,ffffffff84011112 <Arch_sameRegionAs+0xaa>
    0x8401107e     0x16    li a6,3
    0x84011080     0x18    bne a5,a6,ffffffff840110c0 <Arch_sameRegionAs+0x58>
    0x84011084     0x1c    srli a2,a2,0x3b
    0x84011086     0x1e    li a5,3
    0x84011088     0x20    li a0,0
    0x8401108a     0x22    bne a2,a5,ffffffff8401111e <Arch_sameRegionAs+0xb6>
    0x8401108e     0x26    srli a1,a1,0x9
    0x84011090     0x28    slli a0,a1,0x19
    0x84011094     0x2c    srli a5,a0,0x19
    0x84011098     0x30    srli a1,a1,0x26
    0x8401109a     0x32    andi a1,a1,1
    0x8401109c     0x34    beqz a1,ffffffff840110a4 <Arch_sameRegionAs+0x3c>
    0x8401109e     0x36    li a4,-1
    0x840110a0     0x38    slli a4,a4,0x27
    0x840110a2     0x3a    or a5,a5,a4
    0x840110a4     0x3c    srli a3,a3,0x9
    0x840110a6     0x3e    slli a0,a3,0x19
    0x840110aa     0x42    srli a0,a0,0x19
    0x840110ac     0x44    srli a3,a3,0x26
    0x840110ae     0x46    andi a3,a3,1
    0x840110b0     0x48    beqz a3,ffffffff840110b8 <Arch_sameRegionAs+0x50>
    0x840110b2     0x4a    li a4,-1
    0x840110b4     0x4c    slli a4,a4,0x27
    0x840110b6     0x4e    or a0,a0,a4
    0x840110b8     0x50    sub a0,a0,a5
    0x840110ba     0x52    seqz a0,a0
    0x840110be     0x56    ret
    0x840110c0     0x58    li a0,0
    0x840110c2     0x5a    ret
    0x840110c4     0x5c    li a3,13
    0x840110c6     0x5e    bne a5,a3,ffffffff8401110e <Arch_sameRegionAs+0xa6>
    0x840110ca     0x62    srli a5,a2,0x3b
    0x840110ce     0x66    li a3,13
    0x840110d0     0x68    li a0,0
    0x840110d2     0x6a    bne a5,a3,ffffffff8401111e <Arch_sameRegionAs+0xb6>
    0x840110d6     0x6e    slli a4,a4,0x2
    0x840110d8     0x70    lui a0,0xf8000
    0x840110dc     0x74    srli a0,a0,0x19
    0x840110de     0x76    and a0,a0,a4
    0x840110e0     0x78    srli a4,a4,0x26
    0x840110e2     0x7a    andi a4,a4,1
    0x840110e4     0x7c    beqz a4,ffffffff840110ec <Arch_sameRegionAs+0x84>
    0x840110e6     0x7e    li a5,-1
    0x840110e8     0x80    slli a5,a5,0x27
    0x840110ea     0x82    or a0,a0,a5
    0x840110ec     0x84    slli a4,a2,0x2
    0x840110f0     0x88    lui a5,0xf8000
    0x840110f4     0x8c    srli a5,a5,0x19
    0x840110f6     0x8e    and a5,a5,a4
    0x840110f8     0x90    srli a4,a4,0x26
    0x840110fa     0x92    andi a4,a4,1
    0x840110fc     0x94    beqz a4,ffffffff84011104 <Arch_sameRegionAs+0x9c>
    0x840110fe     0x96    li a4,-1
    0x84011100     0x98    slli a4,a4,0x27
    0x84011102     0x9a    or a5,a5,a4
    0x84011104     0x9c    sub a0,a5,a0
    0x84011108     0xa0    seqz a0,a0
    0x8401110c     0xa4    ret
    0x8401110e     0xa6    li a0,0
    0x84011110     0xa8    ret
    0x84011112     0xaa    srli a5,a2,0x3b
    0x84011116     0xae    li a6,1
    0x84011118     0xb0    li a0,0
    0x8401111a     0xb2    beq a5,a6,ffffffff84011120 <Arch_sameRegionAs+0xb8>
    0x8401111e     0xb6    ret
    0x84011120     0xb8    addi sp,sp,-48
    0x84011122     0xba    sd ra,40(sp)          ; stack access
    0x84011124     0xbc    srli a1,a1,0x9
    0x84011126     0xbe    slli a5,a1,0x19
    0x8401112a     0xc2    srli a5,a5,0x19
    0x8401112c     0xc4    srli a1,a1,0x26
    0x8401112e     0xc6    andi a1,a1,1
    0x84011130     0xc8    beqz a1,ffffffff84011138 <Arch_sameRegionAs+0xd0>
    0x84011132     0xca    li a1,-1
    0x84011134     0xcc    slli a1,a1,0x27
    0x84011136     0xce    or a5,a5,a1
    0x84011138     0xd0    srli a3,a3,0x9
    0x8401113a     0xd2    slli a1,a3,0x19
    0x8401113e     0xd6    srli a1,a1,0x19
    0x84011140     0xd8    srli a3,a3,0x26
    0x84011142     0xda    andi a3,a3,1
    0x84011144     0xdc    beqz a3,ffffffff8401114c <Arch_sameRegionAs+0xe4>
    0x84011146     0xde    li a3,-1
    0x84011148     0xe0    slli a3,a3,0x27
    0x8401114a     0xe2    or a1,a1,a3
    0x8401114c     0xe4    srli a4,a4,0x39
    0x8401114e     0xe6    andi a4,a4,3
    0x84011150     0xe8    li a3,1
    0x84011152     0xea    beq a4,a3,ffffffff84011162 <Arch_sameRegionAs+0xfa>
    0x84011156     0xee    li a3,2
    0x84011158     0xf0    beq a4,a3,ffffffff84011166 <Arch_sameRegionAs+0xfe>
    0x8401115c     0xf4    beqz a4,ffffffff8401117e <Arch_sameRegionAs+0x116>
    0x8401115e     0xf6    jal ra,ffffffff8401041e <halt>
    0x84011162     0xfa    li a6,21
    0x84011164     0xfc    j ffffffff84011168 <Arch_sameRegionAs+0x100>
    0x84011166     0xfe    li a6,30
    0x84011168    0x100    srli a2,a2,0x39
    0x8401116a    0x102    andi a2,a2,3
    0x8401116c    0x104    li a4,1
    0x8401116e    0x106    beq a2,a4,ffffffff84011182 <Arch_sameRegionAs+0x11a>
    0x84011172    0x10a    li a4,2
    0x84011174    0x10c    beq a2,a4,ffffffff84011186 <Arch_sameRegionAs+0x11e>
    0x84011178    0x110    beqz a2,ffffffff840111b6 <Arch_sameRegionAs+0x14e>
    0x8401117a    0x112    jal ra,ffffffff8401041e <halt>
    0x8401117e    0x116    li a6,12
    0x84011180    0x118    j ffffffff84011168 <Arch_sameRegionAs+0x100>
    0x84011182    0x11a    li a4,21
    0x84011184    0x11c    j ffffffff84011188 <Arch_sameRegionAs+0x120>
    0x84011186    0x11e    li a4,30
    0x84011188    0x120    li a0,0
    0x8401118a    0x122    bltu a1,a5,ffffffff840111b0 <Arch_sameRegionAs+0x148>
    0x8401118e    0x126    li a3,1
    0x84011190    0x128    sll a4,a3,a4
    0x84011194    0x12c    addi a2,a1,-1 # fffffffff7ffffff <ki_end+0x73fd0fff>
    0x84011198    0x130    add a4,a4,a2
    0x8401119a    0x132    sll a3,a3,a6
    0x8401119e    0x136    addi a5,a5,-1
    0x840111a0    0x138    add a5,a5,a3
    0x840111a2    0x13a    bltu a5,a4,ffffffff840111b0 <Arch_sameRegionAs+0x148>
    0x840111a6    0x13e    sltu a0,a4,a1
    0x840111aa    0x142    xori a0,a0,1
    0x840111ae    0x146    sext.w a0,a0
    0x840111b0    0x148    ld ra,40(sp)          ; stack access
    0x840111b2    0x14a    addi sp,sp,48
    0x840111b4    0x14c    ret
    0x840111b6    0x14e    li a4,12
    0x840111b8    0x150    j ffffffff84011188 <Arch_sameRegionAs+0x120>
    0x840111ba    0x152    srli a0,a2,0x3b
    0x840111be    0x156    addi a0,a0,-11
    0x840111c0    0x158    seqz a0,a0
    0x840111c4    0x15c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
138 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_sameRegionAs` has 193 nodes.

Section Arch_maskCapRights (135 of 271)
=======================================

Deriving specifications
-----------------------

Section `Arch_maskCapRights` consists of 32 instructions.

RVC_FTTFFFFTFFT___FT.

Stack analysis
---------------

12 stack accesses found. Annotated code for `Arch_maskCapRights`:

    0x84010f0c     0x0    addi sp,sp,-64
    0x84010f0e     0x2    sd ra,56(sp)          ; stack access
    0x84010f10     0x4    sd s0,48(sp)          ; stack access
    0x84010f12     0x6    sd s1,40(sp)          ; stack access
    0x84010f14     0x8    mv s0,a1
    0x84010f16     0xa    mv s1,a2
    0x84010f18     0xc    srli a4,a1,0x3b
    0x84010f1c    0x10    li a5,1
    0x84010f1e    0x12    beq a4,a5,ffffffff84010f34 <Arch_maskCapRights+0x28>
    0x84010f22    0x16    sd a1,16(sp)          ; stack access
    0x84010f24    0x18    sd a2,24(sp)          ; stack access
    0x84010f26    0x1a    ld a0,16(sp)          ; stack access
    0x84010f28    0x1c    ld a1,24(sp)          ; stack access
    0x84010f2a    0x1e    ld ra,56(sp)          ; stack access
    0x84010f2c    0x20    ld s0,48(sp)          ; stack access
    0x84010f2e    0x22    ld s1,40(sp)          ; stack access
    0x84010f30    0x24    addi sp,sp,64
    0x84010f32    0x26    ret
    0x84010f34    0x28    srli a5,a1,0x37
    0x84010f38    0x2c    mv a1,a0
    0x84010f3a    0x2e    andi a0,a5,3
    0x84010f3e    0x32    jal ra,ffffffff84010da6 <maskVMRights>
    0x84010f42    0x36    andi a0,a0,3
    0x84010f44    0x38    slli a0,a0,0x37
    0x84010f46    0x3a    li a1,-3
    0x84010f48    0x3c    slli a1,a1,0x37
    0x84010f4a    0x3e    addi a1,a1,-1
    0x84010f4c    0x40    and s0,s0,a1
    0x84010f4e    0x42    or s0,s0,a0
    0x84010f50    0x44    sd s0,16(sp)          ; stack access
    0x84010f52    0x46    sd s1,24(sp)          ; stack access
    0x84010f54    0x48    j ffffffff84010f26 <Arch_maskCapRights+0x1a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
32 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_maskCapRights` has 48 nodes.

Section Arch_deriveCap (136 of 271)
===================================

Deriving specifications
-----------------------

Section `Arch_deriveCap` consists of 39 instructions.


Stack analysis
---------------

Section `Arch_deriveCap` expects pointer to stack in a0.
10 stack accesses found. Annotated code for `Arch_deriveCap`:

    0x84010e9e     0x0    srli a5,a2,0x3b
    0x84010ea2     0x4    li a4,3
    0x84010ea4     0x6    beq a5,a4,ffffffff84010ed6 <Arch_deriveCap+0x38>
    0x84010ea8     0xa    bgeu a4,a5,ffffffff84010eba <Arch_deriveCap+0x1c>
    0x84010eac     0xe    addi a5,a5,-11
    0x84010eae    0x10    andi a5,a5,-3
    0x84010eb0    0x12    beqz a5,ffffffff84010ef8 <Arch_deriveCap+0x5a>
    0x84010eb2    0x14    addi sp,sp,-32
    0x84010eb4    0x16    sd ra,24(sp)          ; stack access
    0x84010eb6    0x18    jal ra,ffffffff8401041e <halt>
    0x84010eba    0x1c    li a4,1
    0x84010ebc    0x1e    bne a5,a4,ffffffff84010eb2 <Arch_deriveCap+0x14>
    0x84010ec0    0x22    sd zero,0(a0)         ; stack access
    0x84010ec4    0x26    li a5,-1
    0x84010ec6    0x28    slli a4,a5,0x27
    0x84010eca    0x2c    and a2,a2,a4
    0x84010ecc    0x2e    sd a2,8(a0)           ; stack access
    0x84010ece    0x30    srli a5,a5,0x10
    0x84010ed0    0x32    and a3,a3,a5
    0x84010ed2    0x34    sd a3,16(a0)          ; stack access
    0x84010ed4    0x36    ret
    0x84010ed6    0x38    srli a4,a2,0x27
    0x84010eda    0x3c    andi a4,a4,1
    0x84010edc    0x3e    bnez a4,ffffffff84010ef4 <Arch_deriveCap+0x56>
    0x84010ede    0x40    li a3,3
    0x84010ee0    0x42    auipc a2,0x7
    0x84010ee4    0x46    sd a3,2032(a2) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84010ee8    0x4a    mv a3,a4
    0x84010eea    0x4c    mv a2,a4
    0x84010eec    0x4e    sd a5,0(a0)           ; stack access
    0x84010eee    0x50    sd a2,8(a0)           ; stack access
    0x84010ef0    0x52    sd a3,16(a0)          ; stack access
    0x84010ef2    0x54    ret
    0x84010ef4    0x56    li a5,0
    0x84010ef6    0x58    j ffffffff84010eec <Arch_deriveCap+0x4e>
    0x84010ef8    0x5a    sd zero,0(a0)         ; stack access
    0x84010efc    0x5e    sd a2,8(a0)           ; stack access
    0x84010efe    0x60    sd a3,16(a0)          ; stack access
    0x84010f00    0x62    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
39 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_deriveCap` has 64 nodes.

Section performPageInvocationUnmap (137 of 271)
===============================================

Deriving specifications
-----------------------

Section `performPageInvocationUnmap` consists of 43 instructions.


Stack analysis
---------------

5 stack accesses found. Annotated code for `performPageInvocationUnmap`:

    0x84010dfe     0x0    addi sp,sp,-32
    0x84010e00     0x2    sd ra,24(sp)          ; stack access
    0x84010e02     0x4    sd s0,16(sp)          ; stack access
    0x84010e04     0x6    sd a0,0(sp)           ; stack access
    0x84010e06     0x8    mv s0,a2
    0x84010e08     0xa    mv a5,a1
    0x84010e0a     0xc    srli a1,a1,0x30
    0x84010e0c     0xe    beqz a1,ffffffff84010e3e <performPageInvocationUnmap+0x40>
    0x84010e0e    0x10    mv a4,a0
    0x84010e10    0x12    srli a0,a0,0x39
    0x84010e12    0x14    andi a0,a0,3
    0x84010e14    0x16    slli a2,a4,0x19
    0x84010e18    0x1a    srli a2,a2,0x19
    0x84010e1a    0x1c    srli a4,a4,0x26
    0x84010e1c    0x1e    andi a4,a4,1
    0x84010e1e    0x20    beqz a4,ffffffff84010e26 <performPageInvocationUnmap+0x28>
    0x84010e20    0x22    li a4,-1
    0x84010e22    0x24    slli a4,a4,0x27
    0x84010e24    0x26    or a2,a2,a4
    0x84010e26    0x28    srli a5,a5,0x9
    0x84010e28    0x2a    slli a3,a5,0x19
    0x84010e2c    0x2e    srli a3,a3,0x19
    0x84010e2e    0x30    srli a5,a5,0x26
    0x84010e30    0x32    andi a5,a5,1
    0x84010e32    0x34    beqz a5,ffffffff84010e3a <performPageInvocationUnmap+0x3c>
    0x84010e34    0x36    li a5,-1
    0x84010e36    0x38    slli a5,a5,0x27
    0x84010e38    0x3a    or a3,a3,a5
    0x84010e3a    0x3c    jal ra,ffffffff84010b54 <unmapPage>
    0x84010e3e    0x40    ld a4,8(s0)
    0x84010e40    0x42    li a5,-1
    0x84010e42    0x44    srli a3,a5,0x10
    0x84010e46    0x48    and a4,a4,a3
    0x84010e48    0x4a    ld a3,0(s0)
    0x84010e4a    0x4c    slli a5,a5,0x27
    0x84010e4c    0x4e    and a5,a5,a3
    0x84010e4e    0x50    sd a5,0(s0)
    0x84010e50    0x52    sd a4,8(s0)
    0x84010e52    0x54    li a0,0
    0x84010e54    0x56    ld ra,24(sp)          ; stack access
    0x84010e56    0x58    ld s0,16(sp)          ; stack access
    0x84010e58    0x5a    addi sp,sp,32
    0x84010e5a    0x5c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
43 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performPageInvocationUnmap` has 60 nodes.

Section deleteASID (138 of 271)
===============================

Deriving specifications
-----------------------

Section `deleteASID` consists of 23 instructions.

Skipping 12a00073 sfence.vma zero,a0


Stack analysis
---------------

2 stack accesses found. Annotated code for `deleteASID`:

    0x84010d06     0x0    srli a5,a0,0x9
    0x84010d0a     0x4    slli a4,a5,0x3
    0x84010d0e     0x8    auipc a5,0x7
    0x84010d12     0xc    addi a5,a5,754 # ffffffff84018000 <riscvKSASIDTable>
    0x84010d16    0x10    add a5,a5,a4
    0x84010d18    0x12    ld a5,0(a5)
    0x84010d1a    0x14    beqz a5,ffffffff84010d2a <deleteASID+0x24>
    0x84010d1c    0x16    andi a4,a0,511
    0x84010d20    0x1a    slli a4,a4,0x3
    0x84010d22    0x1c    add a5,a5,a4
    0x84010d24    0x1e    ld a4,0(a5)
    0x84010d26    0x20    beq a4,a1,ffffffff84010d2c <deleteASID+0x26>
    0x84010d2a    0x24    ret
    0x84010d2c    0x26    addi sp,sp,-16
    0x84010d2e    0x28    sd ra,8(sp)           ; stack access
    0x84010d30    0x2a    sfence.vma zero,a0
    0x84010d34    0x2e    sd zero,0(a5)
    0x84010d38    0x32    auipc a0,0x1a
    0x84010d3c    0x36    ld a0,-1280(a0) # ffffffff8402a838 <ksCurThread>
    0x84010d40    0x3a    jal ra,ffffffff84010be2 <setVMRoot>
    0x84010d44    0x3e    ld ra,8(sp)           ; stack access
    0x84010d46    0x40    addi sp,sp,16
    0x84010d48    0x42    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deleteASID` has 37 nodes.

Section deleteASIDPool (139 of 271)
===================================

Deriving specifications
-----------------------

Section `deleteASIDPool` consists of 20 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `deleteASIDPool`:

    0x84010cc8     0x0    srli a0,a0,0x9
    0x84010cca     0x2    slli a4,a0,0x3
    0x84010cce     0x6    auipc a5,0x7
    0x84010cd2     0xa    addi a5,a5,818 # ffffffff84018000 <riscvKSASIDTable>
    0x84010cd6     0xe    add a5,a5,a4
    0x84010cd8    0x10    ld a5,0(a5)
    0x84010cda    0x12    beq a5,a1,ffffffff84010ce0 <deleteASIDPool+0x18>
    0x84010cde    0x16    ret
    0x84010ce0    0x18    addi sp,sp,-16
    0x84010ce2    0x1a    sd ra,8(sp)           ; stack access
    0x84010ce4    0x1c    auipc a5,0x7
    0x84010ce8    0x20    addi a5,a5,796 # ffffffff84018000 <riscvKSASIDTable>
    0x84010cec    0x24    add a0,a5,a4
    0x84010cf0    0x28    sd zero,0(a0)
    0x84010cf4    0x2c    auipc a0,0x1a
    0x84010cf8    0x30    ld a0,-1212(a0) # ffffffff8402a838 <ksCurThread>
    0x84010cfc    0x34    jal ra,ffffffff84010be2 <setVMRoot>
    0x84010d00    0x38    ld ra,8(sp)           ; stack access
    0x84010d02    0x3a    addi sp,sp,16
    0x84010d04    0x3c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deleteASIDPool` has 30 nodes.

Section Arch_switchToIdleThread (140 of 271)
============================================

Deriving specifications
-----------------------

Section `Arch_switchToIdleThread` consists of 8 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `Arch_switchToIdleThread`:

    0x84010cb2     0x0    addi sp,sp,-16
    0x84010cb4     0x2    sd ra,8(sp)           ; stack access
    0x84010cb6     0x4    auipc a0,0x1a
    0x84010cba     0x8    ld a0,-1158(a0) # ffffffff8402a830 <ksIdleThread>
    0x84010cbe     0xc    jal ra,ffffffff84010be2 <setVMRoot>
    0x84010cc2    0x10    ld ra,8(sp)           ; stack access
    0x84010cc4    0x12    addi sp,sp,16
    0x84010cc6    0x14    ret

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_switchToIdleThread` has 13 nodes.

Section Arch_switchToThread (141 of 271)
========================================

Deriving specifications
-----------------------

Section `Arch_switchToThread` consists of 6 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `Arch_switchToThread`:

    0x84010ca4    0x0    addi sp,sp,-16
    0x84010ca6    0x2    sd ra,8(sp)           ; stack access
    0x84010ca8    0x4    jal ra,ffffffff84010be2 <setVMRoot>
    0x84010cac    0x8    ld ra,8(sp)           ; stack access
    0x84010cae    0xa    addi sp,sp,16
    0x84010cb0    0xc    ret

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_switchToThread` has 10 nodes.

Section setVMRoot (142 of 271)
==============================

Deriving specifications
-----------------------

Section `setVMRoot` consists of 75 instructions.

Skipping 18079073 csrw satp,a5

Skipping 12000073 sfence.vma

Skipping 18079073 csrw satp,a5

Skipping 12000073 sfence.vma

Skipping 18079073 csrw satp,a5

Skipping 12000073 sfence.vma


Stack analysis
---------------

10 stack accesses found. Annotated code for `setVMRoot`:

    0x84010be2     0x0    andi a0,a0,-1024
    0x84010be6     0x4    ld a5,32(a0)
    0x84010be8     0x6    srli a5,a5,0x3b
    0x84010bea     0x8    li a4,3
    0x84010bec     0xa    beq a5,a4,ffffffff84010c16 <setVMRoot+0x34>
    0x84010bf0     0xe    auipc a5,0x1c
    0x84010bf4    0x12    addi a5,a5,1040 # ffffffff8402d000 <kernel_root_pageTable>
    0x84010bf8    0x16    li a4,1
    0x84010bfa    0x18    slli a4,a4,0x20
    0x84010bfc    0x1a    add a5,a5,a4
    0x84010bfe    0x1c    srli a5,a5,0xc
    0x84010c00    0x1e    li a4,-1
    0x84010c02    0x20    srli a3,a4,0x14
    0x84010c06    0x24    and a5,a5,a3
    0x84010c08    0x26    slli a4,a4,0x3f
    0x84010c0a    0x28    or a5,a5,a4
    0x84010c0c    0x2a    csrw satp,a5
    0x84010c10    0x2e    sfence.vma
    0x84010c14    0x32    ret
    0x84010c16    0x34    addi sp,sp,-48
    0x84010c18    0x36    sd ra,40(sp)          ; stack access
    0x84010c1a    0x38    sd s0,32(sp)          ; stack access
    0x84010c1c    0x3a    sd s1,24(sp)          ; stack access
    0x84010c1e    0x3c    sd s2,16(sp)          ; stack access
    0x84010c20    0x3e    addi a3,a0,32
    0x84010c24    0x42    ld a5,8(a3)
    0x84010c26    0x44    srli a4,a5,0x9
    0x84010c2a    0x48    slli s0,a4,0x19
    0x84010c2e    0x4c    srli s0,s0,0x19
    0x84010c30    0x4e    srli a4,a4,0x26
    0x84010c32    0x50    andi a4,a4,1
    0x84010c34    0x52    beqz a4,ffffffff84010c3c <setVMRoot+0x5a>
    0x84010c36    0x54    li a4,-1
    0x84010c38    0x56    slli a4,a4,0x27
    0x84010c3a    0x58    or s0,s0,a4
    0x84010c3c    0x5a    srli s1,a5,0x30
    0x84010c40    0x5e    mv a0,s1
    0x84010c42    0x60    jal ra,ffffffff84010144 <findVSpaceForASID>
    0x84010c46    0x64    sd a0,0(sp)           ; stack access
    0x84010c48    0x66    sd a1,8(sp)           ; stack access
    0x84010c4a    0x68    bnez a0,ffffffff84010c7e <setVMRoot+0x9c>
    0x84010c4c    0x6a    bne a1,s0,ffffffff84010c7e <setVMRoot+0x9c>
    0x84010c50    0x6e    li a5,1
    0x84010c52    0x70    slli a5,a5,0x26
    0x84010c54    0x72    add a5,a5,s0
    0x84010c56    0x74    srli a5,a5,0xc
    0x84010c58    0x76    li a4,-1
    0x84010c5a    0x78    srli s0,a4,0x14
    0x84010c5e    0x7c    and a5,a5,s0
    0x84010c60    0x7e    slli a0,s1,0x2c
    0x84010c64    0x82    or a5,a5,a0
    0x84010c66    0x84    slli a4,a4,0x3f
    0x84010c68    0x86    or a5,a5,a4
    0x84010c6a    0x88    csrw satp,a5
    0x84010c6e    0x8c    sfence.vma
    0x84010c72    0x90    ld ra,40(sp)          ; stack access
    0x84010c74    0x92    ld s0,32(sp)          ; stack access
    0x84010c76    0x94    ld s1,24(sp)          ; stack access
    0x84010c78    0x96    ld s2,16(sp)          ; stack access
    0x84010c7a    0x98    addi sp,sp,48
    0x84010c7c    0x9a    ret
    0x84010c7e    0x9c    auipc a5,0x1c
    0x84010c82    0xa0    addi a5,a5,898 # ffffffff8402d000 <kernel_root_pageTable>
    0x84010c86    0xa4    li a4,1
    0x84010c88    0xa6    slli a4,a4,0x20
    0x84010c8a    0xa8    add a5,a5,a4
    0x84010c8c    0xaa    srli a5,a5,0xc
    0x84010c8e    0xac    li a4,-1
    0x84010c90    0xae    srli a3,a4,0x14
    0x84010c94    0xb2    and a5,a5,a3
    0x84010c96    0xb4    slli a4,a4,0x3f
    0x84010c98    0xb6    or a5,a5,a4
    0x84010c9a    0xb8    csrw satp,a5
    0x84010c9e    0xbc    sfence.vma
    0x84010ca2    0xc0    j ffffffff84010c72 <setVMRoot+0x90>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
75 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setVMRoot` has 104 nodes.

Section unmapPageTable (143 of 271)
===================================

Deriving specifications
-----------------------

Section `unmapPageTable` consists of 64 instructions.

Skipping 12000073 sfence.vma


Stack analysis
---------------

8 stack accesses found. Annotated code for `unmapPageTable`:

    0x84010aaa     0x0    addi sp,sp,-48
    0x84010aac     0x2    sd ra,40(sp)          ; stack access
    0x84010aae     0x4    sd s0,32(sp)          ; stack access
    0x84010ab0     0x6    sd s1,24(sp)          ; stack access
    0x84010ab2     0x8    mv s0,a1
    0x84010ab4     0xa    mv s1,a2
    0x84010ab6     0xc    jal ra,ffffffff84010144 <findVSpaceForASID>
    0x84010aba    0x10    sd a0,0(sp)           ; stack access
    0x84010abc    0x12    sd a1,8(sp)           ; stack access
    0x84010abe    0x14    bnez a0,ffffffff84010b3e <unmapPageTable+0x94>
    0x84010ac0    0x16    beq a1,s1,ffffffff84010b48 <unmapPageTable+0x9e>
    0x84010ac4    0x1a    srli a5,s0,0x1e
    0x84010ac8    0x1e    andi a5,a5,511
    0x84010acc    0x22    slli a5,a5,0x3
    0x84010ace    0x24    add a4,a1,a5
    0x84010ad2    0x28    ld a5,0(a4)
    0x84010ad4    0x2a    andi a3,a5,1
    0x84010ad8    0x2e    beqz a3,ffffffff84010b3e <unmapPageTable+0x94>
    0x84010ada    0x30    srli a3,a5,0x1
    0x84010ade    0x34    srli a2,a5,0x2
    0x84010ae2    0x38    or a3,a3,a2
    0x84010ae4    0x3a    srli a2,a5,0x3
    0x84010ae8    0x3e    or a3,a3,a2
    0x84010aea    0x40    andi a3,a3,1
    0x84010aec    0x42    bnez a3,ffffffff84010b3e <unmapPageTable+0x94>
    0x84010aee    0x44    slli a5,a5,0x2
    0x84010af0    0x46    lui a3,0xfff00
    0x84010af4    0x4a    srli a3,a3,0x8
    0x84010af6    0x4c    and a5,a5,a3
    0x84010af8    0x4e    li a3,-1
    0x84010afa    0x50    slli a3,a3,0x26
    0x84010afc    0x52    add a5,a5,a3
    0x84010afe    0x54    beq s1,a5,ffffffff84010b4a <unmapPageTable+0xa0>
    0x84010b02    0x58    srli s0,s0,0x15
    0x84010b04    0x5a    andi s0,s0,511
    0x84010b08    0x5e    slli s0,s0,0x3
    0x84010b0a    0x60    add a4,a5,s0
    0x84010b0e    0x64    ld a5,0(a4)
    0x84010b10    0x66    andi a3,a5,1
    0x84010b14    0x6a    beqz a3,ffffffff84010b3e <unmapPageTable+0x94>
    0x84010b16    0x6c    srli a3,a5,0x1
    0x84010b1a    0x70    srli a2,a5,0x2
    0x84010b1e    0x74    or a3,a3,a2
    0x84010b20    0x76    srli a2,a5,0x3
    0x84010b24    0x7a    or a3,a3,a2
    0x84010b26    0x7c    andi a3,a3,1
    0x84010b28    0x7e    bnez a3,ffffffff84010b3e <unmapPageTable+0x94>
    0x84010b2a    0x80    slli a5,a5,0x2
    0x84010b2c    0x82    lui a3,0xfff00
    0x84010b30    0x86    srli a3,a3,0x8
    0x84010b32    0x88    and a5,a5,a3
    0x84010b34    0x8a    li a3,-1
    0x84010b36    0x8c    slli a3,a3,0x26
    0x84010b38    0x8e    add a5,a5,a3
    0x84010b3a    0x90    beq s1,a5,ffffffff84010b4a <unmapPageTable+0xa0>
    0x84010b3e    0x94    ld ra,40(sp)          ; stack access
    0x84010b40    0x96    ld s0,32(sp)          ; stack access
    0x84010b42    0x98    ld s1,24(sp)          ; stack access
    0x84010b44    0x9a    addi sp,sp,48
    0x84010b46    0x9c    ret
    0x84010b48    0x9e    li a4,0
    0x84010b4a    0xa0    sd zero,0(a4)
    0x84010b4e    0xa4    sfence.vma
    0x84010b52    0xa8    j ffffffff84010b3e <unmapPageTable+0x94>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
64 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `unmapPageTable` has 94 nodes.

Section handleVMFault (144 of 271)
==================================

Deriving specifications
-----------------------

Section `handleVMFault` consists of 42 instructions.

Skipping 14302773 csrr a4,stval

RVC_FTTFFT___FFFT_FT.

Stack analysis
---------------

1 stack accesses found. Annotated code for `handleVMFault`:

    0x84010a2c     0x0    csrr a4,stval
    0x84010a30     0x4    li a5,15
    0x84010a32     0x6    bltu a5,a1,ffffffff84010a58 <handleVMFault+0x2c>
    0x84010a36     0xa    li a5,1
    0x84010a38     0xc    sll a1,a5,a1
    0x84010a3c    0x10    lui a5,0x1
    0x84010a3e    0x12    addi a5,a5,2
    0x84010a40    0x14    and a5,a5,a1
    0x84010a42    0x16    bnez a5,ffffffff84010a92 <handleVMFault+0x66>
    0x84010a44    0x18    lui a5,0x8
    0x84010a46    0x1a    addi a5,a5,128 # 8080 <KERNEL_OFFSET-0xfffffffeffff7f80>
    0x84010a4a    0x1e    and a5,a5,a1
    0x84010a4c    0x20    bnez a5,ffffffff84010a7a <handleVMFault+0x4e>
    0x84010a4e    0x22    lui a5,0x2
    0x84010a50    0x24    addi a5,a5,32 # 2020 <KERNEL_OFFSET-0xfffffffeffffdfe0>
    0x84010a54    0x28    and a1,a1,a5
    0x84010a56    0x2a    bnez a1,ffffffff84010a60 <handleVMFault+0x34>
    0x84010a58    0x2c    addi sp,sp,-16
    0x84010a5a    0x2e    sd ra,8(sp)           ; stack access
    0x84010a5c    0x30    jal ra,ffffffff8401041e <halt>
    0x84010a60    0x34    auipc a3,0x7
    0x84010a64    0x38    addi a3,a3,1440 # ffffffff84018000 <riscvKSASIDTable>
    0x84010a68    0x3c    lui a5,0x28000
    0x84010a6c    0x40    addi a5,a5,5
    0x84010a6e    0x42    sd a5,1680(a3)
    0x84010a72    0x46    sd a4,1688(a3)
    0x84010a76    0x4a    li a0,1
    0x84010a78    0x4c    ret
    0x84010a7a    0x4e    auipc a3,0x7
    0x84010a7e    0x52    addi a3,a3,1414 # ffffffff84018000 <riscvKSASIDTable>
    0x84010a82    0x56    lui a5,0x38000
    0x84010a86    0x5a    addi a5,a5,5
    0x84010a88    0x5c    sd a5,1680(a3)
    0x84010a8c    0x60    sd a4,1688(a3)
    0x84010a90    0x64    j ffffffff84010a76 <handleVMFault+0x4a>
    0x84010a92    0x66    auipc a3,0x7
    0x84010a96    0x6a    addi a3,a3,1390 # ffffffff84018000 <riscvKSASIDTable>
    0x84010a9a    0x6e    lui a5,0x8080
    0x84010a9e    0x72    addi a5,a5,5
    0x84010aa0    0x74    sd a5,1680(a3)
    0x84010aa4    0x78    sd a4,1688(a3)
    0x84010aa8    0x7c    j ffffffff84010a76 <handleVMFault+0x4a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
42 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleVMFault` has 60 nodes.

Section lookupIPCBuffer (145 of 271)
====================================

Deriving specifications
-----------------------

Section `lookupIPCBuffer` consists of 56 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `lookupIPCBuffer`:

    0x840107e6     0x0    andi a5,a1,-1024
    0x840107ea     0x4    addi a2,a5,128
    0x840107ee     0x8    ld a5,128(a5)
    0x840107f0     0xa    srli a3,a5,0x3b
    0x840107f4     0xe    li a4,1
    0x840107f6    0x10    bne a3,a4,ffffffff8401086a <lookupIPCBuffer+0x84>
    0x840107fa    0x14    srli a4,a5,0x36
    0x840107fe    0x18    andi a4,a4,1
    0x84010800    0x1a    bnez a4,ffffffff8401086e <lookupIPCBuffer+0x88>
    0x84010802    0x1c    srli a4,a5,0x37
    0x84010806    0x20    andi a4,a4,3
    0x84010808    0x22    li a3,3
    0x8401080a    0x24    bne a4,a3,ffffffff84010844 <lookupIPCBuffer+0x5e>
    0x8401080e    0x28    ld a4,8(a2)
    0x84010810    0x2a    srli a4,a4,0x9
    0x84010812    0x2c    slli a0,a4,0x19
    0x84010816    0x30    srli a3,a0,0x19
    0x8401081a    0x34    srli a4,a4,0x26
    0x8401081c    0x36    andi a4,a4,1
    0x8401081e    0x38    beqz a4,ffffffff84010826 <lookupIPCBuffer+0x40>
    0x84010820    0x3a    li a4,-1
    0x84010822    0x3c    slli a4,a4,0x27
    0x84010824    0x3e    or a3,a3,a4
    0x84010826    0x40    ld a4,384(a1)
    0x8401082a    0x44    srli a5,a5,0x39
    0x8401082c    0x46    andi a5,a5,3
    0x8401082e    0x48    li a2,1
    0x84010830    0x4a    beq a5,a2,ffffffff84010850 <lookupIPCBuffer+0x6a>
    0x84010834    0x4e    li a2,2
    0x84010836    0x50    beq a5,a2,ffffffff84010854 <lookupIPCBuffer+0x6e>
    0x8401083a    0x54    beqz a5,ffffffff84010866 <lookupIPCBuffer+0x80>
    0x8401083c    0x56    addi sp,sp,-16
    0x8401083e    0x58    sd ra,8(sp)           ; stack access
    0x84010840    0x5a    jal ra,ffffffff8401041e <halt>
    0x84010844    0x5e    bnez a0,ffffffff84010872 <lookupIPCBuffer+0x8c>
    0x84010846    0x60    li a3,2
    0x84010848    0x62    beq a4,a3,ffffffff8401080e <lookupIPCBuffer+0x28>
    0x8401084c    0x66    li a0,0
    0x8401084e    0x68    ret
    0x84010850    0x6a    li a5,21
    0x84010852    0x6c    j ffffffff84010856 <lookupIPCBuffer+0x70>
    0x84010854    0x6e    li a5,30
    0x84010856    0x70    li a0,-1
    0x84010858    0x72    sll a0,a0,a5
    0x8401085c    0x76    not a0,a0
    0x84010860    0x7a    and a0,a0,a4
    0x84010862    0x7c    add a0,a0,a3
    0x84010864    0x7e    ret
    0x84010866    0x80    li a5,12
    0x84010868    0x82    j ffffffff84010856 <lookupIPCBuffer+0x70>
    0x8401086a    0x84    li a0,0
    0x8401086c    0x86    ret
    0x8401086e    0x88    li a0,0
    0x84010870    0x8a    ret
    0x84010872    0x8c    li a0,0
    0x84010874    0x8e    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
56 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupIPCBuffer` has 84 nodes.

Section Arch_setMRs_fault (146 of 271)
======================================

Deriving specifications
-----------------------

Section `Arch_setMRs_fault` consists of 18 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `Arch_setMRs_fault`:

    0x840106ca     0x0    li a5,5
    0x840106cc     0x2    bne a3,a5,ffffffff840106f4 <Arch_setMRs_fault+0x2a>
    0x840106d0     0x6    ld a5,264(a0)
    0x840106d4     0xa    sd a5,88(a1)
    0x840106d6     0xc    ld a5,320(a0)
    0x840106da    0x10    sd a5,96(a1)
    0x840106dc    0x12    ld a5,312(a0)
    0x840106e0    0x16    srli a5,a5,0x13
    0x840106e2    0x18    andi a5,a5,1
    0x840106e4    0x1a    sd a5,104(a1)
    0x840106e6    0x1c    ld a5,312(a0)
    0x840106ea    0x20    srliw a5,a5,0x1b
    0x840106ee    0x24    sd a5,112(a1)
    0x840106f0    0x26    li a0,4
    0x840106f2    0x28    ret
    0x840106f4    0x2a    addi sp,sp,-16
    0x840106f6    0x2c    sd ra,8(sp)           ; stack access
    0x840106f8    0x2e    jal ra,ffffffff8401041e <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_setMRs_fault` has 31 nodes.

Section Arch_handleFaultReply (147 of 271)
==========================================

Deriving specifications
-----------------------

Section `Arch_handleFaultReply` consists of 7 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `Arch_handleFaultReply`:

    0x840106b8    0x0    li a5,5
    0x840106ba    0x2    bne a2,a5,ffffffff840106c2 <Arch_handleFaultReply+0xa>
    0x840106be    0x6    li a0,1
    0x840106c0    0x8    ret
    0x840106c2    0xa    addi sp,sp,-16
    0x840106c4    0xc    sd ra,8(sp)           ; stack access
    0x840106c6    0xe    jal ra,ffffffff8401041e <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_handleFaultReply` has 12 nodes.

Section setMRs_lookup_failure (148 of 271)
==========================================

Deriving specifications
-----------------------

Section `setMRs_lookup_failure` consists of 238 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `setMRs_lookup_failure`:

    0x8401042a      0x0    addi sp,sp,-32
    0x8401042c      0x2    sd ra,24(sp)          ; stack access
    0x8401042e      0x4    mv a6,a0
    0x84010430      0x6    sd a3,8(sp)           ; stack access
    0x84010432      0x8    andi a5,a2,3
    0x84010436      0xc    addi a7,a5,1
    0x8401043a     0x10    li a3,3
    0x8401043c     0x12    bgeu a3,a4,ffffffff84010496 <setMRs_lookup_failure+0x6c>
    0x84010440     0x16    beqz a1,ffffffff840104ba <setMRs_lookup_failure+0x90>
    0x84010442     0x18    addiw a3,a4,1
    0x84010446     0x1c    sext.w a0,a3
    0x8401044a     0x20    slli a3,a3,0x20
    0x8401044c     0x22    srli a3,a3,0x20
    0x8401044e     0x24    slli a3,a3,0x3
    0x84010450     0x26    add a3,a3,a1
    0x84010452     0x28    sd a7,0(a3)
    0x84010456     0x2c    li a3,2
    0x84010458     0x2e    beq a5,a3,ffffffff840104dc <setMRs_lookup_failure+0xb2>
    0x8401045c     0x32    bltu a3,a5,ffffffff84010554 <setMRs_lookup_failure+0x12a>
    0x84010460     0x36    beqz a5,ffffffff84010490 <setMRs_lookup_failure+0x66>
    0x84010462     0x38    li a3,1
    0x84010464     0x3a    bne a5,a3,ffffffff84010614 <setMRs_lookup_failure+0x1ea>
    0x84010468     0x3e    addiw a5,a4,1
    0x8401046c     0x42    sext.w a0,a5
    0x84010470     0x46    srli a2,a2,0x2
    0x84010472     0x48    andi a2,a2,127
    0x84010476     0x4c    li a3,3
    0x84010478     0x4e    bgeu a3,a0,ffffffff840104be <setMRs_lookup_failure+0x94>
    0x8401047c     0x52    beqz a1,ffffffff84010618 <setMRs_lookup_failure+0x1ee>
    0x84010480     0x56    addiw a4,a4,2
    0x84010482     0x58    sext.w a0,a4
    0x84010486     0x5c    slli a4,a4,0x20
    0x84010488     0x5e    srli a4,a4,0x20
    0x8401048a     0x60    slli a4,a4,0x3
    0x8401048c     0x62    add a1,a1,a4
    0x8401048e     0x64    sd a2,0(a1)
    0x84010490     0x66    ld ra,24(sp)          ; stack access
    0x84010492     0x68    addi sp,sp,32
    0x84010494     0x6a    ret
    0x84010496     0x6c    slli a3,a4,0x20
    0x8401049a     0x70    srli a3,a3,0x20
    0x8401049c     0x72    slli a0,a3,0x3
    0x840104a0     0x76    auipc a3,0x7
    0x840104a4     0x7a    addi a3,a3,184 # ffffffff84017558 <msgRegisters>
    0x840104a8     0x7e    add a3,a3,a0
    0x840104aa     0x80    ld a3,0(a3)
    0x840104ac     0x82    slli a3,a3,0x3
    0x840104ae     0x84    add a3,a3,a6
    0x840104b0     0x86    sd a7,0(a3)
    0x840104b4     0x8a    addiw a0,a4,1
    0x840104b8     0x8e    j ffffffff84010456 <setMRs_lookup_failure+0x2c>
    0x840104ba     0x90    li a0,4
    0x840104bc     0x92    j ffffffff84010456 <setMRs_lookup_failure+0x2c>
    0x840104be     0x94    slli a5,a5,0x20
    0x840104c0     0x96    srli a5,a5,0x20
    0x840104c2     0x98    slli a5,a5,0x3
    0x840104c4     0x9a    auipc a3,0x7
    0x840104c8     0x9e    addi a3,a3,148 # ffffffff84017558 <msgRegisters>
    0x840104cc     0xa2    add a5,a5,a3
    0x840104ce     0xa4    ld a0,0(a5)
    0x840104d0     0xa6    slli a0,a0,0x3
    0x840104d2     0xa8    add a0,a0,a6
    0x840104d4     0xaa    sd a2,0(a0)
    0x840104d6     0xac    addiw a0,a4,2
    0x840104da     0xb0    j ffffffff84010490 <setMRs_lookup_failure+0x66>
    0x840104dc     0xb2    addiw a0,a4,1
    0x840104e0     0xb6    sext.w a7,a0
    0x840104e4     0xba    srli a5,a2,0x2
    0x840104e8     0xbe    andi a3,a5,127
    0x840104ec     0xc2    li a5,3
    0x840104ee     0xc4    bgeu a5,a7,ffffffff84010526 <setMRs_lookup_failure+0xfc>
    0x840104f2     0xc8    beqz a1,ffffffff8401061c <setMRs_lookup_failure+0x1f2>
    0x840104f6     0xcc    addiw a5,a4,2
    0x840104fa     0xd0    sext.w a7,a5
    0x840104fe     0xd4    slli a5,a5,0x20
    0x84010500     0xd6    srli a5,a5,0x20
    0x84010502     0xd8    slli a5,a5,0x3
    0x84010504     0xda    add a5,a5,a1
    0x84010506     0xdc    sd a3,0(a5)
    0x84010508     0xde    srli a2,a2,0x9
    0x8401050a     0xe0    andi a2,a2,127
    0x8401050e     0xe4    li a5,3
    0x84010510     0xe6    bgeu a5,a7,ffffffff8401062e <setMRs_lookup_failure+0x204>
    0x84010514     0xea    addiw a4,a4,3
    0x84010516     0xec    sext.w a0,a4
    0x8401051a     0xf0    slli a4,a4,0x20
    0x8401051c     0xf2    srli a4,a4,0x20
    0x8401051e     0xf4    slli a4,a4,0x3
    0x84010520     0xf6    add a1,a1,a4
    0x84010522     0xf8    sd a2,0(a1)
    0x84010524     0xfa    j ffffffff84010490 <setMRs_lookup_failure+0x66>
    0x84010526     0xfc    slli a0,a0,0x20
    0x84010528     0xfe    srli a0,a0,0x20
    0x8401052a    0x100    slli a0,a0,0x3
    0x8401052c    0x102    auipc a5,0x7
    0x84010530    0x106    addi a5,a5,44 # ffffffff84017558 <msgRegisters>
    0x84010534    0x10a    add a0,a0,a5
    0x84010536    0x10c    ld a5,0(a0)
    0x84010538    0x10e    slli a5,a5,0x3
    0x8401053a    0x110    add a5,a5,a6
    0x8401053c    0x112    sd a3,0(a5)
    0x8401053e    0x114    addiw a7,a4,2
    0x84010542    0x118    srli a2,a2,0x9
    0x84010544    0x11a    andi a2,a2,127
    0x84010548    0x11e    li a5,3
    0x8401054a    0x120    bgeu a5,a7,ffffffff8401062e <setMRs_lookup_failure+0x204>
    0x8401054e    0x124    bnez a1,ffffffff84010514 <setMRs_lookup_failure+0xea>
    0x84010550    0x126    li a0,4
    0x84010552    0x128    j ffffffff84010490 <setMRs_lookup_failure+0x66>
    0x84010554    0x12a    addiw a3,a4,1
    0x84010558    0x12e    sext.w a7,a3
    0x8401055c    0x132    srli a5,a2,0x9
    0x84010560    0x136    andi a5,a5,127
    0x84010564    0x13a    li a0,3
    0x84010566    0x13c    bgeu a0,a7,ffffffff840105bc <setMRs_lookup_failure+0x192>
    0x8401056a    0x140    beqz a1,ffffffff84010698 <setMRs_lookup_failure+0x26e>
    0x8401056e    0x144    addiw a0,a4,2
    0x84010572    0x148    sext.w t1,a0
    0x84010576    0x14c    slli a3,a0,0x20
    0x8401057a    0x150    srli a3,a3,0x20
    0x8401057c    0x152    slli a3,a3,0x3
    0x8401057e    0x154    add a3,a3,a1
    0x84010580    0x156    sd a5,0(a3)
    0x84010582    0x158    ld a7,8(sp)           ; stack access
    0x84010584    0x15a    li a5,3
    0x84010586    0x15c    bgeu a5,t1,ffffffff84010650 <setMRs_lookup_failure+0x226>
    0x8401058a    0x160    addiw a5,a4,3
    0x8401058e    0x164    sext.w a3,a5
    0x84010592    0x168    slli a5,a5,0x20
    0x84010594    0x16a    srli a5,a5,0x20
    0x84010596    0x16c    slli a5,a5,0x3
    0x84010598    0x16e    add a5,a5,a1
    0x8401059a    0x170    sd a7,0(a5)
    0x8401059e    0x174    srli a2,a2,0x2
    0x840105a0    0x176    andi a2,a2,127
    0x840105a4    0x17a    li a5,3
    0x840105a6    0x17c    bgeu a5,a3,ffffffff8401067a <setMRs_lookup_failure+0x250>
    0x840105aa    0x180    addiw a4,a4,4
    0x840105ac    0x182    sext.w a0,a4
    0x840105b0    0x186    slli a4,a4,0x20
    0x840105b2    0x188    srli a4,a4,0x20
    0x840105b4    0x18a    slli a4,a4,0x3
    0x840105b6    0x18c    add a1,a1,a4
    0x840105b8    0x18e    sd a2,0(a1)
    0x840105ba    0x190    j ffffffff84010490 <setMRs_lookup_failure+0x66>
    0x840105bc    0x192    slli a3,a3,0x20
    0x840105be    0x194    srli a3,a3,0x20
    0x840105c0    0x196    slli a3,a3,0x3
    0x840105c2    0x198    auipc a0,0x7
    0x840105c6    0x19c    addi a0,a0,-106 # ffffffff84017558 <msgRegisters>
    0x840105ca    0x1a0    add a3,a3,a0
    0x840105cc    0x1a2    ld a3,0(a3)
    0x840105ce    0x1a4    slli a3,a3,0x3
    0x840105d0    0x1a6    add a3,a3,a6
    0x840105d2    0x1a8    sd a5,0(a3)
    0x840105d4    0x1aa    addiw a5,a4,2
    0x840105d8    0x1ae    ld a7,8(sp)           ; stack access
    0x840105da    0x1b0    li a3,3
    0x840105dc    0x1b2    bgeu a3,a5,ffffffff840105e4 <setMRs_lookup_failure+0x1ba>
    0x840105e0    0x1b6    bnez a1,ffffffff8401058a <setMRs_lookup_failure+0x160>
    0x840105e2    0x1b8    j ffffffff840106a4 <setMRs_lookup_failure+0x27a>
    0x840105e4    0x1ba    slli a5,a5,0x20
    0x840105e6    0x1bc    srli a5,a5,0x20
    0x840105e8    0x1be    slli a5,a5,0x3
    0x840105ea    0x1c0    auipc a3,0x7
    0x840105ee    0x1c4    addi a3,a3,-146 # ffffffff84017558 <msgRegisters>
    0x840105f2    0x1c8    add a5,a5,a3
    0x840105f4    0x1ca    ld a5,0(a5)
    0x840105f6    0x1cc    slli a5,a5,0x3
    0x840105f8    0x1ce    add a5,a5,a6
    0x840105fa    0x1d0    sd a7,0(a5)
    0x840105fe    0x1d4    addiw a3,a4,3
    0x84010602    0x1d8    srli a2,a2,0x2
    0x84010604    0x1da    andi a2,a2,127
    0x84010608    0x1de    li a5,3
    0x8401060a    0x1e0    bgeu a5,a3,ffffffff8401067a <setMRs_lookup_failure+0x250>
    0x8401060e    0x1e4    li a0,4
    0x84010610    0x1e6    bnez a1,ffffffff840105aa <setMRs_lookup_failure+0x180>
    0x84010612    0x1e8    j ffffffff84010490 <setMRs_lookup_failure+0x66>
    0x84010614    0x1ea    jal ra,ffffffff8401041e <halt>
    0x84010618    0x1ee    li a0,4
    0x8401061a    0x1f0    j ffffffff84010490 <setMRs_lookup_failure+0x66>
    0x8401061c    0x1f2    addiw a7,a4,2
    0x84010620    0x1f6    li a5,3
    0x84010622    0x1f8    li a0,4
    0x84010624    0x1fa    srli a2,a2,0x9
    0x84010626    0x1fc    andi a2,a2,127
    0x8401062a    0x200    bltu a5,a7,ffffffff84010490 <setMRs_lookup_failure+0x66>
    0x8401062e    0x204    slli a7,a7,0x20
    0x84010630    0x206    srli a7,a7,0x20
    0x84010634    0x20a    slli a7,a7,0x3
    0x84010636    0x20c    auipc a5,0x7
    0x8401063a    0x210    addi a5,a5,-222 # ffffffff84017558 <msgRegisters>
    0x8401063e    0x214    add a7,a7,a5
    0x84010640    0x216    ld a0,0(a7)
    0x84010644    0x21a    slli a0,a0,0x3
    0x84010646    0x21c    add a0,a0,a6
    0x84010648    0x21e    sd a2,0(a0)
    0x8401064a    0x220    addiw a0,a4,3
    0x8401064e    0x224    j ffffffff84010490 <setMRs_lookup_failure+0x66>
    0x84010650    0x226    slli a0,a0,0x20
    0x84010652    0x228    srli a0,a0,0x20
    0x84010654    0x22a    slli a0,a0,0x3
    0x84010656    0x22c    auipc a5,0x7
    0x8401065a    0x230    addi a5,a5,-254 # ffffffff84017558 <msgRegisters>
    0x8401065e    0x234    add a0,a0,a5
    0x84010660    0x236    ld a5,0(a0)
    0x84010662    0x238    slli a5,a5,0x3
    0x84010664    0x23a    add a5,a5,a6
    0x84010666    0x23c    sd a7,0(a5)
    0x8401066a    0x240    addiw a3,a4,3
    0x8401066e    0x244    srli a2,a2,0x2
    0x84010670    0x246    andi a2,a2,127
    0x84010674    0x24a    li a5,3
    0x84010676    0x24c    bltu a5,a3,ffffffff840105aa <setMRs_lookup_failure+0x180>
    0x8401067a    0x250    slli a3,a3,0x20
    0x8401067c    0x252    srli a3,a3,0x20
    0x8401067e    0x254    slli a3,a3,0x3
    0x84010680    0x256    auipc a5,0x7
    0x84010684    0x25a    addi a5,a5,-296 # ffffffff84017558 <msgRegisters>
    0x84010688    0x25e    add a3,a3,a5
    0x8401068a    0x260    ld a0,0(a3)
    0x8401068c    0x262    slli a0,a0,0x3
    0x8401068e    0x264    add a0,a0,a6
    0x84010690    0x266    sd a2,0(a0)
    0x84010692    0x268    addiw a0,a4,4
    0x84010696    0x26c    j ffffffff84010490 <setMRs_lookup_failure+0x66>
    0x84010698    0x26e    addiw a5,a4,2
    0x8401069c    0x272    ld a7,8(sp)           ; stack access
    0x8401069e    0x274    li a3,3
    0x840106a0    0x276    bgeu a3,a5,ffffffff840105e4 <setMRs_lookup_failure+0x1ba>
    0x840106a4    0x27a    addiw a3,a4,3
    0x840106a8    0x27e    li a5,3
    0x840106aa    0x280    li a0,4
    0x840106ac    0x282    srli a2,a2,0x2
    0x840106ae    0x284    andi a2,a2,127
    0x840106b2    0x288    bltu a5,a3,ffffffff84010490 <setMRs_lookup_failure+0x66>
    0x840106b6    0x28c    j ffffffff8401067a <setMRs_lookup_failure+0x250>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
238 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setMRs_lookup_failure` has 319 nodes.

Section isHighestPrio (149 of 271)
==================================

Deriving specifications
-----------------------

Section `isHighestPrio` consists of 40 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `isHighestPrio`:

    0x8401030c     0x0    addi sp,sp,-32
    0x8401030e     0x2    sd ra,24(sp)          ; stack access
    0x84010310     0x4    sd s0,16(sp)          ; stack access
    0x84010312     0x6    sd s1,8(sp)           ; stack access
    0x84010314     0x8    sd s2,0(sp)           ; stack access
    0x84010316     0xa    mv s0,a0
    0x84010318     0xc    slli a4,a0,0x3
    0x8401031c    0x10    auipc a5,0x8
    0x84010320    0x14    addi a5,a5,-796 # ffffffff84018000 <riscvKSASIDTable>
    0x84010324    0x18    add a5,a5,a4
    0x84010326    0x1a    ld a0,1040(a5)
    0x8401032a    0x1e    beqz a0,ffffffff84010378 <isHighestPrio+0x6c>
    0x8401032c    0x20    mv s1,a1
    0x8401032e    0x22    jal ra,ffffffff840100cc <clzl>
    0x84010332    0x26    mv s2,a0
    0x84010334    0x28    slli s0,s0,0x2
    0x84010336    0x2a    addi a0,a0,-60 # fffffffff7ffffc4 <ki_end+0x73fd0fc4>
    0x8401033a    0x2e    add s0,s0,a0
    0x8401033c    0x30    slli s0,s0,0x3
    0x8401033e    0x32    auipc a5,0x8
    0x84010342    0x36    addi a5,a5,-830 # ffffffff84018000 <riscvKSASIDTable>
    0x84010346    0x3a    add s0,s0,a5
    0x84010348    0x3c    ld a0,1168(s0) # 1490 <KERNEL_OFFSET-0xfffffffeffffeb70>
    0x8401034c    0x40    jal ra,ffffffff840100cc <clzl>
    0x84010350    0x44    li a5,63
    0x84010354    0x48    sub s2,a5,s2
    0x84010358    0x4c    slli s2,s2,0x6
    0x8401035a    0x4e    sub a0,a5,a0
    0x8401035e    0x52    or a0,s2,a0
    0x84010362    0x56    sltu a0,s1,a0
    0x84010366    0x5a    xori a0,a0,1
    0x8401036a    0x5e    sext.w a0,a0
    0x8401036c    0x60    ld ra,24(sp)          ; stack access
    0x8401036e    0x62    ld s0,16(sp)          ; stack access
    0x84010370    0x64    ld s1,8(sp)           ; stack access
    0x84010372    0x66    ld s2,0(sp)           ; stack access
    0x84010374    0x68    addi sp,sp,32
    0x84010376    0x6a    ret
    0x84010378    0x6c    li a0,1
    0x8401037a    0x6e    j ffffffff8401036c <isHighestPrio+0x60>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
40 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isHighestPrio` has 55 nodes.

Section interrupt (150 of 271)
==============================

Deriving specifications
-----------------------

Section `interrupt` consists of 2 instructions.

JAL_NOP.

Stack analysis
---------------

No stack accesses found. Code for `interrupt`:

    0x840100c4    0x0    sd ra,272(t0)
    0x840100c8    0x4    j ffffffff84013e6e <c_handle_interrupt>

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `interrupt` has 4 nodes.

Section exception (151 of 271)
==============================

Deriving specifications
-----------------------

Section `exception` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `exception`:

    0x840100bc    0x0    sd ra,272(t0)
    0x840100c0    0x4    j ffffffff840145d8 <c_handle_exception>

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `exception` has 4 nodes.

Section syscall (152 of 271)
============================

Deriving specifications
-----------------------

Section `syscall` consists of 3 instructions.

RVC_FFFFFFFFT_____FT.

Stack analysis
---------------

No stack accesses found. Code for `syscall`:

    0x840100b2    0x0    addi ra,ra,4
    0x840100b4    0x2    sd ra,272(t0)
    0x840100b8    0x6    j ffffffff84017384 <c_handle_syscall>

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `syscall` has 5 nodes.

Section maybe_alloc_extra_bi (153 of 271)
=========================================

Deriving specifications
-----------------------

Section `maybe_alloc_extra_bi` consists of 16 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `maybe_alloc_extra_bi`:

    0x84000e50     0x0    bltu a1,a0,ffffffff84000e60 <maybe_alloc_extra_bi+0x10>
    0x84000e54     0x4    mv a5,a1
    0x84000e56     0x6    auipc a4,0x1
    0x84000e5a     0xa    ld a4,-1702(a4) # ffffffff840017b0 <rootserver+0x28>
    0x84000e5e     0xe    beqz a4,ffffffff84000e62 <maybe_alloc_extra_bi+0x12>
    0x84000e60    0x10    ret
    0x84000e62    0x12    addi sp,sp,-16
    0x84000e64    0x14    sd ra,8(sp)           ; stack access
    0x84000e66    0x16    li a1,1
    0x84000e68    0x18    mv a0,a5
    0x84000e6a    0x1a    jal ra,ffffffff84000e22 <alloc_rootserver_obj>
    0x84000e6e    0x1e    auipc a5,0x1
    0x84000e72    0x22    sd a0,-1726(a5) # ffffffff840017b0 <rootserver+0x28>
    0x84000e76    0x26    ld ra,8(sp)           ; stack access
    0x84000e78    0x28    addi sp,sp,16
    0x84000e7a    0x2a    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `maybe_alloc_extra_bi` has 27 nodes.

Section alloc_rootserver_obj (154 of 271)
=========================================

Deriving specifications
-----------------------

Section `alloc_rootserver_obj` consists of 16 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `alloc_rootserver_obj`:

    0x84000e22     0x0    addi sp,sp,-16
    0x84000e24     0x2    sd ra,8(sp)           ; stack access
    0x84000e26     0x4    sd s0,0(sp)           ; stack access
    0x84000e28     0x6    auipc a5,0x0
    0x84000e2c     0xa    addi a5,a5,1792 # ffffffff84001528 <ndks_boot>
    0x84000e30     0xe    ld s0,680(a5)
    0x84000e34    0x12    sll a1,a1,a0
    0x84000e38    0x16    add a4,a1,s0
    0x84000e3c    0x1a    sd a4,680(a5)
    0x84000e40    0x1e    mv a0,s0
    0x84000e42    0x20    jal ra,ffffffff84015b8a <memzero>
    0x84000e46    0x24    mv a0,s0
    0x84000e48    0x26    ld ra,8(sp)           ; stack access
    0x84000e4a    0x28    ld s0,0(sp)           ; stack access
    0x84000e4c    0x2a    addi sp,sp,16
    0x84000e4e    0x2c    ret

Proving inst theorems
---------------------

16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `alloc_rootserver_obj` has 24 nodes.

Section create_idle_thread (155 of 271)
=======================================

Deriving specifications
-----------------------

Section `create_idle_thread` consists of 11 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `create_idle_thread`:

    0x84000cfe     0x0    addi sp,sp,-16
    0x84000d00     0x2    sd ra,8(sp)           ; stack access
    0x84000d02     0x4    auipc a0,0x17
    0x84000d06     0x8    addi a0,a0,-770 # ffffffff84017a00 <ksIdleThreadTCB+0x200>
    0x84000d0a     0xc    auipc a5,0x2a
    0x84000d0e    0x10    sd a0,-1242(a5) # ffffffff8402a830 <ksIdleThread>
    0x84000d12    0x14    jal ra,ffffffff84000cd0 <configureIdleThread>
    0x84000d16    0x18    li a0,1
    0x84000d18    0x1a    ld ra,8(sp)           ; stack access
    0x84000d1a    0x1c    addi sp,sp,16
    0x84000d1c    0x1e    ret

Proving inst theorems
---------------------

11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_idle_thread` has 16 nodes.

Section configureIdleThread (156 of 271)
========================================

Deriving specifications
-----------------------

Section `configureIdleThread` consists of 15 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `configureIdleThread`:

    0x84000cd0     0x0    addi sp,sp,-16
    0x84000cd2     0x2    sd ra,8(sp)           ; stack access
    0x84000cd4     0x4    auipc a4,0xf
    0x84000cd8     0x8    addi a4,a4,1094 # ffffffff8401011a <idle_thread>
    0x84000cdc     0xc    sd a4,272(a0)
    0x84000ce0    0x10    li a4,288
    0x84000ce4    0x14    sd a4,256(a0)
    0x84000ce8    0x18    auipc a4,0x2a
    0x84000cec    0x1c    addi a4,a4,-1256 # ffffffff8402a800 <tlbLockCount>
    0x84000cf0    0x20    sd a4,8(a0)
    0x84000cf2    0x22    li a1,7
    0x84000cf4    0x24    jal ra,ffffffff8401263a <setThreadState>
    0x84000cf8    0x28    ld ra,8(sp)           ; stack access
    0x84000cfa    0x2a    addi sp,sp,16
    0x84000cfc    0x2c    ret

Proving inst theorems
---------------------

15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `configureIdleThread` has 22 nodes.

Section create_kernel_untypeds (157 of 271)
===========================================

Deriving specifications
-----------------------

Section `create_kernel_untypeds` consists of 38 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `create_kernel_untypeds`:

    0x84000b26     0x0    addi sp,sp,-80
    0x84000b28     0x2    sd ra,72(sp)          ; stack access
    0x84000b2a     0x4    sd s0,64(sp)          ; stack access
    0x84000b2c     0x6    sd s1,56(sp)          ; stack access
    0x84000b2e     0x8    sd s2,48(sp)          ; stack access
    0x84000b30     0xa    sd a0,16(sp)          ; stack access
    0x84000b32     0xc    sd a1,24(sp)          ; stack access
    0x84000b34     0xe    mv a6,a3
    0x84000b36    0x10    mv s1,a4
    0x84000b38    0x12    mv a5,a4
    0x84000b3a    0x14    mv a3,a2
    0x84000b3c    0x16    mv a4,a6
    0x84000b3e    0x18    li a2,0
    0x84000b40    0x1a    jal ra,ffffffff84000974 <create_untypeds_for_region>
    0x84000b44    0x1e    beqz a0,ffffffff84000b78 <create_kernel_untypeds+0x52>
    0x84000b46    0x20    auipc s0,0x1
    0x84000b4a    0x24    addi s0,s0,-1238 # ffffffff84001670 <ndks_boot+0x148>
    0x84000b4e    0x28    auipc s2,0x1
    0x84000b52    0x2c    addi s2,s2,-990 # ffffffff84001770 <ndks_boot+0x248>
    0x84000b56    0x30    ld a3,0(s0)
    0x84000b58    0x32    ld a4,8(s0)
    0x84000b5a    0x34    sd zero,0(s0)
    0x84000b5e    0x38    sd zero,8(s0)
    0x84000b62    0x3c    mv a5,s1
    0x84000b64    0x3e    li a2,0
    0x84000b66    0x40    ld a0,16(sp)          ; stack access
    0x84000b68    0x42    ld a1,24(sp)          ; stack access
    0x84000b6a    0x44    jal ra,ffffffff84000974 <create_untypeds_for_region>
    0x84000b6e    0x48    beqz a0,ffffffff84000b78 <create_kernel_untypeds+0x52>
    0x84000b70    0x4a    addi s0,s0,16
    0x84000b72    0x4c    bne s0,s2,ffffffff84000b56 <create_kernel_untypeds+0x30>
    0x84000b76    0x50    li a0,1
    0x84000b78    0x52    ld ra,72(sp)          ; stack access
    0x84000b7a    0x54    ld s0,64(sp)          ; stack access
    0x84000b7c    0x56    ld s1,56(sp)          ; stack access
    0x84000b7e    0x58    ld s2,48(sp)          ; stack access
    0x84000b80    0x5a    addi sp,sp,80
    0x84000b82    0x5c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
38 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_kernel_untypeds` has 63 nodes.

Section create_device_untypeds (158 of 271)
===========================================

Deriving specifications
-----------------------

Section `create_device_untypeds` consists of 68 instructions.


Stack analysis
---------------

24 stack accesses found. Annotated code for `create_device_untypeds`:

    0x84000a84     0x0    addi sp,sp,-96
    0x84000a86     0x2    sd ra,88(sp)          ; stack access
    0x84000a88     0x4    sd s0,80(sp)          ; stack access
    0x84000a8a     0x6    sd s1,72(sp)          ; stack access
    0x84000a8c     0x8    sd s2,64(sp)          ; stack access
    0x84000a8e     0xa    sd s3,56(sp)          ; stack access
    0x84000a90     0xc    sd s4,48(sp)          ; stack access
    0x84000a92     0xe    sd s5,40(sp)          ; stack access
    0x84000a94    0x10    sd a0,0(sp)           ; stack access
    0x84000a96    0x12    sd a1,8(sp)           ; stack access
    0x84000a98    0x14    mv s4,a2
    0x84000a9a    0x16    auipc a3,0x1
    0x84000a9e    0x1a    ld a3,-1074(a3) # ffffffff84001668 <ndks_boot+0x140>
    0x84000aa2    0x1e    beqz a3,ffffffff84000b06 <create_device_untypeds+0x82>
    0x84000aa4    0x20    auipc s0,0x1
    0x84000aa8    0x24    addi s0,s0,-1404 # ffffffff84001528 <ndks_boot>
    0x84000aac    0x28    li s1,0
    0x84000aae    0x2a    li a3,0
    0x84000ab0    0x2c    li s5,-1
    0x84000ab2    0x2e    slli s5,s5,0x26
    0x84000ab4    0x30    mv s3,s0
    0x84000ab6    0x32    j ffffffff84000ac8 <create_device_untypeds+0x44>
    0x84000ab8    0x34    ld a3,8(s2)
    0x84000abc    0x38    addi s1,s1,1
    0x84000abe    0x3a    addi s0,s0,16
    0x84000ac0    0x3c    ld a4,320(s3)
    0x84000ac4    0x40    bgeu s1,a4,ffffffff84000ae8 <create_device_untypeds+0x64>
    0x84000ac8    0x44    mv s2,s0
    0x84000aca    0x46    ld a4,0(s0)
    0x84000acc    0x48    bgeu a3,a4,ffffffff84000ab8 <create_device_untypeds+0x34>
    0x84000ad0    0x4c    add a3,a3,s5
    0x84000ad2    0x4e    sd a3,16(sp)          ; stack access
    0x84000ad4    0x50    add a4,a4,s5
    0x84000ad6    0x52    sd a4,24(sp)          ; stack access
    0x84000ad8    0x54    mv a5,s4
    0x84000ada    0x56    li a2,1
    0x84000adc    0x58    ld a0,0(sp)           ; stack access
    0x84000ade    0x5a    ld a1,8(sp)           ; stack access
    0x84000ae0    0x5c    jal ra,ffffffff84000974 <create_untypeds_for_region>
    0x84000ae4    0x60    bnez a0,ffffffff84000ab8 <create_device_untypeds+0x34>
    0x84000ae6    0x62    j ffffffff84000af4 <create_device_untypeds+0x70>
    0x84000ae8    0x64    lui a5,0xfc000
    0x84000aec    0x68    srli a5,a5,0x19
    0x84000aee    0x6a    li a0,1
    0x84000af0    0x6c    bgeu a5,a3,ffffffff84000b06 <create_device_untypeds+0x82>
    0x84000af4    0x70    ld ra,88(sp)          ; stack access
    0x84000af6    0x72    ld s0,80(sp)          ; stack access
    0x84000af8    0x74    ld s1,72(sp)          ; stack access
    0x84000afa    0x76    ld s2,64(sp)          ; stack access
    0x84000afc    0x78    ld s3,56(sp)          ; stack access
    0x84000afe    0x7a    ld s4,48(sp)          ; stack access
    0x84000b00    0x7c    ld s5,40(sp)          ; stack access
    0x84000b02    0x7e    addi sp,sp,96
    0x84000b04    0x80    ret
    0x84000b06    0x82    li a4,-1
    0x84000b08    0x84    slli a5,a4,0x26
    0x84000b0c    0x88    add a3,a3,a5
    0x84000b0e    0x8a    sd a3,16(sp)          ; stack access
    0x84000b10    0x8c    srli a4,a4,0x1a
    0x84000b12    0x8e    sd a4,24(sp)          ; stack access
    0x84000b14    0x90    mv a5,s4
    0x84000b16    0x92    li a2,1
    0x84000b18    0x94    ld a0,0(sp)           ; stack access
    0x84000b1a    0x96    ld a1,8(sp)           ; stack access
    0x84000b1c    0x98    jal ra,ffffffff84000974 <create_untypeds_for_region>
    0x84000b20    0x9c    beqz a0,ffffffff84000af4 <create_device_untypeds+0x70>
    0x84000b22    0x9e    li a0,1
    0x84000b24    0xa0    j ffffffff84000af4 <create_device_untypeds+0x70>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
68 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_device_untypeds` has 111 nodes.

Section create_it_asid_pool (159 of 271)
========================================

Deriving specifications
-----------------------

Section `create_it_asid_pool` consists of 39 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `create_it_asid_pool`:

    0x840008f8     0x0    addi sp,sp,-80
    0x840008fa     0x2    sd ra,72(sp)          ; stack access
    0x840008fc     0x4    sd s0,64(sp)          ; stack access
    0x840008fe     0x6    sd s1,56(sp)          ; stack access
    0x84000900     0x8    sd s2,48(sp)          ; stack access
    0x84000902     0xa    sd s3,40(sp)          ; stack access
    0x84000904     0xc    mv s2,a0
    0x84000906     0xe    mv s1,a1
    0x84000908    0x10    auipc s0,0x1
    0x8400090c    0x14    ld s0,-368(s0) # ffffffff84001798 <rootserver+0x10>
    0x84000910    0x18    slli s0,s0,0x19
    0x84000912    0x1a    srli s0,s0,0x1b
    0x84000914    0x1c    li a5,13
    0x84000916    0x1e    slli a5,a5,0x3b
    0x84000918    0x20    or s0,s0,a5
    0x8400091a    0x22    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x8400091e    0x26    sd s0,192(a0)
    0x84000920    0x28    sd zero,200(a0)
    0x84000924    0x2c    sd zero,208(a0)
    0x84000928    0x30    li s3,3
    0x8400092a    0x32    sd s3,216(a0)
    0x8400092e    0x36    mv a0,s2
    0x84000930    0x38    mv a1,s1
    0x84000932    0x3a    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x84000936    0x3e    li a5,11
    0x84000938    0x40    slli a5,a5,0x3b
    0x8400093a    0x42    sd a5,160(a0)
    0x8400093c    0x44    sd zero,168(a0)
    0x84000940    0x48    sd zero,176(a0)
    0x84000944    0x4c    sd s3,184(a0)
    0x84000948    0x50    mv a0,s0
    0x8400094a    0x52    li a1,0
    0x8400094c    0x54    ld ra,72(sp)          ; stack access
    0x8400094e    0x56    ld s0,64(sp)          ; stack access
    0x84000950    0x58    ld s1,56(sp)          ; stack access
    0x84000952    0x5a    ld s2,48(sp)          ; stack access
    0x84000954    0x5c    ld s3,40(sp)          ; stack access
    0x84000956    0x5e    addi sp,sp,80
    0x84000958    0x60    ret

Proving inst theorems
---------------------

39 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_it_asid_pool` has 61 nodes.

Section provide_cap (160 of 271)
================================

Deriving specifications
-----------------------

Section `provide_cap` consists of 34 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `provide_cap`:

    0x84000688     0x0    addi sp,sp,-48
    0x8400068a     0x2    sd ra,40(sp)          ; stack access
    0x8400068c     0x4    sd s0,32(sp)          ; stack access
    0x8400068e     0x6    sd a0,16(sp)          ; stack access
    0x84000690     0x8    sd a1,24(sp)          ; stack access
    0x84000692     0xa    sd a2,0(sp)           ; stack access
    0x84000694     0xc    sd a3,8(sp)           ; stack access
    0x84000696     0xe    auipc a5,0x1
    0x8400069a    0x12    addi a5,a5,-366 # ffffffff84001528 <ndks_boot>
    0x8400069e    0x16    ld s0,592(a5)
    0x840006a2    0x1a    ld a5,600(a5)
    0x840006a6    0x1e    bltu s0,a5,ffffffff840006b4 <provide_cap+0x2c>
    0x840006aa    0x22    li a0,0
    0x840006ac    0x24    ld ra,40(sp)          ; stack access
    0x840006ae    0x26    ld s0,32(sp)          ; stack access
    0x840006b0    0x28    addi sp,sp,48
    0x840006b2    0x2a    ret
    0x840006b4    0x2c    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x840006b8    0x30    slli s0,s0,0x5
    0x840006ba    0x32    add s0,s0,a0
    0x840006bc    0x34    ld a5,0(sp)           ; stack access
    0x840006be    0x36    sd a5,0(s0)
    0x840006c0    0x38    ld a5,8(sp)           ; stack access
    0x840006c2    0x3a    sd a5,8(s0)
    0x840006c4    0x3c    sd zero,16(s0)
    0x840006c8    0x40    li a5,3
    0x840006ca    0x42    sd a5,24(s0)
    0x840006cc    0x44    auipc a4,0x1
    0x840006d0    0x48    addi a4,a4,-420 # ffffffff84001528 <ndks_boot>
    0x840006d4    0x4c    ld a5,592(a4)
    0x840006d8    0x50    addi a5,a5,1
    0x840006da    0x52    sd a5,592(a4)
    0x840006de    0x56    li a0,1
    0x840006e0    0x58    j ffffffff840006ac <provide_cap+0x24>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
34 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `provide_cap` has 56 nodes.

Section calculate_extra_bi_size_bits (161 of 271)
=================================================

Deriving specifications
-----------------------

Section `calculate_extra_bi_size_bits` consists of 22 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `calculate_extra_bi_size_bits`:

    0x8400064e     0x0    addi sp,sp,-16
    0x84000650     0x2    sd ra,8(sp)           ; stack access
    0x84000652     0x4    sd s0,0(sp)           ; stack access
    0x84000654     0x6    mv s0,a0
    0x84000656     0x8    beqz a0,ffffffff84000680 <calculate_extra_bi_size_bits+0x32>
    0x84000658     0xa    addi a0,a0,-1
    0x8400065a     0xc    srli a0,a0,0xc
    0x8400065c     0xe    addi a0,a0,1
    0x8400065e    0x10    slli a0,a0,0xc
    0x84000660    0x12    jal ra,ffffffff840100cc <clzl>
    0x84000664    0x16    mv a4,a0
    0x84000666    0x18    li a5,63
    0x8400066a    0x1c    sub a0,a5,a0
    0x8400066e    0x20    li a5,1
    0x84000670    0x22    sll a5,a5,a0
    0x84000674    0x26    bgeu a5,s0,ffffffff84000680 <calculate_extra_bi_size_bits+0x32>
    0x84000678    0x2a    li a5,64
    0x8400067c    0x2e    sub a0,a5,a4
    0x84000680    0x32    ld ra,8(sp)           ; stack access
    0x84000682    0x34    ld s0,0(sp)           ; stack access
    0x84000684    0x36    addi sp,sp,16
    0x84000686    0x38    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `calculate_extra_bi_size_bits` has 32 nodes.

Section create_domain_cap (162 of 271)
======================================

Deriving specifications
-----------------------

Section `create_domain_cap` consists of 13 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `create_domain_cap`:

    0x840005de     0x0    addi sp,sp,-32
    0x840005e0     0x2    sd ra,24(sp)          ; stack access
    0x840005e2     0x4    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x840005e6     0x8    li a5,-3
    0x840005e8     0xa    slli a5,a5,0x3d
    0x840005ea     0xc    sd a5,352(a0)
    0x840005ee    0x10    sd zero,360(a0)
    0x840005f2    0x14    sd zero,368(a0)
    0x840005f6    0x18    li a5,3
    0x840005f8    0x1a    sd a5,376(a0)
    0x840005fc    0x1e    ld ra,24(sp)          ; stack access
    0x840005fe    0x20    addi sp,sp,32
    0x84000600    0x22    ret

Proving inst theorems
---------------------

13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_domain_cap` has 21 nodes.

Section insert_region (163 of 271)
==================================

Deriving specifications
-----------------------

Section `insert_region` consists of 39 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `insert_region`:

    0x84000532     0x0    addi sp,sp,-48
    0x84000534     0x2    sd ra,40(sp)          ; stack access
    0x84000536     0x4    sd s0,32(sp)          ; stack access
    0x84000538     0x6    sd a0,0(sp)           ; stack access
    0x8400053a     0x8    sd a1,8(sp)           ; stack access
    0x8400053c     0xa    beq a1,a0,ffffffff8400058c <insert_region+0x5a>
    0x84000540     0xe    auipc a5,0x1
    0x84000544    0x12    addi a5,a5,304 # ffffffff84001670 <ndks_boot+0x148>
    0x84000548    0x16    li s0,0
    0x8400054a    0x18    li a2,16
    0x8400054c    0x1a    ld a3,0(a5)
    0x8400054e    0x1c    ld a4,8(a5)
    0x84000550    0x1e    beq a3,a4,ffffffff84000566 <insert_region+0x34>
    0x84000554    0x22    addi s0,s0,1
    0x84000556    0x24    addi a5,a5,16
    0x84000558    0x26    bne s0,a2,ffffffff8400054c <insert_region+0x1a>
    0x8400055c    0x2a    li a0,0
    0x8400055e    0x2c    ld ra,40(sp)          ; stack access
    0x84000560    0x2e    ld s0,32(sp)          ; stack access
    0x84000562    0x30    addi sp,sp,48
    0x84000564    0x32    ret
    0x84000566    0x34    li a5,1
    0x84000568    0x36    slli a5,a5,0x26
    0x8400056a    0x38    add a0,a0,a5
    0x8400056c    0x3a    add a1,a1,a5
    0x8400056e    0x3c    jal ra,ffffffff84000366 <reserve_region>
    0x84000572    0x40    addi s0,s0,20
    0x84000574    0x42    slli s0,s0,0x4
    0x84000576    0x44    auipc a5,0x1
    0x8400057a    0x48    addi a5,a5,-78 # ffffffff84001528 <ndks_boot>
    0x8400057e    0x4c    add s0,s0,a5
    0x84000580    0x4e    ld a5,0(sp)           ; stack access
    0x84000582    0x50    sd a5,8(s0)
    0x84000584    0x52    ld a5,8(sp)           ; stack access
    0x84000586    0x54    sd a5,16(s0)
    0x84000588    0x56    li a0,1
    0x8400058a    0x58    j ffffffff8400055e <insert_region+0x2c>
    0x8400058c    0x5a    li a0,1
    0x8400058e    0x5c    j ffffffff8400055e <insert_region+0x2c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
39 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `insert_region` has 59 nodes.

Section reserve_region (164 of 271)
===================================

Deriving specifications
-----------------------

Section `reserve_region` consists of 78 instructions.

RVC_TFFFFT___FFT__TF.
RVC_TFFTFFT__FT___TF.

Stack analysis
---------------

2 stack accesses found. Annotated code for `reserve_region`:

    0x84000366     0x0    beq a0,a1,ffffffff8400044c <reserve_region+0xe6>
    0x8400036a     0x4    addi sp,sp,-32
    0x8400036c     0x6    sd ra,24(sp)          ; stack access
    0x8400036e     0x8    mv a7,a0
    0x84000370     0xa    auipc a6,0x1
    0x84000374     0xe    ld a6,760(a6) # ffffffff84001668 <ndks_boot+0x140>
    0x84000378    0x12    beqz a6,ffffffff840003a8 <reserve_region+0x42>
    0x8400037c    0x16    auipc t1,0x1
    0x84000380    0x1a    addi t1,t1,428 # ffffffff84001528 <ndks_boot>
    0x84000384    0x1e    mv a5,t1
    0x84000386    0x20    li a4,0
    0x84000388    0x22    ld a3,0(a5)
    0x8400038a    0x24    beq a3,a1,ffffffff840003c6 <reserve_region+0x60>
    0x8400038e    0x28    ld a2,8(a5)
    0x84000390    0x2a    beq a2,a7,ffffffff840003e2 <reserve_region+0x7c>
    0x84000394    0x2e    bltu a1,a3,ffffffff840003f8 <reserve_region+0x92>
    0x84000398    0x32    addi a4,a4,1
    0x8400039a    0x34    addi a5,a5,16
    0x8400039c    0x36    bne a4,a6,ffffffff84000388 <reserve_region+0x22>
    0x840003a0    0x3a    li a5,19
    0x840003a2    0x3c    li a0,0
    0x840003a4    0x3e    beq a6,a5,ffffffff840003dc <reserve_region+0x76>
    0x840003a8    0x42    auipc a4,0x1
    0x840003ac    0x46    addi a4,a4,384 # ffffffff84001528 <ndks_boot>
    0x840003b0    0x4a    slli a5,a6,0x4
    0x840003b4    0x4e    add a5,a5,a4
    0x840003b6    0x50    sd a7,0(a5) # ffffffffcc000000 <ki_end+0x47fd1000>
    0x840003ba    0x54    sd a1,8(a5)
    0x840003bc    0x56    addi a6,a6,1
    0x840003be    0x58    sd a6,320(a4)
    0x840003c2    0x5c    li a0,1
    0x840003c4    0x5e    j ffffffff840003dc <reserve_region+0x76>
    0x840003c6    0x60    slli a4,a4,0x4
    0x840003c8    0x62    auipc a5,0x1
    0x840003cc    0x66    addi a5,a5,352 # ffffffff84001528 <ndks_boot>
    0x840003d0    0x6a    add a4,a4,a5
    0x840003d2    0x6c    sd a7,0(a4)
    0x840003d6    0x70    jal ra,ffffffff84000026 <merge_regions>
    0x840003da    0x74    li a0,1
    0x840003dc    0x76    ld ra,24(sp)          ; stack access
    0x840003de    0x78    addi sp,sp,32
    0x840003e0    0x7a    ret
    0x840003e2    0x7c    slli a4,a4,0x4
    0x840003e4    0x7e    auipc a5,0x1
    0x840003e8    0x82    addi a5,a5,324 # ffffffff84001528 <ndks_boot>
    0x840003ec    0x86    add a4,a4,a5
    0x840003ee    0x88    sd a1,8(a4)
    0x840003f0    0x8a    jal ra,ffffffff84000026 <merge_regions>
    0x840003f4    0x8e    li a0,1
    0x840003f6    0x90    j ffffffff840003dc <reserve_region+0x76>
    0x840003f8    0x92    addi a3,a6,1
    0x840003fc    0x96    li a5,19
    0x840003fe    0x98    li a0,0
    0x84000400    0x9a    bltu a5,a3,ffffffff840003dc <reserve_region+0x76>
    0x84000404    0x9e    bgeu a4,a6,ffffffff84000430 <reserve_region+0xca>
    0x84000408    0xa2    slli a6,a6,0x4
    0x8400040a    0xa4    auipc a5,0x1
    0x8400040e    0xa8    addi a5,a5,286 # ffffffff84001528 <ndks_boot>
    0x84000412    0xac    add a6,a6,a5
    0x84000414    0xae    slli a5,a4,0x4
    0x84000418    0xb2    add t1,t1,a5
    0x8400041a    0xb4    ld a5,-16(a6)
    0x8400041e    0xb8    sd a5,0(a6)
    0x84000422    0xbc    ld a5,-8(a6)
    0x84000426    0xc0    sd a5,8(a6)
    0x8400042a    0xc4    addi a6,a6,-16
    0x8400042c    0xc6    bne a6,t1,ffffffff8400041a <reserve_region+0xb4>
    0x84000430    0xca    auipc a2,0x1
    0x84000434    0xce    addi a2,a2,248 # ffffffff84001528 <ndks_boot>
    0x84000438    0xd2    slli a5,a4,0x4
    0x8400043c    0xd6    add a5,a5,a2
    0x8400043e    0xd8    sd a7,0(a5)
    0x84000442    0xdc    sd a1,8(a5)
    0x84000444    0xde    sd a3,320(a2)
    0x84000448    0xe2    li a0,1
    0x8400044a    0xe4    j ffffffff840003dc <reserve_region+0x76>
    0x8400044c    0xe6    li a0,1
    0x8400044e    0xe8    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
78 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `reserve_region` has 119 nodes.

Section create_mapped_it_frame_cap (165 of 271)
===============================================

Deriving specifications
-----------------------

Section `create_mapped_it_frame_cap` consists of 28 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `create_mapped_it_frame_cap`:

    0x84000268     0x0    addi sp,sp,-80
    0x8400026a     0x2    sd ra,72(sp)          ; stack access
    0x8400026c     0x4    sd s0,64(sp)          ; stack access
    0x8400026e     0x6    sd s1,56(sp)          ; stack access
    0x84000270     0x8    snez s0,a5
    0x84000274     0xc    slli s0,s0,0x39
    0x84000276     0xe    slli a3,a3,0x19
    0x84000278    0x10    srli a3,a3,0x19
    0x8400027a    0x12    or s0,s0,a3
    0x8400027c    0x14    li a5,19
    0x8400027e    0x16    slli a5,a5,0x37
    0x84000280    0x18    or s0,s0,a5
    0x84000282    0x1a    slli a2,a2,0x9
    0x84000284    0x1c    lui s1,0xfe000
    0x84000288    0x20    srli s1,s1,0x10
    0x8400028a    0x22    and s1,s1,a2
    0x8400028c    0x24    slli a4,a4,0x30
    0x8400028e    0x26    or s1,s1,a4
    0x84000290    0x28    mv a2,s0
    0x84000292    0x2a    mv a3,s1
    0x84000294    0x2c    jal ra,ffffffff840001fa <map_it_frame_cap>
    0x84000298    0x30    mv a0,s0
    0x8400029a    0x32    mv a1,s1
    0x8400029c    0x34    ld ra,72(sp)          ; stack access
    0x8400029e    0x36    ld s0,64(sp)          ; stack access
    0x840002a0    0x38    ld s1,56(sp)          ; stack access
    0x840002a2    0x3a    addi sp,sp,80
    0x840002a4    0x3c    ret

Proving inst theorems
---------------------

28 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_mapped_it_frame_cap` has 36 nodes.

Section write_it_asid_pool (166 of 271)
=======================================

Deriving specifications
-----------------------

Section `write_it_asid_pool` consists of 21 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `write_it_asid_pool`:

    0x8400015e     0x0    addi sp,sp,-64
    0x84000160     0x2    sd ra,56(sp)          ; stack access
    0x84000162     0x4    sd s0,48(sp)          ; stack access
    0x84000164     0x6    sd s1,40(sp)          ; stack access
    0x84000166     0x8    sd s2,32(sp)          ; stack access
    0x84000168     0xa    mv s2,a2
    0x8400016a     0xc    mv s1,a3
    0x8400016c     0xe    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x84000170    0x12    mv s0,a0
    0x84000172    0x14    mv a0,s2
    0x84000174    0x16    mv a1,s1
    0x84000176    0x18    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x8400017a    0x1c    sd a0,8(s0)
    0x8400017c    0x1e    auipc a5,0x18
    0x84000180    0x22    sd s0,-380(a5) # ffffffff84018000 <riscvKSASIDTable>
    0x84000184    0x26    ld ra,56(sp)          ; stack access
    0x84000186    0x28    ld s0,48(sp)          ; stack access
    0x84000188    0x2a    ld s1,40(sp)          ; stack access
    0x8400018a    0x2c    ld s2,32(sp)          ; stack access
    0x8400018c    0x2e    addi sp,sp,64
    0x8400018e    0x30    ret

Proving inst theorems
---------------------

21 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `write_it_asid_pool` has 34 nodes.

Section map_kernel_frame (167 of 271)
=====================================

Deriving specifications
-----------------------

Section `map_kernel_frame` consists of 18 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `map_kernel_frame`:

    0x840000c4     0x0    addi sp,sp,-16
    0x840000c6     0x2    sd ra,8(sp)           ; stack access
    0x840000c8     0x4    sd s0,0(sp)           ; stack access
    0x840000ca     0x6    srli a1,a1,0x1e
    0x840000cc     0x8    andi a1,a1,511
    0x840000d0     0xc    slli a1,a1,0x3
    0x840000d2     0xe    auipc s0,0x2d
    0x840000d6    0x12    addi s0,s0,-210 # ffffffff8402d000 <kernel_root_pageTable>
    0x840000da    0x16    add s0,s0,a1
    0x840000dc    0x18    li a1,1
    0x840000de    0x1a    lui a5,0xc0000
    0x840000e2    0x1e    and a0,a0,a5
    0x840000e4    0x20    jal ra,ffffffff84010120 <pte_next>
    0x840000e8    0x24    sd a0,0(s0)
    0x840000ea    0x26    ld ra,8(sp)           ; stack access
    0x840000ec    0x28    ld s0,0(sp)           ; stack access
    0x840000ee    0x2a    addi sp,sp,16
    0x840000f0    0x2c    ret

Proving inst theorems
---------------------

18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `map_kernel_frame` has 25 nodes.

Section _start (168 of 271)
===========================

Deriving specifications
-----------------------

Section `_start` consists of 10 instructions.

Skipping 0000100f fence.i

Skipping 14001073 csrw sscratch,zero


Stack analysis
---------------

No stack accesses found. Code for `_start`:

    0x84000000     0x0    fence.i
    0x84000004     0x4    auipc gp,0x18
    0x84000008     0x8    addi gp,gp,-692 # ffffffff84017d50 <__global_pointer$>
    0x8400000c     0xc    auipc sp,0x2a
    0x84000010    0x10    addi sp,sp,2036 # ffffffff8402a800 <tlbLockCount>
    0x84000014    0x14    csrw sscratch,zero
    0x84000018    0x18    jal ra,ffffffff840012c6 <init_kernel>
    0x8400001c    0x1c    auipc ra,0x10
    0x84000020    0x20    addi ra,ra,864 # ffffffff8401037c <restore_user_context>
    0x84000024    0x24    ret

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `_start` has 14 nodes.

Section fastpath_reply_recv (169 of 271)
========================================

Deriving specifications
-----------------------

Section `fastpath_reply_recv` consists of 252 instructions.

Skipping 180b1073 csrw satp,s6

Skipping 12000073 sfence.vma

RVC_FTTTFT________FT.
RVC_TFFFFFT__T____TF.
Skipping 14131073 csrw sepc,t1

Skipping 14029073 csrw sscratch,t0

Skipping 10031073 csrw sstatus,t1

Skipping 10200073 sret


Stack analysis
---------------

12 stack accesses found. Annotated code for `fastpath_reply_recv`:

    0x84017060      0x0    addi sp,sp,-96
    0x84017062      0x2    sd ra,88(sp)          ; stack access
    0x84017064      0x4    sd s0,80(sp)          ; stack access
    0x84017066      0x6    sd s1,72(sp)          ; stack access
    0x84017068      0x8    sd s2,64(sp)          ; stack access
    0x8401706a      0xa    sd s3,56(sp)          ; stack access
    0x8401706c      0xc    sd s4,48(sp)          ; stack access
    0x8401706e      0xe    sd s5,40(sp)          ; stack access
    0x84017070     0x10    sd s6,32(sp)          ; stack access
    0x84017072     0x12    sd s7,24(sp)          ; stack access
    0x84017074     0x14    sd s8,16(sp)          ; stack access
    0x84017076     0x16    sd s9,8(sp)           ; stack access
    0x84017078     0x18    sd s10,0(sp)          ; stack access
    0x8401707a     0x1a    auipc s2,0x13
    0x8401707e     0x1e    ld s2,1982(s2) # ffffffff8402a838 <ksCurThread>
    0x84017082     0x22    ld a4,312(s2)
    0x84017086     0x26    andi a3,a1,511
    0x8401708a     0x2a    li a5,4
    0x8401708c     0x2c    bltu a5,a3,ffffffff840171b2 <fastpath_reply_recv+0x152>
    0x84017090     0x30    mv s1,a1
    0x84017092     0x32    andi a4,a4,15
    0x84017094     0x34    bnez a4,ffffffff840171b2 <fastpath_reply_recv+0x152>
    0x84017098     0x38    andi s3,s2,-1024
    0x8401709c     0x3c    ld s0,0(s3)
    0x840170a0     0x40    ld a6,8(s3)
    0x840170a4     0x44    srli a3,s0,0x3b
    0x840170a8     0x48    li a5,10
    0x840170aa     0x4a    bne a3,a5,ffffffff840171c2 <fastpath_reply_recv+0x162>
    0x840170ae     0x4e    li t3,64
    0x840170b2     0x52    lui a5,0xfc000
    0x840170b6     0x56    srli t4,a5,0x19
    0x840170ba     0x5a    li a5,1
    0x840170bc     0x5c    slli t1,a5,0x26
    0x840170c0     0x60    li a5,-1
    0x840170c2     0x62    slli a7,a5,0x27
    0x840170c6     0x66    li t5,63
    0x840170ca     0x6a    li t6,10
    0x840170cc     0x6c    srli a3,s0,0x35
    0x840170d0     0x70    andi a3,a3,63
    0x840170d4     0x74    srli a2,s0,0x2f
    0x840170d8     0x78    andi a2,a2,63
    0x840170dc     0x7c    sll a5,a0,a4
    0x840170e0     0x80    beqz a3,ffffffff840170ee <fastpath_reply_recv+0x8e>
    0x840170e2     0x82    subw a1,t3,a3
    0x840170e6     0x86    srl a1,a5,a1
    0x840170ea     0x8a    bne a6,a1,ffffffff840171c2 <fastpath_reply_recv+0x162>
    0x840170ee     0x8e    sll a5,a5,a3
    0x840170f2     0x92    subw a1,t3,a2
    0x840170f6     0x96    srl a5,a5,a1
    0x840170fa     0x9a    slli a5,a5,0x5
    0x840170fc     0x9c    slli s0,s0,0x1
    0x840170fe     0x9e    and a1,s0,t4
    0x84017102     0xa2    and s0,s0,t1
    0x84017106     0xa6    beqz s0,ffffffff8401710c <fastpath_reply_recv+0xac>
    0x84017108     0xa8    or a1,a1,a7
    0x8401710c     0xac    add a5,a5,a1
    0x8401710e     0xae    ld s0,0(a5)
    0x84017110     0xb0    ld a6,8(a5) # fffffffffc000008 <ki_end+0x77fd1008>
    0x84017114     0xb4    add a3,a3,a2
    0x84017116     0xb6    add a4,a4,a3
    0x84017118     0xb8    bgeu t5,a4,ffffffff840171b8 <fastpath_reply_recv+0x158>
    0x8401711c     0xbc    li a5,64
    0x84017120     0xc0    bltu a5,a4,ffffffff840171c2 <fastpath_reply_recv+0x162>
    0x84017124     0xc4    srli a5,s0,0x3b
    0x84017128     0xc8    li a4,4
    0x8401712a     0xca    bne a5,a4,ffffffff840171c2 <fastpath_reply_recv+0x162>
    0x8401712e     0xce    srli a5,s0,0x38
    0x84017132     0xd2    andi a5,a5,1
    0x84017134     0xd4    beqz a5,ffffffff840171c2 <fastpath_reply_recv+0x162>
    0x84017136     0xd6    ld a5,304(s2)
    0x8401713a     0xda    bnez a5,ffffffff840171c8 <fastpath_reply_recv+0x168>
    0x8401713c     0xdc    slli s9,s0,0x19
    0x84017140     0xe0    srli s9,s9,0x19
    0x84017144     0xe4    srli a5,s0,0x26
    0x84017148     0xe8    andi a5,a5,1
    0x8401714a     0xea    beqz a5,ffffffff84017154 <fastpath_reply_recv+0xf4>
    0x8401714c     0xec    li a5,-1
    0x8401714e     0xee    slli a5,a5,0x27
    0x84017150     0xf0    or s9,s9,a5
    0x84017154     0xf4    mv s8,s9
    0x84017156     0xf6    ld a5,0(s9)
    0x8401715a     0xfa    andi a5,a5,3
    0x8401715c     0xfc    li a4,1
    0x8401715e     0xfe    beq a5,a4,ffffffff840171d8 <fastpath_reply_recv+0x178>
    0x84017162    0x102    addi s7,s3,96
    0x84017166    0x106    ld s5,8(s7)
    0x8401716a    0x10a    ld a5,96(s3)
    0x8401716e    0x10e    srli a5,a5,0x3b
    0x84017170    0x110    li a4,8
    0x84017172    0x112    bne a5,a4,ffffffff840171de <fastpath_reply_recv+0x17e>
    0x84017176    0x116    ld a5,312(s5)
    0x8401717a    0x11a    andi a5,a5,15
    0x8401717c    0x11c    bnez a5,ffffffff840171e4 <fastpath_reply_recv+0x184>
    0x8401717e    0x11e    andi a5,s5,-1024
    0x84017182    0x122    ld a4,32(a5)
    0x84017184    0x124    ld s6,40(a5)
    0x84017188    0x128    srli a5,s6,0x9
    0x8401718c    0x12c    slli s4,a5,0x19
    0x84017190    0x130    srli s4,s4,0x19
    0x84017194    0x134    srli a5,a5,0x26
    0x84017196    0x136    andi a5,a5,1
    0x84017198    0x138    beqz a5,ffffffff840171a2 <fastpath_reply_recv+0x142>
    0x8401719a    0x13a    li a5,-1
    0x8401719c    0x13c    slli a5,a5,0x27
    0x8401719e    0x13e    or s4,s4,a5
    0x840171a2    0x142    srli a5,a4,0x3b
    0x840171a6    0x146    li a3,3
    0x840171a8    0x148    beq a5,a3,ffffffff840171ea <fastpath_reply_recv+0x18a>
    0x840171ac    0x14c    li a0,-2
    0x840171ae    0x14e    jal ra,ffffffff84016d78 <slowpath>
    0x840171b2    0x152    li a0,-2
    0x840171b4    0x154    jal ra,ffffffff84016d78 <slowpath>
    0x840171b8    0x158    srli a5,s0,0x3b
    0x840171bc    0x15c    bne a5,t6,ffffffff84017124 <fastpath_reply_recv+0xc4>
    0x840171c0    0x160    j ffffffff840170cc <fastpath_reply_recv+0x6c>
    0x840171c2    0x162    li a0,-2
    0x840171c4    0x164    jal ra,ffffffff84016d78 <slowpath>
    0x840171c8    0x168    ld a5,0(a5)
    0x840171ca    0x16a    andi a5,a5,3
    0x840171cc    0x16c    li a4,2
    0x840171ce    0x16e    bne a5,a4,ffffffff8401713c <fastpath_reply_recv+0xdc>
    0x840171d2    0x172    li a0,-2
    0x840171d4    0x174    jal ra,ffffffff84016d78 <slowpath>
    0x840171d8    0x178    li a0,-2
    0x840171da    0x17a    jal ra,ffffffff84016d78 <slowpath>
    0x840171de    0x17e    li a0,-2
    0x840171e0    0x180    jal ra,ffffffff84016d78 <slowpath>
    0x840171e4    0x184    li a0,-2
    0x840171e6    0x186    jal ra,ffffffff84016d78 <slowpath>
    0x840171ea    0x18a    srli a4,a4,0x27
    0x840171ec    0x18c    andi a4,a4,1
    0x840171ee    0x18e    beqz a4,ffffffff840171ac <fastpath_reply_recv+0x14c>
    0x840171f0    0x190    srli s6,s6,0x30
    0x840171f4    0x194    auipc s10,0x13
    0x840171f8    0x198    ld s10,1572(s10) # ffffffff8402a818 <ksCurDomain>
    0x840171fc    0x19c    ld a1,360(s5)
    0x84017200    0x1a0    mv a0,s10
    0x84017202    0x1a2    jal ra,ffffffff8401030c <isHighestPrio>
    0x84017206    0x1a6    beqz a0,ffffffff84017256 <fastpath_reply_recv+0x1f6>
    0x84017208    0x1a8    ld a5,344(s5)
    0x8401720c    0x1ac    bne a5,s10,ffffffff8401725c <fastpath_reply_recv+0x1fc>
    0x84017210    0x1b0    ori s9,s9,3
    0x84017214    0x1b4    sd s9,280(s2)
    0x84017218    0x1b8    srli s0,s0,0x36
    0x8401721a    0x1ba    andi s0,s0,8
    0x8401721c    0x1bc    ld a5,288(s2)
    0x84017220    0x1c0    andi a5,a5,-9
    0x84017222    0x1c2    or s0,s0,a5
    0x84017224    0x1c4    sd s0,288(s2)
    0x84017228    0x1c8    ld a4,0(s8)
    0x8401722c    0x1cc    lui a5,0xf8000
    0x84017230    0x1d0    srli a5,a5,0x19
    0x84017232    0x1d2    and a5,a5,a4
    0x84017234    0x1d4    srli a4,a4,0x26
    0x84017236    0x1d6    andi a4,a4,1
    0x84017238    0x1d8    beqz a4,ffffffff84017262 <fastpath_reply_recv+0x202>
    0x8401723a    0x1da    li a4,-1
    0x8401723c    0x1dc    slli a4,a4,0x27
    0x8401723e    0x1de    or a5,a5,a4
    0x84017240    0x1e0    sd s2,408(a5) # fffffffff8000198 <ki_end+0x73fd1198>
    0x84017244    0x1e4    sd a5,416(s2)
    0x84017248    0x1e8    sd zero,408(s2)
    0x8401724c    0x1ec    ori s2,s2,2
    0x84017250    0x1f0    sd s2,0(s8)
    0x84017254    0x1f4    j ffffffff84017278 <fastpath_reply_recv+0x218>
    0x84017256    0x1f6    li a0,-2
    0x84017258    0x1f8    jal ra,ffffffff84016d78 <slowpath>
    0x8401725c    0x1fc    li a0,-2
    0x8401725e    0x1fe    jal ra,ffffffff84016d78 <slowpath>
    0x84017262    0x202    bnez a5,ffffffff84017240 <fastpath_reply_recv+0x1e0>
    0x84017264    0x204    sd zero,416(s2)
    0x84017268    0x208    sd zero,408(s2)
    0x8401726c    0x20c    sd s2,8(s8)
    0x84017270    0x210    ori s2,s2,2
    0x84017274    0x214    sd s2,0(s8)
    0x84017278    0x218    andi a3,s1,127
    0x8401727c    0x21c    ld a5,16(s7)
    0x84017280    0x220    li a4,3
    0x84017282    0x222    sd a4,24(a5)
    0x84017284    0x224    sd zero,96(s3)
    0x84017288    0x228    sd zero,8(s7)
    0x8401728c    0x22c    sd zero,16(s7)
    0x84017290    0x230    sd zero,24(s7)
    0x84017294    0x234    auipc a2,0x13
    0x84017298    0x238    ld a2,1444(a2) # ffffffff8402a838 <ksCurThread>
    0x8401729c    0x23c    beqz a3,ffffffff840172b4 <fastpath_reply_recv+0x254>
    0x8401729e    0x23e    mv a5,a2
    0x840172a0    0x240    addi a4,s5,88
    0x840172a4    0x244    slli a3,a3,0x3
    0x840172a6    0x246    add a2,a2,a3
    0x840172a8    0x248    ld a3,88(a5)
    0x840172aa    0x24a    sd a3,0(a4)
    0x840172ac    0x24c    addi a5,a5,8
    0x840172ae    0x24e    addi a4,a4,8
    0x840172b0    0x250    bne a2,a5,ffffffff840172a8 <fastpath_reply_recv+0x248>
    0x840172b4    0x254    li a5,1
    0x840172b6    0x256    sd a5,280(s5)
    0x840172ba    0x25a    slli a5,a5,0x26
    0x840172bc    0x25c    add s4,s4,a5
    0x840172be    0x25e    srli s4,s4,0xc
    0x840172c2    0x262    li a5,-1
    0x840172c4    0x264    srli a4,a5,0x14
    0x840172c8    0x268    and s4,s4,a4
    0x840172cc    0x26c    slli s6,s6,0x2c
    0x840172ce    0x26e    or s6,s4,s6
    0x840172d2    0x272    slli a5,a5,0x3f
    0x840172d4    0x274    or s6,s6,a5
    0x840172d8    0x278    csrw satp,s6
    0x840172dc    0x27c    sfence.vma
    0x840172e0    0x280    auipc a5,0x13
    0x840172e4    0x284    sd s5,1368(a5) # ffffffff8402a838 <ksCurThread>
    0x840172e8    0x288    li a0,0
    0x840172ea    0x28a    lui a1,0xfffff
    0x840172ec    0x28c    addi a1,a1,511 # fffffffffffff1ff <ki_end+0x7bfd01ff>
    0x840172f0    0x290    and a1,a1,s1
    0x840172f2    0x292    mv t0,s5
    0x840172f4    0x294    ld ra,0(t0)
    0x840172f8    0x298    ld sp,8(t0)
    0x840172fc    0x29c    ld gp,16(t0)
    0x84017300    0x2a0    ld t2,48(t0)
    0x84017304    0x2a4    ld s0,56(t0)
    0x84017308    0x2a8    ld s1,64(t0)
    0x8401730c    0x2ac    ld a2,88(t0)
    0x84017310    0x2b0    ld a3,96(t0)
    0x84017314    0x2b4    ld a4,104(t0)
    0x84017318    0x2b8    ld a5,112(t0)
    0x8401731c    0x2bc    ld a6,120(t0)
    0x84017320    0x2c0    ld a7,128(t0)
    0x84017324    0x2c4    ld s2,136(t0)
    0x84017328    0x2c8    ld s3,144(t0)
    0x8401732c    0x2cc    ld s4,152(t0)
    0x84017330    0x2d0    ld s5,160(t0)
    0x84017334    0x2d4    ld s6,168(t0)
    0x84017338    0x2d8    ld s7,176(t0)
    0x8401733c    0x2dc    ld s8,184(t0)
    0x84017340    0x2e0    ld s9,192(t0)
    0x84017344    0x2e4    ld s10,200(t0)
    0x84017348    0x2e8    ld s11,208(t0)
    0x8401734c    0x2ec    ld t3,216(t0)
    0x84017350    0x2f0    ld t4,224(t0)
    0x84017354    0x2f4    ld t5,232(t0)
    0x84017358    0x2f8    ld t6,240(t0)
    0x8401735c    0x2fc    ld t1,24(t0)
    0x84017360    0x300    add tp,t1,zero
    0x84017364    0x304    ld t1,272(t0)
    0x84017368    0x308    csrw sepc,t1
    0x8401736c    0x30c    csrw sscratch,t0
    0x84017370    0x310    ld t1,256(t0)
    0x84017374    0x314    csrw sstatus,t1
    0x84017378    0x318    ld t1,40(t0)
    0x8401737c    0x31c    ld t0,32(t0)
    0x84017380    0x320    sret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
252 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `fastpath_reply_recv` has 403 nodes.

Section fastpath_call (170 of 271)
==================================

Deriving specifications
-----------------------

Section `fastpath_call` consists of 227 instructions.

Skipping 18079073 csrw satp,a5

Skipping 12000073 sfence.vma

Skipping 14131073 csrw sepc,t1

Skipping 14029073 csrw sscratch,t0

Skipping 10031073 csrw sstatus,t1

Skipping 10200073 sret


Stack analysis
---------------

10 stack accesses found. Annotated code for `fastpath_call`:

    0x84016d90      0x0    addi sp,sp,-80
    0x84016d92      0x2    sd ra,72(sp)          ; stack access
    0x84016d94      0x4    sd s0,64(sp)          ; stack access
    0x84016d96      0x6    sd s1,56(sp)          ; stack access
    0x84016d98      0x8    sd s2,48(sp)          ; stack access
    0x84016d9a      0xa    sd s3,40(sp)          ; stack access
    0x84016d9c      0xc    sd s4,32(sp)          ; stack access
    0x84016d9e      0xe    sd s5,24(sp)          ; stack access
    0x84016da0     0x10    sd s6,16(sp)          ; stack access
    0x84016da2     0x12    sd s7,8(sp)           ; stack access
    0x84016da4     0x14    sd s8,0(sp)           ; stack access
    0x84016da6     0x16    auipc a6,0x14
    0x84016daa     0x1a    ld a6,-1390(a6) # ffffffff8402a838 <ksCurThread>
    0x84016dae     0x1e    ld a4,312(a6)
    0x84016db2     0x22    andi a3,a1,511
    0x84016db6     0x26    li a5,4
    0x84016db8     0x28    bltu a5,a3,ffffffff84016eb4 <fastpath_call+0x124>
    0x84016dbc     0x2c    mv s2,a1
    0x84016dbe     0x2e    andi a4,a4,15
    0x84016dc0     0x30    bnez a4,ffffffff84016eb4 <fastpath_call+0x124>
    0x84016dc2     0x32    andi a5,a6,-1024
    0x84016dc6     0x36    ld s0,0(a5)
    0x84016dc8     0x38    ld s3,8(a5)
    0x84016dcc     0x3c    srli a3,s0,0x3b
    0x84016dd0     0x40    li a5,10
    0x84016dd2     0x42    bne a3,a5,ffffffff84016ec4 <fastpath_call+0x134>
    0x84016dd6     0x46    li t4,64
    0x84016dda     0x4a    lui a5,0xfc000
    0x84016dde     0x4e    srli t3,a5,0x19
    0x84016de2     0x52    li a5,1
    0x84016de4     0x54    slli t1,a5,0x26
    0x84016de8     0x58    li a5,-1
    0x84016dea     0x5a    slli a7,a5,0x27
    0x84016dee     0x5e    li t5,63
    0x84016df2     0x62    li t6,10
    0x84016df4     0x64    srli a3,s0,0x35
    0x84016df8     0x68    andi a3,a3,63
    0x84016dfc     0x6c    srli a2,s0,0x2f
    0x84016e00     0x70    andi a2,a2,63
    0x84016e04     0x74    sll a5,a0,a4
    0x84016e08     0x78    beqz a3,ffffffff84016e16 <fastpath_call+0x86>
    0x84016e0a     0x7a    subw a1,t4,a3
    0x84016e0e     0x7e    srl a1,a5,a1
    0x84016e12     0x82    bne s3,a1,ffffffff84016ec4 <fastpath_call+0x134>
    0x84016e16     0x86    sll a5,a5,a3
    0x84016e1a     0x8a    subw a1,t4,a2
    0x84016e1e     0x8e    srl a5,a5,a1
    0x84016e22     0x92    slli a5,a5,0x5
    0x84016e24     0x94    slli s0,s0,0x1
    0x84016e26     0x96    and a1,s0,t3
    0x84016e2a     0x9a    and s0,s0,t1
    0x84016e2e     0x9e    beqz s0,ffffffff84016e34 <fastpath_call+0xa4>
    0x84016e30     0xa0    or a1,a1,a7
    0x84016e34     0xa4    add a5,a5,a1
    0x84016e36     0xa6    ld s0,0(a5)
    0x84016e38     0xa8    ld s3,8(a5) # fffffffffc000008 <ki_end+0x77fd1008>
    0x84016e3c     0xac    add a3,a3,a2
    0x84016e3e     0xae    add a4,a4,a3
    0x84016e40     0xb0    bgeu t5,a4,ffffffff84016eba <fastpath_call+0x12a>
    0x84016e44     0xb4    li a5,64
    0x84016e48     0xb8    bltu a5,a4,ffffffff84016ec4 <fastpath_call+0x134>
    0x84016e4c     0xbc    srli a5,s0,0x3b
    0x84016e50     0xc0    li a4,4
    0x84016e52     0xc2    bne a5,a4,ffffffff84016ec4 <fastpath_call+0x134>
    0x84016e56     0xc6    srli a5,s0,0x37
    0x84016e5a     0xca    andi a5,a5,1
    0x84016e5c     0xcc    beqz a5,ffffffff84016ec4 <fastpath_call+0x134>
    0x84016e5e     0xce    slli a5,s0,0x19
    0x84016e62     0xd2    srli a5,a5,0x19
    0x84016e64     0xd4    srli a4,s0,0x26
    0x84016e68     0xd8    andi a4,a4,1
    0x84016e6a     0xda    beqz a4,ffffffff84016e72 <fastpath_call+0xe2>
    0x84016e6c     0xdc    li a4,-1
    0x84016e6e     0xde    slli a4,a4,0x27
    0x84016e70     0xe0    or a5,a5,a4
    0x84016e72     0xe2    mv s6,a5
    0x84016e74     0xe4    ld s4,8(a5)
    0x84016e78     0xe8    ld a5,0(a5)
    0x84016e7a     0xea    andi a5,a5,3
    0x84016e7c     0xec    li a4,2
    0x84016e7e     0xee    bne a5,a4,ffffffff84016eca <fastpath_call+0x13a>
    0x84016e82     0xf2    andi s7,s4,-1024
    0x84016e86     0xf6    ld a3,32(s7)
    0x84016e8a     0xfa    ld s5,40(s7)
    0x84016e8e     0xfe    srli a4,s5,0x9
    0x84016e92    0x102    slli s1,a4,0x19
    0x84016e96    0x106    srli s1,s1,0x19
    0x84016e98    0x108    srli a4,a4,0x26
    0x84016e9a    0x10a    andi a4,a4,1
    0x84016e9c    0x10c    beqz a4,ffffffff84016ea4 <fastpath_call+0x114>
    0x84016e9e    0x10e    li a4,-1
    0x84016ea0    0x110    slli a4,a4,0x27
    0x84016ea2    0x112    or s1,s1,a4
    0x84016ea4    0x114    srli a4,a3,0x3b
    0x84016ea8    0x118    li a5,3
    0x84016eaa    0x11a    beq a4,a5,ffffffff84016ed0 <fastpath_call+0x140>
    0x84016eae    0x11e    li a0,-1
    0x84016eb0    0x120    jal ra,ffffffff84016d78 <slowpath>
    0x84016eb4    0x124    li a0,-1
    0x84016eb6    0x126    jal ra,ffffffff84016d78 <slowpath>
    0x84016eba    0x12a    srli a5,s0,0x3b
    0x84016ebe    0x12e    bne a5,t6,ffffffff84016e4c <fastpath_call+0xbc>
    0x84016ec2    0x132    j ffffffff84016df4 <fastpath_call+0x64>
    0x84016ec4    0x134    li a0,-1
    0x84016ec6    0x136    jal ra,ffffffff84016d78 <slowpath>
    0x84016eca    0x13a    li a0,-1
    0x84016ecc    0x13c    jal ra,ffffffff84016d78 <slowpath>
    0x84016ed0    0x140    srli a3,a3,0x27
    0x84016ed2    0x142    andi a3,a3,1
    0x84016ed4    0x144    beqz a3,ffffffff84016eae <fastpath_call+0x11e>
    0x84016ed6    0x146    srli s5,s5,0x30
    0x84016eda    0x14a    auipc s8,0x14
    0x84016ede    0x14e    ld s8,-1730(s8) # ffffffff8402a818 <ksCurDomain>
    0x84016ee2    0x152    ld a1,360(s4)
    0x84016ee6    0x156    ld a5,360(a6)
    0x84016eea    0x15a    bltu a1,a5,ffffffff8401703e <fastpath_call+0x2ae>
    0x84016eee    0x15e    srli a5,s0,0x39
    0x84016ef2    0x162    srli s0,s0,0x3a
    0x84016ef4    0x164    or s0,s0,a5
    0x84016ef6    0x166    andi s0,s0,1
    0x84016ef8    0x168    beqz s0,ffffffff8401704e <fastpath_call+0x2be>
    0x84016efc    0x16c    ld a5,344(s4)
    0x84016f00    0x170    bne a5,s8,ffffffff84017054 <fastpath_call+0x2c4>
    0x84016f04    0x174    ld a5,408(s4)
    0x84016f08    0x178    sd a5,8(s6)
    0x84016f0c    0x17c    ld a5,408(s4)
    0x84016f10    0x180    bnez a5,ffffffff8401705a <fastpath_call+0x2ca>
    0x84016f14    0x184    sd zero,0(s6)
    0x84016f18    0x188    andi a1,s2,127
    0x84016f1c    0x18c    auipc a0,0x14
    0x84016f20    0x190    addi a0,a0,-1764 # ffffffff8402a838 <ksCurThread>
    0x84016f24    0x194    ld a2,0(a0)
    0x84016f26    0x196    li a5,5
    0x84016f28    0x198    sd a5,280(a2)
    0x84016f2c    0x19c    andi a3,a2,-1024
    0x84016f30    0x1a0    addi a3,a3,64
    0x84016f34    0x1a4    addi a4,s7,96
    0x84016f38    0x1a8    ld a5,288(s4)
    0x84016f3c    0x1ac    sd a2,104(s7)
    0x84016f40    0x1b0    srli a5,a5,0x2
    0x84016f42    0x1b2    andi a5,a5,2
    0x84016f44    0x1b4    li a2,1
    0x84016f46    0x1b6    slli a2,a2,0x3e
    0x84016f48    0x1b8    or a5,a5,a2
    0x84016f4a    0x1ba    sd a5,96(s7)
    0x84016f4e    0x1be    sd a3,112(s7)
    0x84016f52    0x1c2    ori a4,a4,3
    0x84016f56    0x1c6    sd a4,24(a3)
    0x84016f58    0x1c8    ld a2,0(a0)
    0x84016f5a    0x1ca    beqz a1,ffffffff84016f72 <fastpath_call+0x1e2>
    0x84016f5c    0x1cc    mv a5,a2
    0x84016f5e    0x1ce    addi a4,s4,88
    0x84016f62    0x1d2    slli a1,a1,0x3
    0x84016f64    0x1d4    add a2,a2,a1
    0x84016f66    0x1d6    ld a3,88(a5)
    0x84016f68    0x1d8    sd a3,0(a4)
    0x84016f6a    0x1da    addi a5,a5,8
    0x84016f6c    0x1dc    addi a4,a4,8
    0x84016f6e    0x1de    bne a5,a2,ffffffff84016f66 <fastpath_call+0x1d6>
    0x84016f72    0x1e2    li a5,1
    0x84016f74    0x1e4    sd a5,280(s4)
    0x84016f78    0x1e8    slli a5,a5,0x26
    0x84016f7a    0x1ea    add a5,a5,s1
    0x84016f7c    0x1ec    srli a5,a5,0xc
    0x84016f7e    0x1ee    li a4,-1
    0x84016f80    0x1f0    srli s1,a4,0x14
    0x84016f84    0x1f4    and a5,a5,s1
    0x84016f86    0x1f6    slli s5,s5,0x2c
    0x84016f88    0x1f8    or a5,a5,s5
    0x84016f8c    0x1fc    slli a4,a4,0x3f
    0x84016f8e    0x1fe    or a5,a5,a4
    0x84016f90    0x200    csrw satp,a5
    0x84016f94    0x204    sfence.vma
    0x84016f98    0x208    auipc a5,0x14
    0x84016f9c    0x20c    sd s4,-1888(a5) # ffffffff8402a838 <ksCurThread>
    0x84016fa0    0x210    mv a0,s3
    0x84016fa2    0x212    lui a1,0xfffff
    0x84016fa4    0x214    addi a1,a1,511 # fffffffffffff1ff <ki_end+0x7bfd01ff>
    0x84016fa8    0x218    and a1,s2,a1
    0x84016fac    0x21c    mv t0,s4
    0x84016fae    0x21e    ld ra,0(t0) # fffffffffc000000 <ki_end+0x77fd1000>
    0x84016fb2    0x222    ld sp,8(t0)
    0x84016fb6    0x226    ld gp,16(t0)
    0x84016fba    0x22a    ld t2,48(t0)
    0x84016fbe    0x22e    ld s0,56(t0)
    0x84016fc2    0x232    ld s1,64(t0)
    0x84016fc6    0x236    ld a2,88(t0)
    0x84016fca    0x23a    ld a3,96(t0)
    0x84016fce    0x23e    ld a4,104(t0)
    0x84016fd2    0x242    ld a5,112(t0)
    0x84016fd6    0x246    ld a6,120(t0)
    0x84016fda    0x24a    ld a7,128(t0)
    0x84016fde    0x24e    ld s2,136(t0)
    0x84016fe2    0x252    ld s3,144(t0)
    0x84016fe6    0x256    ld s4,152(t0)
    0x84016fea    0x25a    ld s5,160(t0)
    0x84016fee    0x25e    ld s6,168(t0)
    0x84016ff2    0x262    ld s7,176(t0)
    0x84016ff6    0x266    ld s8,184(t0)
    0x84016ffa    0x26a    ld s9,192(t0)
    0x84016ffe    0x26e    ld s10,200(t0)
    0x84017002    0x272    ld s11,208(t0)
    0x84017006    0x276    ld t3,216(t0)
    0x8401700a    0x27a    ld t4,224(t0)
    0x8401700e    0x27e    ld t5,232(t0)
    0x84017012    0x282    ld t6,240(t0)
    0x84017016    0x286    ld t1,24(t0)
    0x8401701a    0x28a    add tp,t1,zero
    0x8401701e    0x28e    ld t1,272(t0)
    0x84017022    0x292    csrw sepc,t1
    0x84017026    0x296    csrw sscratch,t0
    0x8401702a    0x29a    ld t1,256(t0)
    0x8401702e    0x29e    csrw sstatus,t1
    0x84017032    0x2a2    ld t1,40(t0)
    0x84017036    0x2a6    ld t0,32(t0)
    0x8401703a    0x2aa    sret
    0x8401703e    0x2ae    mv a0,s8
    0x84017040    0x2b0    jal ra,ffffffff8401030c <isHighestPrio>
    0x84017044    0x2b4    bnez a0,ffffffff84016eee <fastpath_call+0x15e>
    0x84017048    0x2b8    li a0,-1
    0x8401704a    0x2ba    jal ra,ffffffff84016d78 <slowpath>
    0x8401704e    0x2be    li a0,-1
    0x84017050    0x2c0    jal ra,ffffffff84016d78 <slowpath>
    0x84017054    0x2c4    li a0,-1
    0x84017056    0x2c6    jal ra,ffffffff84016d78 <slowpath>
    0x8401705a    0x2ca    sd zero,416(a5)
    0x8401705e    0x2ce    j ffffffff84016f18 <fastpath_call+0x188>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
227 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `fastpath_call` has 359 nodes.

Section performPageTableInvocationUnmap (171 of 271)
====================================================

Deriving specifications
-----------------------

Section `performPageTableInvocationUnmap` consists of 47 instructions.


Stack analysis
---------------

7 stack accesses found. Annotated code for `performPageTableInvocationUnmap`:

    0x84015b9c     0x0    addi sp,sp,-48
    0x84015b9e     0x2    sd ra,40(sp)          ; stack access
    0x84015ba0     0x4    sd s0,32(sp)          ; stack access
    0x84015ba2     0x6    sd s1,24(sp)          ; stack access
    0x84015ba4     0x8    sd a1,8(sp)           ; stack access
    0x84015ba6     0xa    mv s0,a2
    0x84015ba8     0xc    srli a4,a0,0x27
    0x84015bac    0x10    andi a4,a4,1
    0x84015bae    0x12    beqz a4,ffffffff84015bf0 <performPageTableInvocationUnmap+0x54>
    0x84015bb0    0x14    mv a5,a0
    0x84015bb2    0x16    mv a3,a1
    0x84015bb4    0x18    srli a4,a1,0x9
    0x84015bb8    0x1c    slli a0,a4,0x19
    0x84015bbc    0x20    srli a0,a0,0x19
    0x84015bbe    0x22    srli a4,a4,0x26
    0x84015bc0    0x24    andi a4,a4,1
    0x84015bc2    0x26    beqz a4,ffffffff84015bca <performPageTableInvocationUnmap+0x2e>
    0x84015bc4    0x28    li a4,-1
    0x84015bc6    0x2a    slli a4,a4,0x27
    0x84015bc8    0x2c    or a0,a0,a4
    0x84015bca    0x2e    mv s1,a0
    0x84015bcc    0x30    srli a0,a3,0x30
    0x84015bd0    0x34    slli a1,a5,0x19
    0x84015bd4    0x38    srli a1,a1,0x19
    0x84015bd6    0x3a    srli a5,a5,0x26
    0x84015bd8    0x3c    andi a5,a5,1
    0x84015bda    0x3e    beqz a5,ffffffff84015be2 <performPageTableInvocationUnmap+0x46>
    0x84015bdc    0x40    li a5,-1
    0x84015bde    0x42    slli a5,a5,0x27
    0x84015be0    0x44    or a1,a1,a5
    0x84015be2    0x46    mv a2,s1
    0x84015be4    0x48    jal ra,ffffffff84010aaa <unmapPageTable>
    0x84015be8    0x4c    lui a1,0x1
    0x84015bea    0x4e    mv a0,s1
    0x84015bec    0x50    jal ra,ffffffff84015b8a <memzero>
    0x84015bf0    0x54    ld a4,0(s0)
    0x84015bf2    0x56    li a5,-1
    0x84015bf4    0x58    slli a5,a5,0x27
    0x84015bf6    0x5a    addi a5,a5,-1
    0x84015bf8    0x5c    and a5,a5,a4
    0x84015bfa    0x5e    sd a5,0(s0)
    0x84015bfc    0x60    li a0,0
    0x84015bfe    0x62    ld ra,40(sp)          ; stack access
    0x84015c00    0x64    ld s0,32(sp)          ; stack access
    0x84015c02    0x66    ld s1,24(sp)          ; stack access
    0x84015c04    0x68    addi sp,sp,48
    0x84015c06    0x6a    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
47 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performPageTableInvocationUnmap` has 65 nodes.

Section replyFromKernel_error (172 of 271)
==========================================

Deriving specifications
-----------------------

Section `replyFromKernel_error` consists of 21 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `replyFromKernel_error`:

    0x84015aac     0x0    addi sp,sp,-16
    0x84015aae     0x2    sd ra,8(sp)           ; stack access
    0x84015ab0     0x4    sd s0,0(sp)           ; stack access
    0x84015ab2     0x6    mv s0,a0
    0x84015ab4     0x8    mv a1,a0
    0x84015ab6     0xa    li a0,1
    0x84015ab8     0xc    jal ra,ffffffff840107e6 <lookupIPCBuffer>
    0x84015abc    0x10    mv a1,a0
    0x84015abe    0x12    sd zero,72(s0)
    0x84015ac2    0x16    mv a0,s0
    0x84015ac4    0x18    jal ra,ffffffff840159ee <setMRs_syscall_error>
    0x84015ac8    0x1c    auipc a5,0x3
    0x84015acc    0x20    ld a5,-1016(a5) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84015ad0    0x24    slli a5,a5,0xc
    0x84015ad2    0x26    andi a0,a0,127
    0x84015ad6    0x2a    or a5,a5,a0
    0x84015ad8    0x2c    sd a5,80(s0)
    0x84015ada    0x2e    ld ra,8(sp)           ; stack access
    0x84015adc    0x30    ld s0,0(sp)           ; stack access
    0x84015ade    0x32    addi sp,sp,16
    0x84015ae0    0x34    ret

Proving inst theorems
---------------------

21 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `replyFromKernel_error` has 31 nodes.

Section setMRs_syscall_error (173 of 271)
=========================================

Deriving specifications
-----------------------

Section `setMRs_syscall_error` consists of 66 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `setMRs_syscall_error`:

    0x840159ee     0x0    mv a5,a0
    0x840159f0     0x2    auipc a0,0x3
    0x840159f4     0x6    ld a0,-800(a0) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840159f8     0xa    li a4,4
    0x840159fa     0xc    beq a0,a4,ffffffff84015a88 <setMRs_syscall_error+0x9a>
    0x840159fe    0x10    addi sp,sp,-16
    0x84015a00    0x12    sd ra,8(sp)           ; stack access
    0x84015a02    0x14    bgeu a4,a0,ffffffff84015a40 <setMRs_syscall_error+0x52>
    0x84015a06    0x18    li a4,9
    0x84015a08    0x1a    bltu a4,a0,ffffffff84015a66 <setMRs_syscall_error+0x78>
    0x84015a0c    0x1e    li a4,6
    0x84015a0e    0x20    bltu a4,a0,ffffffff84015aa4 <setMRs_syscall_error+0xb6>
    0x84015a12    0x24    li a4,5
    0x84015a14    0x26    beq a0,a4,ffffffff84015aa8 <setMRs_syscall_error+0xba>
    0x84015a18    0x2a    auipc a3,0x2
    0x84015a1c    0x2e    addi a3,a3,1512 # ffffffff84018000 <riscvKSASIDTable>
    0x84015a20    0x32    ld a4,1736(a3)
    0x84015a24    0x36    snez a4,a4
    0x84015a28    0x3a    sd a4,88(a5)
    0x84015a2a    0x3c    li a4,1
    0x84015a2c    0x3e    ld a2,1024(a3)
    0x84015a30    0x42    ld a3,1032(a3)
    0x84015a34    0x46    mv a0,a5
    0x84015a36    0x48    jal ra,ffffffff8401042a <setMRs_lookup_failure>
    0x84015a3a    0x4c    slli a0,a0,0x20
    0x84015a3c    0x4e    srli a0,a0,0x20
    0x84015a3e    0x50    j ffffffff84015a4e <setMRs_syscall_error+0x60>
    0x84015a40    0x52    li a4,2
    0x84015a42    0x54    beq a0,a4,ffffffff84015a7a <setMRs_syscall_error+0x8c>
    0x84015a46    0x58    li a4,3
    0x84015a48    0x5a    bne a0,a4,ffffffff84015a54 <setMRs_syscall_error+0x66>
    0x84015a4c    0x5e    li a0,0
    0x84015a4e    0x60    ld ra,8(sp)           ; stack access
    0x84015a50    0x62    addi sp,sp,16
    0x84015a52    0x64    ret
    0x84015a54    0x66    li a4,1
    0x84015a56    0x68    bne a0,a4,ffffffff84015aa0 <setMRs_syscall_error+0xb2>
    0x84015a5a    0x6c    auipc a4,0x3
    0x84015a5e    0x70    ld a4,-954(a4) # ffffffff840186a0 <current_syscall_error>
    0x84015a62    0x74    sd a4,88(a5)
    0x84015a64    0x76    j ffffffff84015a4e <setMRs_syscall_error+0x60>
    0x84015a66    0x78    li a4,10
    0x84015a68    0x7a    bne a0,a4,ffffffff84015aa0 <setMRs_syscall_error+0xb2>
    0x84015a6c    0x7e    auipc a4,0x3
    0x84015a70    0x82    ld a4,-940(a4) # ffffffff840186c0 <current_syscall_error+0x20>
    0x84015a74    0x86    sd a4,88(a5)
    0x84015a76    0x88    li a0,1
    0x84015a78    0x8a    j ffffffff84015a4e <setMRs_syscall_error+0x60>
    0x84015a7a    0x8c    auipc a4,0x3
    0x84015a7e    0x90    ld a4,-978(a4) # ffffffff840186a8 <current_syscall_error+0x8>
    0x84015a82    0x94    sd a4,88(a5)
    0x84015a84    0x96    li a0,1
    0x84015a86    0x98    j ffffffff84015a4e <setMRs_syscall_error+0x60>
    0x84015a88    0x9a    auipc a4,0x2
    0x84015a8c    0x9e    addi a4,a4,1400 # ffffffff84018000 <riscvKSASIDTable>
    0x84015a90    0xa2    ld a3,1712(a4)
    0x84015a94    0xa6    sd a3,88(a5)
    0x84015a96    0xa8    ld a4,1720(a4)
    0x84015a9a    0xac    sd a4,96(a5)
    0x84015a9c    0xae    li a0,2
    0x84015a9e    0xb0    ret
    0x84015aa0    0xb2    jal ra,ffffffff8401041e <halt>
    0x84015aa4    0xb6    li a0,0
    0x84015aa6    0xb8    j ffffffff84015a4e <setMRs_syscall_error+0x60>
    0x84015aa8    0xba    li a0,0
    0x84015aaa    0xbc    j ffffffff84015a4e <setMRs_syscall_error+0x60>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
66 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setMRs_syscall_error` has 105 nodes.

Section decodeUnbindNotification (174 of 271)
=============================================

Deriving specifications
-----------------------

Section `decodeUnbindNotification` consists of 31 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `decodeUnbindNotification`:

    0x840157e2     0x0    addi sp,sp,-32
    0x840157e4     0x2    sd ra,24(sp)          ; stack access
    0x840157e6     0x4    sd s0,16(sp)          ; stack access
    0x840157e8     0x6    sd a0,0(sp)           ; stack access
    0x840157ea     0x8    sd a1,8(sp)           ; stack access
    0x840157ec     0xa    slli s0,a0,0x19
    0x840157f0     0xe    srli s0,s0,0x19
    0x840157f2    0x10    srli a0,a0,0x26
    0x840157f4    0x12    andi a0,a0,1
    0x840157f6    0x14    beqz a0,ffffffff840157fe <decodeUnbindNotification+0x1c>
    0x840157f8    0x16    li a5,-1
    0x840157fa    0x18    slli a5,a5,0x27
    0x840157fc    0x1a    or s0,s0,a5
    0x840157fe    0x1c    ld a5,304(s0)
    0x84015802    0x20    beqz a5,ffffffff84015822 <decodeUnbindNotification+0x40>
    0x84015804    0x22    li a1,2
    0x84015806    0x24    auipc a0,0x15
    0x8401580a    0x28    ld a0,50(a0) # ffffffff8402a838 <ksCurThread>
    0x8401580e    0x2c    jal ra,ffffffff8401263a <setThreadState>
    0x84015812    0x30    li a1,0
    0x84015814    0x32    mv a0,s0
    0x84015816    0x34    jal ra,ffffffff840156fe <invokeTCB_NotificationControl>
    0x8401581a    0x38    ld ra,24(sp)          ; stack access
    0x8401581c    0x3a    ld s0,16(sp)          ; stack access
    0x8401581e    0x3c    addi sp,sp,32
    0x84015820    0x3e    ret
    0x84015822    0x40    li a5,3
    0x84015824    0x42    auipc a4,0x3
    0x84015828    0x46    sd a5,-340(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x8401582c    0x4a    li a0,3
    0x8401582e    0x4c    j ffffffff8401581a <decodeUnbindNotification+0x38>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
31 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeUnbindNotification` has 47 nodes.

Section decodeBindNotification (175 of 271)
===========================================

Deriving specifications
-----------------------

Section `decodeBindNotification` consists of 80 instructions.


Stack analysis
---------------

9 stack accesses found. Annotated code for `decodeBindNotification`:

    0x84015716     0x0    addi sp,sp,-48
    0x84015718     0x2    sd ra,40(sp)          ; stack access
    0x8401571a     0x4    sd s0,32(sp)          ; stack access
    0x8401571c     0x6    sd s1,24(sp)          ; stack access
    0x8401571e     0x8    sd a0,0(sp)           ; stack access
    0x84015720     0xa    sd a1,8(sp)           ; stack access
    0x84015722     0xc    auipc a3,0x3
    0x84015726    0x10    ld a3,366(a3) # ffffffff84018890 <current_extra_caps>
    0x8401572a    0x14    beqz a3,ffffffff84015784 <decodeBindNotification+0x6e>
    0x8401572c    0x16    ld a5,0(sp)           ; stack access
    0x8401572e    0x18    slli a4,a5,0x19
    0x84015732    0x1c    srli a4,a4,0x19
    0x84015734    0x1e    srli a5,a5,0x26
    0x84015736    0x20    andi a5,a5,1
    0x84015738    0x22    beqz a5,ffffffff84015740 <decodeBindNotification+0x2a>
    0x8401573a    0x24    li a5,-1
    0x8401573c    0x26    slli a5,a5,0x27
    0x8401573e    0x28    or a4,a4,a5
    0x84015740    0x2a    mv s0,a4
    0x84015742    0x2c    ld a5,304(a4)
    0x84015746    0x30    bnez a5,ffffffff84015792 <decodeBindNotification+0x7c>
    0x84015748    0x32    ld a5,0(a3)
    0x8401574a    0x34    srli a3,a5,0x3b
    0x8401574e    0x38    li a4,6
    0x84015750    0x3a    bne a3,a4,ffffffff840157a8 <decodeBindNotification+0x92>
    0x84015754    0x3e    slli a4,a5,0x19
    0x84015758    0x42    srli a4,a4,0x19
    0x8401575a    0x44    srli a3,a5,0x26
    0x8401575e    0x48    andi a3,a3,1
    0x84015760    0x4a    beqz a3,ffffffff84015768 <decodeBindNotification+0x52>
    0x84015762    0x4c    li a3,-1
    0x84015764    0x4e    slli a3,a3,0x27
    0x84015766    0x50    or a4,a4,a3
    0x84015768    0x52    mv s1,a4
    0x8401576a    0x54    srli a5,a5,0x3a
    0x8401576c    0x56    andi a5,a5,1
    0x8401576e    0x58    beqz a5,ffffffff840157b6 <decodeBindNotification+0xa0>
    0x84015770    0x5a    ld a5,8(a4)
    0x84015772    0x5c    slli a5,a5,0x19
    0x84015774    0x5e    beqz a5,ffffffff840157c4 <decodeBindNotification+0xae>
    0x84015776    0x60    li a5,3
    0x84015778    0x62    auipc a4,0x3
    0x8401577c    0x66    sd a5,-168(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84015780    0x6a    li a0,3
    0x84015782    0x6c    j ffffffff8401579e <decodeBindNotification+0x88>
    0x84015784    0x6e    li a5,7
    0x84015786    0x70    auipc a4,0x3
    0x8401578a    0x74    sd a5,-182(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x8401578e    0x78    li a0,3
    0x84015790    0x7a    j ffffffff8401579e <decodeBindNotification+0x88>
    0x84015792    0x7c    li a5,3
    0x84015794    0x7e    auipc a4,0x3
    0x84015798    0x82    sd a5,-196(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x8401579c    0x86    li a0,3
    0x8401579e    0x88    ld ra,40(sp)          ; stack access
    0x840157a0    0x8a    ld s0,32(sp)          ; stack access
    0x840157a2    0x8c    ld s1,24(sp)          ; stack access
    0x840157a4    0x8e    addi sp,sp,48
    0x840157a6    0x90    ret
    0x840157a8    0x92    li a5,3
    0x840157aa    0x94    auipc a4,0x3
    0x840157ae    0x98    sd a5,-218(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840157b2    0x9c    li a0,3
    0x840157b4    0x9e    j ffffffff8401579e <decodeBindNotification+0x88>
    0x840157b6    0xa0    li a5,3
    0x840157b8    0xa2    auipc a4,0x3
    0x840157bc    0xa6    sd a5,-232(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840157c0    0xaa    li a0,3
    0x840157c2    0xac    j ffffffff8401579e <decodeBindNotification+0x88>
    0x840157c4    0xae    ld a5,24(a4)
    0x840157c6    0xb0    slli a5,a5,0x19
    0x840157c8    0xb2    bnez a5,ffffffff84015776 <decodeBindNotification+0x60>
    0x840157ca    0xb4    li a1,2
    0x840157cc    0xb6    auipc a0,0x15
    0x840157d0    0xba    ld a0,108(a0) # ffffffff8402a838 <ksCurThread>
    0x840157d4    0xbe    jal ra,ffffffff8401263a <setThreadState>
    0x840157d8    0xc2    mv a1,s1
    0x840157da    0xc4    mv a0,s0
    0x840157dc    0xc6    jal ra,ffffffff840156fe <invokeTCB_NotificationControl>
    0x840157e0    0xca    j ffffffff8401579e <decodeBindNotification+0x88>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
80 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeBindNotification` has 119 nodes.

Section invokeTCB_NotificationControl (176 of 271)
==================================================

Deriving specifications
-----------------------

Section `invokeTCB_NotificationControl` consists of 10 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeTCB_NotificationControl`:

    0x840156fe     0x0    addi sp,sp,-16
    0x84015700     0x2    sd ra,8(sp)           ; stack access
    0x84015702     0x4    beqz a1,ffffffff84015710 <invokeTCB_NotificationControl+0x12>
    0x84015704     0x6    jal ra,ffffffff84011c4e <bindNotification>
    0x84015708     0xa    li a0,0
    0x8401570a     0xc    ld ra,8(sp)           ; stack access
    0x8401570c     0xe    addi sp,sp,16
    0x8401570e    0x10    ret
    0x84015710    0x12    jal ra,ffffffff84011c3a <unbindNotification>
    0x84015714    0x16    j ffffffff84015708 <invokeTCB_NotificationControl+0xa>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_NotificationControl` has 17 nodes.

Section handleFault (177 of 271)
================================

Deriving specifications
-----------------------

Section `handleFault` consists of 14 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `handleFault`:

    0x84014514     0x0    addi sp,sp,-16
    0x84014516     0x2    sd ra,8(sp)           ; stack access
    0x84014518     0x4    sd s0,0(sp)           ; stack access
    0x8401451a     0x6    mv s0,a0
    0x8401451c     0x8    jal ra,ffffffff8401442a <sendFaultIPC>
    0x84014520     0xc    bnez a0,ffffffff8401452a <handleFault+0x16>
    0x84014522     0xe    ld ra,8(sp)           ; stack access
    0x84014524    0x10    ld s0,0(sp)           ; stack access
    0x84014526    0x12    addi sp,sp,16
    0x84014528    0x14    ret
    0x8401452a    0x16    li a1,0
    0x8401452c    0x18    mv a0,s0
    0x8401452e    0x1a    jal ra,ffffffff8401263a <setThreadState>
    0x84014532    0x1e    j ffffffff84014522 <handleFault+0xe>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleFault` has 23 nodes.

Section sendFaultIPC (178 of 271)
=================================

Deriving specifications
-----------------------

Section `sendFaultIPC` consists of 83 instructions.


Stack analysis
---------------

15 stack accesses found. Annotated code for `sendFaultIPC`:

    0x8401442a     0x0    addi sp,sp,-80
    0x8401442c     0x2    sd ra,72(sp)          ; stack access
    0x8401442e     0x4    sd s0,64(sp)          ; stack access
    0x84014430     0x6    sd s1,56(sp)          ; stack access
    0x84014432     0x8    sd s2,48(sp)          ; stack access
    0x84014434     0xa    sd s3,40(sp)          ; stack access
    0x84014436     0xc    sd s4,32(sp)          ; stack access
    0x84014438     0xe    mv s0,a0
    0x8401443a    0x10    auipc a5,0x4
    0x8401443e    0x14    addi a5,a5,-1082 # ffffffff84018000 <riscvKSASIDTable>
    0x84014442    0x18    ld s3,1024(a5)
    0x84014446    0x1c    ld s4,1032(a5)
    0x8401444a    0x20    ld s2,376(a0)
    0x8401444e    0x24    mv a2,s2
    0x84014450    0x26    mv a1,a0
    0x84014452    0x28    addi a0,sp,8
    0x84014454    0x2a    jal ra,ffffffff84011488 <lookupCap>
    0x84014458    0x2e    ld s1,8(sp)           ; stack access
    0x8401445a    0x30    bnez s1,ffffffff840144c6 <sendFaultIPC+0x9c>
    0x8401445c    0x32    ld a5,16(sp)          ; stack access
    0x8401445e    0x34    srli a3,a5,0x3b
    0x84014462    0x38    li a4,4
    0x84014464    0x3a    bne a3,a4,ffffffff840144e6 <sendFaultIPC+0xbc>
    0x84014468    0x3e    srli a4,a5,0x37
    0x8401446c    0x42    andi a4,a4,1
    0x8401446e    0x44    beqz a4,ffffffff840144e6 <sendFaultIPC+0xbc>
    0x84014470    0x46    srli a3,a5,0x39
    0x84014474    0x4a    srli a4,a5,0x3a
    0x84014478    0x4e    or a4,a4,a3
    0x8401447a    0x50    andi a4,a4,1
    0x8401447c    0x52    beqz a4,ffffffff840144e6 <sendFaultIPC+0xbc>
    0x8401447e    0x54    ld a2,24(sp)          ; stack access
    0x84014480    0x56    auipc a1,0x4
    0x84014484    0x5a    addi a1,a1,-1152 # ffffffff84018000 <riscvKSASIDTable>
    0x84014488    0x5e    ld a4,1680(a1)
    0x8401448c    0x62    sd a4,312(s0)
    0x84014490    0x66    ld a1,1688(a1)
    0x84014494    0x6a    sd a1,320(s0)
    0x84014498    0x6e    andi a4,a4,15
    0x8401449a    0x70    li a1,1
    0x8401449c    0x72    beq a4,a1,ffffffff840144dc <sendFaultIPC+0xb2>
    0x840144a0    0x76    slli a6,a5,0x19
    0x840144a4    0x7a    srli a6,a6,0x19
    0x840144a8    0x7e    srli a5,a5,0x26
    0x840144aa    0x80    andi a5,a5,1
    0x840144ac    0x82    beqz a5,ffffffff840144b6 <sendFaultIPC+0x8c>
    0x840144ae    0x84    li a5,-1
    0x840144b0    0x86    slli a5,a5,0x27
    0x840144b2    0x88    or a6,a6,a5
    0x840144b6    0x8c    mv a5,s0
    0x840144b8    0x8e    li a4,1
    0x840144ba    0x90    andi a3,a3,1
    0x840144bc    0x92    li a1,1
    0x840144be    0x94    li a0,1
    0x840144c0    0x96    jal ra,ffffffff840142b4 <sendIPC>
    0x840144c4    0x9a    j ffffffff84014502 <sendFaultIPC+0xd8>
    0x840144c6    0x9c    auipc a5,0x4
    0x840144ca    0xa0    addi a5,a5,-1222 # ffffffff84018000 <riscvKSASIDTable>
    0x840144ce    0xa4    li a4,1
    0x840144d0    0xa6    sd a4,1680(a5)
    0x840144d4    0xaa    sd s2,1688(a5)
    0x840144d8    0xae    li s1,1
    0x840144da    0xb0    j ffffffff84014502 <sendFaultIPC+0xd8>
    0x840144dc    0xb2    sd s3,328(s0)
    0x840144e0    0xb6    sd s4,336(s0)
    0x840144e4    0xba    j ffffffff840144a0 <sendFaultIPC+0x76>
    0x840144e6    0xbc    auipc a5,0x4
    0x840144ea    0xc0    addi a5,a5,-1254 # ffffffff84018000 <riscvKSASIDTable>
    0x840144ee    0xc4    li a4,1
    0x840144f0    0xc6    sd a4,1680(a5)
    0x840144f4    0xca    sd s2,1688(a5)
    0x840144f8    0xce    sd a4,1024(a5)
    0x840144fc    0xd2    sd zero,1032(a5)
    0x84014500    0xd6    li s1,1
    0x84014502    0xd8    mv a0,s1
    0x84014504    0xda    ld ra,72(sp)          ; stack access
    0x84014506    0xdc    ld s0,64(sp)          ; stack access
    0x84014508    0xde    ld s1,56(sp)          ; stack access
    0x8401450a    0xe0    ld s2,48(sp)          ; stack access
    0x8401450c    0xe2    ld s3,40(sp)          ; stack access
    0x8401450e    0xe4    ld s4,32(sp)          ; stack access
    0x84014510    0xe6    addi sp,sp,80
    0x84014512    0xe8    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
83 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sendFaultIPC` has 128 nodes.

Section handleReply (179 of 271)
================================

Deriving specifications
-----------------------

Section `handleReply` consists of 22 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleReply`:

    0x84014258     0x0    auipc a0,0x16
    0x8401425c     0x4    ld a0,1504(a0) # ffffffff8402a838 <ksCurThread>
    0x84014260     0x8    andi a5,a0,-1024
    0x84014264     0xc    addi a2,a5,96
    0x84014268    0x10    ld a3,96(a5)
    0x8401426a    0x12    srli a5,a3,0x3b
    0x8401426e    0x16    beqz a5,ffffffff84014294 <handleReply+0x3c>
    0x84014270    0x18    addi sp,sp,-16
    0x84014272    0x1a    sd ra,8(sp)           ; stack access
    0x84014274    0x1c    li a4,8
    0x84014276    0x1e    bne a5,a4,ffffffff84014290 <handleReply+0x38>
    0x8401427a    0x22    andi a5,a3,1
    0x8401427e    0x26    bnez a5,ffffffff84014290 <handleReply+0x38>
    0x84014280    0x28    srli a3,a3,0x1
    0x84014282    0x2a    andi a3,a3,1
    0x84014284    0x2c    ld a1,8(a2)
    0x84014286    0x2e    jal ra,ffffffff840141e4 <doReplyTransfer>
    0x8401428a    0x32    ld ra,8(sp)           ; stack access
    0x8401428c    0x34    addi sp,sp,16
    0x8401428e    0x36    ret
    0x84014290    0x38    jal ra,ffffffff8401041e <halt>
    0x84014294    0x3c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleReply` has 37 nodes.

Section setupCallerCap (180 of 271)
===================================

Deriving specifications
-----------------------

Section `setupCallerCap` consists of 27 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `setupCallerCap`:

    0x84013ea2     0x0    addi sp,sp,-48
    0x84013ea4     0x2    sd ra,40(sp)          ; stack access
    0x84013ea6     0x4    sd s0,32(sp)          ; stack access
    0x84013ea8     0x6    sd s1,24(sp)          ; stack access
    0x84013eaa     0x8    sd s2,16(sp)          ; stack access
    0x84013eac     0xa    mv s2,a0
    0x84013eae     0xc    mv s1,a1
    0x84013eb0     0xe    mv s0,a2
    0x84013eb2    0x10    li a1,5
    0x84013eb4    0x12    jal ra,ffffffff8401263a <setThreadState>
    0x84013eb8    0x16    slli s0,s0,0x1
    0x84013eba    0x18    andi s0,s0,2
    0x84013ebc    0x1a    andi a3,s1,-1024
    0x84013ec0    0x1e    andi a2,s2,-1024
    0x84013ec4    0x22    addi a3,a3,96 # fffffffff8000060 <ki_end+0x73fd1060>
    0x84013ec8    0x26    addi a2,a2,64
    0x84013ecc    0x2a    li a0,1
    0x84013ece    0x2c    slli a0,a0,0x3e
    0x84013ed0    0x2e    or a0,a0,s0
    0x84013ed2    0x30    mv a1,s2
    0x84013ed4    0x32    jal ra,ffffffff840116ba <cteInsert>
    0x84013ed8    0x36    ld ra,40(sp)          ; stack access
    0x84013eda    0x38    ld s0,32(sp)          ; stack access
    0x84013edc    0x3a    ld s1,24(sp)          ; stack access
    0x84013ede    0x3c    ld s2,16(sp)          ; stack access
    0x84013ee0    0x3e    addi sp,sp,48
    0x84013ee2    0x40    ret

Proving inst theorems
---------------------

27 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setupCallerCap` has 38 nodes.

Section c_handle_interrupt (181 of 271)
=======================================

Deriving specifications
-----------------------

Section `c_handle_interrupt` consists of 4 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_interrupt`:

    0x84013e6e    0x0    addi sp,sp,-16
    0x84013e70    0x2    sd ra,8(sp)           ; stack access
    0x84013e72    0x4    jal ra,ffffffff84013e20 <handleInterruptEntry>
    0x84013e76    0x8    jal ra,ffffffff8401037c <restore_user_context>

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_interrupt` has 7 nodes.

Section invokeIRQHandler_SetIRQHandler (182 of 271)
===================================================

Deriving specifications
-----------------------

Section `invokeIRQHandler_SetIRQHandler` consists of 23 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `invokeIRQHandler_SetIRQHandler`:

    0x84013ab0     0x0    addi sp,sp,-48
    0x84013ab2     0x2    sd ra,40(sp)          ; stack access
    0x84013ab4     0x4    sd s0,32(sp)          ; stack access
    0x84013ab6     0x6    sd s1,24(sp)          ; stack access
    0x84013ab8     0x8    sd a1,0(sp)           ; stack access
    0x84013aba     0xa    sd a2,8(sp)           ; stack access
    0x84013abc     0xc    mv s1,a3
    0x84013abe     0xe    slli a0,a0,0x5
    0x84013ac0    0x10    auipc s0,0x5
    0x84013ac4    0x14    addi s0,s0,1344 # ffffffff84019000 <intStateIRQNode>
    0x84013ac8    0x18    add s0,s0,a0
    0x84013aca    0x1a    mv a0,s0
    0x84013acc    0x1c    jal ra,ffffffff84013a7c <cteDeleteOne>
    0x84013ad0    0x20    mv a3,s0
    0x84013ad2    0x22    mv a2,s1
    0x84013ad4    0x24    ld a0,0(sp)           ; stack access
    0x84013ad6    0x26    ld a1,8(sp)           ; stack access
    0x84013ad8    0x28    jal ra,ffffffff840116ba <cteInsert>
    0x84013adc    0x2c    ld ra,40(sp)          ; stack access
    0x84013ade    0x2e    ld s0,32(sp)          ; stack access
    0x84013ae0    0x30    ld s1,24(sp)          ; stack access
    0x84013ae2    0x32    addi sp,sp,48
    0x84013ae4    0x34    ret

Proving inst theorems
---------------------

23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeIRQHandler_SetIRQHandler` has 36 nodes.

Section cancelSignal (183 of 271)
=================================

Deriving specifications
-----------------------

Section `cancelSignal` consists of 49 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `cancelSignal`:

    0x84012ffa     0x0    addi sp,sp,-48
    0x84012ffc     0x2    sd ra,40(sp)          ; stack access
    0x84012ffe     0x4    sd s0,32(sp)          ; stack access
    0x84013000     0x6    sd s1,24(sp)          ; stack access
    0x84013002     0x8    mv s1,a0
    0x84013004     0xa    mv s0,a1
    0x84013006     0xc    ld a5,8(a1)
    0x84013008     0xe    slli a1,a5,0x19
    0x8401300c    0x12    srli a1,a1,0x19
    0x8401300e    0x14    srli a5,a5,0x26
    0x84013010    0x16    andi a5,a5,1
    0x84013012    0x18    beqz a5,ffffffff8401301a <cancelSignal+0x20>
    0x84013014    0x1a    li a5,-1
    0x84013016    0x1c    slli a5,a5,0x27
    0x84013018    0x1e    or a1,a1,a5
    0x8401301a    0x20    ld a5,0(s0)
    0x8401301c    0x22    srli a2,a5,0x19
    0x84013020    0x26    bgez a5,ffffffff8401302a <cancelSignal+0x30>
    0x84013024    0x2a    li a5,-1
    0x84013026    0x2c    slli a5,a5,0x27
    0x84013028    0x2e    or a2,a2,a5
    0x8401302a    0x30    mv a0,s1
    0x8401302c    0x32    jal ra,ffffffff84012ec2 <tcbEPDequeue>
    0x84013030    0x36    ld a3,8(s0)
    0x84013032    0x38    li a4,-1
    0x84013034    0x3a    slli a5,a4,0x27
    0x84013038    0x3e    and a3,a3,a5
    0x8401303a    0x40    srli a4,a4,0x19
    0x8401303c    0x42    and a4,a4,a0
    0x8401303e    0x44    or a4,a4,a3
    0x84013040    0x46    sd a4,8(s0)
    0x84013042    0x48    ld a5,0(s0)
    0x84013044    0x4a    slli a5,a5,0x27
    0x84013046    0x4c    srli a5,a5,0x27
    0x84013048    0x4e    slli a1,a1,0x19
    0x8401304a    0x50    or a5,a5,a1
    0x8401304c    0x52    beqz a0,ffffffff84013062 <cancelSignal+0x68>
    0x8401304e    0x54    sd a5,0(s0)
    0x84013050    0x56    li a1,0
    0x84013052    0x58    mv a0,s1
    0x84013054    0x5a    jal ra,ffffffff8401263a <setThreadState>
    0x84013058    0x5e    ld ra,40(sp)          ; stack access
    0x8401305a    0x60    ld s0,32(sp)          ; stack access
    0x8401305c    0x62    ld s1,24(sp)          ; stack access
    0x8401305e    0x64    addi sp,sp,48
    0x84013060    0x66    ret
    0x84013062    0x68    andi a5,a5,-4
    0x84013064    0x6a    sd a5,0(s0)
    0x84013066    0x6c    j ffffffff84013050 <cancelSignal+0x56>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
49 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelSignal` has 71 nodes.

Section switchToThread (184 of 271)
===================================

Deriving specifications
-----------------------

Section `switchToThread` consists of 13 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `switchToThread`:

    0x84012be8     0x0    addi sp,sp,-16
    0x84012bea     0x2    sd ra,8(sp)           ; stack access
    0x84012bec     0x4    sd s0,0(sp)           ; stack access
    0x84012bee     0x6    mv s0,a0
    0x84012bf0     0x8    jal ra,ffffffff84010be2 <setVMRoot>
    0x84012bf4     0xc    mv a0,s0
    0x84012bf6     0xe    jal ra,ffffffff84012b0c <tcbSchedDequeue>
    0x84012bfa    0x12    auipc a5,0x18
    0x84012bfe    0x16    sd s0,-962(a5) # ffffffff8402a838 <ksCurThread>
    0x84012c02    0x1a    ld ra,8(sp)           ; stack access
    0x84012c04    0x1c    ld s0,0(sp)           ; stack access
    0x84012c06    0x1e    addi sp,sp,16
    0x84012c08    0x20    ret

Proving inst theorems
---------------------

13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `switchToThread` has 21 nodes.

Section timerTick (185 of 271)
==============================

Deriving specifications
-----------------------

Section `timerTick` consists of 28 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `timerTick`:

    0x84012aba     0x0    addi sp,sp,-16
    0x84012abc     0x2    sd ra,8(sp)           ; stack access
    0x84012abe     0x4    auipc a0,0x18
    0x84012ac2     0x8    ld a0,-646(a0) # ffffffff8402a838 <ksCurThread>
    0x84012ac6     0xc    ld a5,280(a0)
    0x84012aca    0x10    andi a5,a5,15
    0x84012acc    0x12    li a4,1
    0x84012ace    0x14    bne a5,a4,ffffffff84012ae0 <timerTick+0x26>
    0x84012ad2    0x18    ld a5,368(a0)
    0x84012ad6    0x1c    bgeu a4,a5,ffffffff84012af6 <timerTick+0x3c>
    0x84012ada    0x20    addi a5,a5,-1
    0x84012adc    0x22    sd a5,368(a0)
    0x84012ae0    0x26    auipc a4,0x18
    0x84012ae4    0x2a    addi a4,a4,-720 # ffffffff8402a810 <ksDomainTime>
    0x84012ae8    0x2e    ld a5,0(a4)
    0x84012aea    0x30    addi a5,a5,-1
    0x84012aec    0x32    sd a5,0(a4)
    0x84012aee    0x34    beqz a5,ffffffff84012b06 <timerTick+0x4c>
    0x84012af0    0x36    ld ra,8(sp)           ; stack access
    0x84012af2    0x38    addi sp,sp,16
    0x84012af4    0x3a    ret
    0x84012af6    0x3c    li a5,5
    0x84012af8    0x3e    sd a5,368(a0)
    0x84012afc    0x42    jal ra,ffffffff84012a22 <tcbSchedAppend>
    0x84012b00    0x46    jal ra,ffffffff840125d4 <rescheduleRequired>
    0x84012b04    0x4a    j ffffffff84012ae0 <timerTick+0x26>
    0x84012b06    0x4c    jal ra,ffffffff840125d4 <rescheduleRequired>
    0x84012b0a    0x50    j ffffffff84012af0 <timerTick+0x36>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
28 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `timerTick` has 47 nodes.

Section possibleSwitchTo (186 of 271)
=====================================

Deriving specifications
-----------------------

Section `possibleSwitchTo` consists of 23 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `possibleSwitchTo`:

    0x84012934     0x0    addi sp,sp,-16
    0x84012936     0x2    sd ra,8(sp)           ; stack access
    0x84012938     0x4    sd s0,0(sp)           ; stack access
    0x8401293a     0x6    mv s0,a0
    0x8401293c     0x8    ld a4,344(a0)
    0x84012940     0xc    auipc a5,0x18
    0x84012944    0x10    ld a5,-296(a5) # ffffffff8402a818 <ksCurDomain>
    0x84012948    0x14    bne a4,a5,ffffffff84012962 <possibleSwitchTo+0x2e>
    0x8401294c    0x18    auipc a5,0x18
    0x84012950    0x1c    ld a5,-292(a5) # ffffffff8402a828 <ksSchedulerAction>
    0x84012954    0x20    beqz a5,ffffffff8401296e <possibleSwitchTo+0x3a>
    0x84012956    0x22    jal ra,ffffffff840125d4 <rescheduleRequired>
    0x8401295a    0x26    mv a0,s0
    0x8401295c    0x28    jal ra,ffffffff8401253a <tcbSchedEnqueue>
    0x84012960    0x2c    j ffffffff84012966 <possibleSwitchTo+0x32>
    0x84012962    0x2e    jal ra,ffffffff8401253a <tcbSchedEnqueue>
    0x84012966    0x32    ld ra,8(sp)           ; stack access
    0x84012968    0x34    ld s0,0(sp)           ; stack access
    0x8401296a    0x36    addi sp,sp,16
    0x8401296c    0x38    ret
    0x8401296e    0x3a    auipc a5,0x18
    0x84012972    0x3e    sd a0,-326(a5) # ffffffff8402a828 <ksSchedulerAction>
    0x84012976    0x42    j ffffffff84012966 <possibleSwitchTo+0x32>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `possibleSwitchTo` has 39 nodes.

Section activateThread (187 of 271)
===================================

Deriving specifications
-----------------------

Section `activateThread` consists of 20 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `activateThread`:

    0x84012744     0x0    addi sp,sp,-16
    0x84012746     0x2    sd ra,8(sp)           ; stack access
    0x84012748     0x4    auipc a0,0x18
    0x8401274c     0x8    ld a0,240(a0) # ffffffff8402a838 <ksCurThread>
    0x84012750     0xc    ld a5,280(a0)
    0x84012754    0x10    andi a5,a5,15
    0x84012756    0x12    li a4,2
    0x84012758    0x14    beq a5,a4,ffffffff8401276c <activateThread+0x28>
    0x8401275c    0x18    li a4,7
    0x8401275e    0x1a    beq a5,a4,ffffffff8401277a <activateThread+0x36>
    0x84012762    0x1e    li a4,1
    0x84012764    0x20    beq a5,a4,ffffffff8401277a <activateThread+0x36>
    0x84012768    0x24    jal ra,ffffffff8401041e <halt>
    0x8401276c    0x28    ld a5,264(a0)
    0x84012770    0x2c    sd a5,272(a0)
    0x84012774    0x30    li a1,1
    0x84012776    0x32    jal ra,ffffffff8401263a <setThreadState>
    0x8401277a    0x36    ld ra,8(sp)           ; stack access
    0x8401277c    0x38    addi sp,sp,16
    0x8401277e    0x3a    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `activateThread` has 35 nodes.

Section createObject (188 of 271)
=================================

Deriving specifications
-----------------------

Section `createObject` consists of 76 instructions.


Stack analysis
---------------

16 stack accesses found. Annotated code for `createObject`:

    0x84012406     0x0    addi sp,sp,-32
    0x84012408     0x2    sd ra,24(sp)          ; stack access
    0x8401240a     0x4    li a5,4
    0x8401240c     0x6    bltu a5,a0,ffffffff84012450 <createObject+0x4a>
    0x84012410     0xa    li a5,2
    0x84012412     0xc    beq a0,a5,ffffffff84012480 <createObject+0x7a>
    0x84012416    0x10    bltu a5,a0,ffffffff84012462 <createObject+0x5c>
    0x8401241a    0x14    beqz a0,ffffffff840124a2 <createObject+0x9c>
    0x8401241c    0x16    li a5,1
    0x8401241e    0x18    bne a0,a5,ffffffff840124be <createObject+0xb8>
    0x84012422    0x1c    li a5,32
    0x84012426    0x20    sd a5,768(a1) # fffffffff8000300 <ki_end+0x73fd1300>
    0x8401242a    0x24    li a5,5
    0x8401242c    0x26    sd a5,880(a1)
    0x84012430    0x2a    auipc a5,0x18
    0x84012434    0x2e    ld a5,1000(a5) # ffffffff8402a818 <ksCurDomain>
    0x84012438    0x32    sd a5,856(a1)
    0x8401243c    0x36    addi a1,a1,512
    0x84012440    0x3a    slli a1,a1,0x19
    0x84012442    0x3c    srli a1,a1,0x19
    0x84012444    0x3e    li a5,3
    0x84012446    0x40    slli a5,a5,0x3d
    0x84012448    0x42    or a1,a1,a5
    0x8401244a    0x44    sd a1,0(sp)           ; stack access
    0x8401244c    0x46    sd zero,8(sp)         ; stack access
    0x8401244e    0x48    j ffffffff84012458 <createObject+0x52>
    0x84012450    0x4a    jal ra,ffffffff84011298 <Arch_createObject>
    0x84012454    0x4e    sd a0,0(sp)           ; stack access
    0x84012456    0x50    sd a1,8(sp)           ; stack access
    0x84012458    0x52    ld a0,0(sp)           ; stack access
    0x8401245a    0x54    ld a1,8(sp)           ; stack access
    0x8401245c    0x56    ld ra,24(sp)          ; stack access
    0x8401245e    0x58    addi sp,sp,32
    0x84012460    0x5a    ret
    0x84012462    0x5c    li a5,3
    0x84012464    0x5e    beq a0,a5,ffffffff84012492 <createObject+0x8c>
    0x84012468    0x62    andi a2,a2,63
    0x8401246c    0x66    slli a2,a2,0x2f
    0x8401246e    0x68    slli a1,a1,0x19
    0x84012470    0x6a    srli a1,a1,0x1a
    0x84012472    0x6c    or a2,a2,a1
    0x84012474    0x6e    li a1,5
    0x84012476    0x70    slli a1,a1,0x3c
    0x84012478    0x72    or a2,a2,a1
    0x8401247a    0x74    sd a2,0(sp)           ; stack access
    0x8401247c    0x76    sd zero,8(sp)         ; stack access
    0x8401247e    0x78    j ffffffff84012458 <createObject+0x52>
    0x84012480    0x7a    slli a1,a1,0x19
    0x84012482    0x7c    srli a1,a1,0x19
    0x84012484    0x7e    li a5,79
    0x84012488    0x82    slli a5,a5,0x37
    0x8401248a    0x84    or a1,a1,a5
    0x8401248c    0x86    sd a1,0(sp)           ; stack access
    0x8401248e    0x88    sd zero,8(sp)         ; stack access
    0x84012490    0x8a    j ffffffff84012458 <createObject+0x52>
    0x84012492    0x8c    slli a1,a1,0x19
    0x84012494    0x8e    srli a1,a1,0x19
    0x84012496    0x90    li a5,27
    0x84012498    0x92    slli a5,a5,0x39
    0x8401249a    0x94    or a1,a1,a5
    0x8401249c    0x96    sd a1,0(sp)           ; stack access
    0x8401249e    0x98    sd zero,8(sp)         ; stack access
    0x840124a0    0x9a    j ffffffff84012458 <createObject+0x52>
    0x840124a2    0x9c    slli a1,a1,0x19
    0x840124a4    0x9e    srli a1,a1,0x19
    0x840124a6    0xa0    li a5,1
    0x840124a8    0xa2    slli a5,a5,0x3c
    0x840124aa    0xa4    or a1,a1,a5
    0x840124ac    0xa6    sd a1,0(sp)           ; stack access
    0x840124ae    0xa8    snez a3,a3
    0x840124b2    0xac    slli a3,a3,0x6
    0x840124b4    0xae    andi a2,a2,63
    0x840124b8    0xb2    or a2,a2,a3
    0x840124ba    0xb4    sd a2,8(sp)           ; stack access
    0x840124bc    0xb6    j ffffffff84012458 <createObject+0x52>
    0x840124be    0xb8    jal ra,ffffffff8401041e <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
76 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `createObject` has 111 nodes.

Section maskCapRights (189 of 271)
==================================

Deriving specifications
-----------------------

Section `maskCapRights` consists of 111 instructions.


Stack analysis
---------------

17 stack accesses found. Annotated code for `maskCapRights`:

    0x840122de      0x0    addi sp,sp,-48
    0x840122e0      0x2    sd ra,40(sp)          ; stack access
    0x840122e2      0x4    sd a1,0(sp)           ; stack access
    0x840122e4      0x6    sd a2,8(sp)           ; stack access
    0x840122e6      0x8    srli a5,a1,0x3b
    0x840122ea      0xc    andi a4,a5,1
    0x840122ee     0x10    bnez a4,ffffffff84012350 <maskCapRights+0x72>
    0x840122f0     0x12    ld a3,8(sp)           ; stack access
    0x840122f2     0x14    li a4,20
    0x840122f4     0x16    bltu a4,a5,ffffffff840123e4 <maskCapRights+0x106>
    0x840122f8     0x1a    li a4,5
    0x840122fa     0x1c    bgeu a4,a5,ffffffff84012362 <maskCapRights+0x84>
    0x840122fe     0x20    li a4,1
    0x84012300     0x22    sll a5,a4,a5
    0x84012304     0x26    lui a4,0x155
    0x84012308     0x2a    addi a4,a4,1024 # 155400 <KERNEL_OFFSET-0xfffffffeffeaac00>
    0x8401230c     0x2e    and a4,a4,a5
    0x8401230e     0x30    bnez a4,ffffffff840123e8 <maskCapRights+0x10a>
    0x84012310     0x32    andi a4,a5,256
    0x84012314     0x36    bnez a4,ffffffff840123ee <maskCapRights+0x110>
    0x84012316     0x38    andi a5,a5,64
    0x8401231a     0x3c    beqz a5,ffffffff840123e4 <maskCapRights+0x106>
    0x8401231c     0x3e    srli a5,a1,0x39
    0x84012320     0x42    and a5,a5,a0
    0x84012322     0x44    li a4,1
    0x84012324     0x46    and a5,a5,a4
    0x84012326     0x48    slli a5,a5,0x39
    0x84012328     0x4a    li a2,-1
    0x8401232a     0x4c    slli a6,a2,0x39
    0x8401232e     0x50    addi a6,a6,-1
    0x84012330     0x52    and a6,a1,a6
    0x84012334     0x56    or a5,a5,a6
    0x84012338     0x5a    slli a2,a2,0x3a
    0x8401233a     0x5c    addi a2,a2,-1
    0x8401233c     0x5e    and a5,a5,a2
    0x8401233e     0x60    srli a0,a0,0x1
    0x84012340     0x62    srli a1,a1,0x3a
    0x84012342     0x64    and a1,a1,a0
    0x84012344     0x66    and a4,a4,a1
    0x84012346     0x68    slli a4,a4,0x3a
    0x84012348     0x6a    or a5,a5,a4
    0x8401234a     0x6c    sd a5,16(sp)          ; stack access
    0x8401234c     0x6e    sd a3,24(sp)          ; stack access
    0x8401234e     0x70    j ffffffff84012358 <maskCapRights+0x7a>
    0x84012350     0x72    jal ra,ffffffff84010f0c <Arch_maskCapRights>
    0x84012354     0x76    sd a0,16(sp)          ; stack access
    0x84012356     0x78    sd a1,24(sp)          ; stack access
    0x84012358     0x7a    ld a0,16(sp)          ; stack access
    0x8401235a     0x7c    ld a1,24(sp)          ; stack access
    0x8401235c     0x7e    ld ra,40(sp)          ; stack access
    0x8401235e     0x80    addi sp,sp,48
    0x84012360     0x82    ret
    0x84012362     0x84    li a4,4
    0x84012364     0x86    bne a5,a4,ffffffff840123dc <maskCapRights+0xfe>
    0x84012368     0x8a    srli a5,a1,0x37
    0x8401236c     0x8e    and a5,a5,a0
    0x8401236e     0x90    li a4,1
    0x84012370     0x92    and a5,a5,a4
    0x84012372     0x94    slli a5,a5,0x37
    0x84012374     0x96    li a2,-1
    0x84012376     0x98    slli a6,a2,0x37
    0x8401237a     0x9c    addi a6,a6,-1
    0x8401237c     0x9e    and a6,a1,a6
    0x84012380     0xa2    or a5,a5,a6
    0x84012384     0xa6    slli a6,a2,0x38
    0x84012388     0xaa    addi a6,a6,-1
    0x8401238a     0xac    and a5,a5,a6
    0x8401238e     0xb0    srli a6,a0,0x1
    0x84012392     0xb4    srli a7,a1,0x38
    0x84012396     0xb8    and a6,a6,a7
    0x8401239a     0xbc    and a6,a4,a6
    0x8401239e     0xc0    slli a6,a6,0x38
    0x840123a0     0xc2    or a5,a5,a6
    0x840123a4     0xc6    slli a6,a2,0x39
    0x840123a8     0xca    addi a6,a6,-1
    0x840123aa     0xcc    and a5,a5,a6
    0x840123ae     0xd0    srli a6,a0,0x2
    0x840123b2     0xd4    srli a7,a1,0x39
    0x840123b6     0xd8    and a6,a6,a7
    0x840123ba     0xdc    and a6,a4,a6
    0x840123be     0xe0    slli a6,a6,0x39
    0x840123c0     0xe2    or a5,a5,a6
    0x840123c4     0xe6    slli a2,a2,0x3a
    0x840123c6     0xe8    addi a2,a2,-1
    0x840123c8     0xea    and a5,a5,a2
    0x840123ca     0xec    srli a0,a0,0x3
    0x840123cc     0xee    srli a1,a1,0x3a
    0x840123ce     0xf0    and a1,a1,a0
    0x840123d0     0xf2    and a4,a4,a1
    0x840123d2     0xf4    slli a4,a4,0x3a
    0x840123d4     0xf6    or a5,a5,a4
    0x840123d6     0xf8    sd a5,16(sp)          ; stack access
    0x840123d8     0xfa    sd a3,24(sp)          ; stack access
    0x840123da     0xfc    j ffffffff84012358 <maskCapRights+0x7a>
    0x840123dc     0xfe    bltu a4,a5,ffffffff840123e4 <maskCapRights+0x106>
    0x840123e0    0x102    andi a5,a5,-3
    0x840123e2    0x104    beqz a5,ffffffff840123e8 <maskCapRights+0x10a>
    0x840123e4    0x106    jal ra,ffffffff8401041e <halt>
    0x840123e8    0x10a    sd a1,16(sp)          ; stack access
    0x840123ea    0x10c    sd a3,24(sp)          ; stack access
    0x840123ec    0x10e    j ffffffff84012358 <maskCapRights+0x7a>
    0x840123ee    0x110    srli a5,a0,0x2
    0x840123f2    0x114    srli a0,a1,0x1
    0x840123f6    0x118    and a5,a5,a0
    0x840123f8    0x11a    slli a5,a5,0x1
    0x840123fa    0x11c    andi a5,a5,2
    0x840123fc    0x11e    andi a1,a1,-3
    0x840123fe    0x120    or a1,a1,a5
    0x84012400    0x122    sd a1,16(sp)          ; stack access
    0x84012402    0x124    sd a3,24(sp)          ; stack access
    0x84012404    0x126    j ffffffff84012358 <maskCapRights+0x7a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
111 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `maskCapRights` has 149 nodes.

Section sameObjectAs (190 of 271)
=================================

Deriving specifications
-----------------------

Section `sameObjectAs` consists of 37 instructions.


Stack analysis
---------------

14 stack accesses found. Annotated code for `sameObjectAs`:

    0x84012166     0x0    addi sp,sp,-48
    0x84012168     0x2    sd ra,40(sp)          ; stack access
    0x8401216a     0x4    sd a0,16(sp)          ; stack access
    0x8401216c     0x6    sd a1,24(sp)          ; stack access
    0x8401216e     0x8    sd a2,0(sp)           ; stack access
    0x84012170     0xa    sd a3,8(sp)           ; stack access
    0x84012172     0xc    srli a0,a0,0x3b
    0x84012174     0xe    li a5,2
    0x84012176    0x10    beq a0,a5,ffffffff840121ba <sameObjectAs+0x54>
    0x8401217a    0x14    li a4,14
    0x8401217c    0x16    beq a0,a4,ffffffff8401219e <sameObjectAs+0x38>
    0x84012180    0x1a    andi a0,a0,1
    0x84012182    0x1c    beqz a0,ffffffff8401218c <sameObjectAs+0x26>
    0x84012184    0x1e    srli a5,a2,0x3b
    0x84012188    0x22    andi a5,a5,1
    0x8401218a    0x24    bnez a5,ffffffff840121ac <sameObjectAs+0x46>
    0x8401218c    0x26    ld a2,0(sp)           ; stack access
    0x8401218e    0x28    ld a3,8(sp)           ; stack access
    0x84012190    0x2a    ld a0,16(sp)          ; stack access
    0x84012192    0x2c    ld a1,24(sp)          ; stack access
    0x84012194    0x2e    jal ra,ffffffff84011cde <sameRegionAs>
    0x84012198    0x32    ld ra,40(sp)          ; stack access
    0x8401219a    0x34    addi sp,sp,48
    0x8401219c    0x36    ret
    0x8401219e    0x38    srli a5,a2,0x3b
    0x840121a2    0x3c    li a4,16
    0x840121a4    0x3e    li a0,0
    0x840121a6    0x40    bne a5,a4,ffffffff8401218c <sameObjectAs+0x26>
    0x840121aa    0x44    j ffffffff84012198 <sameObjectAs+0x32>
    0x840121ac    0x46    ld a2,0(sp)           ; stack access
    0x840121ae    0x48    ld a3,8(sp)           ; stack access
    0x840121b0    0x4a    ld a0,16(sp)          ; stack access
    0x840121b2    0x4c    ld a1,24(sp)          ; stack access
    0x840121b4    0x4e    jal ra,ffffffff840111c6 <Arch_sameObjectAs>
    0x840121b8    0x52    j ffffffff84012198 <sameObjectAs+0x32>
    0x840121ba    0x54    li a0,0
    0x840121bc    0x56    j ffffffff84012198 <sameObjectAs+0x32>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
37 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sameObjectAs` has 64 nodes.

Section deriveCap (191 of 271)
==============================

Deriving specifications
-----------------------

Section `deriveCap` consists of 51 instructions.


Stack analysis
---------------

Section `deriveCap` expects pointer to stack in a0.
16 stack accesses found. Annotated code for `deriveCap`:

    0x840120ec     0x0    addi sp,sp,-64
    0x840120ee     0x2    sd ra,56(sp)          ; stack access
    0x840120f0     0x4    sd s0,48(sp)          ; stack access
    0x840120f2     0x6    sd s1,40(sp)          ; stack access
    0x840120f4     0x8    sd s2,32(sp)          ; stack access
    0x840120f6     0xa    sd s3,24(sp)          ; stack access
    0x840120f8     0xc    mv s0,a0
    0x840120fa     0xe    sd a2,0(sp)           ; stack access
    0x840120fc    0x10    sd a3,8(sp)           ; stack access
    0x840120fe    0x12    mv s1,a2
    0x84012100    0x14    srli a5,a2,0x3b
    0x84012104    0x18    andi s3,a5,1
    0x84012108    0x1c    bnez s3,ffffffff8401212a <deriveCap+0x3e>
    0x8401210c    0x20    ld s2,8(sp)           ; stack access
    0x8401210e    0x22    li a4,8
    0x84012110    0x24    beq a5,a4,ffffffff84012158 <deriveCap+0x6c>
    0x84012114    0x28    bltu a4,a5,ffffffff84012130 <deriveCap+0x44>
    0x84012118    0x2c    li a4,2
    0x8401211a    0x2e    bne a5,a4,ffffffff84012136 <deriveCap+0x4a>
    0x8401211e    0x32    mv a0,a1
    0x84012120    0x34    jal ra,ffffffff840120ae <ensureNoChildren>
    0x84012124    0x38    bnez a0,ffffffff8401215e <deriveCap+0x72>
    0x84012126    0x3a    mv s3,a0
    0x84012128    0x3c    j ffffffff84012136 <deriveCap+0x4a>
    0x8401212a    0x3e    jal ra,ffffffff84010e9e <Arch_deriveCap>
    0x8401212e    0x42    j ffffffff84012140 <deriveCap+0x54>
    0x84012130    0x44    addi a5,a5,-14
    0x84012132    0x46    andi a5,a5,-5
    0x84012134    0x48    beqz a5,ffffffff84012150 <deriveCap+0x64>
    0x84012136    0x4a    sd s3,0(s0)           ; stack access
    0x8401213a    0x4e    sd s1,8(s0)           ; stack access
    0x8401213c    0x50    sd s2,16(s0)          ; stack access
    0x84012140    0x54    mv a0,s0
    0x84012142    0x56    ld ra,56(sp)          ; stack access
    0x84012144    0x58    ld s0,48(sp)          ; stack access
    0x84012146    0x5a    ld s1,40(sp)          ; stack access
    0x84012148    0x5c    ld s2,32(sp)          ; stack access
    0x8401214a    0x5e    ld s3,24(sp)          ; stack access
    0x8401214c    0x60    addi sp,sp,64
    0x8401214e    0x62    ret
    0x84012150    0x64    mv s2,a5
    0x84012152    0x66    mv s1,a5
    0x84012154    0x68    mv s3,a5
    0x84012156    0x6a    j ffffffff84012136 <deriveCap+0x4a>
    0x84012158    0x6c    mv s2,s3
    0x8401215a    0x6e    mv s1,s3
    0x8401215c    0x70    j ffffffff84012136 <deriveCap+0x4a>
    0x8401215e    0x72    mv s2,s3
    0x84012160    0x74    mv s1,s3
    0x84012162    0x76    mv s3,a0
    0x84012164    0x78    j ffffffff84012136 <deriveCap+0x4a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
51 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deriveCap` has 82 nodes.

Section getObjectSize (192 of 271)
==================================

Deriving specifications
-----------------------

Section `getObjectSize` consists of 27 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `getObjectSize`:

    0x84011c66     0x0    addi sp,sp,-16
    0x84011c68     0x2    sd ra,8(sp)           ; stack access
    0x84011c6a     0x4    mv a5,a0
    0x84011c6c     0x6    li a4,4
    0x84011c6e     0x8    bltu a4,a0,ffffffff84011c8c <getObjectSize+0x26>
    0x84011c72     0xc    li a4,2
    0x84011c74     0xe    beq a0,a4,ffffffff84011ca4 <getObjectSize+0x3e>
    0x84011c78    0x12    bltu a4,a0,ffffffff84011c92 <getObjectSize+0x2c>
    0x84011c7c    0x16    beqz a0,ffffffff84011ca8 <getObjectSize+0x42>
    0x84011c7e    0x18    li a4,1
    0x84011c80    0x1a    li a0,10
    0x84011c82    0x1c    bne a5,a4,ffffffff84011ca0 <getObjectSize+0x3a>
    0x84011c86    0x20    ld ra,8(sp)           ; stack access
    0x84011c88    0x22    addi sp,sp,16
    0x84011c8a    0x24    ret
    0x84011c8c    0x26    jal ra,ffffffff84011266 <Arch_getObjectSize>
    0x84011c90    0x2a    j ffffffff84011c86 <getObjectSize+0x20>
    0x84011c92    0x2c    li a4,3
    0x84011c94    0x2e    li a0,5
    0x84011c96    0x30    beq a5,a4,ffffffff84011c86 <getObjectSize+0x20>
    0x84011c9a    0x34    addi a0,a1,5 # fffffffff8000005 <ki_end+0x73fd1005>
    0x84011c9e    0x38    j ffffffff84011c86 <getObjectSize+0x20>
    0x84011ca0    0x3a    jal ra,ffffffff8401041e <halt>
    0x84011ca4    0x3e    li a0,4
    0x84011ca6    0x40    j ffffffff84011c86 <getObjectSize+0x20>
    0x84011ca8    0x42    mv a0,a1
    0x84011caa    0x44    j ffffffff84011c86 <getObjectSize+0x20>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
27 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getObjectSize` has 44 nodes.

Section invokeIRQControl (193 of 271)
=====================================

Deriving specifications
-----------------------

Section `invokeIRQControl` consists of 25 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `invokeIRQControl`:

    0x84011b2a     0x0    addi sp,sp,-48
    0x84011b2c     0x2    sd ra,40(sp)          ; stack access
    0x84011b2e     0x4    sd s0,32(sp)          ; stack access
    0x84011b30     0x6    sd s1,24(sp)          ; stack access
    0x84011b32     0x8    sd s2,16(sp)          ; stack access
    0x84011b34     0xa    mv s0,a0
    0x84011b36     0xc    mv s2,a1
    0x84011b38     0xe    mv s1,a2
    0x84011b3a    0x10    mv a1,a0
    0x84011b3c    0x12    li a0,1
    0x84011b3e    0x14    jal ra,ffffffff84011ac2 <setIRQState>
    0x84011b42    0x18    slli s0,s0,0x34
    0x84011b44    0x1a    mv a3,s2
    0x84011b46    0x1c    mv a2,s1
    0x84011b48    0x1e    li a0,-1
    0x84011b4a    0x20    slli a0,a0,0x3f
    0x84011b4c    0x22    srli a1,s0,0x34
    0x84011b50    0x26    jal ra,ffffffff840116ba <cteInsert>
    0x84011b54    0x2a    li a0,0
    0x84011b56    0x2c    ld ra,40(sp)          ; stack access
    0x84011b58    0x2e    ld s0,32(sp)          ; stack access
    0x84011b5a    0x30    ld s1,24(sp)          ; stack access
    0x84011b5c    0x32    ld s2,16(sp)          ; stack access
    0x84011b5e    0x34    addi sp,sp,48
    0x84011b60    0x36    ret

Proving inst theorems
---------------------

25 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeIRQControl` has 36 nodes.

Section getReceiveSlots (194 of 271)
====================================

Deriving specifications
-----------------------

Section `getReceiveSlots` consists of 38 instructions.

RVC_FFFT__________FF.

Stack analysis
---------------

13 stack accesses found. Annotated code for `getReceiveSlots`:

    0x84011a26     0x0    beqz a1,ffffffff84011a7a <getReceiveSlots+0x54>
    0x84011a28     0x2    addi sp,sp,-96
    0x84011a2a     0x4    sd ra,88(sp)          ; stack access
    0x84011a2c     0x6    sd s0,80(sp)          ; stack access
    0x84011a2e     0x8    sd s1,72(sp)          ; stack access
    0x84011a30     0xa    ld s0,1008(a1) # fffffffff80003f0 <ki_end+0x73fd13f0>
    0x84011a34     0xe    ld s1,1016(a1)
    0x84011a38    0x12    ld a2,1000(a1)
    0x84011a3c    0x16    mv a1,a0
    0x84011a3e    0x18    addi a0,sp,40
    0x84011a40    0x1a    jal ra,ffffffff84011488 <lookupCap>
    0x84011a44    0x1e    ld a5,40(sp)          ; stack access
    0x84011a46    0x20    li a0,0
    0x84011a48    0x22    bnez a5,ffffffff84011a70 <getReceiveSlots+0x4a>
    0x84011a4a    0x24    ld a0,48(sp)          ; stack access
    0x84011a4c    0x26    sd a0,8(sp)           ; stack access
    0x84011a4e    0x28    ld a1,56(sp)          ; stack access
    0x84011a50    0x2a    sd a1,16(sp)          ; stack access
    0x84011a52    0x2c    mv a3,s1
    0x84011a54    0x2e    mv a2,s0
    0x84011a56    0x30    jal ra,ffffffff840115ea <lookupTargetSlot>
    0x84011a5a    0x34    sd a0,24(sp)          ; stack access
    0x84011a5c    0x36    sd a1,32(sp)          ; stack access
    0x84011a5e    0x38    bnez a0,ffffffff84011a7e <getReceiveSlots+0x58>
    0x84011a60    0x3a    ld a5,0(a1)
    0x84011a62    0x3c    srli a5,a5,0x3b
    0x84011a64    0x3e    seqz a5,a5
    0x84011a68    0x42    neg a5,a5
    0x84011a6c    0x46    and a0,a1,a5
    0x84011a70    0x4a    ld ra,88(sp)          ; stack access
    0x84011a72    0x4c    ld s0,80(sp)          ; stack access
    0x84011a74    0x4e    ld s1,72(sp)          ; stack access
    0x84011a76    0x50    addi sp,sp,96
    0x84011a78    0x52    ret
    0x84011a7a    0x54    mv a0,a1
    0x84011a7c    0x56    ret
    0x84011a7e    0x58    li a0,0
    0x84011a80    0x5a    j ffffffff84011a70 <getReceiveSlots+0x4a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
38 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getReceiveSlots` has 65 nodes.

Section invokeCNodeRotate (195 of 271)
======================================

Deriving specifications
-----------------------

Section `invokeCNodeRotate` consists of 32 instructions.


Stack analysis
---------------

15 stack accesses found. Annotated code for `invokeCNodeRotate`:

    0x8401192e     0x0    addi sp,sp,-64
    0x84011930     0x2    sd ra,56(sp)          ; stack access
    0x84011932     0x4    sd s0,48(sp)          ; stack access
    0x84011934     0x6    sd s1,40(sp)          ; stack access
    0x84011936     0x8    sd a0,16(sp)          ; stack access
    0x84011938     0xa    sd a1,24(sp)          ; stack access
    0x8401193a     0xc    sd a2,0(sp)           ; stack access
    0x8401193c     0xe    sd a3,8(sp)           ; stack access
    0x8401193e    0x10    mv s0,a4
    0x84011940    0x12    mv s1,a5
    0x84011942    0x14    beq a4,a6,ffffffff8401196a <invokeCNodeRotate+0x3c>
    0x84011946    0x18    mv a3,a6
    0x84011948    0x1a    mv a2,a5
    0x8401194a    0x1c    ld a0,0(sp)           ; stack access
    0x8401194c    0x1e    ld a1,8(sp)           ; stack access
    0x8401194e    0x20    jal ra,ffffffff840117f6 <cteMove>
    0x84011952    0x24    mv a3,s1
    0x84011954    0x26    mv a2,s0
    0x84011956    0x28    ld a0,16(sp)          ; stack access
    0x84011958    0x2a    ld a1,24(sp)          ; stack access
    0x8401195a    0x2c    jal ra,ffffffff840117f6 <cteMove>
    0x8401195e    0x30    li a0,0
    0x84011960    0x32    ld ra,56(sp)          ; stack access
    0x84011962    0x34    ld s0,48(sp)          ; stack access
    0x84011964    0x36    ld s1,40(sp)          ; stack access
    0x84011966    0x38    addi sp,sp,64
    0x84011968    0x3a    ret
    0x8401196a    0x3c    mv a3,a2
    0x8401196c    0x3e    ld a4,8(sp)           ; stack access
    0x8401196e    0x40    mv a2,s0
    0x84011970    0x42    jal ra,ffffffff840118a2 <cteSwap>
    0x84011974    0x46    j ffffffff8401195e <invokeCNodeRotate+0x30>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
32 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeRotate` has 53 nodes.

Section invokeCNodeSaveCaller (196 of 271)
==========================================

Deriving specifications
-----------------------

Section `invokeCNodeSaveCaller` consists of 26 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `invokeCNodeSaveCaller`:

    0x8401185e     0x0    addi sp,sp,-32
    0x84011860     0x2    sd ra,24(sp)          ; stack access
    0x84011862     0x4    auipc a5,0x19
    0x84011866     0x8    ld a5,-42(a5) # ffffffff8402a838 <ksCurThread>
    0x8401186a     0xc    andi a5,a5,-1024
    0x8401186e    0x10    addi a2,a5,96
    0x84011872    0x14    ld a5,96(a5)
    0x84011874    0x16    sd a5,0(sp)           ; stack access
    0x84011876    0x18    ld a4,8(a2)
    0x84011878    0x1a    sd a4,8(sp)           ; stack access
    0x8401187a    0x1c    srli a4,a5,0x3b
    0x8401187e    0x20    beqz a4,ffffffff8401188a <invokeCNodeSaveCaller+0x2c>
    0x84011880    0x22    li a3,8
    0x84011882    0x24    bne a4,a3,ffffffff8401189e <invokeCNodeSaveCaller+0x40>
    0x84011886    0x28    andi a5,a5,1
    0x84011888    0x2a    beqz a5,ffffffff84011892 <invokeCNodeSaveCaller+0x34>
    0x8401188a    0x2c    li a0,0
    0x8401188c    0x2e    ld ra,24(sp)          ; stack access
    0x8401188e    0x30    addi sp,sp,32
    0x84011890    0x32    ret
    0x84011892    0x34    mv a3,a0
    0x84011894    0x36    ld a0,0(sp)           ; stack access
    0x84011896    0x38    ld a1,8(sp)           ; stack access
    0x84011898    0x3a    jal ra,ffffffff840117f6 <cteMove>
    0x8401189c    0x3e    j ffffffff8401188a <invokeCNodeSaveCaller+0x2c>
    0x8401189e    0x40    jal ra,ffffffff8401041e <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
26 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeSaveCaller` has 44 nodes.

Section handleFaultReply (197 of 271)
=====================================

Deriving specifications
-----------------------

Section `handleFaultReply` consists of 123 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `handleFaultReply`:

    0x84010876      0x0    addi sp,sp,-48
    0x84010878      0x2    sd ra,40(sp)          ; stack access
    0x8401087a      0x4    sd s0,32(sp)          ; stack access
    0x8401087c      0x6    sd s1,24(sp)          ; stack access
    0x8401087e      0x8    sd s2,16(sp)          ; stack access
    0x84010880      0xa    sd s3,8(sp)           ; stack access
    0x84010882      0xc    mv s0,a0
    0x84010884      0xe    ld a4,80(a1)
    0x84010886     0x10    andi a3,a4,127
    0x8401088a     0x14    li a5,120
    0x8401088e     0x18    bgeu a5,a3,ffffffff8401089a <handleFaultReply+0x24>
    0x84010892     0x1c    andi a4,a4,-128
    0x84010896     0x20    ori a4,a4,120
    0x8401089a     0x24    srli s1,a4,0xc
    0x8401089e     0x28    andi a6,a4,127
    0x840108a2     0x2c    ld a5,312(s0)
    0x840108a6     0x30    andi a0,a5,15
    0x840108aa     0x34    li a5,2
    0x840108ac     0x36    beq a0,a5,ffffffff840108c6 <handleFaultReply+0x50>
    0x840108b0     0x3a    li a5,3
    0x840108b2     0x3c    beq a0,a5,ffffffff84010958 <handleFaultReply+0xe2>
    0x840108b6     0x40    li a5,1
    0x840108b8     0x42    beq a0,a5,ffffffff8401094a <handleFaultReply+0xd4>
    0x840108bc     0x46    li a5,5
    0x840108be     0x48    bne a0,a5,ffffffff840109c2 <handleFaultReply+0x14c>
    0x840108c2     0x4c    li a0,1
    0x840108c4     0x4e    j ffffffff8401094a <handleFaultReply+0xd4>
    0x840108c6     0x50    mv s2,a6
    0x840108c8     0x52    li a5,10
    0x840108ca     0x54    bgeu a5,a6,ffffffff840108d0 <handleFaultReply+0x5a>
    0x840108ce     0x58    li s2,10
    0x840108d0     0x5a    mv a7,s2
    0x840108d2     0x5c    li a5,4
    0x840108d4     0x5e    bgeu a5,s2,ffffffff840108da <handleFaultReply+0x64>
    0x840108d8     0x62    li a7,4
    0x840108da     0x64    beqz a6,ffffffff84010946 <handleFaultReply+0xd0>
    0x840108de     0x68    auipc a0,0x7
    0x840108e2     0x6c    addi a0,a0,-870 # ffffffff84017578 <fault_messages>
    0x840108e6     0x70    auipc a2,0x7
    0x840108ea     0x74    addi a2,a2,-910 # ffffffff84017558 <msgRegisters>
    0x840108ee     0x78    li a3,0
    0x840108f0     0x7a    ld a5,0(a0)
    0x840108f2     0x7c    ld a4,0(a2)
    0x840108f4     0x7e    slli a4,a4,0x3
    0x840108f6     0x80    add a4,a4,a1
    0x840108f8     0x82    ld a4,0(a4)
    0x840108fa     0x84    slli a5,a5,0x3
    0x840108fc     0x86    add a5,a5,s0
    0x840108fe     0x88    sd a4,0(a5)
    0x84010900     0x8a    addi a3,a3,1
    0x84010902     0x8c    addi a0,a0,8
    0x84010904     0x8e    addi a2,a2,8
    0x84010906     0x90    bltu a3,a7,ffffffff840108f0 <handleFaultReply+0x7a>
    0x8401090a     0x94    li a4,1
    0x8401090c     0x96    beqz a6,ffffffff84010912 <handleFaultReply+0x9c>
    0x84010910     0x9a    mv a4,a7
    0x84010912     0x9c    mv s3,a4
    0x84010914     0x9e    bgeu a4,s2,ffffffff84010946 <handleFaultReply+0xd0>
    0x84010918     0xa2    li a0,0
    0x8401091a     0xa4    jal ra,ffffffff840107e6 <lookupIPCBuffer>
    0x8401091e     0xa8    beqz a0,ffffffff84010946 <handleFaultReply+0xd0>
    0x84010920     0xaa    slli a4,s3,0x3
    0x84010924     0xae    auipc a3,0x7
    0x84010928     0xb2    addi a3,a3,-940 # ffffffff84017578 <fault_messages>
    0x8401092c     0xb6    add a3,a3,a4
    0x8401092e     0xb8    add a4,a4,a0
    0x84010930     0xba    slli s2,s2,0x3
    0x84010932     0xbc    add s2,s2,a0
    0x84010934     0xbe    ld a5,0(a3)
    0x84010936     0xc0    ld a2,8(a4)
    0x84010938     0xc2    slli a5,a5,0x3
    0x8401093a     0xc4    add a5,a5,s0
    0x8401093c     0xc6    sd a2,0(a5)
    0x8401093e     0xc8    addi a3,a3,8
    0x84010940     0xca    addi a4,a4,8
    0x84010942     0xcc    bne a4,s2,ffffffff84010934 <handleFaultReply+0xbe>
    0x84010946     0xd0    seqz a0,s1
    0x8401094a     0xd4    ld ra,40(sp)          ; stack access
    0x8401094c     0xd6    ld s0,32(sp)          ; stack access
    0x8401094e     0xd8    ld s1,24(sp)          ; stack access
    0x84010950     0xda    ld s2,16(sp)          ; stack access
    0x84010952     0xdc    ld s3,8(sp)           ; stack access
    0x84010954     0xde    addi sp,sp,48
    0x84010956     0xe0    ret
    0x84010958     0xe2    mv s3,a6
    0x8401095a     0xe4    li a5,2
    0x8401095c     0xe6    bgeu a5,a6,ffffffff84010962 <handleFaultReply+0xec>
    0x84010960     0xea    li s3,2
    0x84010962     0xec    mv a3,s3
    0x84010964     0xee    li a5,4
    0x84010966     0xf0    bgeu a5,s3,ffffffff8401096c <handleFaultReply+0xf6>
    0x8401096a     0xf4    li a3,4
    0x8401096c     0xf6    beqz a6,ffffffff840109bc <handleFaultReply+0x146>
    0x84010970     0xfa    ld a5,88(a1)
    0x84010972     0xfc    sd a5,264(s0)
    0x84010976    0x100    andi a4,a4,126
    0x8401097a    0x104    beqz a4,ffffffff84010980 <handleFaultReply+0x10a>
    0x8401097c    0x106    ld a5,96(a1)
    0x8401097e    0x108    sd a5,8(s0)
    0x84010980    0x10a    li a5,1
    0x84010982    0x10c    beqz a6,ffffffff84010988 <handleFaultReply+0x112>
    0x84010986    0x110    mv a5,a3
    0x84010988    0x112    mv s2,a5
    0x8401098a    0x114    bgeu a5,s3,ffffffff840109bc <handleFaultReply+0x146>
    0x8401098e    0x118    li a0,0
    0x84010990    0x11a    jal ra,ffffffff840107e6 <lookupIPCBuffer>
    0x84010994    0x11e    beqz a0,ffffffff840109bc <handleFaultReply+0x146>
    0x84010996    0x120    slli a5,s2,0x3
    0x8401099a    0x124    slli s3,s3,0x3
    0x8401099c    0x126    auipc a2,0x7
    0x840109a0    0x12a    addi a2,a2,-1060 # ffffffff84017578 <fault_messages>
    0x840109a4    0x12e    add a4,a2,a5
    0x840109a8    0x132    ld a4,80(a4)
    0x840109aa    0x134    add a3,a0,a5
    0x840109ae    0x138    ld a3,8(a3)
    0x840109b0    0x13a    slli a4,a4,0x3
    0x840109b2    0x13c    add a4,a4,s0
    0x840109b4    0x13e    sd a3,0(a4)
    0x840109b6    0x140    addi a5,a5,8
    0x840109b8    0x142    bne a5,s3,ffffffff840109a4 <handleFaultReply+0x12e>
    0x840109bc    0x146    seqz a0,s1
    0x840109c0    0x14a    j ffffffff8401094a <handleFaultReply+0xd4>
    0x840109c2    0x14c    jal ra,ffffffff8401041e <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
123 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleFaultReply` has 195 nodes.

Section setMRs_fault (198 of 271)
=================================

Deriving specifications
-----------------------

Section `setMRs_fault` consists of 72 instructions.

LWU..

Stack analysis
---------------

2 stack accesses found. Annotated code for `setMRs_fault`:

    0x840106fc     0x0    mv a5,a1
    0x840106fe     0x2    mv a1,a2
    0x84010700     0x4    ld a3,312(a0)
    0x84010704     0x8    andi a3,a3,15
    0x84010706     0xa    li a4,2
    0x84010708     0xc    beq a3,a4,ffffffff84010752 <setMRs_fault+0x56>
    0x8401070c    0x10    li a4,3
    0x8401070e    0x12    beq a3,a4,ffffffff8401079e <setMRs_fault+0xa2>
    0x84010712    0x16    addi sp,sp,-16
    0x84010714    0x18    sd ra,8(sp)           ; stack access
    0x84010716    0x1a    li a4,1
    0x84010718    0x1c    beq a3,a4,ffffffff84010724 <setMRs_fault+0x28>
    0x8401071c    0x20    mv a1,a5
    0x8401071e    0x22    jal ra,ffffffff840106ca <Arch_setMRs_fault>
    0x84010722    0x26    j ffffffff8401074c <setMRs_fault+0x50>
    0x84010724    0x28    ld a4,264(a0)
    0x84010728    0x2c    sd a4,88(a5)
    0x8401072a    0x2e    ld a4,320(a0)
    0x8401072e    0x32    sd a4,96(a5)
    0x84010730    0x34    ld a4,312(a0)
    0x84010734    0x38    srli a4,a4,0x3f
    0x84010736    0x3a    sd a4,104(a5)
    0x84010738    0x3c    li a4,3
    0x8401073a    0x3e    ld a2,328(a0)
    0x8401073e    0x42    ld a3,336(a0)
    0x84010742    0x46    mv a0,a5
    0x84010744    0x48    jal ra,ffffffff8401042a <setMRs_lookup_failure>
    0x84010748    0x4c    slli a0,a0,0x20
    0x8401074a    0x4e    srli a0,a0,0x20
    0x8401074c    0x50    ld ra,8(sp)           ; stack access
    0x8401074e    0x52    addi sp,sp,16
    0x84010750    0x54    ret
    0x84010752    0x56    ld a4,264(a0)
    0x84010756    0x5a    sd a4,88(a5)
    0x84010758    0x5c    ld a4,8(a0)
    0x8401075a    0x5e    sd a4,96(a5)
    0x8401075c    0x60    ld a4,0(a0)
    0x8401075e    0x62    sd a4,104(a5)
    0x84010760    0x64    ld a4,72(a0)
    0x84010762    0x66    sd a4,112(a5)
    0x84010764    0x68    li a5,4
    0x84010766    0x6a    beqz a2,ffffffff84010796 <setMRs_fault+0x9a>
    0x84010768    0x6c    auipc a4,0x7
    0x8401076c    0x70    addi a4,a4,-496 # ffffffff84017578 <fault_messages>
    0x84010770    0x74    addi a3,a2,40
    0x84010774    0x78    auipc a2,0x7
    0x84010778    0x7c    addi a2,a2,-460 # ffffffff840175a8 <fault_messages+0x30>
    0x8401077c    0x80    ld a5,32(a4)
    0x8401077e    0x82    slli a5,a5,0x3
    0x84010780    0x84    add a5,a5,a0
    0x84010782    0x86    ld a5,0(a5)
    0x84010784    0x88    sd a5,0(a3)
    0x84010786    0x8a    addi a4,a4,8
    0x84010788    0x8c    addi a3,a3,8
    0x8401078a    0x8e    bne a2,a4,ffffffff8401077c <setMRs_fault+0x80>
    0x8401078e    0x92    ld a5,320(a0)
    0x84010792    0x96    sd a5,88(a1)
    0x84010794    0x98    li a5,11
    0x84010796    0x9a    slli a0,a5,0x20
    0x8401079a    0x9e    srli a0,a0,0x20
    0x8401079c    0xa0    ret
    0x8401079e    0xa2    ld a4,264(a0)
    0x840107a2    0xa6    sd a4,88(a5)
    0x840107a4    0xa8    ld a4,8(a0)
    0x840107a6    0xaa    sd a4,96(a5)
    0x840107a8    0xac    lwu a4,316(a0)
    0x840107ac    0xb0    sd a4,104(a5)
    0x840107ae    0xb2    ld a4,312(a0)
    0x840107b2    0xb6    srliw a4,a4,0x4
    0x840107b6    0xba    sd a4,112(a5)
    0x840107b8    0xbc    li a0,4
    0x840107ba    0xbe    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
72 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setMRs_fault` has 119 nodes.

Section trap_entry (199 of 271)
===============================

Deriving specifications
-----------------------

Section `trap_entry` consists of 45 instructions.

Skipping 140292f3 csrrw t0,sscratch,t0

Skipping 140020f3 csrr ra,sscratch

Skipping 100020f3 csrr ra,sstatus

Skipping 14202473 csrr s0,scause

Skipping 141020f3 csrr ra,sepc


Stack analysis
---------------

No stack accesses found. Code for `trap_entry`:

    0x84010000     0x0    csrrw t0,sscratch,t0
    0x84010004     0x4    sd ra,0(t0)
    0x84010008     0x8    sd sp,8(t0)
    0x8401000c     0xc    sd gp,16(t0)
    0x84010010    0x10    sd tp,24(t0)
    0x84010014    0x14    sd t1,40(t0)
    0x84010018    0x18    sd t2,48(t0)
    0x8401001c    0x1c    sd s0,56(t0)
    0x84010020    0x20    sd s1,64(t0)
    0x84010024    0x24    sd a0,72(t0)
    0x84010028    0x28    sd a1,80(t0)
    0x8401002c    0x2c    sd a2,88(t0)
    0x84010030    0x30    sd a3,96(t0)
    0x84010034    0x34    sd a4,104(t0)
    0x84010038    0x38    sd a5,112(t0)
    0x8401003c    0x3c    sd a6,120(t0)
    0x84010040    0x40    sd a7,128(t0)
    0x84010044    0x44    sd s2,136(t0)
    0x84010048    0x48    sd s3,144(t0)
    0x8401004c    0x4c    sd s4,152(t0)
    0x84010050    0x50    sd s5,160(t0)
    0x84010054    0x54    sd s6,168(t0)
    0x84010058    0x58    sd s7,176(t0)
    0x8401005c    0x5c    sd s8,184(t0)
    0x84010060    0x60    sd s9,192(t0)
    0x84010064    0x64    sd s10,200(t0)
    0x84010068    0x68    sd s11,208(t0)
    0x8401006c    0x6c    sd t3,216(t0)
    0x84010070    0x70    sd t4,224(t0)
    0x84010074    0x74    sd t5,232(t0)
    0x84010078    0x78    sd t6,240(t0)
    0x8401007c    0x7c    csrr ra,sscratch
    0x84010080    0x80    sd ra,32(t0)
    0x84010084    0x84    csrr ra,sstatus
    0x84010088    0x88    sd ra,256(t0)
    0x8401008c    0x8c    csrr s0,scause
    0x84010090    0x90    sd s0,248(t0)
    0x84010094    0x94    mv gp,gp
    0x84010098    0x98    auipc sp,0x1a
    0x8401009c    0x9c    addi sp,sp,1896 # ffffffff8402a800 <tlbLockCount>
    0x840100a0    0xa0    csrr ra,sepc
    0x840100a4    0xa4    sd ra,264(t0)
    0x840100a8    0xa8    bltz s0,ffffffff840100c4 <interrupt>
    0x840100ac    0xac    li s4,8
    0x840100ae    0xae    bne s0,s4,ffffffff840100bc <exception>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
45 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `trap_entry` has 92 nodes.

Section populate_bi_frame (200 of 271)
======================================

Deriving specifications
-----------------------

Section `populate_bi_frame` consists of 55 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `populate_bi_frame`:

    0x84000d82     0x0    addi sp,sp,-48
    0x84000d84     0x2    sd ra,40(sp)          ; stack access
    0x84000d86     0x4    sd s0,32(sp)          ; stack access
    0x84000d88     0x6    sd s1,24(sp)          ; stack access
    0x84000d8a     0x8    sd s2,16(sp)          ; stack access
    0x84000d8c     0xa    sd s3,8(sp)           ; stack access
    0x84000d8e     0xc    mv s3,a0
    0x84000d90     0xe    mv s2,a1
    0x84000d92    0x10    mv s1,a2
    0x84000d94    0x12    mv s0,a3
    0x84000d96    0x14    lui a1,0x1
    0x84000d98    0x16    auipc a0,0x1
    0x84000d9c    0x1a    ld a0,-1520(a0) # ffffffff840017a8 <rootserver+0x20>
    0x84000da0    0x1e    jal ra,ffffffff84015b8a <memzero>
    0x84000da4    0x22    bnez s0,ffffffff84000e08 <populate_bi_frame+0x86>
    0x84000da6    0x24    auipc a5,0x0
    0x84000daa    0x28    addi a5,a5,1922 # ffffffff84001528 <ndks_boot>
    0x84000dae    0x2c    ld a4,640(a5)
    0x84000db2    0x30    sd a4,584(a5)
    0x84000db6    0x34    li a3,12
    0x84000db8    0x36    sd a3,592(a5)
    0x84000dbc    0x3a    sd s3,8(a4)
    0x84000dc0    0x3e    ld a4,640(a5)
    0x84000dc4    0x42    sd s2,16(a4)
    0x84000dc8    0x46    ld a4,640(a5)
    0x84000dcc    0x4a    sd zero,24(a4)
    0x84000dd0    0x4e    ld a4,640(a5)
    0x84000dd4    0x52    sd s1,32(a4)
    0x84000dd6    0x54    ld a5,640(a5)
    0x84000dda    0x58    li a4,19
    0x84000ddc    0x5a    sd a4,136(a5)
    0x84000dde    0x5c    auipc a4,0x2a
    0x84000de2    0x60    ld a4,-1494(a4) # ffffffff8402a808 <ksDomScheduleIdx>
    0x84000de6    0x64    slli a3,a4,0x4
    0x84000dea    0x68    auipc a4,0x16
    0x84000dee    0x6c    addi a4,a4,1902 # ffffffff84017558 <msgRegisters>
    0x84000df2    0x70    add a4,a4,a3
    0x84000df4    0x72    ld a4,192(a4)
    0x84000df6    0x74    sd a4,144(a5)
    0x84000df8    0x76    sd s0,0(a5)
    0x84000dfa    0x78    ld ra,40(sp)          ; stack access
    0x84000dfc    0x7a    ld s0,32(sp)          ; stack access
    0x84000dfe    0x7c    ld s1,24(sp)          ; stack access
    0x84000e00    0x7e    ld s2,16(sp)          ; stack access
    0x84000e02    0x80    ld s3,8(sp)           ; stack access
    0x84000e04    0x82    addi sp,sp,48
    0x84000e06    0x84    ret
    0x84000e08    0x86    mv a0,s0
    0x84000e0a    0x88    jal ra,ffffffff8400064e <calculate_extra_bi_size_bits>
    0x84000e0e    0x8c    li a1,1
    0x84000e10    0x8e    sll a1,a1,a0
    0x84000e14    0x92    auipc a0,0x1
    0x84000e18    0x96    ld a0,-1636(a0) # ffffffff840017b0 <rootserver+0x28>
    0x84000e1c    0x9a    jal ra,ffffffff84015b8a <memzero>
    0x84000e20    0x9e    j ffffffff84000da6 <populate_bi_frame+0x24>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
55 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `populate_bi_frame` has 89 nodes.

Section create_frames_of_region (201 of 271)
============================================

Deriving specifications
-----------------------

Section `create_frames_of_region` consists of 80 instructions.

RVC_FTTFT____FFFFTFT.
RVC_FTTFFFFTFFFFT_FT.

Stack analysis
---------------

Section `create_frames_of_region` expects pointer to stack in a0.
43 stack accesses found. Annotated code for `create_frames_of_region`:

    0x8400082a     0x0    addi sp,sp,-160
    0x8400082c     0x2    sd ra,152(sp)         ; stack access
    0x8400082e     0x4    sd s0,144(sp)         ; stack access
    0x84000830     0x6    sd s1,136(sp)         ; stack access
    0x84000832     0x8    sd s2,128(sp)         ; stack access
    0x84000834     0xa    sd s3,120(sp)         ; stack access
    0x84000836     0xc    sd s4,112(sp)         ; stack access
    0x84000838     0xe    sd s5,104(sp)         ; stack access
    0x8400083a    0x10    sd s6,96(sp)          ; stack access
    0x8400083c    0x12    sd s7,88(sp)          ; stack access
    0x8400083e    0x14    sd s8,80(sp)          ; stack access
    0x84000840    0x16    sd s9,72(sp)          ; stack access
    0x84000842    0x18    mv s7,a0
    0x84000844    0x1a    sd a1,32(sp)          ; stack access
    0x84000846    0x1c    sd a2,40(sp)          ; stack access
    0x84000848    0x1e    sd a3,16(sp)          ; stack access
    0x8400084a    0x20    sd a4,24(sp)          ; stack access
    0x8400084c    0x22    auipc s9,0x1
    0x84000850    0x26    ld s9,-212(s9) # ffffffff84001778 <ndks_boot+0x250>
    0x84000854    0x2a    bgeu a5,a6,ffffffff840008c6 <create_frames_of_region+0x9c>
    0x84000858    0x2e    mv s2,a7
    0x8400085a    0x30    mv s1,a6
    0x8400085c    0x32    mv s0,a5
    0x8400085e    0x34    li s3,1
    0x84000860    0x36    slli s8,s3,0x3b
    0x84000864    0x3a    lui s6,0xfe000
    0x84000868    0x3e    srli s6,s6,0x10
    0x8400086c    0x42    slli s5,s3,0x26
    0x84000870    0x46    ld a5,160(sp)         ; stack access
    0x84000872    0x48    sub s5,s5,a5
    0x84000876    0x4c    lui s4,0x1
    0x84000878    0x4e    j ffffffff8400089a <create_frames_of_region+0x70>
    0x8400087a    0x50    sd s8,48(sp)          ; stack access
    0x8400087c    0x52    slli a5,s0,0x9
    0x84000880    0x56    and a5,a5,s6
    0x84000884    0x5a    sd a5,56(sp)          ; stack access
    0x84000886    0x5c    ld a2,48(sp)          ; stack access
    0x84000888    0x5e    ld a3,56(sp)          ; stack access
    0x8400088a    0x60    ld a0,32(sp)          ; stack access
    0x8400088c    0x62    ld a1,40(sp)          ; stack access
    0x8400088e    0x64    jal ra,ffffffff84000688 <provide_cap>
    0x84000892    0x68    beqz a0,ffffffff840008b8 <create_frames_of_region+0x8e>
    0x84000894    0x6a    add s0,s0,s4
    0x84000896    0x6c    bgeu s0,s1,ffffffff840008c6 <create_frames_of_region+0x9c>
    0x8400089a    0x70    beqz s2,ffffffff8400087a <create_frames_of_region+0x50>
    0x8400089e    0x74    mv a6,s3
    0x840008a0    0x76    li a5,0
    0x840008a2    0x78    mv a4,s3
    0x840008a4    0x7a    add a3,s5,s0
    0x840008a8    0x7e    mv a2,s0
    0x840008aa    0x80    ld a0,16(sp)          ; stack access
    0x840008ac    0x82    ld a1,24(sp)          ; stack access
    0x840008ae    0x84    jal ra,ffffffff84000268 <create_mapped_it_frame_cap>
    0x840008b2    0x88    sd a0,48(sp)          ; stack access
    0x840008b4    0x8a    sd a1,56(sp)          ; stack access
    0x840008b6    0x8c    j ffffffff84000886 <create_frames_of_region+0x5c>
    0x840008b8    0x8e    sd zero,0(s7) # fffffffffe000000 <ki_end+0x79fd1000>  ; stack access
    0x840008bc    0x92    sd zero,8(s7)         ; stack access
    0x840008c0    0x96    sd zero,16(s7)        ; stack access
    0x840008c4    0x9a    j ffffffff840008dc <create_frames_of_region+0xb2>
    0x840008c6    0x9c    sd s9,0(s7)           ; stack access
    0x840008ca    0xa0    auipc a5,0x1
    0x840008ce    0xa4    ld a5,-338(a5) # ffffffff84001778 <ndks_boot+0x250>
    0x840008d2    0xa8    sd a5,8(s7)           ; stack access
    0x840008d6    0xac    li a5,1
    0x840008d8    0xae    sd a5,16(s7)          ; stack access
    0x840008dc    0xb2    mv a0,s7
    0x840008de    0xb4    ld ra,152(sp)         ; stack access
    0x840008e0    0xb6    ld s0,144(sp)         ; stack access
    0x840008e2    0xb8    ld s1,136(sp)         ; stack access
    0x840008e4    0xba    ld s2,128(sp)         ; stack access
    0x840008e6    0xbc    ld s3,120(sp)         ; stack access
    0x840008e8    0xbe    ld s4,112(sp)         ; stack access
    0x840008ea    0xc0    ld s5,104(sp)         ; stack access
    0x840008ec    0xc2    ld s6,96(sp)          ; stack access
    0x840008ee    0xc4    ld s7,88(sp)          ; stack access
    0x840008f0    0xc6    ld s8,80(sp)          ; stack access
    0x840008f2    0xc8    ld s9,72(sp)          ; stack access
    0x840008f4    0xca    addi sp,sp,160
    0x840008f6    0xcc    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
80 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_frames_of_region` has 136 nodes.

Section create_bi_frame_cap (202 of 271)
========================================

Deriving specifications
-----------------------

Section `create_bi_frame_cap` consists of 30 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `create_bi_frame_cap`:

    0x84000602     0x0    addi sp,sp,-80
    0x84000604     0x2    sd ra,72(sp)          ; stack access
    0x84000606     0x4    sd s0,64(sp)          ; stack access
    0x84000608     0x6    sd s1,56(sp)          ; stack access
    0x8400060a     0x8    sd a0,16(sp)          ; stack access
    0x8400060c     0xa    sd a1,24(sp)          ; stack access
    0x8400060e     0xc    mv a0,a2
    0x84000610     0xe    mv a1,a3
    0x84000612    0x10    mv a3,a4
    0x84000614    0x12    li a6,0
    0x84000616    0x14    li a5,0
    0x84000618    0x16    li a4,1
    0x8400061a    0x18    auipc a2,0x1
    0x8400061e    0x1c    ld a2,398(a2) # ffffffff840017a8 <rootserver+0x20>
    0x84000622    0x20    jal ra,ffffffff84000268 <create_mapped_it_frame_cap>
    0x84000626    0x24    mv s1,a0
    0x84000628    0x26    mv s0,a1
    0x8400062a    0x28    ld a0,16(sp)          ; stack access
    0x8400062c    0x2a    ld a1,24(sp)          ; stack access
    0x8400062e    0x2c    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x84000632    0x30    sd s1,288(a0)
    0x84000636    0x34    sd s0,296(a0)
    0x8400063a    0x38    sd zero,304(a0)
    0x8400063e    0x3c    li a5,3
    0x84000640    0x3e    sd a5,312(a0)
    0x84000644    0x42    ld ra,72(sp)          ; stack access
    0x84000646    0x44    ld s0,64(sp)          ; stack access
    0x84000648    0x46    ld s1,56(sp)          ; stack access
    0x8400064a    0x48    addi sp,sp,80
    0x8400064c    0x4a    ret

Proving inst theorems
---------------------

30 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_bi_frame_cap` has 48 nodes.

Section map_kernel_window (203 of 271)
======================================

Deriving specifications
-----------------------

Section `map_kernel_window` consists of 69 instructions.


Stack analysis
---------------

16 stack accesses found. Annotated code for `map_kernel_window`:

    0x84000474     0x0    addi sp,sp,-64
    0x84000476     0x2    sd ra,56(sp)          ; stack access
    0x84000478     0x4    sd s0,48(sp)          ; stack access
    0x8400047a     0x6    sd s1,40(sp)          ; stack access
    0x8400047c     0x8    sd s2,32(sp)          ; stack access
    0x8400047e     0xa    sd s3,24(sp)          ; stack access
    0x84000480     0xc    sd s4,16(sp)          ; stack access
    0x84000482     0xe    sd s5,8(sp)           ; stack access
    0x84000484    0x10    sd s6,0(sp)           ; stack access
    0x84000486    0x12    li s1,-1
    0x84000488    0x14    slli s1,s1,0x26
    0x8400048a    0x16    auipc s6,0x2d
    0x8400048e    0x1a    addi s6,s6,-1162 # ffffffff8402d000 <kernel_root_pageTable>
    0x84000492    0x1e    li s2,1
    0x84000494    0x20    slli s5,s2,0x26
    0x84000498    0x24    lui s4,0x40000
    0x8400049c    0x28    lui s3,0x80000
    0x840004a0    0x2c    srli s0,s1,0x1e
    0x840004a4    0x30    andi s0,s0,511
    0x840004a8    0x34    slli s0,s0,0x3
    0x840004aa    0x36    add s0,s0,s6
    0x840004ac    0x38    mv a1,s2
    0x840004ae    0x3a    add a0,s1,s5
    0x840004b2    0x3e    jal ra,ffffffff84010120 <pte_next>
    0x840004b6    0x42    sd a0,0(s0)
    0x840004b8    0x44    add s1,s1,s4
    0x840004ba    0x46    bne s1,s3,ffffffff840004a0 <map_kernel_window+0x2c>
    0x840004be    0x4a    li s0,1
    0x840004c0    0x4c    slli a5,s0,0x20
    0x840004c4    0x50    auipc s1,0x2c
    0x840004c8    0x54    addi s1,s1,-1220 # ffffffff8402c000 <kernel_image_level2_pt>
    0x840004cc    0x58    add s1,s1,a5
    0x840004ce    0x5a    auipc s2,0x2e
    0x840004d2    0x5e    addi s2,s2,-1230 # ffffffff8402e000 <kernel_root_pageTable+0x1000>
    0x840004d6    0x62    li a1,0
    0x840004d8    0x64    mv a0,s1
    0x840004da    0x66    jal ra,ffffffff84010120 <pte_next>
    0x840004de    0x6a    sd a0,-2032(s2)
    0x840004e2    0x6e    li a1,0
    0x840004e4    0x70    mv a0,s1
    0x840004e6    0x72    jal ra,ffffffff84010120 <pte_next>
    0x840004ea    0x76    sd a0,-16(s2)
    0x840004ee    0x7a    li s2,0
    0x840004f0    0x7c    slli s0,s0,0x1f
    0x840004f2    0x7e    auipc s5,0x2c
    0x840004f6    0x82    addi s5,s5,-1266 # ffffffff8402c000 <kernel_image_level2_pt>
    0x840004fa    0x86    lui s4,0x200
    0x840004fe    0x8a    li s3,3
    0x84000500    0x8c    slli s3,s3,0x1e
    0x84000502    0x8e    slli s1,s2,0x3
    0x84000506    0x92    add s1,s1,s5
    0x84000508    0x94    li a1,1
    0x8400050a    0x96    mv a0,s0
    0x8400050c    0x98    jal ra,ffffffff84010120 <pte_next>
    0x84000510    0x9c    sd a0,0(s1)
    0x84000512    0x9e    addi s2,s2,1
    0x84000514    0xa0    add s0,s0,s4
    0x84000516    0xa2    bne s0,s3,ffffffff84000502 <map_kernel_window+0x8e>
    0x8400051a    0xa6    jal ra,ffffffff84000450 <map_kernel_devices>
    0x8400051e    0xaa    ld ra,56(sp)          ; stack access
    0x84000520    0xac    ld s0,48(sp)          ; stack access
    0x84000522    0xae    ld s1,40(sp)          ; stack access
    0x84000524    0xb0    ld s2,32(sp)          ; stack access
    0x84000526    0xb2    ld s3,24(sp)          ; stack access
    0x84000528    0xb4    ld s4,16(sp)          ; stack access
    0x8400052a    0xb6    ld s5,8(sp)           ; stack access
    0x8400052c    0xb8    ld s6,0(sp)           ; stack access
    0x8400052e    0xba    addi sp,sp,64
    0x84000530    0xbc    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
69 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `map_kernel_window` has 99 nodes.

Section map_kernel_devices (204 of 271)
=======================================

Deriving specifications
-----------------------

Section `map_kernel_devices` consists of 12 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `map_kernel_devices`:

    0x84000450     0x0    addi sp,sp,-32
    0x84000452     0x2    sd ra,24(sp)          ; stack access
    0x84000454     0x4    li a2,1
    0x84000456     0x6    lui a1,0xc0000
    0x8400045a     0xa    lui a0,0xc000
    0x8400045e     0xe    jal ra,ffffffff840000c4 <map_kernel_frame>
    0x84000462    0x12    lui a0,0xc000
    0x84000466    0x16    lui a1,0xc001
    0x8400046a    0x1a    jal ra,ffffffff84000366 <reserve_region>
    0x8400046e    0x1e    ld ra,24(sp)          ; stack access
    0x84000470    0x20    addi sp,sp,32
    0x84000472    0x22    ret

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `map_kernel_devices` has 17 nodes.

Section map_it_frame_cap (205 of 271)
=====================================

Deriving specifications
-----------------------

Section `map_it_frame_cap` consists of 47 instructions.

Skipping 12000073 sfence.vma


Stack analysis
---------------

16 stack accesses found. Annotated code for `map_it_frame_cap`:

    0x840001fa     0x0    addi sp,sp,-96
    0x840001fc     0x2    sd ra,88(sp)          ; stack access
    0x840001fe     0x4    sd s0,80(sp)          ; stack access
    0x84000200     0x6    sd s1,72(sp)          ; stack access
    0x84000202     0x8    sd s2,64(sp)          ; stack access
    0x84000204     0xa    sd s3,56(sp)          ; stack access
    0x84000206     0xc    sd a0,16(sp)          ; stack access
    0x84000208     0xe    sd a1,24(sp)          ; stack access
    0x8400020a    0x10    mv s3,a2
    0x8400020c    0x12    sd a2,0(sp)           ; stack access
    0x8400020e    0x14    mv s0,a3
    0x84000210    0x16    sd a3,8(sp)           ; stack access
    0x84000212    0x18    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x84000216    0x1c    mv s2,a0
    0x84000218    0x1e    mv a0,s3
    0x8400021a    0x20    mv a1,s0
    0x8400021c    0x22    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x84000220    0x26    mv s0,a0
    0x84000222    0x28    slli a1,s3,0x19
    0x84000226    0x2c    srli a1,a1,0x19
    0x84000228    0x2e    srli s1,s3,0x26
    0x8400022c    0x32    andi s1,s1,1
    0x8400022e    0x34    beqz s1,ffffffff84000236 <map_it_frame_cap+0x3c>
    0x84000230    0x36    li a5,-1
    0x84000232    0x38    slli a5,a5,0x27
    0x84000234    0x3a    or a1,a1,a5
    0x84000236    0x3c    mv a0,s2
    0x84000238    0x3e    jal ra,ffffffff840109c6 <lookupPTSlot>
    0x8400023c    0x42    sd a0,32(sp)          ; stack access
    0x8400023e    0x44    sd a1,40(sp)          ; stack access
    0x84000240    0x46    li a5,1
    0x84000242    0x48    slli a5,a5,0x26
    0x84000244    0x4a    add s0,s0,a5
    0x84000246    0x4c    srli s0,s0,0x2
    0x84000248    0x4e    lui a5,0xfff00
    0x8400024c    0x52    srli a5,a5,0xa
    0x8400024e    0x54    and s0,s0,a5
    0x84000250    0x56    ori s0,s0,223
    0x84000254    0x5a    sd s0,0(a0)
    0x84000256    0x5c    sfence.vma
    0x8400025a    0x60    ld ra,88(sp)          ; stack access
    0x8400025c    0x62    ld s0,80(sp)          ; stack access
    0x8400025e    0x64    ld s1,72(sp)          ; stack access
    0x84000260    0x66    ld s2,64(sp)          ; stack access
    0x84000262    0x68    ld s3,56(sp)          ; stack access
    0x84000264    0x6a    addi sp,sp,96
    0x84000266    0x6c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
47 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `map_it_frame_cap` has 71 nodes.

Section map_it_pt_cap (206 of 271)
==================================

Deriving specifications
-----------------------

Section `map_it_pt_cap` consists of 46 instructions.

Skipping 12000073 sfence.vma


Stack analysis
---------------

18 stack accesses found. Annotated code for `map_it_pt_cap`:

    0x84000190     0x0    addi sp,sp,-80
    0x84000192     0x2    sd ra,72(sp)          ; stack access
    0x84000194     0x4    sd s0,64(sp)          ; stack access
    0x84000196     0x6    sd s1,56(sp)          ; stack access
    0x84000198     0x8    sd s2,48(sp)          ; stack access
    0x8400019a     0xa    sd a0,16(sp)          ; stack access
    0x8400019c     0xc    sd a1,24(sp)          ; stack access
    0x8400019e     0xe    sd a2,0(sp)           ; stack access
    0x840001a0    0x10    sd a3,8(sp)           ; stack access
    0x840001a2    0x12    slli s1,a2,0x19
    0x840001a6    0x16    srli s1,s1,0x19
    0x840001a8    0x18    srli a2,a2,0x26
    0x840001aa    0x1a    andi a2,a2,1
    0x840001ac    0x1c    beqz a2,ffffffff840001b4 <map_it_pt_cap+0x24>
    0x840001ae    0x1e    li a5,-1
    0x840001b0    0x20    slli a5,a5,0x27
    0x840001b2    0x22    or s1,s1,a5
    0x840001b4    0x24    ld a0,16(sp)          ; stack access
    0x840001b6    0x26    ld a1,24(sp)          ; stack access
    0x840001b8    0x28    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x840001bc    0x2c    mv s2,a0
    0x840001be    0x2e    ld a0,0(sp)           ; stack access
    0x840001c0    0x30    ld a1,8(sp)           ; stack access
    0x840001c2    0x32    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x840001c6    0x36    mv s0,a0
    0x840001c8    0x38    mv a1,s1
    0x840001ca    0x3a    mv a0,s2
    0x840001cc    0x3c    jal ra,ffffffff840109c6 <lookupPTSlot>
    0x840001d0    0x40    sd a0,32(sp)          ; stack access
    0x840001d2    0x42    sd a1,40(sp)          ; stack access
    0x840001d4    0x44    li a5,1
    0x840001d6    0x46    slli a5,a5,0x26
    0x840001d8    0x48    add s0,s0,a5
    0x840001da    0x4a    srli s0,s0,0x2
    0x840001dc    0x4c    lui a5,0xfff00
    0x840001e0    0x50    srli a5,a5,0xa
    0x840001e2    0x52    and s0,s0,a5
    0x840001e4    0x54    ori s0,s0,193
    0x840001e8    0x58    sd s0,0(a0)
    0x840001ea    0x5a    sfence.vma
    0x840001ee    0x5e    ld ra,72(sp)          ; stack access
    0x840001f0    0x60    ld s0,64(sp)          ; stack access
    0x840001f2    0x62    ld s1,56(sp)          ; stack access
    0x840001f4    0x64    ld s2,48(sp)          ; stack access
    0x840001f6    0x66    addi sp,sp,80
    0x840001f8    0x68    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
46 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `map_it_pt_cap` has 72 nodes.

Section c_handle_syscall (207 of 271)
=====================================

Deriving specifications
-----------------------

Section `c_handle_syscall` consists of 10 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_syscall`:

    0x84017384     0x0    addi sp,sp,-16
    0x84017386     0x2    sd ra,8(sp)           ; stack access
    0x84017388     0x4    li a5,-1
    0x8401738a     0x6    beq a7,a5,ffffffff8401739a <c_handle_syscall+0x16>
    0x8401738e     0xa    li a5,-2
    0x84017390     0xc    beq a7,a5,ffffffff8401739e <c_handle_syscall+0x1a>
    0x84017394    0x10    mv a0,a7
    0x84017396    0x12    jal ra,ffffffff84016d78 <slowpath>
    0x8401739a    0x16    jal ra,ffffffff84016d90 <fastpath_call>
    0x8401739e    0x1a    jal ra,ffffffff84017060 <fastpath_reply_recv>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_syscall` has 18 nodes.

Section slowpath (208 of 271)
=============================

Deriving specifications
-----------------------

Section `slowpath` consists of 8 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `slowpath`:

    0x84016d78     0x0    addi sp,sp,-16
    0x84016d7a     0x2    sd ra,8(sp)           ; stack access
    0x84016d7c     0x4    li a5,-9
    0x84016d7e     0x6    bgeu a5,a0,ffffffff84016d8a <slowpath+0x12>
    0x84016d82     0xa    jal ra,ffffffff84016c16 <handleSyscall>
    0x84016d86     0xe    jal ra,ffffffff8401037c <restore_user_context>
    0x84016d8a    0x12    jal ra,ffffffff84014534 <handleUnknownSyscall>
    0x84016d8e    0x16    j ffffffff84016d86 <slowpath+0xe>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `slowpath` has 14 nodes.

Section decodeWriteRegisters (209 of 271)
=========================================

Deriving specifications
-----------------------

Section `decodeWriteRegisters` consists of 66 instructions.


Stack analysis
---------------

14 stack accesses found. Annotated code for `decodeWriteRegisters`:

    0x84015658     0x0    addi sp,sp,-64
    0x8401565a     0x2    sd ra,56(sp)          ; stack access
    0x8401565c     0x4    sd s0,48(sp)          ; stack access
    0x8401565e     0x6    sd s1,40(sp)          ; stack access
    0x84015660     0x8    sd s2,32(sp)          ; stack access
    0x84015662     0xa    sd s3,24(sp)          ; stack access
    0x84015664     0xc    sd s4,16(sp)          ; stack access
    0x84015666     0xe    sd a0,0(sp)           ; stack access
    0x84015668    0x10    li a5,1
    0x8401566a    0x12    bgeu a5,a2,ffffffff840156d4 <decodeWriteRegisters+0x7c>
    0x8401566e    0x16    mv s0,a2
    0x84015670    0x18    mv s1,a3
    0x84015672    0x1a    mv a1,a3
    0x84015674    0x1c    li a0,1
    0x84015676    0x1e    jal ra,ffffffff840100ea <getSyscallArg>
    0x8401567a    0x22    mv s2,a0
    0x8401567c    0x24    addi s0,s0,-2
    0x8401567e    0x26    bltu s0,a0,ffffffff840156e2 <decodeWriteRegisters+0x8a>
    0x84015682    0x2a    ld a5,0(sp)           ; stack access
    0x84015684    0x2c    slli s0,a5,0x19
    0x84015688    0x30    srli s0,s0,0x19
    0x8401568a    0x32    srli a5,a5,0x26
    0x8401568c    0x34    andi a5,a5,1
    0x8401568e    0x36    beqz a5,ffffffff84015696 <decodeWriteRegisters+0x3e>
    0x84015690    0x38    li a5,-1
    0x84015692    0x3a    slli a5,a5,0x27
    0x84015694    0x3c    or s0,s0,a5
    0x84015696    0x3e    auipc s4,0x15
    0x8401569a    0x42    ld s4,418(s4) # ffffffff8402a838 <ksCurThread>
    0x8401569e    0x46    beq s4,s0,ffffffff840156f0 <decodeWriteRegisters+0x98>
    0x840156a2    0x4a    mv a1,s1
    0x840156a4    0x4c    li a0,0
    0x840156a6    0x4e    jal ra,ffffffff840100ea <getSyscallArg>
    0x840156aa    0x52    mv s3,a0
    0x840156ac    0x54    li a1,2
    0x840156ae    0x56    mv a0,s4
    0x840156b0    0x58    jal ra,ffffffff8401263a <setThreadState>
    0x840156b4    0x5c    mv a4,s1
    0x840156b6    0x5e    li a3,0
    0x840156b8    0x60    mv a2,s2
    0x840156ba    0x62    andi a1,s3,1
    0x840156be    0x66    mv a0,s0
    0x840156c0    0x68    jal ra,ffffffff84015570 <invokeTCB_WriteRegisters>
    0x840156c4    0x6c    ld ra,56(sp)          ; stack access
    0x840156c6    0x6e    ld s0,48(sp)          ; stack access
    0x840156c8    0x70    ld s1,40(sp)          ; stack access
    0x840156ca    0x72    ld s2,32(sp)          ; stack access
    0x840156cc    0x74    ld s3,24(sp)          ; stack access
    0x840156ce    0x76    ld s4,16(sp)          ; stack access
    0x840156d0    0x78    addi sp,sp,64
    0x840156d2    0x7a    ret
    0x840156d4    0x7c    li a5,7
    0x840156d6    0x7e    auipc a4,0x3
    0x840156da    0x82    sd a5,-6(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840156de    0x86    li a0,3
    0x840156e0    0x88    j ffffffff840156c4 <decodeWriteRegisters+0x6c>
    0x840156e2    0x8a    li a5,7
    0x840156e4    0x8c    auipc a4,0x3
    0x840156e8    0x90    sd a5,-20(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840156ec    0x94    li a0,3
    0x840156ee    0x96    j ffffffff840156c4 <decodeWriteRegisters+0x6c>
    0x840156f0    0x98    li a5,3
    0x840156f2    0x9a    auipc a4,0x3
    0x840156f6    0x9e    sd a5,-34(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840156fa    0xa2    li a0,3
    0x840156fc    0xa4    j ffffffff840156c4 <decodeWriteRegisters+0x6c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
66 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeWriteRegisters` has 97 nodes.

Section invokeTCB_WriteRegisters (210 of 271)
=============================================

Deriving specifications
-----------------------

Section `invokeTCB_WriteRegisters` consists of 84 instructions.


Stack analysis
---------------

20 stack accesses found. Annotated code for `invokeTCB_WriteRegisters`:

    0x84015570     0x0    addi sp,sp,-80
    0x84015572     0x2    sd ra,72(sp)          ; stack access
    0x84015574     0x4    sd s0,64(sp)          ; stack access
    0x84015576     0x6    sd s1,56(sp)          ; stack access
    0x84015578     0x8    sd s2,48(sp)          ; stack access
    0x8401557a     0xa    sd s3,40(sp)          ; stack access
    0x8401557c     0xc    sd s4,32(sp)          ; stack access
    0x8401557e     0xe    sd s5,24(sp)          ; stack access
    0x84015580    0x10    sd s6,16(sp)          ; stack access
    0x84015582    0x12    sd s7,8(sp)           ; stack access
    0x84015584    0x14    sd s8,0(sp)           ; stack access
    0x84015586    0x16    mv s2,a0
    0x84015588    0x18    mv s5,a1
    0x8401558a    0x1a    mv s7,a2
    0x8401558c    0x1c    mv s3,a4
    0x8401558e    0x1e    mv s4,a2
    0x84015590    0x20    li a5,32
    0x84015594    0x24    bgeu a5,a2,ffffffff8401559c <invokeTCB_WriteRegisters+0x2c>
    0x84015598    0x28    li s4,32
    0x8401559c    0x2c    beqz s7,ffffffff84015618 <invokeTCB_WriteRegisters+0xa8>
    0x840155a0    0x30    mv a1,s3
    0x840155a2    0x32    li a0,2
    0x840155a4    0x34    jal ra,ffffffff840100ea <getSyscallArg>
    0x840155a8    0x38    sd a0,264(s2)
    0x840155ac    0x3c    auipc s6,0x2
    0x840155b0    0x40    addi s6,s6,164 # ffffffff84017650 <frameRegisters+0x8>
    0x840155b4    0x44    li s1,1
    0x840155b6    0x46    li s8,16
    0x840155b8    0x48    bgeu s1,s4,ffffffff840155d8 <invokeTCB_WriteRegisters+0x68>
    0x840155bc    0x4c    ld s0,0(s6)
    0x840155c0    0x50    mv a1,s3
    0x840155c2    0x52    addi a0,s1,2
    0x840155c6    0x56    jal ra,ffffffff840100ea <getSyscallArg>
    0x840155ca    0x5a    slli s0,s0,0x3
    0x840155cc    0x5c    add s0,s0,s2
    0x840155ce    0x5e    sd a0,0(s0)
    0x840155d0    0x60    addi s1,s1,1
    0x840155d2    0x62    addi s6,s6,8
    0x840155d4    0x64    bne s1,s8,ffffffff840155b8 <invokeTCB_WriteRegisters+0x48>
    0x840155d8    0x68    li a5,16
    0x840155da    0x6a    bgeu a5,s7,ffffffff84015618 <invokeTCB_WriteRegisters+0xa8>
    0x840155de    0x6e    mv a1,s3
    0x840155e0    0x70    li a0,18
    0x840155e2    0x72    jal ra,ffffffff840100ea <getSyscallArg>
    0x840155e6    0x76    sd a0,72(s2)
    0x840155ea    0x7a    auipc s6,0x2
    0x840155ee    0x7e    addi s6,s6,230 # ffffffff840176d0 <gpRegisters+0x8>
    0x840155f2    0x82    li s1,17
    0x840155f4    0x84    li s7,32
    0x840155f8    0x88    bgeu s1,s4,ffffffff84015618 <invokeTCB_WriteRegisters+0xa8>
    0x840155fc    0x8c    ld s0,0(s6)
    0x84015600    0x90    mv a1,s3
    0x84015602    0x92    addi a0,s1,2
    0x84015606    0x96    jal ra,ffffffff840100ea <getSyscallArg>
    0x8401560a    0x9a    slli s0,s0,0x3
    0x8401560c    0x9c    add s0,s0,s2
    0x8401560e    0x9e    sd a0,0(s0)
    0x84015610    0xa0    addi s1,s1,1
    0x84015612    0xa2    addi s6,s6,8
    0x84015614    0xa4    bne s1,s7,ffffffff840155f8 <invokeTCB_WriteRegisters+0x88>
    0x84015618    0xa8    ld a5,264(s2)
    0x8401561c    0xac    sd a5,272(s2)
    0x84015620    0xb0    bnez s5,ffffffff8401564a <invokeTCB_WriteRegisters+0xda>
    0x84015624    0xb4    auipc a5,0x15
    0x84015628    0xb8    ld a5,532(a5) # ffffffff8402a838 <ksCurThread>
    0x8401562c    0xbc    beq a5,s2,ffffffff84015652 <invokeTCB_WriteRegisters+0xe2>
    0x84015630    0xc0    li a0,0
    0x84015632    0xc2    ld ra,72(sp)          ; stack access
    0x84015634    0xc4    ld s0,64(sp)          ; stack access
    0x84015636    0xc6    ld s1,56(sp)          ; stack access
    0x84015638    0xc8    ld s2,48(sp)          ; stack access
    0x8401563a    0xca    ld s3,40(sp)          ; stack access
    0x8401563c    0xcc    ld s4,32(sp)          ; stack access
    0x8401563e    0xce    ld s5,24(sp)          ; stack access
    0x84015640    0xd0    ld s6,16(sp)          ; stack access
    0x84015642    0xd2    ld s7,8(sp)           ; stack access
    0x84015644    0xd4    ld s8,0(sp)           ; stack access
    0x84015646    0xd6    addi sp,sp,80
    0x84015648    0xd8    ret
    0x8401564a    0xda    mv a0,s2
    0x8401564c    0xdc    jal ra,ffffffff84013be4 <restart>
    0x84015650    0xe0    j ffffffff84015624 <invokeTCB_WriteRegisters+0xb4>
    0x84015652    0xe2    jal ra,ffffffff840125d4 <rescheduleRequired>
    0x84015656    0xe6    j ffffffff84015630 <invokeTCB_WriteRegisters+0xc0>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
84 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_WriteRegisters` has 138 nodes.

Section decodeReadRegisters (211 of 271)
========================================

Deriving specifications
-----------------------

Section `decodeReadRegisters` consists of 72 instructions.


Stack analysis
---------------

14 stack accesses found. Annotated code for `decodeReadRegisters`:

    0x840154b4     0x0    addi sp,sp,-64
    0x840154b6     0x2    sd ra,56(sp)          ; stack access
    0x840154b8     0x4    sd s0,48(sp)          ; stack access
    0x840154ba     0x6    sd s1,40(sp)          ; stack access
    0x840154bc     0x8    sd s2,32(sp)          ; stack access
    0x840154be     0xa    sd s3,24(sp)          ; stack access
    0x840154c0     0xc    sd s4,16(sp)          ; stack access
    0x840154c2     0xe    sd a0,0(sp)           ; stack access
    0x840154c4    0x10    li a5,1
    0x840154c6    0x12    bgeu a5,a2,ffffffff84015534 <decodeReadRegisters+0x80>
    0x840154ca    0x16    mv s3,a3
    0x840154cc    0x18    mv s0,a4
    0x840154ce    0x1a    mv a1,a4
    0x840154d0    0x1c    li a0,1
    0x840154d2    0x1e    jal ra,ffffffff840100ea <getSyscallArg>
    0x840154d6    0x22    mv s2,a0
    0x840154d8    0x24    addi a4,a0,-1
    0x840154dc    0x28    li a5,31
    0x840154de    0x2a    bltu a5,a4,ffffffff84015542 <decodeReadRegisters+0x8e>
    0x840154e2    0x2e    ld a5,0(sp)           ; stack access
    0x840154e4    0x30    slli s1,a5,0x19
    0x840154e8    0x34    srli s1,s1,0x19
    0x840154ea    0x36    srli a5,a5,0x26
    0x840154ec    0x38    andi a5,a5,1
    0x840154ee    0x3a    beqz a5,ffffffff840154f6 <decodeReadRegisters+0x42>
    0x840154f0    0x3c    li a5,-1
    0x840154f2    0x3e    slli a5,a5,0x27
    0x840154f4    0x40    or s1,s1,a5
    0x840154f6    0x42    auipc s4,0x15
    0x840154fa    0x46    ld s4,834(s4) # ffffffff8402a838 <ksCurThread>
    0x840154fe    0x4a    beq s4,s1,ffffffff84015562 <decodeReadRegisters+0xae>
    0x84015502    0x4e    mv a1,s0
    0x84015504    0x50    li a0,0
    0x84015506    0x52    jal ra,ffffffff840100ea <getSyscallArg>
    0x8401550a    0x56    mv s0,a0
    0x8401550c    0x58    li a1,2
    0x8401550e    0x5a    mv a0,s4
    0x84015510    0x5c    jal ra,ffffffff8401263a <setThreadState>
    0x84015514    0x60    mv a4,s3
    0x84015516    0x62    li a3,0
    0x84015518    0x64    mv a2,s2
    0x8401551a    0x66    andi a1,s0,1
    0x8401551e    0x6a    mv a0,s1
    0x84015520    0x6c    jal ra,ffffffff840153a2 <invokeTCB_ReadRegisters>
    0x84015524    0x70    ld ra,56(sp)          ; stack access
    0x84015526    0x72    ld s0,48(sp)          ; stack access
    0x84015528    0x74    ld s1,40(sp)          ; stack access
    0x8401552a    0x76    ld s2,32(sp)          ; stack access
    0x8401552c    0x78    ld s3,24(sp)          ; stack access
    0x8401552e    0x7a    ld s4,16(sp)          ; stack access
    0x84015530    0x7c    addi sp,sp,64
    0x84015532    0x7e    ret
    0x84015534    0x80    li a5,7
    0x84015536    0x82    auipc a4,0x3
    0x8401553a    0x86    sd a5,410(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x8401553e    0x8a    li a0,3
    0x84015540    0x8c    j ffffffff84015524 <decodeReadRegisters+0x70>
    0x84015542    0x8e    auipc a5,0x3
    0x84015546    0x92    addi a5,a5,-1346 # ffffffff84018000 <riscvKSASIDTable>
    0x8401554a    0x96    li a4,4
    0x8401554c    0x98    sd a4,1744(a5)
    0x84015550    0x9c    li a4,1
    0x84015552    0x9e    sd a4,1712(a5)
    0x84015556    0xa2    li a4,32
    0x8401555a    0xa6    sd a4,1720(a5)
    0x8401555e    0xaa    li a0,3
    0x84015560    0xac    j ffffffff84015524 <decodeReadRegisters+0x70>
    0x84015562    0xae    li a5,3
    0x84015564    0xb0    auipc a4,0x3
    0x84015568    0xb4    sd a5,364(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x8401556c    0xb8    li a0,3
    0x8401556e    0xba    j ffffffff84015524 <decodeReadRegisters+0x70>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
72 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeReadRegisters` has 105 nodes.

Section invokeTCB_ReadRegisters (212 of 271)
============================================

Deriving specifications
-----------------------

Section `invokeTCB_ReadRegisters` consists of 106 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `invokeTCB_ReadRegisters`:

    0x840153a2      0x0    addi sp,sp,-48
    0x840153a4      0x2    sd ra,40(sp)          ; stack access
    0x840153a6      0x4    sd s0,32(sp)          ; stack access
    0x840153a8      0x6    sd s1,24(sp)          ; stack access
    0x840153aa      0x8    sd s2,16(sp)          ; stack access
    0x840153ac      0xa    sd s3,8(sp)           ; stack access
    0x840153ae      0xc    mv s1,a0
    0x840153b0      0xe    mv s0,a2
    0x840153b2     0x10    mv s3,a4
    0x840153b4     0x12    auipc s2,0x15
    0x840153b8     0x16    ld s2,1156(s2) # ffffffff8402a838 <ksCurThread>
    0x840153bc     0x1a    bnez a1,ffffffff84015438 <invokeTCB_ReadRegisters+0x96>
    0x840153be     0x1c    beqz s3,ffffffff84015458 <invokeTCB_ReadRegisters+0xb6>
    0x840153c2     0x20    mv a1,s2
    0x840153c4     0x22    li a0,1
    0x840153c6     0x24    jal ra,ffffffff840107e6 <lookupIPCBuffer>
    0x840153ca     0x28    sd zero,72(s2)
    0x840153ce     0x2c    beqz s0,ffffffff840154ac <invokeTCB_ReadRegisters+0x10a>
    0x840153d0     0x2e    ld a5,264(s1)
    0x840153d4     0x32    sd a5,88(s2)
    0x840153d8     0x36    li a5,1
    0x840153da     0x38    bgeu a5,s0,ffffffff8401543e <invokeTCB_ReadRegisters+0x9c>
    0x840153de     0x3c    ld a5,0(s1)
    0x840153e0     0x3e    sd a5,96(s2)
    0x840153e4     0x42    li a5,2
    0x840153e6     0x44    bgeu a5,s0,ffffffff84015470 <invokeTCB_ReadRegisters+0xce>
    0x840153ea     0x48    ld a5,8(s1)
    0x840153ec     0x4a    sd a5,104(s2)
    0x840153f0     0x4e    li a5,3
    0x840153f2     0x50    bgeu a5,s0,ffffffff84015474 <invokeTCB_ReadRegisters+0xd2>
    0x840153f6     0x54    ld a5,16(s1)
    0x840153f8     0x56    sd a5,112(s2)
    0x840153fc     0x5a    li a5,4
    0x840153fe     0x5c    li a3,4
    0x84015400     0x5e    bgeu a5,s0,ffffffff84015440 <invokeTCB_ReadRegisters+0x9e>
    0x84015404     0x62    li a3,4
    0x84015406     0x64    beqz a0,ffffffff840154b0 <invokeTCB_ReadRegisters+0x10e>
    0x84015408     0x66    bgeu a3,s0,ffffffff84015446 <invokeTCB_ReadRegisters+0xa4>
    0x8401540c     0x6a    slli a4,a3,0x3
    0x84015410     0x6e    auipc a2,0x2
    0x84015414     0x72    addi a2,a2,568 # ffffffff84017648 <frameRegisters>
    0x84015418     0x76    add a2,a2,a4
    0x8401541a     0x78    add a4,a4,a0
    0x8401541c     0x7a    li a1,16
    0x8401541e     0x7c    addi a3,a3,1
    0x84015420     0x7e    ld a5,0(a2)
    0x84015422     0x80    slli a5,a5,0x3
    0x84015424     0x82    add a5,a5,s1
    0x84015426     0x84    ld a5,0(a5)
    0x84015428     0x86    sd a5,8(a4)
    0x8401542a     0x88    bgeu a3,s0,ffffffff84015446 <invokeTCB_ReadRegisters+0xa4>
    0x8401542e     0x8c    addi a2,a2,8
    0x84015430     0x8e    addi a4,a4,8
    0x84015432     0x90    bne a3,a1,ffffffff8401541e <invokeTCB_ReadRegisters+0x7c>
    0x84015436     0x94    j ffffffff84015446 <invokeTCB_ReadRegisters+0xa4>
    0x84015438     0x96    jal ra,ffffffff84013144 <suspend>
    0x8401543c     0x9a    j ffffffff840153be <invokeTCB_ReadRegisters+0x1c>
    0x8401543e     0x9c    li a3,1
    0x84015440     0x9e    beqz a0,ffffffff840154b0 <invokeTCB_ReadRegisters+0x10e>
    0x84015442     0xa0    bltu a3,s0,ffffffff84015408 <invokeTCB_ReadRegisters+0x66>
    0x84015446     0xa4    li a5,16
    0x84015448     0xa6    bltu a5,s0,ffffffff8401547c <invokeTCB_ReadRegisters+0xda>
    0x8401544c     0xaa    li a5,0
    0x8401544e     0xac    add a5,a5,a3
    0x84015450     0xae    andi a5,a5,127
    0x84015454     0xb2    sd a5,80(s2)
    0x84015458     0xb6    li a1,1
    0x8401545a     0xb8    mv a0,s2
    0x8401545c     0xba    jal ra,ffffffff8401263a <setThreadState>
    0x84015460     0xbe    li a0,0
    0x84015462     0xc0    ld ra,40(sp)          ; stack access
    0x84015464     0xc2    ld s0,32(sp)          ; stack access
    0x84015466     0xc4    ld s1,24(sp)          ; stack access
    0x84015468     0xc6    ld s2,16(sp)          ; stack access
    0x8401546a     0xc8    ld s3,8(sp)           ; stack access
    0x8401546c     0xca    addi sp,sp,48
    0x8401546e     0xcc    ret
    0x84015470     0xce    li a3,2
    0x84015472     0xd0    j ffffffff84015440 <invokeTCB_ReadRegisters+0x9e>
    0x84015474     0xd2    li a3,3
    0x84015476     0xd4    j ffffffff84015440 <invokeTCB_ReadRegisters+0x9e>
    0x84015478     0xd6    mv a5,s0
    0x8401547a     0xd8    j ffffffff8401544e <invokeTCB_ReadRegisters+0xac>
    0x8401547c     0xda    ld a5,72(s1)
    0x8401547e     0xdc    sd a5,136(a0)
    0x84015480     0xde    auipc a1,0x2
    0x84015484     0xe2    addi a1,a1,592 # ffffffff840176d0 <gpRegisters+0x8>
    0x84015488     0xe6    addi a0,a0,144
    0x8401548c     0xea    addi s0,s0,-16
    0x8401548e     0xec    li a5,1
    0x84015490     0xee    li a2,16
    0x84015492     0xf0    beq a5,s0,ffffffff84015478 <invokeTCB_ReadRegisters+0xd6>
    0x84015496     0xf4    ld a4,0(a1)
    0x84015498     0xf6    slli a4,a4,0x3
    0x8401549a     0xf8    add a4,a4,s1
    0x8401549c     0xfa    ld a4,0(a4)
    0x8401549e     0xfc    sd a4,0(a0)
    0x840154a0     0xfe    addi a5,a5,1
    0x840154a2    0x100    addi a1,a1,8
    0x840154a4    0x102    addi a0,a0,8
    0x840154a6    0x104    bne a5,a2,ffffffff84015492 <invokeTCB_ReadRegisters+0xf0>
    0x840154aa    0x108    j ffffffff8401544e <invokeTCB_ReadRegisters+0xac>
    0x840154ac    0x10a    mv a3,s0
    0x840154ae    0x10c    bnez a0,ffffffff84015446 <invokeTCB_ReadRegisters+0xa4>
    0x840154b0    0x10e    li a5,0
    0x840154b2    0x110    j ffffffff8401544e <invokeTCB_ReadRegisters+0xac>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
106 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_ReadRegisters` has 173 nodes.

Section decodeCopyRegisters (213 of 271)
========================================

Deriving specifications
-----------------------

Section `decodeCopyRegisters` consists of 64 instructions.


Stack analysis
---------------

9 stack accesses found. Annotated code for `decodeCopyRegisters`:

    0x840152f8     0x0    addi sp,sp,-48
    0x840152fa     0x2    sd ra,40(sp)          ; stack access
    0x840152fc     0x4    sd s0,32(sp)          ; stack access
    0x840152fe     0x6    sd s1,24(sp)          ; stack access
    0x84015300     0x8    sd a0,0(sp)           ; stack access
    0x84015302     0xa    sd a1,8(sp)           ; stack access
    0x84015304     0xc    beqz a2,ffffffff8401537c <decodeCopyRegisters+0x84>
    0x84015306     0xe    auipc a5,0x3
    0x8401530a    0x12    ld a5,1418(a5) # ffffffff84018890 <current_extra_caps>
    0x8401530e    0x16    beqz a5,ffffffff8401537c <decodeCopyRegisters+0x84>
    0x84015310    0x18    ld a5,0(a5)
    0x84015312    0x1a    srli a2,a5,0x3b
    0x84015316    0x1e    li a4,12
    0x84015318    0x20    bne a2,a4,ffffffff8401538a <decodeCopyRegisters+0x92>
    0x8401531c    0x24    slli s0,a5,0x19
    0x84015320    0x28    srli s0,s0,0x19
    0x84015322    0x2a    srli a5,a5,0x26
    0x84015324    0x2c    andi a5,a5,1
    0x84015326    0x2e    beqz a5,ffffffff8401532e <decodeCopyRegisters+0x36>
    0x84015328    0x30    li a5,-1
    0x8401532a    0x32    slli a5,a5,0x27
    0x8401532c    0x34    or s0,s0,a5
    0x8401532e    0x36    mv a1,a3
    0x84015330    0x38    li a0,0
    0x84015332    0x3a    jal ra,ffffffff840100ea <getSyscallArg>
    0x84015336    0x3e    mv s1,a0
    0x84015338    0x40    li a1,2
    0x8401533a    0x42    auipc a0,0x15
    0x8401533e    0x46    ld a0,1278(a0) # ffffffff8402a838 <ksCurThread>
    0x84015342    0x4a    jal ra,ffffffff8401263a <setThreadState>
    0x84015346    0x4e    ld a5,0(sp)           ; stack access
    0x84015348    0x50    slli a0,a5,0x19
    0x8401534c    0x54    srli a0,a0,0x19
    0x8401534e    0x56    srli a5,a5,0x26
    0x84015350    0x58    andi a5,a5,1
    0x84015352    0x5a    beqz a5,ffffffff8401535a <decodeCopyRegisters+0x62>
    0x84015354    0x5c    li a5,-1
    0x84015356    0x5e    slli a5,a5,0x27
    0x84015358    0x60    or a0,a0,a5
    0x8401535a    0x62    li a6,0
    0x8401535c    0x64    andi a5,s1,8
    0x84015360    0x68    andi a4,s1,4
    0x84015364    0x6c    andi a3,s1,2
    0x84015368    0x70    andi a2,s1,1
    0x8401536c    0x74    mv a1,s0
    0x8401536e    0x76    jal ra,ffffffff8401524e <invokeTCB_CopyRegisters>
    0x84015372    0x7a    ld ra,40(sp)          ; stack access
    0x84015374    0x7c    ld s0,32(sp)          ; stack access
    0x84015376    0x7e    ld s1,24(sp)          ; stack access
    0x84015378    0x80    addi sp,sp,48
    0x8401537a    0x82    ret
    0x8401537c    0x84    li a5,7
    0x8401537e    0x86    auipc a4,0x3
    0x84015382    0x8a    sd a5,850(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84015386    0x8e    li a0,3
    0x84015388    0x90    j ffffffff84015372 <decodeCopyRegisters+0x7a>
    0x8401538a    0x92    auipc a5,0x3
    0x8401538e    0x96    addi a5,a5,-906 # ffffffff84018000 <riscvKSASIDTable>
    0x84015392    0x9a    li a4,2
    0x84015394    0x9c    sd a4,1744(a5)
    0x84015398    0xa0    li a4,1
    0x8401539a    0xa2    sd a4,1704(a5)
    0x8401539e    0xa6    li a0,3
    0x840153a0    0xa8    j ffffffff84015372 <decodeCopyRegisters+0x7a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
64 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeCopyRegisters` has 93 nodes.

Section invokeTCB_CopyRegisters (214 of 271)
============================================

Deriving specifications
-----------------------

Section `invokeTCB_CopyRegisters` consists of 62 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `invokeTCB_CopyRegisters`:

    0x8401524e     0x0    addi sp,sp,-48
    0x84015250     0x2    sd ra,40(sp)          ; stack access
    0x84015252     0x4    sd s0,32(sp)          ; stack access
    0x84015254     0x6    sd s1,24(sp)          ; stack access
    0x84015256     0x8    sd s2,16(sp)          ; stack access
    0x84015258     0xa    sd s3,8(sp)           ; stack access
    0x8401525a     0xc    sd s4,0(sp)           ; stack access
    0x8401525c     0xe    mv s0,a0
    0x8401525e    0x10    mv s1,a1
    0x84015260    0x12    mv s4,a3
    0x84015262    0x14    mv s3,a4
    0x84015264    0x16    mv s2,a5
    0x84015266    0x18    bnez a2,ffffffff840152e2 <invokeTCB_CopyRegisters+0x94>
    0x84015268    0x1a    bnez s4,ffffffff840152ea <invokeTCB_CopyRegisters+0x9c>
    0x8401526c    0x1e    beqz s3,ffffffff8401529c <invokeTCB_CopyRegisters+0x4e>
    0x84015270    0x22    auipc a3,0x2
    0x84015274    0x26    addi a3,a3,984 # ffffffff84017648 <frameRegisters>
    0x84015278    0x2a    auipc a1,0x2
    0x8401527c    0x2e    addi a1,a1,1104 # ffffffff840176c8 <gpRegisters>
    0x84015280    0x32    ld a4,0(a3)
    0x84015282    0x34    slli a4,a4,0x3
    0x84015284    0x36    add a2,s1,a4
    0x84015288    0x3a    ld a2,0(a2)
    0x8401528a    0x3c    add a4,a4,s0
    0x8401528c    0x3e    sd a2,0(a4)
    0x8401528e    0x40    addi a3,a3,8
    0x84015290    0x42    bne a3,a1,ffffffff84015280 <invokeTCB_CopyRegisters+0x32>
    0x84015294    0x46    ld a5,264(s0)
    0x84015298    0x4a    sd a5,272(s0)
    0x8401529c    0x4e    beqz s2,ffffffff840152c4 <invokeTCB_CopyRegisters+0x76>
    0x840152a0    0x52    auipc a4,0x2
    0x840152a4    0x56    addi a4,a4,1064 # ffffffff840176c8 <gpRegisters>
    0x840152a8    0x5a    auipc a2,0x2
    0x840152ac    0x5e    addi a2,a2,1184 # ffffffff84017748 <gpRegisters+0x80>
    0x840152b0    0x62    ld a5,0(a4)
    0x840152b2    0x64    slli a5,a5,0x3
    0x840152b4    0x66    add a3,s1,a5
    0x840152b8    0x6a    ld a3,0(a3)
    0x840152ba    0x6c    add a5,a5,s0
    0x840152bc    0x6e    sd a3,0(a5)
    0x840152be    0x70    addi a4,a4,8
    0x840152c0    0x72    bne a4,a2,ffffffff840152b0 <invokeTCB_CopyRegisters+0x62>
    0x840152c4    0x76    auipc a5,0x15
    0x840152c8    0x7a    ld a5,1396(a5) # ffffffff8402a838 <ksCurThread>
    0x840152cc    0x7e    beq a5,s0,ffffffff840152f2 <invokeTCB_CopyRegisters+0xa4>
    0x840152d0    0x82    li a0,0
    0x840152d2    0x84    ld ra,40(sp)          ; stack access
    0x840152d4    0x86    ld s0,32(sp)          ; stack access
    0x840152d6    0x88    ld s1,24(sp)          ; stack access
    0x840152d8    0x8a    ld s2,16(sp)          ; stack access
    0x840152da    0x8c    ld s3,8(sp)           ; stack access
    0x840152dc    0x8e    ld s4,0(sp)           ; stack access
    0x840152de    0x90    addi sp,sp,48
    0x840152e0    0x92    ret
    0x840152e2    0x94    mv a0,a1
    0x840152e4    0x96    jal ra,ffffffff84013144 <suspend>
    0x840152e8    0x9a    j ffffffff84015268 <invokeTCB_CopyRegisters+0x1a>
    0x840152ea    0x9c    mv a0,s0
    0x840152ec    0x9e    jal ra,ffffffff84013be4 <restart>
    0x840152f0    0xa2    j ffffffff8401526c <invokeTCB_CopyRegisters+0x1e>
    0x840152f2    0xa4    jal ra,ffffffff840125d4 <rescheduleRequired>
    0x840152f6    0xa8    j ffffffff840152d0 <invokeTCB_CopyRegisters+0x82>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
62 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_CopyRegisters` has 101 nodes.

Section decodeSetSchedParams (215 of 271)
=========================================

Deriving specifications
-----------------------

Section `decodeSetSchedParams` consists of 101 instructions.


Stack analysis
---------------

19 stack accesses found. Annotated code for `decodeSetSchedParams`:

    0x84014efe      0x0    addi sp,sp,-128
    0x84014f00      0x2    sd ra,120(sp)         ; stack access
    0x84014f02      0x4    sd s0,112(sp)         ; stack access
    0x84014f04      0x6    sd s1,104(sp)         ; stack access
    0x84014f06      0x8    sd s2,96(sp)          ; stack access
    0x84014f08      0xa    sd a0,64(sp)          ; stack access
    0x84014f0a      0xc    sd a1,72(sp)          ; stack access
    0x84014f0c      0xe    li a5,1
    0x84014f0e     0x10    bgeu a5,a2,ffffffff84014fa4 <decodeSetSchedParams+0xa6>
    0x84014f12     0x14    mv s2,a3
    0x84014f14     0x16    auipc a5,0x4
    0x84014f18     0x1a    ld a5,-1668(a5) # ffffffff84018890 <current_extra_caps>
    0x84014f1c     0x1e    beqz a5,ffffffff84014fa4 <decodeSetSchedParams+0xa6>
    0x84014f1e     0x20    ld a5,0(a5)
    0x84014f20     0x22    srli a3,a5,0x3b
    0x84014f24     0x26    li a4,12
    0x84014f26     0x28    bne a3,a4,ffffffff84014fb2 <decodeSetSchedParams+0xb4>
    0x84014f2a     0x2c    slli s0,a5,0x19
    0x84014f2e     0x30    srli s0,s0,0x19
    0x84014f30     0x32    srli a5,a5,0x26
    0x84014f32     0x34    andi a5,a5,1
    0x84014f34     0x36    beqz a5,ffffffff84014f3c <decodeSetSchedParams+0x3e>
    0x84014f36     0x38    li a5,-1
    0x84014f38     0x3a    slli a5,a5,0x27
    0x84014f3a     0x3c    or s0,s0,a5
    0x84014f3c     0x3e    mv a1,s2
    0x84014f3e     0x40    li a0,0
    0x84014f40     0x42    jal ra,ffffffff840100ea <getSyscallArg>
    0x84014f44     0x46    mv s1,a0
    0x84014f46     0x48    ld s0,352(s0)
    0x84014f4a     0x4c    bltu s0,a0,ffffffff84014fd4 <decodeSetSchedParams+0xd6>
    0x84014f4e     0x50    mv a1,s2
    0x84014f50     0x52    li a0,1
    0x84014f52     0x54    jal ra,ffffffff840100ea <getSyscallArg>
    0x84014f56     0x58    mv s2,a0
    0x84014f58     0x5a    bltu s0,a0,ffffffff84014fee <decodeSetSchedParams+0xf0>
    0x84014f5c     0x5e    li a1,2
    0x84014f5e     0x60    auipc a0,0x16
    0x84014f62     0x64    ld a0,-1830(a0) # ffffffff8402a838 <ksCurThread>
    0x84014f66     0x68    jal ra,ffffffff8401263a <setThreadState>
    0x84014f6a     0x6c    ld a5,64(sp)          ; stack access
    0x84014f6c     0x6e    slli a0,a5,0x19
    0x84014f70     0x72    srli a0,a0,0x19
    0x84014f72     0x74    srli a5,a5,0x26
    0x84014f74     0x76    andi a5,a5,1
    0x84014f76     0x78    beqz a5,ffffffff84014f7e <decodeSetSchedParams+0x80>
    0x84014f78     0x7a    li a5,-1
    0x84014f7a     0x7c    slli a5,a5,0x27
    0x84014f7c     0x7e    or a0,a0,a5
    0x84014f7e     0x80    li a5,9
    0x84014f80     0x82    sd a5,56(sp)          ; stack access
    0x84014f82     0x84    sd zero,48(sp)        ; stack access
    0x84014f84     0x86    sd zero,32(sp)        ; stack access
    0x84014f86     0x88    sd zero,40(sp)        ; stack access
    0x84014f88     0x8a    sd zero,24(sp)        ; stack access
    0x84014f8a     0x8c    sd zero,16(sp)        ; stack access
    0x84014f8c     0x8e    sd zero,0(sp)         ; stack access
    0x84014f8e     0x90    sd zero,8(sp)         ; stack access
    0x84014f90     0x92    li a7,0
    0x84014f92     0x94    li a5,0
    0x84014f94     0x96    li a6,0
    0x84014f96     0x98    mv a4,s2
    0x84014f98     0x9a    mv a3,s1
    0x84014f9a     0x9c    li a2,0
    0x84014f9c     0x9e    li a1,0
    0x84014f9e     0xa0    jal ra,ffffffff84014a0a <invokeTCB_ThreadControl>
    0x84014fa2     0xa4    j ffffffff84014fc8 <decodeSetSchedParams+0xca>
    0x84014fa4     0xa6    li a5,7
    0x84014fa6     0xa8    auipc a4,0x3
    0x84014faa     0xac    sd a5,1834(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84014fae     0xb0    li a0,3
    0x84014fb0     0xb2    j ffffffff84014fc8 <decodeSetSchedParams+0xca>
    0x84014fb2     0xb4    auipc a5,0x3
    0x84014fb6     0xb8    addi a5,a5,78 # ffffffff84018000 <riscvKSASIDTable>
    0x84014fba     0xbc    li a4,2
    0x84014fbc     0xbe    sd a4,1744(a5)
    0x84014fc0     0xc2    li a4,1
    0x84014fc2     0xc4    sd a4,1704(a5)
    0x84014fc6     0xc8    li a0,3
    0x84014fc8     0xca    ld ra,120(sp)         ; stack access
    0x84014fca     0xcc    ld s0,112(sp)         ; stack access
    0x84014fcc     0xce    ld s1,104(sp)         ; stack access
    0x84014fce     0xd0    ld s2,96(sp)          ; stack access
    0x84014fd0     0xd2    addi sp,sp,128
    0x84014fd2     0xd4    ret
    0x84014fd4     0xd6    auipc a5,0x3
    0x84014fd8     0xda    addi a5,a5,44 # ffffffff84018000 <riscvKSASIDTable>
    0x84014fdc     0xde    li a4,4
    0x84014fde     0xe0    sd a4,1744(a5)
    0x84014fe2     0xe4    sd zero,1712(a5)
    0x84014fe6     0xe8    sd s0,1720(a5)
    0x84014fea     0xec    li a0,3
    0x84014fec     0xee    j ffffffff84014fc8 <decodeSetSchedParams+0xca>
    0x84014fee     0xf0    auipc a5,0x3
    0x84014ff2     0xf4    addi a5,a5,18 # ffffffff84018000 <riscvKSASIDTable>
    0x84014ff6     0xf8    li a4,4
    0x84014ff8     0xfa    sd a4,1744(a5)
    0x84014ffc     0xfe    sd zero,1712(a5)
    0x84015000    0x102    sd s0,1720(a5)
    0x84015004    0x106    li a0,3
    0x84015006    0x108    j ffffffff84014fc8 <decodeSetSchedParams+0xca>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
101 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetSchedParams` has 152 nodes.

Section decodeSetMCPriority (216 of 271)
========================================

Deriving specifications
-----------------------

Section `decodeSetMCPriority` consists of 84 instructions.


Stack analysis
---------------

17 stack accesses found. Annotated code for `decodeSetMCPriority`:

    0x84014e26     0x0    addi sp,sp,-128
    0x84014e28     0x2    sd ra,120(sp)         ; stack access
    0x84014e2a     0x4    sd s0,112(sp)         ; stack access
    0x84014e2c     0x6    sd s1,104(sp)         ; stack access
    0x84014e2e     0x8    sd a0,64(sp)          ; stack access
    0x84014e30     0xa    sd a1,72(sp)          ; stack access
    0x84014e32     0xc    beqz a2,ffffffff84014eb6 <decodeSetMCPriority+0x90>
    0x84014e34     0xe    auipc a5,0x4
    0x84014e38    0x12    ld a5,-1444(a5) # ffffffff84018890 <current_extra_caps>
    0x84014e3c    0x16    beqz a5,ffffffff84014eb6 <decodeSetMCPriority+0x90>
    0x84014e3e    0x18    ld a5,0(a5)
    0x84014e40    0x1a    srli a2,a5,0x3b
    0x84014e44    0x1e    li a4,12
    0x84014e46    0x20    bne a2,a4,ffffffff84014ecc <decodeSetMCPriority+0xa6>
    0x84014e4a    0x24    slli s0,a5,0x19
    0x84014e4e    0x28    srli s0,s0,0x19
    0x84014e50    0x2a    srli a5,a5,0x26
    0x84014e52    0x2c    andi a5,a5,1
    0x84014e54    0x2e    beqz a5,ffffffff84014e5c <decodeSetMCPriority+0x36>
    0x84014e56    0x30    li a5,-1
    0x84014e58    0x32    slli a5,a5,0x27
    0x84014e5a    0x34    or s0,s0,a5
    0x84014e5c    0x36    mv a1,a3
    0x84014e5e    0x38    li a0,0
    0x84014e60    0x3a    jal ra,ffffffff840100ea <getSyscallArg>
    0x84014e64    0x3e    mv s1,a0
    0x84014e66    0x40    ld a5,352(s0)
    0x84014e6a    0x44    bltu a5,a0,ffffffff84014ee4 <decodeSetMCPriority+0xbe>
    0x84014e6e    0x48    li a1,2
    0x84014e70    0x4a    auipc a0,0x16
    0x84014e74    0x4e    ld a0,-1592(a0) # ffffffff8402a838 <ksCurThread>
    0x84014e78    0x52    jal ra,ffffffff8401263a <setThreadState>
    0x84014e7c    0x56    ld a5,64(sp)          ; stack access
    0x84014e7e    0x58    slli a0,a5,0x19
    0x84014e82    0x5c    srli a0,a0,0x19
    0x84014e84    0x5e    srli a5,a5,0x26
    0x84014e86    0x60    andi a5,a5,1
    0x84014e88    0x62    beqz a5,ffffffff84014e90 <decodeSetMCPriority+0x6a>
    0x84014e8a    0x64    li a5,-1
    0x84014e8c    0x66    slli a5,a5,0x27
    0x84014e8e    0x68    or a0,a0,a5
    0x84014e90    0x6a    li a5,8
    0x84014e92    0x6c    sd a5,56(sp)          ; stack access
    0x84014e94    0x6e    sd zero,48(sp)        ; stack access
    0x84014e96    0x70    sd zero,32(sp)        ; stack access
    0x84014e98    0x72    sd zero,40(sp)        ; stack access
    0x84014e9a    0x74    sd zero,24(sp)        ; stack access
    0x84014e9c    0x76    sd zero,16(sp)        ; stack access
    0x84014e9e    0x78    sd zero,0(sp)         ; stack access
    0x84014ea0    0x7a    sd zero,8(sp)         ; stack access
    0x84014ea2    0x7c    li a7,0
    0x84014ea4    0x7e    li a5,0
    0x84014ea6    0x80    li a6,0
    0x84014ea8    0x82    li a4,0
    0x84014eaa    0x84    mv a3,s1
    0x84014eac    0x86    li a2,0
    0x84014eae    0x88    li a1,0
    0x84014eb0    0x8a    jal ra,ffffffff84014a0a <invokeTCB_ThreadControl>
    0x84014eb4    0x8e    j ffffffff84014ec2 <decodeSetMCPriority+0x9c>
    0x84014eb6    0x90    li a5,7
    0x84014eb8    0x92    auipc a4,0x4
    0x84014ebc    0x96    sd a5,-2024(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84014ec0    0x9a    li a0,3
    0x84014ec2    0x9c    ld ra,120(sp)         ; stack access
    0x84014ec4    0x9e    ld s0,112(sp)         ; stack access
    0x84014ec6    0xa0    ld s1,104(sp)         ; stack access
    0x84014ec8    0xa2    addi sp,sp,128
    0x84014eca    0xa4    ret
    0x84014ecc    0xa6    auipc a5,0x3
    0x84014ed0    0xaa    addi a5,a5,308 # ffffffff84018000 <riscvKSASIDTable>
    0x84014ed4    0xae    li a4,2
    0x84014ed6    0xb0    sd a4,1744(a5)
    0x84014eda    0xb4    li a4,1
    0x84014edc    0xb6    sd a4,1704(a5)
    0x84014ee0    0xba    li a0,3
    0x84014ee2    0xbc    j ffffffff84014ec2 <decodeSetMCPriority+0x9c>
    0x84014ee4    0xbe    auipc a4,0x3
    0x84014ee8    0xc2    addi a4,a4,284 # ffffffff84018000 <riscvKSASIDTable>
    0x84014eec    0xc6    li a3,4
    0x84014eee    0xc8    sd a3,1744(a4)
    0x84014ef2    0xcc    sd zero,1712(a4)
    0x84014ef6    0xd0    sd a5,1720(a4)
    0x84014efa    0xd4    li a0,3
    0x84014efc    0xd6    j ffffffff84014ec2 <decodeSetMCPriority+0x9c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
84 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetMCPriority` has 127 nodes.

Section decodeSetPriority (217 of 271)
======================================

Deriving specifications
-----------------------

Section `decodeSetPriority` consists of 84 instructions.


Stack analysis
---------------

17 stack accesses found. Annotated code for `decodeSetPriority`:

    0x84014d4e     0x0    addi sp,sp,-128
    0x84014d50     0x2    sd ra,120(sp)         ; stack access
    0x84014d52     0x4    sd s0,112(sp)         ; stack access
    0x84014d54     0x6    sd s1,104(sp)         ; stack access
    0x84014d56     0x8    sd a0,64(sp)          ; stack access
    0x84014d58     0xa    sd a1,72(sp)          ; stack access
    0x84014d5a     0xc    beqz a2,ffffffff84014dde <decodeSetPriority+0x90>
    0x84014d5c     0xe    auipc a5,0x4
    0x84014d60    0x12    ld a5,-1228(a5) # ffffffff84018890 <current_extra_caps>
    0x84014d64    0x16    beqz a5,ffffffff84014dde <decodeSetPriority+0x90>
    0x84014d66    0x18    ld a5,0(a5)
    0x84014d68    0x1a    srli a2,a5,0x3b
    0x84014d6c    0x1e    li a4,12
    0x84014d6e    0x20    bne a2,a4,ffffffff84014df4 <decodeSetPriority+0xa6>
    0x84014d72    0x24    slli s0,a5,0x19
    0x84014d76    0x28    srli s0,s0,0x19
    0x84014d78    0x2a    srli a5,a5,0x26
    0x84014d7a    0x2c    andi a5,a5,1
    0x84014d7c    0x2e    beqz a5,ffffffff84014d84 <decodeSetPriority+0x36>
    0x84014d7e    0x30    li a5,-1
    0x84014d80    0x32    slli a5,a5,0x27
    0x84014d82    0x34    or s0,s0,a5
    0x84014d84    0x36    mv a1,a3
    0x84014d86    0x38    li a0,0
    0x84014d88    0x3a    jal ra,ffffffff840100ea <getSyscallArg>
    0x84014d8c    0x3e    mv s1,a0
    0x84014d8e    0x40    ld a5,352(s0)
    0x84014d92    0x44    bltu a5,a0,ffffffff84014e0c <decodeSetPriority+0xbe>
    0x84014d96    0x48    li a1,2
    0x84014d98    0x4a    auipc a0,0x16
    0x84014d9c    0x4e    ld a0,-1376(a0) # ffffffff8402a838 <ksCurThread>
    0x84014da0    0x52    jal ra,ffffffff8401263a <setThreadState>
    0x84014da4    0x56    ld a5,64(sp)          ; stack access
    0x84014da6    0x58    slli a0,a5,0x19
    0x84014daa    0x5c    srli a0,a0,0x19
    0x84014dac    0x5e    srli a5,a5,0x26
    0x84014dae    0x60    andi a5,a5,1
    0x84014db0    0x62    beqz a5,ffffffff84014db8 <decodeSetPriority+0x6a>
    0x84014db2    0x64    li a5,-1
    0x84014db4    0x66    slli a5,a5,0x27
    0x84014db6    0x68    or a0,a0,a5
    0x84014db8    0x6a    li a5,1
    0x84014dba    0x6c    sd a5,56(sp)          ; stack access
    0x84014dbc    0x6e    sd zero,48(sp)        ; stack access
    0x84014dbe    0x70    sd zero,32(sp)        ; stack access
    0x84014dc0    0x72    sd zero,40(sp)        ; stack access
    0x84014dc2    0x74    sd zero,24(sp)        ; stack access
    0x84014dc4    0x76    sd zero,16(sp)        ; stack access
    0x84014dc6    0x78    sd zero,0(sp)         ; stack access
    0x84014dc8    0x7a    sd zero,8(sp)         ; stack access
    0x84014dca    0x7c    li a7,0
    0x84014dcc    0x7e    li a5,0
    0x84014dce    0x80    li a6,0
    0x84014dd0    0x82    mv a4,s1
    0x84014dd2    0x84    li a3,0
    0x84014dd4    0x86    li a2,0
    0x84014dd6    0x88    li a1,0
    0x84014dd8    0x8a    jal ra,ffffffff84014a0a <invokeTCB_ThreadControl>
    0x84014ddc    0x8e    j ffffffff84014dea <decodeSetPriority+0x9c>
    0x84014dde    0x90    li a5,7
    0x84014de0    0x92    auipc a4,0x4
    0x84014de4    0x96    sd a5,-1808(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84014de8    0x9a    li a0,3
    0x84014dea    0x9c    ld ra,120(sp)         ; stack access
    0x84014dec    0x9e    ld s0,112(sp)         ; stack access
    0x84014dee    0xa0    ld s1,104(sp)         ; stack access
    0x84014df0    0xa2    addi sp,sp,128
    0x84014df2    0xa4    ret
    0x84014df4    0xa6    auipc a5,0x3
    0x84014df8    0xaa    addi a5,a5,524 # ffffffff84018000 <riscvKSASIDTable>
    0x84014dfc    0xae    li a4,2
    0x84014dfe    0xb0    sd a4,1744(a5)
    0x84014e02    0xb4    li a4,1
    0x84014e04    0xb6    sd a4,1704(a5)
    0x84014e08    0xba    li a0,3
    0x84014e0a    0xbc    j ffffffff84014dea <decodeSetPriority+0x9c>
    0x84014e0c    0xbe    auipc a4,0x3
    0x84014e10    0xc2    addi a4,a4,500 # ffffffff84018000 <riscvKSASIDTable>
    0x84014e14    0xc6    li a3,4
    0x84014e16    0xc8    sd a3,1744(a4)
    0x84014e1a    0xcc    sd zero,1712(a4)
    0x84014e1e    0xd0    sd a5,1720(a4)
    0x84014e22    0xd4    li a0,3
    0x84014e24    0xd6    j ffffffff84014dea <decodeSetPriority+0x9c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
84 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetPriority` has 127 nodes.

Section decodeDomainInvocation (218 of 271)
===========================================

Deriving specifications
-----------------------

Section `decodeDomainInvocation` consists of 70 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `decodeDomainInvocation`:

    0x8401492a     0x0    li a4,29
    0x8401492c     0x2    bne a0,a4,ffffffff84014994 <decodeDomainInvocation+0x6a>
    0x84014930     0x6    mv a5,a1
    0x84014932     0x8    mv a1,a2
    0x84014934     0xa    beqz a5,ffffffff840149a2 <decodeDomainInvocation+0x78>
    0x84014936     0xc    addi sp,sp,-32
    0x84014938     0xe    sd ra,24(sp)          ; stack access
    0x8401493a    0x10    sd s0,16(sp)          ; stack access
    0x8401493c    0x12    sd s1,8(sp)           ; stack access
    0x8401493e    0x14    li a0,0
    0x84014940    0x16    jal ra,ffffffff840100ea <getSyscallArg>
    0x84014944    0x1a    mv s1,a0
    0x84014946    0x1c    li a5,15
    0x84014948    0x1e    bltu a5,a0,ffffffff840149b0 <decodeDomainInvocation+0x86>
    0x8401494c    0x22    auipc a5,0x4
    0x84014950    0x26    ld a5,-188(a5) # ffffffff84018890 <current_extra_caps>
    0x84014954    0x2a    beqz a5,ffffffff840149c6 <decodeDomainInvocation+0x9c>
    0x84014956    0x2c    ld s0,0(a5)
    0x84014958    0x2e    srli a4,s0,0x3b
    0x8401495c    0x32    li a5,12
    0x8401495e    0x34    bne a4,a5,ffffffff840149d4 <decodeDomainInvocation+0xaa>
    0x84014962    0x38    li a1,2
    0x84014964    0x3a    auipc a0,0x16
    0x84014968    0x3e    ld a0,-300(a0) # ffffffff8402a838 <ksCurThread>
    0x8401496c    0x42    jal ra,ffffffff8401263a <setThreadState>
    0x84014970    0x46    slli a0,s0,0x19
    0x84014974    0x4a    srli a0,a0,0x19
    0x84014976    0x4c    srli s0,s0,0x26
    0x84014978    0x4e    andi s0,s0,1
    0x8401497a    0x50    beqz s0,ffffffff84014982 <decodeDomainInvocation+0x58>
    0x8401497c    0x52    li a5,-1
    0x8401497e    0x54    slli a5,a5,0x27
    0x84014980    0x56    or a0,a0,a5
    0x84014982    0x58    mv a1,s1
    0x84014984    0x5a    jal ra,ffffffff84012e1c <setDomain>
    0x84014988    0x5e    li a0,0
    0x8401498a    0x60    ld ra,24(sp)          ; stack access
    0x8401498c    0x62    ld s0,16(sp)          ; stack access
    0x8401498e    0x64    ld s1,8(sp)           ; stack access
    0x84014990    0x66    addi sp,sp,32
    0x84014992    0x68    ret
    0x84014994    0x6a    li a5,3
    0x84014996    0x6c    auipc a4,0x4
    0x8401499a    0x70    sd a5,-710(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x8401499e    0x74    li a0,3
    0x840149a0    0x76    ret
    0x840149a2    0x78    li a5,7
    0x840149a4    0x7a    auipc a4,0x4
    0x840149a8    0x7e    sd a5,-724(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840149ac    0x82    li a0,3
    0x840149ae    0x84    ret
    0x840149b0    0x86    auipc a5,0x3
    0x840149b4    0x8a    addi a5,a5,1616 # ffffffff84018000 <riscvKSASIDTable>
    0x840149b8    0x8e    li a4,1
    0x840149ba    0x90    sd a4,1744(a5)
    0x840149be    0x94    sd zero,1696(a5)
    0x840149c2    0x98    li a0,3
    0x840149c4    0x9a    j ffffffff8401498a <decodeDomainInvocation+0x60>
    0x840149c6    0x9c    li a5,7
    0x840149c8    0x9e    auipc a4,0x4
    0x840149cc    0xa2    sd a5,-760(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840149d0    0xa6    li a0,3
    0x840149d2    0xa8    j ffffffff8401498a <decodeDomainInvocation+0x60>
    0x840149d4    0xaa    auipc a5,0x3
    0x840149d8    0xae    addi a5,a5,1580 # ffffffff84018000 <riscvKSASIDTable>
    0x840149dc    0xb2    li a4,1
    0x840149de    0xb4    sd a4,1744(a5)
    0x840149e2    0xb8    sd a4,1696(a5)
    0x840149e6    0xbc    li a0,3
    0x840149e8    0xbe    j ffffffff8401498a <decodeDomainInvocation+0x60>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
70 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeDomainInvocation` has 104 nodes.

Section c_handle_exception (219 of 271)
=======================================

Deriving specifications
-----------------------

Section `c_handle_exception` consists of 16 instructions.

Skipping 14202573 csrr a0,scause


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_exception`:

    0x840145d8     0x0    addi sp,sp,-16
    0x840145da     0x2    sd ra,8(sp)           ; stack access
    0x840145dc     0x4    csrr a0,scause
    0x840145e0     0x8    li a5,15
    0x840145e2     0xa    bltu a5,a0,ffffffff840145f6 <c_handle_exception+0x1e>
    0x840145e6     0xe    li a5,1
    0x840145e8    0x10    sll a5,a5,a0
    0x840145ec    0x14    lui a4,0xb
    0x840145ee    0x16    addi a4,a4,162 # b0a2 <KERNEL_OFFSET-0xfffffffeffff4f5e>
    0x840145f2    0x1a    and a5,a5,a4
    0x840145f4    0x1c    bnez a5,ffffffff840145fe <c_handle_exception+0x26>
    0x840145f6    0x1e    li a1,0
    0x840145f8    0x20    jal ra,ffffffff84014566 <handleUserLevelFault>
    0x840145fc    0x24    j ffffffff84014602 <c_handle_exception+0x2a>
    0x840145fe    0x26    jal ra,ffffffff840145a6 <handleVMFaultEvent>
    0x84014602    0x2a    jal ra,ffffffff8401037c <restore_user_context>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_exception` has 25 nodes.

Section handleUserLevelFault (220 of 271)
=========================================

Deriving specifications
-----------------------

Section `handleUserLevelFault` consists of 22 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleUserLevelFault`:

    0x84014566     0x0    addi sp,sp,-16
    0x84014568     0x2    sd ra,8(sp)           ; stack access
    0x8401456a     0x4    auipc a4,0x4
    0x8401456e     0x8    addi a4,a4,-1386 # ffffffff84018000 <riscvKSASIDTable>
    0x84014572     0xc    slli a1,a1,0x4
    0x84014574     0xe    li a5,-1
    0x84014576    0x10    srli a5,a5,0x20
    0x84014578    0x12    and a1,a1,a5
    0x8401457a    0x14    slli a0,a0,0x20
    0x8401457c    0x16    or a1,a1,a0
    0x8401457e    0x18    ori a1,a1,3
    0x84014582    0x1c    sd a1,1680(a4)
    0x84014586    0x20    sd zero,1688(a4)
    0x8401458a    0x24    auipc a0,0x16
    0x8401458e    0x28    ld a0,686(a0) # ffffffff8402a838 <ksCurThread>
    0x84014592    0x2c    jal ra,ffffffff84014514 <handleFault>
    0x84014596    0x30    jal ra,ffffffff84012cf4 <schedule>
    0x8401459a    0x34    jal ra,ffffffff84012744 <activateThread>
    0x8401459e    0x38    li a0,0
    0x840145a0    0x3a    ld ra,8(sp)           ; stack access
    0x840145a2    0x3c    addi sp,sp,16
    0x840145a4    0x3e    ret

Proving inst theorems
---------------------

22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleUserLevelFault` has 31 nodes.

Section handleUnknownSyscall (221 of 271)
=========================================

Deriving specifications
-----------------------

Section `handleUnknownSyscall` consists of 16 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleUnknownSyscall`:

    0x84014534     0x0    addi sp,sp,-16
    0x84014536     0x2    sd ra,8(sp)           ; stack access
    0x84014538     0x4    auipc a5,0x4
    0x8401453c     0x8    addi a5,a5,-1336 # ffffffff84018000 <riscvKSASIDTable>
    0x84014540     0xc    li a4,2
    0x84014542     0xe    sd a4,1680(a5)
    0x84014546    0x12    sd a0,1688(a5)
    0x8401454a    0x16    auipc a0,0x16
    0x8401454e    0x1a    ld a0,750(a0) # ffffffff8402a838 <ksCurThread>
    0x84014552    0x1e    jal ra,ffffffff84014514 <handleFault>
    0x84014556    0x22    jal ra,ffffffff84012cf4 <schedule>
    0x8401455a    0x26    jal ra,ffffffff84012744 <activateThread>
    0x8401455e    0x2a    li a0,0
    0x84014560    0x2c    ld ra,8(sp)           ; stack access
    0x84014562    0x2e    addi sp,sp,16
    0x84014564    0x30    ret

Proving inst theorems
---------------------

16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleUnknownSyscall` has 25 nodes.

Section doIPCTransfer (222 of 271)
==================================

Deriving specifications
-----------------------

Section `doIPCTransfer` consists of 46 instructions.


Stack analysis
---------------

14 stack accesses found. Annotated code for `doIPCTransfer`:

    0x8401417e     0x0    addi sp,sp,-64
    0x84014180     0x2    sd ra,56(sp)          ; stack access
    0x84014182     0x4    sd s0,48(sp)          ; stack access
    0x84014184     0x6    sd s1,40(sp)          ; stack access
    0x84014186     0x8    sd s2,32(sp)          ; stack access
    0x84014188     0xa    sd s3,24(sp)          ; stack access
    0x8401418a     0xc    sd s4,16(sp)          ; stack access
    0x8401418c     0xe    sd s5,8(sp)           ; stack access
    0x8401418e    0x10    mv s0,a0
    0x84014190    0x12    mv s5,a1
    0x84014192    0x14    mv s2,a2
    0x84014194    0x16    mv s4,a3
    0x84014196    0x18    mv s1,a4
    0x84014198    0x1a    mv a1,a4
    0x8401419a    0x1c    li a0,1
    0x8401419c    0x1e    jal ra,ffffffff840107e6 <lookupIPCBuffer>
    0x840141a0    0x22    mv s3,a0
    0x840141a2    0x24    ld a5,312(s0)
    0x840141a6    0x28    andi a5,a5,15
    0x840141a8    0x2a    bnez a5,ffffffff840141d6 <doIPCTransfer+0x58>
    0x840141aa    0x2c    mv a1,s0
    0x840141ac    0x2e    li a0,0
    0x840141ae    0x30    jal ra,ffffffff840107e6 <lookupIPCBuffer>
    0x840141b2    0x34    mv a1,a0
    0x840141b4    0x36    mv a6,s3
    0x840141b6    0x38    mv a5,s1
    0x840141b8    0x3a    mv a4,s4
    0x840141ba    0x3c    mv a3,s2
    0x840141bc    0x3e    mv a2,s5
    0x840141be    0x40    mv a0,s0
    0x840141c0    0x42    jal ra,ffffffff84014000 <doNormalTransfer>
    0x840141c4    0x46    ld ra,56(sp)          ; stack access
    0x840141c6    0x48    ld s0,48(sp)          ; stack access
    0x840141c8    0x4a    ld s1,40(sp)          ; stack access
    0x840141ca    0x4c    ld s2,32(sp)          ; stack access
    0x840141cc    0x4e    ld s3,24(sp)          ; stack access
    0x840141ce    0x50    ld s4,16(sp)          ; stack access
    0x840141d0    0x52    ld s5,8(sp)           ; stack access
    0x840141d2    0x54    addi sp,sp,64
    0x840141d4    0x56    ret
    0x840141d6    0x58    mv a3,a0
    0x840141d8    0x5a    mv a2,s1
    0x840141da    0x5c    mv a1,s0
    0x840141dc    0x5e    mv a0,s2
    0x840141de    0x60    jal ra,ffffffff8401161e <doFaultTransfer>
    0x840141e2    0x64    j ffffffff840141c4 <doIPCTransfer+0x46>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
46 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doIPCTransfer` has 68 nodes.

Section handleInterrupt (223 of 271)
====================================

Deriving specifications
-----------------------

Section `handleInterrupt` consists of 89 instructions.

Skipping c01027f3 rdtime a5

Skipping 00000073 ecall

Skipping c0102773 rdtime a4

Skipping 1047b7f3 csrrc a5,sie,a5


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleInterrupt`:

    0x84013d1c      0x0    li a5,54
    0x84013d20      0x4    bltu a5,a0,ffffffff84013d80 <handleInterrupt+0x64>
    0x84013d24      0x8    addi sp,sp,-16
    0x84013d26      0xa    sd ra,8(sp)           ; stack access
    0x84013d28      0xc    slli a4,a0,0x3
    0x84013d2c     0x10    auipc a5,0x4
    0x84013d30     0x14    addi a5,a5,724 # ffffffff84018000 <riscvKSASIDTable>
    0x84013d34     0x18    add a5,a5,a4
    0x84013d36     0x1a    ld a5,1752(a5)
    0x84013d3a     0x1e    li a4,2
    0x84013d3c     0x20    beq a5,a4,ffffffff84013dc2 <handleInterrupt+0xa6>
    0x84013d40     0x24    bltu a4,a5,ffffffff84013dae <handleInterrupt+0x92>
    0x84013d44     0x28    beqz a5,ffffffff84013de4 <handleInterrupt+0xc8>
    0x84013d46     0x2a    slli a0,a0,0x5
    0x84013d48     0x2c    auipc a5,0x5
    0x84013d4c     0x30    addi a5,a5,696 # ffffffff84019000 <intStateIRQNode>
    0x84013d50     0x34    add a5,a5,a0
    0x84013d52     0x36    ld a4,0(a5)
    0x84013d54     0x38    srli a2,a4,0x3b
    0x84013d58     0x3c    li a3,6
    0x84013d5a     0x3e    bne a2,a3,ffffffff84013db4 <handleInterrupt+0x98>
    0x84013d5e     0x42    srli a3,a4,0x39
    0x84013d62     0x46    andi a3,a3,1
    0x84013d64     0x48    beqz a3,ffffffff84013db4 <handleInterrupt+0x98>
    0x84013d66     0x4a    slli a0,a4,0x19
    0x84013d6a     0x4e    srli a0,a0,0x19
    0x84013d6c     0x50    srli a4,a4,0x26
    0x84013d6e     0x52    andi a4,a4,1
    0x84013d70     0x54    beqz a4,ffffffff84013d78 <handleInterrupt+0x5c>
    0x84013d72     0x56    li a4,-1
    0x84013d74     0x58    slli a4,a4,0x27
    0x84013d76     0x5a    or a0,a0,a4
    0x84013d78     0x5c    ld a1,8(a5)
    0x84013d7a     0x5e    jal ra,ffffffff84013c24 <sendSignal>
    0x84013d7e     0x62    j ffffffff84013db4 <handleInterrupt+0x98>
    0x84013d80     0x64    srli a4,a0,0x5
    0x84013d84     0x68    slli a4,a4,0x2
    0x84013d86     0x6a    lui a5,0xcc002
    0x84013d8a     0x6e    addi a5,a5,256 # ffffffffcc002100 <ki_end+0x47fd3100>
    0x84013d8e     0x72    add a4,a4,a5
    0x84013d90     0x74    lw a3,0(a4)
    0x84013d92     0x76    andi a0,a0,31
    0x84013d94     0x78    li a5,1
    0x84013d96     0x7a    sll a0,a5,a0
    0x84013d9a     0x7e    not a5,a0
    0x84013d9e     0x82    and a5,a5,a3
    0x84013da0     0x84    sext.w a5,a5
    0x84013da2     0x86    sw a5,0(a4)
    0x84013da4     0x88    auipc a5,0x17
    0x84013da8     0x8c    sw zero,-1372(a5) # ffffffff8402a848 <active_irq>
    0x84013dac     0x90    ret
    0x84013dae     0x92    li a4,3
    0x84013db0     0x94    bne a5,a4,ffffffff84013e1c <handleInterrupt+0x100>
    0x84013db4     0x98    auipc a5,0x17
    0x84013db8     0x9c    sw zero,-1388(a5) # ffffffff8402a848 <active_irq>
    0x84013dbc     0xa0    ld ra,8(sp)           ; stack access
    0x84013dbe     0xa2    addi sp,sp,16
    0x84013dc0     0xa4    ret
    0x84013dc2     0xa6    jal ra,ffffffff84012aba <timerTick>
    0x84013dc6     0xaa    rdtime a5
    0x84013dca     0xae    addi a5,a5,2000
    0x84013dce     0xb2    mv a0,a5
    0x84013dd0     0xb4    li a1,0
    0x84013dd2     0xb6    li a2,0
    0x84013dd4     0xb8    li a7,0
    0x84013dd6     0xba    ecall
    0x84013dda     0xbe    rdtime a4
    0x84013dde     0xc2    bltu a5,a4,ffffffff84013dc6 <handleInterrupt+0xaa>
    0x84013de2     0xc6    j ffffffff84013db4 <handleInterrupt+0x98>
    0x84013de4     0xc8    li a5,54
    0x84013de8     0xcc    bne a0,a5,ffffffff84013df6 <handleInterrupt+0xda>
    0x84013dec     0xd0    li a5,32
    0x84013df0     0xd4    csrrc a5,sie,a5
    0x84013df4     0xd8    j ffffffff84013db4 <handleInterrupt+0x98>
    0x84013df6     0xda    srli a4,a0,0x5
    0x84013dfa     0xde    slli a4,a4,0x2
    0x84013dfc     0xe0    lui a5,0xcc002
    0x84013e00     0xe4    addi a5,a5,256 # ffffffffcc002100 <ki_end+0x47fd3100>
    0x84013e04     0xe8    add a4,a4,a5
    0x84013e06     0xea    lw a3,0(a4)
    0x84013e08     0xec    andi a0,a0,31
    0x84013e0a     0xee    li a5,1
    0x84013e0c     0xf0    sll a0,a5,a0
    0x84013e10     0xf4    not a5,a0
    0x84013e14     0xf8    and a5,a5,a3
    0x84013e16     0xfa    sext.w a5,a5
    0x84013e18     0xfc    sw a5,0(a4)
    0x84013e1a     0xfe    j ffffffff84013db4 <handleInterrupt+0x98>
    0x84013e1c    0x100    jal ra,ffffffff8401041e <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
89 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleInterrupt` has 129 nodes.

Section decodeIRQHandlerInvocation (224 of 271)
===============================================

Deriving specifications
-----------------------

Section `decodeIRQHandlerInvocation` consists of 73 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `decodeIRQHandlerInvocation`:

    0x84013b00     0x0    addi sp,sp,-48
    0x84013b02     0x2    sd ra,40(sp)          ; stack access
    0x84013b04     0x4    sd s0,32(sp)          ; stack access
    0x84013b06     0x6    sd s1,24(sp)          ; stack access
    0x84013b08     0x8    mv s0,a1
    0x84013b0a     0xa    li a5,27
    0x84013b0c     0xc    beq a0,a5,ffffffff84013b4e <decodeIRQHandlerInvocation+0x4e>
    0x84013b10    0x10    li a5,28
    0x84013b12    0x12    beq a0,a5,ffffffff84013bb2 <decodeIRQHandlerInvocation+0xb2>
    0x84013b16    0x16    li a5,26
    0x84013b18    0x18    beq a0,a5,ffffffff84013b2a <decodeIRQHandlerInvocation+0x2a>
    0x84013b1c    0x1c    li a5,3
    0x84013b1e    0x1e    auipc a4,0x5
    0x84013b22    0x22    sd a5,-1102(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84013b26    0x26    li a0,3
    0x84013b28    0x28    j ffffffff84013b44 <decodeIRQHandlerInvocation+0x44>
    0x84013b2a    0x2a    li a1,2
    0x84013b2c    0x2c    auipc a0,0x17
    0x84013b30    0x30    ld a0,-756(a0) # ffffffff8402a838 <ksCurThread>
    0x84013b34    0x34    jal ra,ffffffff8401263a <setThreadState>
    0x84013b38    0x38    sext.w a1,s0
    0x84013b3c    0x3c    lui a5,0xcc202
    0x84013b40    0x40    sw a1,4(a5)
    0x84013b42    0x42    li a0,0
    0x84013b44    0x44    ld ra,40(sp)          ; stack access
    0x84013b46    0x46    ld s0,32(sp)          ; stack access
    0x84013b48    0x48    ld s1,24(sp)          ; stack access
    0x84013b4a    0x4a    addi sp,sp,48
    0x84013b4c    0x4c    ret
    0x84013b4e    0x4e    auipc s1,0x5
    0x84013b52    0x52    ld s1,-702(s1) # ffffffff84018890 <current_extra_caps>
    0x84013b56    0x56    beqz s1,ffffffff84013b86 <decodeIRQHandlerInvocation+0x86>
    0x84013b58    0x58    ld a5,0(s1)
    0x84013b5a    0x5a    sd a5,0(sp)           ; stack access
    0x84013b5c    0x5c    ld a4,8(s1)
    0x84013b5e    0x5e    sd a4,8(sp)           ; stack access
    0x84013b60    0x60    srli a3,a5,0x3b
    0x84013b64    0x64    li a4,6
    0x84013b66    0x66    bne a3,a4,ffffffff84013b70 <decodeIRQHandlerInvocation+0x70>
    0x84013b6a    0x6a    srli a5,a5,0x39
    0x84013b6c    0x6c    andi a5,a5,1
    0x84013b6e    0x6e    bnez a5,ffffffff84013b94 <decodeIRQHandlerInvocation+0x94>
    0x84013b70    0x70    auipc a5,0x4
    0x84013b74    0x74    addi a5,a5,1168 # ffffffff84018000 <riscvKSASIDTable>
    0x84013b78    0x78    li a4,2
    0x84013b7a    0x7a    sd a4,1744(a5)
    0x84013b7e    0x7e    sd zero,1704(a5)
    0x84013b82    0x82    li a0,3
    0x84013b84    0x84    j ffffffff84013b44 <decodeIRQHandlerInvocation+0x44>
    0x84013b86    0x86    li a5,7
    0x84013b88    0x88    auipc a4,0x5
    0x84013b8c    0x8c    sd a5,-1208(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84013b90    0x90    li a0,3
    0x84013b92    0x92    j ffffffff84013b44 <decodeIRQHandlerInvocation+0x44>
    0x84013b94    0x94    li a1,2
    0x84013b96    0x96    auipc a0,0x17
    0x84013b9a    0x9a    ld a0,-862(a0) # ffffffff8402a838 <ksCurThread>
    0x84013b9e    0x9e    jal ra,ffffffff8401263a <setThreadState>
    0x84013ba2    0xa2    mv a3,s1
    0x84013ba4    0xa4    ld a1,0(sp)           ; stack access
    0x84013ba6    0xa6    ld a2,8(sp)           ; stack access
    0x84013ba8    0xa8    mv a0,s0
    0x84013baa    0xaa    jal ra,ffffffff84013ab0 <invokeIRQHandler_SetIRQHandler>
    0x84013bae    0xae    li a0,0
    0x84013bb0    0xb0    j ffffffff84013b44 <decodeIRQHandlerInvocation+0x44>
    0x84013bb2    0xb2    li a1,2
    0x84013bb4    0xb4    auipc a0,0x17
    0x84013bb8    0xb8    ld a0,-892(a0) # ffffffff8402a838 <ksCurThread>
    0x84013bbc    0xbc    jal ra,ffffffff8401263a <setThreadState>
    0x84013bc0    0xc0    mv a0,s0
    0x84013bc2    0xc2    jal ra,ffffffff84013ae6 <invokeIRQHandler_ClearIRQHandler>
    0x84013bc6    0xc6    li a0,0
    0x84013bc8    0xc8    j ffffffff84013b44 <decodeIRQHandlerInvocation+0x44>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
73 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeIRQHandlerInvocation` has 112 nodes.

Section cteDeleteOne (225 of 271)
=================================

Deriving specifications
-----------------------

Section `cteDeleteOne` consists of 23 instructions.

RVC_TFFFFT___FFFT_TF.

Stack analysis
---------------

4 stack accesses found. Annotated code for `cteDeleteOne`:

    0x84013a7c     0x0    ld a5,0(a0)
    0x84013a7e     0x2    srli a5,a5,0x3b
    0x84013a80     0x4    bnez a5,ffffffff84013a84 <cteDeleteOne+0x8>
    0x84013a82     0x6    ret
    0x84013a84     0x8    addi sp,sp,-64
    0x84013a86     0xa    sd ra,56(sp)          ; stack access
    0x84013a88     0xc    sd s0,48(sp)          ; stack access
    0x84013a8a     0xe    mv s0,a0
    0x84013a8c    0x10    jal ra,ffffffff840121be <isFinalCapability>
    0x84013a90    0x14    mv a3,a0
    0x84013a92    0x16    li a4,1
    0x84013a94    0x18    ld a1,0(s0)
    0x84013a96    0x1a    ld a2,8(s0)
    0x84013a98    0x1c    mv a0,sp
    0x84013a9a    0x1e    jal ra,ffffffff8401317c <finaliseCap>
    0x84013a9e    0x22    li a1,0
    0x84013aa0    0x24    li a2,0
    0x84013aa2    0x26    mv a0,s0
    0x84013aa4    0x28    jal ra,ffffffff84011b74 <emptySlot>
    0x84013aa8    0x2c    ld ra,56(sp)          ; stack access
    0x84013aaa    0x2e    ld s0,48(sp)          ; stack access
    0x84013aac    0x30    addi sp,sp,64
    0x84013aae    0x32    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteDeleteOne` has 37 nodes.

Section cteRevoke (226 of 271)
==============================

Deriving specifications
-----------------------

Section `cteRevoke` consists of 55 instructions.


Stack analysis
---------------

14 stack accesses found. Annotated code for `cteRevoke`:

    0x8401350c     0x0    addi sp,sp,-64
    0x8401350e     0x2    sd ra,56(sp)          ; stack access
    0x84013510     0x4    sd s0,48(sp)          ; stack access
    0x84013512     0x6    sd s1,40(sp)          ; stack access
    0x84013514     0x8    sd s2,32(sp)          ; stack access
    0x84013516     0xa    sd s3,24(sp)          ; stack access
    0x84013518     0xc    sd s4,16(sp)          ; stack access
    0x8401351a     0xe    sd s5,8(sp)           ; stack access
    0x8401351c    0x10    mv s1,a0
    0x8401351e    0x12    ld a4,24(a0)
    0x84013520    0x14    lui a5,0xf8000
    0x84013524    0x18    srli a5,a5,0x19
    0x84013526    0x1a    and a0,a4,a5
    0x8401352a    0x1e    srli a4,a4,0x26
    0x8401352c    0x20    andi a4,a4,1
    0x8401352e    0x22    beqz a4,ffffffff84013574 <cteRevoke+0x68>
    0x84013530    0x24    li s0,-1
    0x84013532    0x26    slli s0,s0,0x27
    0x84013534    0x28    or s0,s0,a0
    0x84013536    0x2a    li s3,1
    0x84013538    0x2c    lui s2,0xf8000
    0x8401353c    0x30    srli s2,s2,0x19
    0x84013540    0x34    slli s5,s3,0x26
    0x84013544    0x38    li s4,-1
    0x84013546    0x3a    slli s4,s4,0x27
    0x84013548    0x3c    mv a1,s0
    0x8401354a    0x3e    mv a0,s1
    0x8401354c    0x40    jal ra,ffffffff84012036 <isMDBParentOf>
    0x84013550    0x44    beqz a0,ffffffff84013578 <cteRevoke+0x6c>
    0x84013552    0x46    mv a1,s3
    0x84013554    0x48    mv a0,s0
    0x84013556    0x4a    jal ra,ffffffff8401333c <cteDelete>
    0x8401355a    0x4e    bnez a0,ffffffff84013578 <cteRevoke+0x6c>
    0x8401355c    0x50    jal ra,ffffffff84011684 <preemptionPoint>
    0x84013560    0x54    bnez a0,ffffffff84013578 <cteRevoke+0x6c>
    0x84013562    0x56    ld a5,24(s1)
    0x84013564    0x58    and a0,a5,s2
    0x84013568    0x5c    and a5,a5,s5
    0x8401356c    0x60    beqz a5,ffffffff8401358a <cteRevoke+0x7e>
    0x8401356e    0x62    or s0,a0,s4
    0x84013572    0x66    j ffffffff84013548 <cteRevoke+0x3c>
    0x84013574    0x68    mv s0,a0
    0x84013576    0x6a    bnez a0,ffffffff84013536 <cteRevoke+0x2a>
    0x84013578    0x6c    ld ra,56(sp)          ; stack access
    0x8401357a    0x6e    ld s0,48(sp)          ; stack access
    0x8401357c    0x70    ld s1,40(sp)          ; stack access
    0x8401357e    0x72    ld s2,32(sp)          ; stack access
    0x84013580    0x74    ld s3,24(sp)          ; stack access
    0x84013582    0x76    ld s4,16(sp)          ; stack access
    0x84013584    0x78    ld s5,8(sp)           ; stack access
    0x84013586    0x7a    addi sp,sp,64
    0x84013588    0x7c    ret
    0x8401358a    0x7e    beqz a0,ffffffff84013578 <cteRevoke+0x6c>
    0x8401358c    0x80    mv s0,a0
    0x8401358e    0x82    j ffffffff84013548 <cteRevoke+0x3c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
55 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteRevoke` has 89 nodes.

Section suspend (227 of 271)
============================

Deriving specifications
-----------------------

Section `suspend` consists of 21 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `suspend`:

    0x84013144     0x0    addi sp,sp,-16
    0x84013146     0x2    sd ra,8(sp)           ; stack access
    0x84013148     0x4    sd s0,0(sp)           ; stack access
    0x8401314a     0x6    mv s0,a0
    0x8401314c     0x8    jal ra,ffffffff84013068 <cancelIPC>
    0x84013150     0xc    ld a5,280(s0)
    0x84013154    0x10    andi a5,a5,15
    0x84013156    0x12    li a4,1
    0x84013158    0x14    beq a5,a4,ffffffff84013172 <suspend+0x2e>
    0x8401315c    0x18    li a1,0
    0x8401315e    0x1a    mv a0,s0
    0x84013160    0x1c    jal ra,ffffffff8401263a <setThreadState>
    0x84013164    0x20    mv a0,s0
    0x84013166    0x22    jal ra,ffffffff84012b0c <tcbSchedDequeue>
    0x8401316a    0x26    ld ra,8(sp)           ; stack access
    0x8401316c    0x28    ld s0,0(sp)           ; stack access
    0x8401316e    0x2a    addi sp,sp,16
    0x84013170    0x2c    ret
    0x84013172    0x2e    ld a5,272(s0)
    0x84013176    0x32    sd a5,264(s0)
    0x8401317a    0x36    j ffffffff8401315c <suspend+0x18>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
21 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `suspend` has 34 nodes.

Section setPriority (228 of 271)
================================

Deriving specifications
-----------------------

Section `setPriority` consists of 26 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `setPriority`:

    0x84012e62     0x0    addi sp,sp,-32
    0x84012e64     0x2    sd ra,24(sp)          ; stack access
    0x84012e66     0x4    sd s0,16(sp)          ; stack access
    0x84012e68     0x6    sd s1,8(sp)           ; stack access
    0x84012e6a     0x8    mv s0,a0
    0x84012e6c     0xa    mv s1,a1
    0x84012e6e     0xc    jal ra,ffffffff84012b0c <tcbSchedDequeue>
    0x84012e72    0x10    sd s1,360(s0)
    0x84012e76    0x14    ld a5,280(s0)
    0x84012e7a    0x18    andi a5,a5,15
    0x84012e7c    0x1a    addi a5,a5,-1
    0x84012e7e    0x1c    li a4,1
    0x84012e80    0x1e    bgeu a4,a5,ffffffff84012e8e <setPriority+0x2c>
    0x84012e84    0x22    ld ra,24(sp)          ; stack access
    0x84012e86    0x24    ld s0,16(sp)          ; stack access
    0x84012e88    0x26    ld s1,8(sp)           ; stack access
    0x84012e8a    0x28    addi sp,sp,32
    0x84012e8c    0x2a    ret
    0x84012e8e    0x2c    auipc a5,0x18
    0x84012e92    0x30    ld a5,-1622(a5) # ffffffff8402a838 <ksCurThread>
    0x84012e96    0x34    beq a5,s0,ffffffff84012ea2 <setPriority+0x40>
    0x84012e9a    0x38    mv a0,s0
    0x84012e9c    0x3a    jal ra,ffffffff84012934 <possibleSwitchTo>
    0x84012ea0    0x3e    j ffffffff84012e84 <setPriority+0x22>
    0x84012ea2    0x40    jal ra,ffffffff840125d4 <rescheduleRequired>
    0x84012ea6    0x44    j ffffffff84012e84 <setPriority+0x22>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
26 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setPriority` has 43 nodes.

Section setDomain (229 of 271)
==============================

Deriving specifications
-----------------------

Section `setDomain` consists of 26 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `setDomain`:

    0x84012e1c     0x0    addi sp,sp,-32
    0x84012e1e     0x2    sd ra,24(sp)          ; stack access
    0x84012e20     0x4    sd s0,16(sp)          ; stack access
    0x84012e22     0x6    sd s1,8(sp)           ; stack access
    0x84012e24     0x8    mv s0,a0
    0x84012e26     0xa    mv s1,a1
    0x84012e28     0xc    jal ra,ffffffff84012b0c <tcbSchedDequeue>
    0x84012e2c    0x10    sd s1,344(s0)
    0x84012e30    0x14    ld a5,280(s0)
    0x84012e34    0x18    andi a5,a5,15
    0x84012e36    0x1a    addi a5,a5,-1
    0x84012e38    0x1c    li a4,1
    0x84012e3a    0x1e    bgeu a4,a5,ffffffff84012e54 <setDomain+0x38>
    0x84012e3e    0x22    auipc a5,0x18
    0x84012e42    0x26    ld a5,-1542(a5) # ffffffff8402a838 <ksCurThread>
    0x84012e46    0x2a    beq a5,s0,ffffffff84012e5c <setDomain+0x40>
    0x84012e4a    0x2e    ld ra,24(sp)          ; stack access
    0x84012e4c    0x30    ld s0,16(sp)          ; stack access
    0x84012e4e    0x32    ld s1,8(sp)           ; stack access
    0x84012e50    0x34    addi sp,sp,32
    0x84012e52    0x36    ret
    0x84012e54    0x38    mv a0,s0
    0x84012e56    0x3a    jal ra,ffffffff8401253a <tcbSchedEnqueue>
    0x84012e5a    0x3e    j ffffffff84012e3e <setDomain+0x22>
    0x84012e5c    0x40    jal ra,ffffffff840125d4 <rescheduleRequired>
    0x84012e60    0x44    j ffffffff84012e4a <setDomain+0x2e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
26 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setDomain` has 43 nodes.

Section chooseThread (230 of 271)
=================================

Deriving specifications
-----------------------

Section `chooseThread` consists of 43 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `chooseThread`:

    0x84012c0a     0x0    addi sp,sp,-32
    0x84012c0c     0x2    sd ra,24(sp)          ; stack access
    0x84012c0e     0x4    sd s0,16(sp)          ; stack access
    0x84012c10     0x6    sd s1,8(sp)           ; stack access
    0x84012c12     0x8    auipc s1,0x18
    0x84012c16     0xc    ld s1,-1018(s1) # ffffffff8402a818 <ksCurDomain>
    0x84012c1a    0x10    slli a4,s1,0x3
    0x84012c1e    0x14    auipc a5,0x5
    0x84012c22    0x18    addi a5,a5,994 # ffffffff84018000 <riscvKSASIDTable>
    0x84012c26    0x1c    add a5,a5,a4
    0x84012c28    0x1e    ld a0,1040(a5)
    0x84012c2c    0x22    beqz a0,ffffffff84012c80 <chooseThread+0x76>
    0x84012c2e    0x24    jal ra,ffffffff840100cc <clzl>
    0x84012c32    0x28    mv s0,a0
    0x84012c34    0x2a    slli a5,s1,0x2
    0x84012c38    0x2e    addi a4,a0,-60
    0x84012c3c    0x32    add a5,a5,a4
    0x84012c3e    0x34    slli a5,a5,0x3
    0x84012c40    0x36    auipc a4,0x5
    0x84012c44    0x3a    addi a4,a4,960 # ffffffff84018000 <riscvKSASIDTable>
    0x84012c48    0x3e    add a5,a5,a4
    0x84012c4a    0x40    ld a0,1168(a5)
    0x84012c4e    0x44    jal ra,ffffffff840100cc <clzl>
    0x84012c52    0x48    li a5,63
    0x84012c56    0x4c    sub s0,a5,s0
    0x84012c5a    0x50    slli s0,s0,0x6
    0x84012c5c    0x52    sub a5,a5,a0
    0x84012c5e    0x54    or s0,s0,a5
    0x84012c60    0x56    slli s1,s1,0x8
    0x84012c62    0x58    add s0,s0,s1
    0x84012c64    0x5a    slli s0,s0,0x4
    0x84012c66    0x5c    auipc s1,0x7
    0x84012c6a    0x60    addi s1,s1,-1126 # ffffffff84019800 <ksReadyQueues>
    0x84012c6e    0x64    add s0,s0,s1
    0x84012c70    0x66    ld a0,0(s0)
    0x84012c72    0x68    jal ra,ffffffff84012be8 <switchToThread>
    0x84012c76    0x6c    ld ra,24(sp)          ; stack access
    0x84012c78    0x6e    ld s0,16(sp)          ; stack access
    0x84012c7a    0x70    ld s1,8(sp)           ; stack access
    0x84012c7c    0x72    addi sp,sp,32
    0x84012c7e    0x74    ret
    0x84012c80    0x76    jal ra,ffffffff84011660 <switchToIdleThread>
    0x84012c84    0x7a    j ffffffff84012c76 <chooseThread+0x6c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
43 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `chooseThread` has 60 nodes.

Section cancelAllSignals (231 of 271)
=====================================

Deriving specifications
-----------------------

Section `cancelAllSignals` consists of 44 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `cancelAllSignals`:

    0x840129b6     0x0    ld a5,0(a0)
    0x840129b8     0x2    andi a3,a5,3
    0x840129bc     0x6    li a4,1
    0x840129be     0x8    beq a3,a4,ffffffff840129c4 <cancelAllSignals+0xe>
    0x840129c2     0xc    ret
    0x840129c4     0xe    addi sp,sp,-16
    0x840129c6    0x10    sd ra,8(sp)           ; stack access
    0x840129c8    0x12    sd s0,0(sp)           ; stack access
    0x840129ca    0x14    ld a4,8(a0)
    0x840129cc    0x16    slli s0,a4,0x19
    0x840129d0    0x1a    srli s0,s0,0x19
    0x840129d2    0x1c    srli a3,a4,0x26
    0x840129d6    0x20    andi a3,a3,1
    0x840129d8    0x22    beqz a3,ffffffff84012a0e <cancelAllSignals+0x58>
    0x840129da    0x24    li a3,-1
    0x840129dc    0x26    slli a3,a3,0x27
    0x840129de    0x28    or s0,s0,a3
    0x840129e0    0x2a    and a4,a4,a3
    0x840129e2    0x2c    sd a4,8(a0)
    0x840129e4    0x2e    lui a4,0x2000
    0x840129e8    0x32    addi a4,a4,-4
    0x840129ea    0x34    and a5,a5,a4
    0x840129ec    0x36    sd a5,0(a0)
    0x840129ee    0x38    li a1,2
    0x840129f0    0x3a    mv a0,s0
    0x840129f2    0x3c    jal ra,ffffffff8401263a <setThreadState>
    0x840129f6    0x40    mv a0,s0
    0x840129f8    0x42    jal ra,ffffffff8401253a <tcbSchedEnqueue>
    0x840129fc    0x46    ld s0,408(s0)
    0x84012a00    0x4a    bnez s0,ffffffff840129ee <cancelAllSignals+0x38>
    0x84012a02    0x4c    jal ra,ffffffff840125d4 <rescheduleRequired>
    0x84012a06    0x50    ld ra,8(sp)           ; stack access
    0x84012a08    0x52    ld s0,0(sp)           ; stack access
    0x84012a0a    0x54    addi sp,sp,16
    0x84012a0c    0x56    ret
    0x84012a0e    0x58    srli a4,a4,0x27
    0x84012a10    0x5a    slli a4,a4,0x27
    0x84012a12    0x5c    sd a4,8(a0)
    0x84012a14    0x5e    lui a4,0x2000
    0x84012a18    0x62    addi a4,a4,-4
    0x84012a1a    0x64    and a5,a5,a4
    0x84012a1c    0x66    sd a5,0(a0)
    0x84012a1e    0x68    beqz s0,ffffffff84012a02 <cancelAllSignals+0x4c>
    0x84012a20    0x6a    j ffffffff840129ee <cancelAllSignals+0x38>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
44 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelAllSignals` has 68 nodes.

Section cancelAllIPC (232 of 271)
=================================

Deriving specifications
-----------------------

Section `cancelAllIPC` consists of 25 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `cancelAllIPC`:

    0x84012978     0x0    ld a5,0(a0)
    0x8401297a     0x2    andi a4,a5,3
    0x8401297e     0x6    beqz a4,ffffffff840129b4 <cancelAllIPC+0x3c>
    0x84012980     0x8    addi sp,sp,-16
    0x84012982     0xa    sd ra,8(sp)           ; stack access
    0x84012984     0xc    sd s0,0(sp)           ; stack access
    0x84012986     0xe    ld s0,8(a0)
    0x84012988    0x10    sd zero,8(a0)
    0x8401298c    0x14    srli a5,a5,0x27
    0x8401298e    0x16    slli a5,a5,0x27
    0x84012990    0x18    sd a5,0(a0)
    0x84012992    0x1a    beqz s0,ffffffff840129a8 <cancelAllIPC+0x30>
    0x84012994    0x1c    li a1,2
    0x84012996    0x1e    mv a0,s0
    0x84012998    0x20    jal ra,ffffffff8401263a <setThreadState>
    0x8401299c    0x24    mv a0,s0
    0x8401299e    0x26    jal ra,ffffffff8401253a <tcbSchedEnqueue>
    0x840129a2    0x2a    ld s0,408(s0)
    0x840129a6    0x2e    bnez s0,ffffffff84012994 <cancelAllIPC+0x1c>
    0x840129a8    0x30    jal ra,ffffffff840125d4 <rescheduleRequired>
    0x840129ac    0x34    ld ra,8(sp)           ; stack access
    0x840129ae    0x36    ld s0,0(sp)           ; stack access
    0x840129b0    0x38    addi sp,sp,16
    0x840129b2    0x3a    ret
    0x840129b4    0x3c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
25 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelAllIPC` has 45 nodes.

Section createNewObjects (233 of 271)
=====================================

Deriving specifications
-----------------------

Section `createNewObjects` consists of 52 instructions.


Stack analysis
---------------

20 stack accesses found. Annotated code for `createNewObjects`:

    0x840124c2     0x0    addi sp,sp,-96
    0x840124c4     0x2    sd ra,88(sp)          ; stack access
    0x840124c6     0x4    sd s0,80(sp)          ; stack access
    0x840124c8     0x6    sd s1,72(sp)          ; stack access
    0x840124ca     0x8    sd s2,64(sp)          ; stack access
    0x840124cc     0xa    sd s3,56(sp)          ; stack access
    0x840124ce     0xc    sd s4,48(sp)          ; stack access
    0x840124d0     0xe    sd s5,40(sp)          ; stack access
    0x840124d2    0x10    sd s6,32(sp)          ; stack access
    0x840124d4    0x12    sd s7,24(sp)          ; stack access
    0x840124d6    0x14    sd s8,16(sp)          ; stack access
    0x840124d8    0x16    mv s5,a0
    0x840124da    0x18    mv s6,a1
    0x840124dc    0x1a    mv s1,a2
    0x840124de    0x1c    mv s0,a3
    0x840124e0    0x1e    mv s2,a4
    0x840124e2    0x20    mv s7,a5
    0x840124e4    0x22    mv s3,a6
    0x840124e6    0x24    mv s8,a7
    0x840124e8    0x26    mv a1,a6
    0x840124ea    0x28    jal ra,ffffffff84011c66 <getObjectSize>
    0x840124ee    0x2c    beqz s2,ffffffff84012522 <createNewObjects+0x60>
    0x840124f2    0x30    sext.w s4,a0
    0x840124f6    0x34    slli s0,s0,0x5
    0x840124f8    0x36    add s1,s1,s0
    0x840124fa    0x38    li s0,0
    0x840124fc    0x3a    sll a1,s0,s4
    0x84012500    0x3e    mv a3,s8
    0x84012502    0x40    mv a2,s3
    0x84012504    0x42    add a1,a1,s7
    0x84012506    0x44    mv a0,s5
    0x84012508    0x46    jal ra,ffffffff84012406 <createObject>
    0x8401250c    0x4a    mv a2,a0
    0x8401250e    0x4c    mv a3,a1
    0x84012510    0x4e    mv a1,s1
    0x84012512    0x50    mv a0,s6
    0x84012514    0x52    jal ra,ffffffff84011996 <insertNewCap>
    0x84012518    0x56    addi s0,s0,1
    0x8401251a    0x58    addi s1,s1,32
    0x8401251e    0x5c    bne s2,s0,ffffffff840124fc <createNewObjects+0x3a>
    0x84012522    0x60    ld ra,88(sp)          ; stack access
    0x84012524    0x62    ld s0,80(sp)          ; stack access
    0x84012526    0x64    ld s1,72(sp)          ; stack access
    0x84012528    0x66    ld s2,64(sp)          ; stack access
    0x8401252a    0x68    ld s3,56(sp)          ; stack access
    0x8401252c    0x6a    ld s4,48(sp)          ; stack access
    0x8401252e    0x6c    ld s5,40(sp)          ; stack access
    0x84012530    0x6e    ld s6,32(sp)          ; stack access
    0x84012532    0x70    ld s7,24(sp)          ; stack access
    0x84012534    0x72    ld s8,16(sp)          ; stack access
    0x84012536    0x74    addi sp,sp,96
    0x84012538    0x76    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
52 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `createNewObjects` has 80 nodes.

Section sameRegionAs (234 of 271)
=================================

Deriving specifications
-----------------------

Section `sameRegionAs` consists of 315 instructions.


Stack analysis
---------------

22 stack accesses found. Annotated code for `sameRegionAs`:

    0x84011cde      0x0    addi sp,sp,-80
    0x84011ce0      0x2    sd ra,72(sp)          ; stack access
    0x84011ce2      0x4    sd s0,64(sp)          ; stack access
    0x84011ce4      0x6    sd s1,56(sp)          ; stack access
    0x84011ce6      0x8    sd s2,48(sp)          ; stack access
    0x84011ce8      0xa    sd s3,40(sp)          ; stack access
    0x84011cea      0xc    sd s4,32(sp)          ; stack access
    0x84011cec      0xe    sd a0,16(sp)          ; stack access
    0x84011cee     0x10    sd a1,24(sp)          ; stack access
    0x84011cf0     0x12    sd a2,0(sp)           ; stack access
    0x84011cf2     0x14    sd a3,8(sp)           ; stack access
    0x84011cf4     0x16    mv s0,a2
    0x84011cf6     0x18    mv s1,a3
    0x84011cf8     0x1a    mv a4,a0
    0x84011cfa     0x1c    srli a5,a0,0x3b
    0x84011cfe     0x20    li a3,10
    0x84011d00     0x22    beq a5,a3,ffffffff84011f42 <sameRegionAs+0x264>
    0x84011d04     0x26    mv s2,a1
    0x84011d06     0x28    bgeu a3,a5,ffffffff84011d34 <sameRegionAs+0x56>
    0x84011d0a     0x2c    li a3,16
    0x84011d0c     0x2e    beq a5,a3,ffffffff84011fee <sameRegionAs+0x310>
    0x84011d10     0x32    bgeu a3,a5,ffffffff84011da2 <sameRegionAs+0xc4>
    0x84011d14     0x36    li a4,20
    0x84011d16     0x38    bne a5,a4,ffffffff8401200c <sameRegionAs+0x32e>
    0x84011d1a     0x3c    srli a0,a2,0x3b
    0x84011d1e     0x40    addi a0,a0,-20
    0x84011d20     0x42    seqz a0,a0
    0x84011d24     0x46    ld ra,72(sp)          ; stack access
    0x84011d26     0x48    ld s0,64(sp)          ; stack access
    0x84011d28     0x4a    ld s1,56(sp)          ; stack access
    0x84011d2a     0x4c    ld s2,48(sp)          ; stack access
    0x84011d2c     0x4e    ld s3,40(sp)          ; stack access
    0x84011d2e     0x50    ld s4,32(sp)          ; stack access
    0x84011d30     0x52    addi sp,sp,80
    0x84011d32     0x54    ret
    0x84011d34     0x56    li a3,6
    0x84011d36     0x58    beq a5,a3,ffffffff84011f06 <sameRegionAs+0x228>
    0x84011d3a     0x5c    bgeu a3,a5,ffffffff84011d5a <sameRegionAs+0x7c>
    0x84011d3e     0x60    li a4,8
    0x84011d40     0x62    bne a5,a4,ffffffff8401200c <sameRegionAs+0x32e>
    0x84011d44     0x66    srli s0,a2,0x3b
    0x84011d48     0x6a    li a5,8
    0x84011d4a     0x6c    li a0,0
    0x84011d4c     0x6e    bne s0,a5,ffffffff84011d24 <sameRegionAs+0x46>
    0x84011d50     0x72    sub a0,a1,s1
    0x84011d54     0x76    seqz a0,a0
    0x84011d58     0x7a    j ffffffff84011d24 <sameRegionAs+0x46>
    0x84011d5a     0x7c    li a3,2
    0x84011d5c     0x7e    beq a5,a3,ffffffff84011dbc <sameRegionAs+0xde>
    0x84011d60     0x82    li a3,4
    0x84011d62     0x84    bne a5,a3,ffffffff8401200c <sameRegionAs+0x32e>
    0x84011d66     0x88    srli a5,a2,0x3b
    0x84011d6a     0x8c    li a3,4
    0x84011d6c     0x8e    li a0,0
    0x84011d6e     0x90    bne a5,a3,ffffffff84011d24 <sameRegionAs+0x46>
    0x84011d72     0x94    slli a5,a4,0x19
    0x84011d76     0x98    srli a3,a5,0x19
    0x84011d7a     0x9c    srli a4,a4,0x26
    0x84011d7c     0x9e    andi a4,a4,1
    0x84011d7e     0xa0    beqz a4,ffffffff84011d86 <sameRegionAs+0xa8>
    0x84011d80     0xa2    li a5,-1
    0x84011d82     0xa4    slli a5,a5,0x27
    0x84011d84     0xa6    or a3,a3,a5
    0x84011d86     0xa8    slli a5,s0,0x19
    0x84011d8a     0xac    srli a5,a5,0x19
    0x84011d8c     0xae    srli a0,s0,0x26
    0x84011d90     0xb2    andi a0,a0,1
    0x84011d92     0xb4    beqz a0,ffffffff84011d9a <sameRegionAs+0xbc>
    0x84011d94     0xb6    li a4,-1
    0x84011d96     0xb8    slli a4,a4,0x27
    0x84011d98     0xba    or a5,a5,a4
    0x84011d9a     0xbc    sub a5,a5,a3
    0x84011d9c     0xbe    seqz a0,a5
    0x84011da0     0xc2    j ffffffff84011d24 <sameRegionAs+0x46>
    0x84011da2     0xc4    li a3,12
    0x84011da4     0xc6    beq a5,a3,ffffffff84011fb2 <sameRegionAs+0x2d4>
    0x84011da8     0xca    li a4,14
    0x84011daa     0xcc    bne a5,a4,ffffffff8401200c <sameRegionAs+0x32e>
    0x84011dae     0xd0    srli a0,a2,0x3b
    0x84011db2     0xd4    addi a0,a0,-14
    0x84011db4     0xd6    andi a0,a0,-3
    0x84011db6     0xd8    seqz a0,a0
    0x84011dba     0xdc    j ffffffff84011d24 <sameRegionAs+0x46>
    0x84011dbc     0xde    srli s3,a2,0x3b
    0x84011dc0     0xe2    li a5,20
    0x84011dc2     0xe4    bltu a5,s3,ffffffff84011de6 <sameRegionAs+0x108>
    0x84011dc6     0xe8    li a3,1
    0x84011dc8     0xea    sll a3,a3,s3
    0x84011dcc     0xee    lui a5,0x41
    0x84011dd0     0xf2    addi a5,a5,1108 # 41454 <KERNEL_OFFSET-0xfffffffefffbebac>
    0x84011dd4     0xf6    and a0,a3,a5
    0x84011dd8     0xfa    bnez a0,ffffffff84011dfe <sameRegionAs+0x120>
    0x84011dda     0xfc    lui a5,0x114
    0x84011dde    0x100    addi a5,a5,256 # 114100 <KERNEL_OFFSET-0xfffffffeffeebf00>
    0x84011de2    0x104    and a3,a3,a5
    0x84011de4    0x106    bnez a3,ffffffff84011d24 <sameRegionAs+0x46>
    0x84011de6    0x108    li a5,13
    0x84011de8    0x10a    bltu a5,s3,ffffffff84011e3e <sameRegionAs+0x160>
    0x84011dec    0x10e    li a5,1
    0x84011dee    0x110    sll a5,a5,s3
    0x84011df2    0x114    lui a0,0x2
    0x84011df4    0x116    addi a0,a0,10
    0x84011df6    0x118    and a5,a5,a0
    0x84011df8    0x11a    snez a0,a5
    0x84011dfc    0x11e    beqz a0,ffffffff84011d24 <sameRegionAs+0x46>
    0x84011dfe    0x120    slli s4,a4,0x19
    0x84011e02    0x124    srli s4,s4,0x19
    0x84011e06    0x128    srli a4,a4,0x26
    0x84011e08    0x12a    andi a4,a4,1
    0x84011e0a    0x12c    beqz a4,ffffffff84011e14 <sameRegionAs+0x136>
    0x84011e0c    0x12e    li a5,-1
    0x84011e0e    0x130    slli a5,a5,0x27
    0x84011e10    0x132    or s4,s4,a5
    0x84011e14    0x136    ld a0,0(sp)           ; stack access
    0x84011e16    0x138    ld a1,8(sp)           ; stack access
    0x84011e18    0x13a    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x84011e1c    0x13e    mv a5,a0
    0x84011e1e    0x140    li a4,10
    0x84011e20    0x142    beq s3,a4,ffffffff84011ed6 <sameRegionAs+0x1f8>
    0x84011e24    0x146    bltu a4,s3,ffffffff84011e7a <sameRegionAs+0x19c>
    0x84011e28    0x14a    li a4,4
    0x84011e2a    0x14c    beq s3,a4,ffffffff84011ef2 <sameRegionAs+0x214>
    0x84011e2e    0x150    bgeu a4,s3,ffffffff84011e42 <sameRegionAs+0x164>
    0x84011e32    0x154    li a4,6
    0x84011e34    0x156    li s1,5
    0x84011e36    0x158    beq s3,a4,ffffffff84011e50 <sameRegionAs+0x172>
    0x84011e3a    0x15c    li s1,0
    0x84011e3c    0x15e    j ffffffff84011e50 <sameRegionAs+0x172>
    0x84011e3e    0x160    li a0,0
    0x84011e40    0x162    j ffffffff84011dfc <sameRegionAs+0x11e>
    0x84011e42    0x164    beqz s3,ffffffff84011ef6 <sameRegionAs+0x218>
    0x84011e46    0x168    li a4,2
    0x84011e48    0x16a    andi s1,s1,63
    0x84011e4c    0x16e    bne s3,a4,ffffffff8401202c <sameRegionAs+0x34e>
    0x84011e50    0x172    li a0,0
    0x84011e52    0x174    bltu a5,s4,ffffffff84011d24 <sameRegionAs+0x46>
    0x84011e56    0x178    li a4,1
    0x84011e58    0x17a    sll s1,a4,s1
    0x84011e5c    0x17e    addi a3,a5,-1
    0x84011e60    0x182    add s1,s1,a3
    0x84011e62    0x184    sll a4,a4,s2
    0x84011e66    0x188    addi a4,a4,-1
    0x84011e68    0x18a    add s4,s4,a4
    0x84011e6a    0x18c    bltu s4,s1,ffffffff84011d24 <sameRegionAs+0x46>
    0x84011e6e    0x190    sltu a0,s1,a5
    0x84011e72    0x194    xori a0,a0,1
    0x84011e76    0x198    sext.w a0,a0
    0x84011e78    0x19a    j ffffffff84011d24 <sameRegionAs+0x46>
    0x84011e7a    0x19c    li a4,16
    0x84011e7c    0x19e    beq s3,a4,ffffffff84011efa <sameRegionAs+0x21c>
    0x84011e80    0x1a2    bgeu a4,s3,ffffffff84011ea0 <sameRegionAs+0x1c2>
    0x84011e84    0x1a6    li a4,18
    0x84011e86    0x1a8    li s1,0
    0x84011e88    0x1aa    bne s3,a4,ffffffff84011e50 <sameRegionAs+0x172>
    0x84011e8c    0x1ae    andi a4,s0,127
    0x84011e90    0x1b2    li a3,64
    0x84011e94    0x1b6    beq a4,a3,ffffffff84011f02 <sameRegionAs+0x224>
    0x84011e98    0x1ba    andi s1,s0,63
    0x84011e9c    0x1be    addi s1,s1,5
    0x84011e9e    0x1c0    j ffffffff84011e50 <sameRegionAs+0x172>
    0x84011ea0    0x1c2    li a4,12
    0x84011ea2    0x1c4    beq s3,a4,ffffffff84011efe <sameRegionAs+0x220>
    0x84011ea6    0x1c8    li a4,14
    0x84011ea8    0x1ca    li s1,0
    0x84011eaa    0x1cc    beq s3,a4,ffffffff84011e50 <sameRegionAs+0x172>
    0x84011eae    0x1d0    li a4,13
    0x84011eb0    0x1d2    beq s3,a4,ffffffff84011ee2 <sameRegionAs+0x204>
    0x84011eb4    0x1d6    li a4,1
    0x84011eb6    0x1d8    li s1,0
    0x84011eb8    0x1da    bne s3,a4,ffffffff84011e50 <sameRegionAs+0x172>
    0x84011ebc    0x1de    srli a0,s0,0x39
    0x84011ec0    0x1e2    andi a4,a0,3
    0x84011ec4    0x1e6    li a3,1
    0x84011ec6    0x1e8    beq a4,a3,ffffffff84011ee6 <sameRegionAs+0x208>
    0x84011eca    0x1ec    li a3,2
    0x84011ecc    0x1ee    beq a4,a3,ffffffff84011eea <sameRegionAs+0x20c>
    0x84011ed0    0x1f2    beqz a4,ffffffff84011eee <sameRegionAs+0x210>
    0x84011ed2    0x1f4    jal ra,ffffffff8401041e <halt>
    0x84011ed6    0x1f8    srli s1,s0,0x2f
    0x84011eda    0x1fc    andi s1,s1,63
    0x84011ede    0x200    addi s1,s1,5
    0x84011ee0    0x202    j ffffffff84011e50 <sameRegionAs+0x172>
    0x84011ee2    0x204    li s1,12
    0x84011ee4    0x206    j ffffffff84011e50 <sameRegionAs+0x172>
    0x84011ee6    0x208    li s1,21
    0x84011ee8    0x20a    j ffffffff84011e50 <sameRegionAs+0x172>
    0x84011eea    0x20c    li s1,30
    0x84011eec    0x20e    j ffffffff84011e50 <sameRegionAs+0x172>
    0x84011eee    0x210    li s1,12
    0x84011ef0    0x212    j ffffffff84011e50 <sameRegionAs+0x172>
    0x84011ef2    0x214    li s1,4
    0x84011ef4    0x216    j ffffffff84011e50 <sameRegionAs+0x172>
    0x84011ef6    0x218    li s1,0
    0x84011ef8    0x21a    j ffffffff84011e50 <sameRegionAs+0x172>
    0x84011efa    0x21c    li s1,0
    0x84011efc    0x21e    j ffffffff84011e50 <sameRegionAs+0x172>
    0x84011efe    0x220    li s1,10
    0x84011f00    0x222    j ffffffff84011e50 <sameRegionAs+0x172>
    0x84011f02    0x224    li s1,10
    0x84011f04    0x226    j ffffffff84011e50 <sameRegionAs+0x172>
    0x84011f06    0x228    srli a5,a2,0x3b
    0x84011f0a    0x22c    li a3,6
    0x84011f0c    0x22e    li a0,0
    0x84011f0e    0x230    bne a5,a3,ffffffff84011d24 <sameRegionAs+0x46>
    0x84011f12    0x234    slli a5,a4,0x19
    0x84011f16    0x238    srli a3,a5,0x19
    0x84011f1a    0x23c    srli a4,a4,0x26
    0x84011f1c    0x23e    andi a4,a4,1
    0x84011f1e    0x240    beqz a4,ffffffff84011f26 <sameRegionAs+0x248>
    0x84011f20    0x242    li a5,-1
    0x84011f22    0x244    slli a5,a5,0x27
    0x84011f24    0x246    or a3,a3,a5
    0x84011f26    0x248    slli a5,s0,0x19
    0x84011f2a    0x24c    srli a5,a5,0x19
    0x84011f2c    0x24e    srli a0,s0,0x26
    0x84011f30    0x252    andi a0,a0,1
    0x84011f32    0x254    beqz a0,ffffffff84011f3a <sameRegionAs+0x25c>
    0x84011f34    0x256    li a4,-1
    0x84011f36    0x258    slli a4,a4,0x27
    0x84011f38    0x25a    or a5,a5,a4
    0x84011f3a    0x25c    sub a5,a5,a3
    0x84011f3c    0x25e    seqz a0,a5
    0x84011f40    0x262    j ffffffff84011d24 <sameRegionAs+0x46>
    0x84011f42    0x264    srli a5,a2,0x3b
    0x84011f46    0x268    li a3,10
    0x84011f48    0x26a    li a0,0
    0x84011f4a    0x26c    bne a5,a3,ffffffff84011d24 <sameRegionAs+0x46>
    0x84011f4e    0x270    slli a5,a4,0x1
    0x84011f52    0x274    lui a3,0xfc000
    0x84011f56    0x278    srli a3,a3,0x19
    0x84011f58    0x27a    and a3,a3,a5
    0x84011f5a    0x27c    srli a5,a5,0x26
    0x84011f5c    0x27e    andi a5,a5,1
    0x84011f5e    0x280    beqz a5,ffffffff84011f88 <sameRegionAs+0x2aa>
    0x84011f60    0x282    li a5,-1
    0x84011f62    0x284    slli a5,a5,0x27
    0x84011f64    0x286    or a3,a3,a5
    0x84011f66    0x288    slli a5,a2,0x1
    0x84011f6a    0x28c    lui a2,0xfc000
    0x84011f6e    0x290    srli a2,a2,0x19
    0x84011f70    0x292    and a2,a2,a5
    0x84011f72    0x294    srli a5,a5,0x26
    0x84011f74    0x296    andi a5,a5,1
    0x84011f76    0x298    beqz a5,ffffffff84011f84 <sameRegionAs+0x2a6>
    0x84011f78    0x29a    li a5,-1
    0x84011f7a    0x29c    slli a5,a5,0x27
    0x84011f7c    0x29e    or a2,a2,a5
    0x84011f7e    0x2a0    li a5,0
    0x84011f80    0x2a2    beq a2,a3,ffffffff84011f9c <sameRegionAs+0x2be>
    0x84011f84    0x2a6    mv a0,a5
    0x84011f86    0x2a8    j ffffffff84011d24 <sameRegionAs+0x46>
    0x84011f88    0x2aa    slli a5,a2,0x1
    0x84011f8c    0x2ae    lui a2,0xfc000
    0x84011f90    0x2b2    srli a2,a2,0x19
    0x84011f92    0x2b4    and a2,a2,a5
    0x84011f94    0x2b6    srli a5,a5,0x26
    0x84011f96    0x2b8    andi a5,a5,1
    0x84011f98    0x2ba    bnez a5,ffffffff84011f78 <sameRegionAs+0x29a>
    0x84011f9a    0x2bc    j ffffffff84011f7e <sameRegionAs+0x2a0>
    0x84011f9c    0x2be    srli a5,s0,0x2f
    0x84011fa0    0x2c2    andi a5,a5,63
    0x84011fa4    0x2c6    srli a4,a4,0x2f
    0x84011fa6    0x2c8    andi a4,a4,63
    0x84011faa    0x2cc    sub a5,a5,a4
    0x84011fac    0x2ce    seqz a5,a5
    0x84011fb0    0x2d2    j ffffffff84011f84 <sameRegionAs+0x2a6>
    0x84011fb2    0x2d4    srli a5,a2,0x3b
    0x84011fb6    0x2d8    li a3,12
    0x84011fb8    0x2da    li a0,0
    0x84011fba    0x2dc    bne a5,a3,ffffffff84011d24 <sameRegionAs+0x46>
    0x84011fbe    0x2e0    slli a5,a4,0x19
    0x84011fc2    0x2e4    srli a3,a5,0x19
    0x84011fc6    0x2e8    srli a4,a4,0x26
    0x84011fc8    0x2ea    andi a4,a4,1
    0x84011fca    0x2ec    beqz a4,ffffffff84011fd2 <sameRegionAs+0x2f4>
    0x84011fcc    0x2ee    li a5,-1
    0x84011fce    0x2f0    slli a5,a5,0x27
    0x84011fd0    0x2f2    or a3,a3,a5
    0x84011fd2    0x2f4    slli a5,s0,0x19
    0x84011fd6    0x2f8    srli a5,a5,0x19
    0x84011fd8    0x2fa    srli a0,s0,0x26
    0x84011fdc    0x2fe    andi a0,a0,1
    0x84011fde    0x300    beqz a0,ffffffff84011fe6 <sameRegionAs+0x308>
    0x84011fe0    0x302    li a4,-1
    0x84011fe2    0x304    slli a4,a4,0x27
    0x84011fe4    0x306    or a5,a5,a4
    0x84011fe6    0x308    sub a5,a5,a3
    0x84011fe8    0x30a    seqz a0,a5
    0x84011fec    0x30e    j ffffffff84011d24 <sameRegionAs+0x46>
    0x84011fee    0x310    srli s0,a2,0x3b
    0x84011ff2    0x314    li a5,16
    0x84011ff4    0x316    li a0,0
    0x84011ff6    0x318    bne s0,a5,ffffffff84011d24 <sameRegionAs+0x46>
    0x84011ffa    0x31c    lui a5,0x1
    0x84011ffc    0x31e    addi a5,a5,-1
    0x84011ffe    0x320    and a0,s1,a5
    0x84012002    0x324    and a5,a5,a1
    0x84012004    0x326    sub a0,a0,a5
    0x84012006    0x328    seqz a0,a0
    0x8401200a    0x32c    j ffffffff84011d24 <sameRegionAs+0x46>
    0x8401200c    0x32e    andi a0,a5,1
    0x84012010    0x332    beqz a0,ffffffff84011d24 <sameRegionAs+0x46>
    0x84012014    0x336    srli a0,s0,0x3b
    0x84012018    0x33a    andi a0,a0,1
    0x8401201a    0x33c    beqz a0,ffffffff84011d24 <sameRegionAs+0x46>
    0x8401201e    0x340    ld a2,0(sp)           ; stack access
    0x84012020    0x342    ld a3,8(sp)           ; stack access
    0x84012022    0x344    ld a0,16(sp)          ; stack access
    0x84012024    0x346    ld a1,24(sp)          ; stack access
    0x84012026    0x348    jal ra,ffffffff84011068 <Arch_sameRegionAs>
    0x8401202a    0x34c    j ffffffff84011d24 <sameRegionAs+0x46>
    0x8401202c    0x34e    li a4,3
    0x8401202e    0x350    bne s3,a4,ffffffff84011eb4 <sameRegionAs+0x1d6>
    0x84012032    0x354    li s1,12
    0x84012034    0x356    j ffffffff84011e50 <sameRegionAs+0x172>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
315 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sameRegionAs` has 455 nodes.

Section unmapPage (235 of 271)
==============================

Deriving specifications
-----------------------

Section `unmapPage` consists of 57 instructions.

Skipping 12000073 sfence.vma


Stack analysis
---------------

13 stack accesses found. Annotated code for `unmapPage`:

    0x84010b54     0x0    addi sp,sp,-64
    0x84010b56     0x2    sd ra,56(sp)          ; stack access
    0x84010b58     0x4    sd s0,48(sp)          ; stack access
    0x84010b5a     0x6    sd s1,40(sp)          ; stack access
    0x84010b5c     0x8    sd s2,32(sp)          ; stack access
    0x84010b5e     0xa    mv s0,a0
    0x84010b60     0xc    mv s2,a2
    0x84010b62     0xe    mv s1,a3
    0x84010b64    0x10    mv a0,a1
    0x84010b66    0x12    jal ra,ffffffff84010144 <findVSpaceForASID>
    0x84010b6a    0x16    sd a0,16(sp)          ; stack access
    0x84010b6c    0x18    sd a1,24(sp)          ; stack access
    0x84010b6e    0x1a    beqz a0,ffffffff84010b7c <unmapPage+0x28>
    0x84010b70    0x1c    ld ra,56(sp)          ; stack access
    0x84010b72    0x1e    ld s0,48(sp)          ; stack access
    0x84010b74    0x20    ld s1,40(sp)          ; stack access
    0x84010b76    0x22    ld s2,32(sp)          ; stack access
    0x84010b78    0x24    addi sp,sp,64
    0x84010b7a    0x26    ret
    0x84010b7c    0x28    mv a1,s2
    0x84010b7e    0x2a    ld a0,24(sp)          ; stack access
    0x84010b80    0x2c    jal ra,ffffffff840109c6 <lookupPTSlot>
    0x84010b84    0x30    sd a0,0(sp)           ; stack access
    0x84010b86    0x32    sd a1,8(sp)           ; stack access
    0x84010b88    0x34    li a5,1
    0x84010b8a    0x36    beq s0,a5,ffffffff84010b9a <unmapPage+0x46>
    0x84010b8e    0x3a    li a5,2
    0x84010b90    0x3c    beq s0,a5,ffffffff84010b9e <unmapPage+0x4a>
    0x84010b94    0x40    beqz s0,ffffffff84010bde <unmapPage+0x8a>
    0x84010b96    0x42    jal ra,ffffffff8401041e <halt>
    0x84010b9a    0x46    li a5,21
    0x84010b9c    0x48    j ffffffff84010ba0 <unmapPage+0x4c>
    0x84010b9e    0x4a    li a5,30
    0x84010ba0    0x4c    bne a1,a5,ffffffff84010b70 <unmapPage+0x1c>
    0x84010ba4    0x50    ld a4,0(a0)
    0x84010ba6    0x52    andi a5,a4,1
    0x84010baa    0x56    beqz a5,ffffffff84010b70 <unmapPage+0x1c>
    0x84010bac    0x58    srli a5,a4,0x1
    0x84010bb0    0x5c    srli a3,a4,0x2
    0x84010bb4    0x60    or a5,a5,a3
    0x84010bb6    0x62    srli a3,a4,0x3
    0x84010bba    0x66    or a5,a5,a3
    0x84010bbc    0x68    andi a5,a5,1
    0x84010bbe    0x6a    beqz a5,ffffffff84010b70 <unmapPage+0x1c>
    0x84010bc0    0x6c    slli a4,a4,0x2
    0x84010bc2    0x6e    lui a5,0xfff00
    0x84010bc6    0x72    srli a5,a5,0x8
    0x84010bc8    0x74    and a4,a4,a5
    0x84010bca    0x76    li a3,1
    0x84010bcc    0x78    slli a3,a3,0x26
    0x84010bce    0x7a    add s1,s1,a3
    0x84010bd0    0x7c    bne a4,s1,ffffffff84010b70 <unmapPage+0x1c>
    0x84010bd4    0x80    sd zero,0(a0)
    0x84010bd8    0x84    sfence.vma
    0x84010bdc    0x88    j ffffffff84010b70 <unmapPage+0x1c>
    0x84010bde    0x8a    li a5,12
    0x84010be0    0x8c    j ffffffff84010ba0 <unmapPage+0x4c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
57 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `unmapPage` has 93 nodes.

Section create_rootserver_objects (236 of 271)
==============================================

Deriving specifications
-----------------------

Section `create_rootserver_objects` consists of 88 instructions.


Stack analysis
---------------

22 stack accesses found. Annotated code for `create_rootserver_objects`:

    0x84000e7c     0x0    addi sp,sp,-80
    0x84000e7e     0x2    sd ra,72(sp)          ; stack access
    0x84000e80     0x4    sd s0,64(sp)          ; stack access
    0x84000e82     0x6    sd s1,56(sp)          ; stack access
    0x84000e84     0x8    sd s2,48(sp)          ; stack access
    0x84000e86     0xa    sd s3,40(sp)          ; stack access
    0x84000e88     0xc    sd s4,32(sp)          ; stack access
    0x84000e8a     0xe    mv s1,a0
    0x84000e8c    0x10    sd a1,0(sp)           ; stack access
    0x84000e8e    0x12    sd a2,8(sp)           ; stack access
    0x84000e90    0x14    mv s2,a3
    0x84000e92    0x16    mv s4,a3
    0x84000e94    0x18    li a5,24
    0x84000e96    0x1a    bgeu a3,a5,ffffffff84000e9c <create_rootserver_objects+0x20>
    0x84000e9a    0x1e    li s4,24
    0x84000e9c    0x20    ld a5,0(sp)           ; stack access
    0x84000e9e    0x22    sd a5,16(sp)          ; stack access
    0x84000ea0    0x24    ld a5,8(sp)           ; stack access
    0x84000ea2    0x26    sd a5,24(sp)          ; stack access
    0x84000ea4    0x28    mv s3,s2
    0x84000ea6    0x2a    beqz s2,ffffffff84000eb0 <create_rootserver_objects+0x34>
    0x84000eaa    0x2e    li s3,1
    0x84000eac    0x30    sll s3,s3,s2
    0x84000eb0    0x34    ld a0,16(sp)          ; stack access
    0x84000eb2    0x36    ld a1,24(sp)          ; stack access
    0x84000eb4    0x38    jal ra,ffffffff84000108 <arch_get_n_paging>
    0x84000eb8    0x3c    auipc s0,0x0
    0x84000ebc    0x40    addi s0,s0,1648 # ffffffff84001528 <ndks_boot>
    0x84000ec0    0x44    sd s1,680(s0)
    0x84000ec4    0x48    lui a5,0x1004
    0x84000ec8    0x4c    addi a5,a5,1024 # 1004400 <KERNEL_OFFSET-0xfffffffefeffbc00>
    0x84000ecc    0x50    add s1,s1,a5
    0x84000ece    0x52    add s1,s1,s3
    0x84000ed0    0x54    slli a0,a0,0xc
    0x84000ed2    0x56    add s1,s1,a0
    0x84000ed4    0x58    sd s1,688(s0)
    0x84000ed8    0x5c    mv a1,s2
    0x84000eda    0x5e    mv a0,s4
    0x84000edc    0x60    jal ra,ffffffff84000e50 <maybe_alloc_extra_bi>
    0x84000ee0    0x64    li a1,1
    0x84000ee2    0x66    li a0,24
    0x84000ee4    0x68    jal ra,ffffffff84000e22 <alloc_rootserver_obj>
    0x84000ee8    0x6c    sd a0,608(s0)
    0x84000eec    0x70    mv a1,s2
    0x84000eee    0x72    li a0,12
    0x84000ef0    0x74    jal ra,ffffffff84000e50 <maybe_alloc_extra_bi>
    0x84000ef4    0x78    li a1,1
    0x84000ef6    0x7a    li a0,12
    0x84000ef8    0x7c    jal ra,ffffffff84000e22 <alloc_rootserver_obj>
    0x84000efc    0x80    sd a0,616(s0)
    0x84000f00    0x84    mv a1,s2
    0x84000f02    0x86    li a0,12
    0x84000f04    0x88    jal ra,ffffffff84000e50 <maybe_alloc_extra_bi>
    0x84000f08    0x8c    li a1,1
    0x84000f0a    0x8e    li a0,12
    0x84000f0c    0x90    jal ra,ffffffff84000e22 <alloc_rootserver_obj>
    0x84000f10    0x94    sd a0,624(s0)
    0x84000f14    0x98    li a1,1
    0x84000f16    0x9a    li a0,12
    0x84000f18    0x9c    jal ra,ffffffff84000e22 <alloc_rootserver_obj>
    0x84000f1c    0xa0    sd a0,632(s0)
    0x84000f20    0xa4    li a1,1
    0x84000f22    0xa6    li a0,12
    0x84000f24    0xa8    jal ra,ffffffff84000e22 <alloc_rootserver_obj>
    0x84000f28    0xac    sd a0,640(s0)
    0x84000f2c    0xb0    ld a0,0(sp)           ; stack access
    0x84000f2e    0xb2    ld a1,8(sp)           ; stack access
    0x84000f30    0xb4    jal ra,ffffffff84000108 <arch_get_n_paging>
    0x84000f34    0xb8    mv s1,a0
    0x84000f36    0xba    mv a1,a0
    0x84000f38    0xbc    li a0,12
    0x84000f3a    0xbe    jal ra,ffffffff84000e22 <alloc_rootserver_obj>
    0x84000f3e    0xc2    sd a0,664(s0)
    0x84000f42    0xc6    slli s1,s1,0xc
    0x84000f44    0xc8    add s1,s1,a0
    0x84000f46    0xca    sd s1,672(s0)
    0x84000f4a    0xce    li a1,1
    0x84000f4c    0xd0    li a0,10
    0x84000f4e    0xd2    jal ra,ffffffff84000e22 <alloc_rootserver_obj>
    0x84000f52    0xd6    sd a0,656(s0)
    0x84000f56    0xda    ld ra,72(sp)          ; stack access
    0x84000f58    0xdc    ld s0,64(sp)          ; stack access
    0x84000f5a    0xde    ld s1,56(sp)          ; stack access
    0x84000f5c    0xe0    ld s2,48(sp)          ; stack access
    0x84000f5e    0xe2    ld s3,40(sp)          ; stack access
    0x84000f60    0xe4    ld s4,32(sp)          ; stack access
    0x84000f62    0xe6    addi sp,sp,80
    0x84000f64    0xe8    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
88 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_rootserver_objects` has 137 nodes.

Section create_ipcbuf_frame_cap (237 of 271)
============================================

Deriving specifications
-----------------------

Section `create_ipcbuf_frame_cap` consists of 39 instructions.


Stack analysis
---------------

14 stack accesses found. Annotated code for `create_ipcbuf_frame_cap`:

    0x84000d1e     0x0    addi sp,sp,-96
    0x84000d20     0x2    sd ra,88(sp)          ; stack access
    0x84000d22     0x4    sd s0,80(sp)          ; stack access
    0x84000d24     0x6    sd s1,72(sp)          ; stack access
    0x84000d26     0x8    sd a0,16(sp)          ; stack access
    0x84000d28     0xa    sd a1,24(sp)          ; stack access
    0x84000d2a     0xc    sd a2,0(sp)           ; stack access
    0x84000d2c     0xe    sd a3,8(sp)           ; stack access
    0x84000d2e    0x10    mv s0,a4
    0x84000d30    0x12    auipc s1,0x0
    0x84000d34    0x16    addi s1,s1,2040 # ffffffff84001528 <ndks_boot>
    0x84000d38    0x1a    lui a1,0x1
    0x84000d3a    0x1c    ld a0,632(s1)
    0x84000d3e    0x20    jal ra,ffffffff84015b8a <memzero>
    0x84000d42    0x24    li a6,0
    0x84000d44    0x26    li a5,0
    0x84000d46    0x28    li a4,1
    0x84000d48    0x2a    mv a3,s0
    0x84000d4a    0x2c    ld a2,632(s1)
    0x84000d4e    0x30    ld a0,0(sp)           ; stack access
    0x84000d50    0x32    ld a1,8(sp)           ; stack access
    0x84000d52    0x34    jal ra,ffffffff84000268 <create_mapped_it_frame_cap>
    0x84000d56    0x38    mv s1,a0
    0x84000d58    0x3a    mv s0,a1
    0x84000d5a    0x3c    ld a0,16(sp)          ; stack access
    0x84000d5c    0x3e    ld a1,24(sp)          ; stack access
    0x84000d5e    0x40    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x84000d62    0x44    sd s1,320(a0)
    0x84000d66    0x48    sd s0,328(a0)
    0x84000d6a    0x4c    sd zero,336(a0)
    0x84000d6e    0x50    li a5,3
    0x84000d70    0x52    sd a5,344(a0)
    0x84000d74    0x56    mv a0,s1
    0x84000d76    0x58    mv a1,s0
    0x84000d78    0x5a    ld ra,88(sp)          ; stack access
    0x84000d7a    0x5c    ld s0,80(sp)          ; stack access
    0x84000d7c    0x5e    ld s1,72(sp)          ; stack access
    0x84000d7e    0x60    addi sp,sp,96
    0x84000d80    0x62    ret

Proving inst theorems
---------------------

39 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_ipcbuf_frame_cap` has 63 nodes.

Section create_untypeds_for_region (238 of 271)
===============================================

Deriving specifications
-----------------------

Section `create_untypeds_for_region` consists of 102 instructions.


Stack analysis
---------------

38 stack accesses found. Annotated code for `create_untypeds_for_region`:

    0x84000974      0x0    addi sp,sp,-192
    0x84000976      0x2    sd ra,184(sp)         ; stack access
    0x84000978      0x4    sd s0,176(sp)         ; stack access
    0x8400097a      0x6    sd s1,168(sp)         ; stack access
    0x8400097c      0x8    sd s2,160(sp)         ; stack access
    0x8400097e      0xa    sd s3,152(sp)         ; stack access
    0x84000980      0xc    sd s4,144(sp)         ; stack access
    0x84000982      0xe    sd s5,136(sp)         ; stack access
    0x84000984     0x10    sd s6,128(sp)         ; stack access
    0x84000986     0x12    sd s7,120(sp)         ; stack access
    0x84000988     0x14    sd s8,112(sp)         ; stack access
    0x8400098a     0x16    sd s9,104(sp)         ; stack access
    0x8400098c     0x18    sd s10,96(sp)         ; stack access
    0x8400098e     0x1a    sd s11,88(sp)         ; stack access
    0x84000990     0x1c    sd a0,32(sp)          ; stack access
    0x84000992     0x1e    sd a1,40(sp)          ; stack access
    0x84000994     0x20    beq a4,a3,ffffffff84000a80 <create_untypeds_for_region+0x10c>
    0x84000998     0x24    mv s9,a2
    0x8400099a     0x26    mv s8,a5
    0x8400099c     0x28    mv s1,a3
    0x8400099e     0x2a    mv s3,a4
    0x840009a0     0x2c    slli s10,a2,0x6
    0x840009a4     0x30    andi s10,s10,64
    0x840009a8     0x34    li s6,63
    0x840009ac     0x38    li s5,38
    0x840009b0     0x3c    auipc s7,0x1
    0x840009b4     0x40    addi s7,s7,-1160 # ffffffff84001528 <ndks_boot>
    0x840009b8     0x44    li s4,1
    0x840009ba     0x46    slli s11,s4,0x26
    0x840009be     0x4a    li a5,-1
    0x840009c0     0x4c    srli a5,a5,0x19
    0x840009c2     0x4e    sd a5,0(sp)           ; stack access
    0x840009c4     0x50    slli a5,s4,0x3c
    0x840009c8     0x54    sd a5,8(sp)           ; stack access
    0x840009ca     0x56    j ffffffff840009f0 <create_untypeds_for_region+0x7c>
    0x840009cc     0x58    mv s0,s5
    0x840009ce     0x5a    ld a5,32(sp)          ; stack access
    0x840009d0     0x5c    sd a5,48(sp)          ; stack access
    0x840009d2     0x5e    ld a5,40(sp)          ; stack access
    0x840009d4     0x60    sd a5,56(sp)          ; stack access
    0x840009d6     0x62    ld a5,592(s7)
    0x840009da     0x66    sub a5,a5,s8
    0x840009de     0x6a    li a4,49
    0x840009e2     0x6e    bgeu a4,a5,ffffffff84000a1c <create_untypeds_for_region+0xa8>
    0x840009e6     0x72    sll s0,s4,s0
    0x840009ea     0x76    add s1,s1,s0
    0x840009ec     0x78    beq s3,s1,ffffffff84000a60 <create_untypeds_for_region+0xec>
    0x840009f0     0x7c    sub a0,s3,s1
    0x840009f4     0x80    jal ra,ffffffff840100cc <clzl>
    0x840009f8     0x84    sub s2,s6,a0
    0x840009fc     0x88    mv s0,s2
    0x840009fe     0x8a    beqz s1,ffffffff84000a0a <create_untypeds_for_region+0x96>
    0x84000a00     0x8c    mv a0,s1
    0x84000a02     0x8e    jal ra,ffffffff8401752e <__ctzdi2>
    0x84000a06     0x92    sext.w s0,a0
    0x84000a0a     0x96    bgeu s2,s0,ffffffff84000a10 <create_untypeds_for_region+0x9c>
    0x84000a0e     0x9a    mv s0,s2
    0x84000a10     0x9c    bltu s5,s0,ffffffff840009cc <create_untypeds_for_region+0x58>
    0x84000a14     0xa0    li a5,3
    0x84000a16     0xa2    bgeu a5,s0,ffffffff840009e6 <create_untypeds_for_region+0x72>
    0x84000a1a     0xa6    j ffffffff840009ce <create_untypeds_for_region+0x5a>
    0x84000a1c     0xa8    slli a5,a5,0x4
    0x84000a1e     0xaa    ld a4,584(s7)
    0x84000a22     0xae    add a5,a5,a4
    0x84000a24     0xb0    sd zero,176(a5)
    0x84000a28     0xb4    add a4,s1,s11
    0x84000a2c     0xb8    sd a4,168(a5)
    0x84000a2e     0xba    sb s0,176(a5)
    0x84000a32     0xbe    sb s9,177(a5)
    0x84000a36     0xc2    ld a5,0(sp)           ; stack access
    0x84000a38     0xc4    and a2,s1,a5
    0x84000a3c     0xc8    addiw a5,s0,-4
    0x84000a40     0xcc    sll a5,s4,a5
    0x84000a44     0xd0    slli a5,a5,0x19
    0x84000a46     0xd2    andi a3,s0,63
    0x84000a4a     0xd6    or a3,a3,s10
    0x84000a4e     0xda    ld a4,8(sp)           ; stack access
    0x84000a50     0xdc    or a2,a2,a4
    0x84000a52     0xde    or a3,a3,a5
    0x84000a54     0xe0    ld a0,48(sp)          ; stack access
    0x84000a56     0xe2    ld a1,56(sp)          ; stack access
    0x84000a58     0xe4    jal ra,ffffffff84000688 <provide_cap>
    0x84000a5c     0xe8    bnez a0,ffffffff840009e6 <create_untypeds_for_region+0x72>
    0x84000a5e     0xea    j ffffffff84000a62 <create_untypeds_for_region+0xee>
    0x84000a60     0xec    li a0,1
    0x84000a62     0xee    ld ra,184(sp)         ; stack access
    0x84000a64     0xf0    ld s0,176(sp)         ; stack access
    0x84000a66     0xf2    ld s1,168(sp)         ; stack access
    0x84000a68     0xf4    ld s2,160(sp)         ; stack access
    0x84000a6a     0xf6    ld s3,152(sp)         ; stack access
    0x84000a6c     0xf8    ld s4,144(sp)         ; stack access
    0x84000a6e     0xfa    ld s5,136(sp)         ; stack access
    0x84000a70     0xfc    ld s6,128(sp)         ; stack access
    0x84000a72     0xfe    ld s7,120(sp)         ; stack access
    0x84000a74    0x100    ld s8,112(sp)         ; stack access
    0x84000a76    0x102    ld s9,104(sp)         ; stack access
    0x84000a78    0x104    ld s10,96(sp)         ; stack access
    0x84000a7a    0x106    ld s11,88(sp)         ; stack access
    0x84000a7c    0x108    addi sp,sp,192
    0x84000a7e    0x10a    ret
    0x84000a80    0x10c    li a0,1
    0x84000a82    0x10e    j ffffffff84000a62 <create_untypeds_for_region+0xee>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
102 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_untypeds_for_region` has 166 nodes.

Section invokeUntyped_Retype (239 of 271)
=========================================

Deriving specifications
-----------------------

Section `invokeUntyped_Retype` consists of 104 instructions.

RVC_TFFTFFT__T____TF.

Stack analysis
---------------

27 stack accesses found. Annotated code for `invokeUntyped_Retype`:

    0x840164e2      0x0    addi sp,sp,-112
    0x840164e4      0x2    sd ra,104(sp)         ; stack access
    0x840164e6      0x4    sd s0,96(sp)          ; stack access
    0x840164e8      0x6    sd s1,88(sp)          ; stack access
    0x840164ea      0x8    sd s2,80(sp)          ; stack access
    0x840164ec      0xa    sd s3,72(sp)          ; stack access
    0x840164ee      0xc    sd s4,64(sp)          ; stack access
    0x840164f0      0xe    sd s5,56(sp)          ; stack access
    0x840164f2     0x10    sd s6,48(sp)          ; stack access
    0x840164f4     0x12    sd s7,40(sp)          ; stack access
    0x840164f6     0x14    sd s8,32(sp)          ; stack access
    0x840164f8     0x16    sd s9,24(sp)          ; stack access
    0x840164fa     0x18    sd s10,16(sp)         ; stack access
    0x840164fc     0x1a    sd s11,8(sp)          ; stack access
    0x840164fe     0x1c    mv s0,a0
    0x84016500     0x1e    mv s3,a2
    0x84016502     0x20    mv s1,a3
    0x84016504     0x22    mv s4,a4
    0x84016506     0x24    mv s5,a5
    0x84016508     0x26    mv s6,a6
    0x8401650a     0x28    mv s2,a7
    0x8401650c     0x2a    ld s9,0(a0)
    0x84016510     0x2e    slli s7,s9,0x19
    0x84016514     0x32    srli s7,s7,0x19
    0x84016518     0x36    srli a5,s9,0x26
    0x8401651c     0x3a    andi a5,a5,1
    0x8401651e     0x3c    beqz a5,ffffffff84016528 <invokeUntyped_Retype+0x46>
    0x84016520     0x3e    li a5,-1
    0x84016522     0x40    slli a5,a5,0x27
    0x84016524     0x42    or s7,s7,a5
    0x84016528     0x46    beqz a1,ffffffff84016560 <invokeUntyped_Retype+0x7e>
    0x8401652a     0x48    ld s10,8(s0)
    0x8401652e     0x4c    srli a5,s10,0x19
    0x84016532     0x50    slli s8,a5,0x4
    0x84016536     0x54    beqz a5,ffffffff84016560 <invokeUntyped_Retype+0x7e>
    0x84016538     0x56    srli a5,s10,0x6
    0x8401653c     0x5a    andi a5,a5,1
    0x8401653e     0x5c    bnez a5,ffffffff84016552 <invokeUntyped_Retype+0x70>
    0x84016540     0x5e    andi a5,s10,56
    0x84016544     0x62    bnez a5,ffffffff840165ba <invokeUntyped_Retype+0xd8>
    0x84016546     0x64    li a1,1
    0x84016548     0x66    sll a1,a1,s10
    0x8401654c     0x6a    mv a0,s7
    0x8401654e     0x6c    jal ra,ffffffff84015b8a <memzero>
    0x84016552     0x70    sd s9,0(s0)
    0x84016556     0x74    slli s10,s10,0x27
    0x84016558     0x76    srli s10,s10,0x27
    0x8401655c     0x7a    sd s10,8(s0)
    0x84016560     0x7e    mv a1,s4
    0x84016562     0x80    mv a0,s1
    0x84016564     0x82    jal ra,ffffffff84011c66 <getObjectSize>
    0x84016568     0x86    sll t1,s2,a0
    0x8401656c     0x8a    sub s7,s3,s7
    0x84016570     0x8e    add t1,t1,s7
    0x84016572     0x90    srli t1,t1,0x4
    0x84016576     0x94    slli t1,t1,0x19
    0x84016578     0x96    ld a5,8(s0)
    0x8401657a     0x98    slli a5,a5,0x27
    0x8401657c     0x9a    srli a5,a5,0x27
    0x8401657e     0x9c    or t1,t1,a5
    0x84016582     0xa0    sd t1,8(s0)
    0x84016586     0xa4    ld a7,112(sp)         ; stack access
    0x84016588     0xa6    mv a6,s4
    0x8401658a     0xa8    mv a5,s3
    0x8401658c     0xaa    mv a4,s2
    0x8401658e     0xac    mv a3,s6
    0x84016590     0xae    mv a2,s5
    0x84016592     0xb0    mv a1,s0
    0x84016594     0xb2    mv a0,s1
    0x84016596     0xb4    jal ra,ffffffff840124c2 <createNewObjects>
    0x8401659a     0xb8    li a0,0
    0x8401659c     0xba    ld ra,104(sp)         ; stack access
    0x8401659e     0xbc    ld s0,96(sp)          ; stack access
    0x840165a0     0xbe    ld s1,88(sp)          ; stack access
    0x840165a2     0xc0    ld s2,80(sp)          ; stack access
    0x840165a4     0xc2    ld s3,72(sp)          ; stack access
    0x840165a6     0xc4    ld s4,64(sp)          ; stack access
    0x840165a8     0xc6    ld s5,56(sp)          ; stack access
    0x840165aa     0xc8    ld s6,48(sp)          ; stack access
    0x840165ac     0xca    ld s7,40(sp)          ; stack access
    0x840165ae     0xcc    ld s8,32(sp)          ; stack access
    0x840165b0     0xce    ld s9,24(sp)          ; stack access
    0x840165b2     0xd0    ld s10,16(sp)         ; stack access
    0x840165b4     0xd2    ld s11,8(sp)          ; stack access
    0x840165b6     0xd4    addi sp,sp,112
    0x840165b8     0xd6    ret
    0x840165ba     0xd8    addi s8,s8,-1
    0x840165bc     0xda    andi s8,s8,-256
    0x840165c0     0xde    slli s10,s10,0x27
    0x840165c2     0xe0    srli s10,s10,0x27
    0x840165c6     0xe4    li s11,-256
    0x840165ca     0xe8    li a1,256
    0x840165ce     0xec    add a0,s7,s8
    0x840165d2     0xf0    jal ra,ffffffff84015b8a <memzero>
    0x840165d6     0xf4    sd s9,0(s0)
    0x840165da     0xf8    srli a5,s8,0x4
    0x840165de     0xfc    slli a5,a5,0x19
    0x840165e0     0xfe    or a5,a5,s10
    0x840165e4    0x102    sd a5,8(s0)
    0x840165e6    0x104    jal ra,ffffffff84011684 <preemptionPoint>
    0x840165ea    0x108    bnez a0,ffffffff8401659c <invokeUntyped_Retype+0xba>
    0x840165ec    0x10a    addi s8,s8,-256
    0x840165f0    0x10e    bne s8,s11,ffffffff840165ca <invokeUntyped_Retype+0xe8>
    0x840165f4    0x112    j ffffffff84016560 <invokeUntyped_Retype+0x7e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
104 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeUntyped_Retype` has 159 nodes.

Section handleVMFaultEvent (240 of 271)
=======================================

Deriving specifications
-----------------------

Section `handleVMFaultEvent` consists of 17 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleVMFaultEvent`:

    0x840145a6     0x0    addi sp,sp,-16
    0x840145a8     0x2    sd ra,8(sp)           ; stack access
    0x840145aa     0x4    mv a1,a0
    0x840145ac     0x6    auipc a0,0x16
    0x840145b0     0xa    ld a0,652(a0) # ffffffff8402a838 <ksCurThread>
    0x840145b4     0xe    jal ra,ffffffff84010a2c <handleVMFault>
    0x840145b8    0x12    bnez a0,ffffffff840145ca <handleVMFaultEvent+0x24>
    0x840145ba    0x14    jal ra,ffffffff84012cf4 <schedule>
    0x840145be    0x18    jal ra,ffffffff84012744 <activateThread>
    0x840145c2    0x1c    li a0,0
    0x840145c4    0x1e    ld ra,8(sp)           ; stack access
    0x840145c6    0x20    addi sp,sp,16
    0x840145c8    0x22    ret
    0x840145ca    0x24    auipc a0,0x16
    0x840145ce    0x28    ld a0,622(a0) # ffffffff8402a838 <ksCurThread>
    0x840145d2    0x2c    jal ra,ffffffff84014514 <handleFault>
    0x840145d6    0x30    j ffffffff840145ba <handleVMFaultEvent+0x14>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleVMFaultEvent` has 28 nodes.

Section handleInterruptEntry (241 of 271)
=========================================

Deriving specifications
-----------------------

Section `handleInterruptEntry` consists of 24 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleInterruptEntry`:

    0x84013e20     0x0    addi sp,sp,-16
    0x84013e22     0x2    sd ra,8(sp)           ; stack access
    0x84013e24     0x4    auipc a5,0x17
    0x84013e28     0x8    lw a5,-1500(a5) # ffffffff8402a848 <active_irq>
    0x84013e2c     0xc    addiw a3,a5,-1
    0x84013e30    0x10    li a4,53
    0x84013e34    0x14    bltu a4,a3,ffffffff84013e44 <handleInterruptEntry+0x24>
    0x84013e38    0x18    slli a0,a5,0x20
    0x84013e3c    0x1c    srli a0,a0,0x20
    0x84013e3e    0x1e    jal ra,ffffffff84013d1c <handleInterrupt>
    0x84013e42    0x22    j ffffffff84013e5e <handleInterruptEntry+0x3e>
    0x84013e44    0x24    jal ra,ffffffff840101a4 <getNewActiveIRQ>
    0x84013e48    0x28    sext.w a5,a0
    0x84013e4c    0x2c    auipc a4,0x17
    0x84013e50    0x30    sw a0,-1540(a4) # ffffffff8402a848 <active_irq>
    0x84013e54    0x34    addiw a0,a0,-1
    0x84013e56    0x36    li a4,53
    0x84013e5a    0x3a    bgeu a4,a0,ffffffff84013e38 <handleInterruptEntry+0x18>
    0x84013e5e    0x3e    jal ra,ffffffff84012cf4 <schedule>
    0x84013e62    0x42    jal ra,ffffffff84012744 <activateThread>
    0x84013e66    0x46    li a0,0
    0x84013e68    0x48    ld ra,8(sp)           ; stack access
    0x84013e6a    0x4a    addi sp,sp,16
    0x84013e6c    0x4c    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
24 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleInterruptEntry` has 37 nodes.

Section sendSignal (242 of 271)
===============================

Deriving specifications
-----------------------

Section `sendSignal` consists of 101 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `sendSignal`:

    0x84013c24     0x0    addi sp,sp,-48
    0x84013c26     0x2    sd ra,40(sp)          ; stack access
    0x84013c28     0x4    sd s0,32(sp)          ; stack access
    0x84013c2a     0x6    sd s1,24(sp)          ; stack access
    0x84013c2c     0x8    sd s2,16(sp)          ; stack access
    0x84013c2e     0xa    mv s0,a0
    0x84013c30     0xc    mv s1,a1
    0x84013c32     0xe    ld a4,0(a0)
    0x84013c34    0x10    andi a5,a4,3
    0x84013c38    0x14    li a3,1
    0x84013c3a    0x16    beq a5,a3,ffffffff84013cac <sendSignal+0x88>
    0x84013c3e    0x1a    li a3,2
    0x84013c40    0x1c    beq a5,a3,ffffffff84013d14 <sendSignal+0xf0>
    0x84013c44    0x20    beqz a5,ffffffff84013c52 <sendSignal+0x2e>
    0x84013c46    0x22    ld ra,40(sp)          ; stack access
    0x84013c48    0x24    ld s0,32(sp)          ; stack access
    0x84013c4a    0x26    ld s1,24(sp)          ; stack access
    0x84013c4c    0x28    ld s2,16(sp)          ; stack access
    0x84013c4e    0x2a    addi sp,sp,48
    0x84013c50    0x2c    ret
    0x84013c52    0x2e    ld a5,24(a0)
    0x84013c54    0x30    slli a3,a5,0x19
    0x84013c58    0x34    srli a3,a3,0x19
    0x84013c5a    0x36    srli a5,a5,0x26
    0x84013c5c    0x38    andi a5,a5,1
    0x84013c5e    0x3a    beqz a5,ffffffff84013c80 <sendSignal+0x5c>
    0x84013c60    0x3c    li s2,-1
    0x84013c62    0x3e    slli s2,s2,0x27
    0x84013c64    0x40    or s2,a3,s2
    0x84013c68    0x44    ld a5,280(s2) # fffffffff8000118 <ki_end+0x73fd1118>
    0x84013c6c    0x48    andi a5,a5,15
    0x84013c6e    0x4a    li a3,3
    0x84013c70    0x4c    beq a5,a3,ffffffff84013c92 <sendSignal+0x6e>
    0x84013c74    0x50    andi a4,a4,-4
    0x84013c76    0x52    ori a4,a4,2
    0x84013c7a    0x56    sd a4,0(s0)
    0x84013c7c    0x58    sd s1,16(s0)
    0x84013c7e    0x5a    j ffffffff84013c46 <sendSignal+0x22>
    0x84013c80    0x5c    bnez a3,ffffffff84013c8e <sendSignal+0x6a>
    0x84013c82    0x5e    andi a4,a4,-4
    0x84013c84    0x60    ori a4,a4,2
    0x84013c88    0x64    sd a4,0(a0)
    0x84013c8a    0x66    sd a1,16(s0)
    0x84013c8c    0x68    j ffffffff84013c46 <sendSignal+0x22>
    0x84013c8e    0x6a    mv s2,a3
    0x84013c90    0x6c    j ffffffff84013c68 <sendSignal+0x44>
    0x84013c92    0x6e    mv a0,s2
    0x84013c94    0x70    jal ra,ffffffff84013068 <cancelIPC>
    0x84013c98    0x74    li a1,1
    0x84013c9a    0x76    mv a0,s2
    0x84013c9c    0x78    jal ra,ffffffff8401263a <setThreadState>
    0x84013ca0    0x7c    sd s1,72(s2)
    0x84013ca4    0x80    mv a0,s2
    0x84013ca6    0x82    jal ra,ffffffff84012934 <possibleSwitchTo>
    0x84013caa    0x86    j ffffffff84013c46 <sendSignal+0x22>
    0x84013cac    0x88    ld a5,8(a0)
    0x84013cae    0x8a    slli s2,a5,0x19
    0x84013cb2    0x8e    srli s2,s2,0x19
    0x84013cb6    0x92    srli a5,a5,0x26
    0x84013cb8    0x94    andi a5,a5,1
    0x84013cba    0x96    beqz a5,ffffffff84013cc4 <sendSignal+0xa0>
    0x84013cbc    0x98    li a5,-1
    0x84013cbe    0x9a    slli a5,a5,0x27
    0x84013cc0    0x9c    or s2,s2,a5
    0x84013cc4    0xa0    srli a2,a4,0x19
    0x84013cc8    0xa4    bgez a4,ffffffff84013cd2 <sendSignal+0xae>
    0x84013ccc    0xa8    li a5,-1
    0x84013cce    0xaa    slli a5,a5,0x27
    0x84013cd0    0xac    or a2,a2,a5
    0x84013cd2    0xae    mv a1,s2
    0x84013cd4    0xb0    mv a0,s2
    0x84013cd6    0xb2    jal ra,ffffffff84012ec2 <tcbEPDequeue>
    0x84013cda    0xb6    ld a3,8(s0)
    0x84013cdc    0xb8    li a4,-1
    0x84013cde    0xba    slli a5,a4,0x27
    0x84013ce2    0xbe    and a3,a3,a5
    0x84013ce4    0xc0    srli a4,a4,0x19
    0x84013ce6    0xc2    and a4,a4,a0
    0x84013ce8    0xc4    or a4,a4,a3
    0x84013cea    0xc6    sd a4,8(s0)
    0x84013cec    0xc8    ld a5,0(s0)
    0x84013cee    0xca    slli a5,a5,0x27
    0x84013cf0    0xcc    srli a5,a5,0x27
    0x84013cf2    0xce    slli a1,a1,0x19
    0x84013cf4    0xd0    or a5,a5,a1
    0x84013cf6    0xd2    beqz a0,ffffffff84013d0e <sendSignal+0xea>
    0x84013cf8    0xd4    sd a5,0(s0)
    0x84013cfa    0xd6    li a1,1
    0x84013cfc    0xd8    mv a0,s2
    0x84013cfe    0xda    jal ra,ffffffff8401263a <setThreadState>
    0x84013d02    0xde    sd s1,72(s2)
    0x84013d06    0xe2    mv a0,s2
    0x84013d08    0xe4    jal ra,ffffffff84012934 <possibleSwitchTo>
    0x84013d0c    0xe8    j ffffffff84013c46 <sendSignal+0x22>
    0x84013d0e    0xea    andi a5,a5,-4
    0x84013d10    0xec    sd a5,0(s0)
    0x84013d12    0xee    j ffffffff84013cfa <sendSignal+0xd6>
    0x84013d14    0xf0    ld a1,16(a0)
    0x84013d16    0xf2    or s1,s1,a1
    0x84013d18    0xf4    sd s1,16(a0)
    0x84013d1a    0xf6    j ffffffff84013c46 <sendSignal+0x22>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
101 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sendSignal` has 151 nodes.

Section cancelIPC (243 of 271)
==============================

Deriving specifications
-----------------------

Section `cancelIPC` consists of 92 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `cancelIPC`:

    0x84013068     0x0    addi sp,sp,-48
    0x8401306a     0x2    sd ra,40(sp)          ; stack access
    0x8401306c     0x4    sd s0,32(sp)          ; stack access
    0x8401306e     0x6    sd s1,24(sp)          ; stack access
    0x84013070     0x8    mv s0,a0
    0x84013072     0xa    ld a4,280(a0)
    0x84013076     0xe    andi a5,a4,15
    0x8401307a    0x12    li a3,5
    0x8401307c    0x14    beq a5,a3,ffffffff84013118 <cancelIPC+0xb0>
    0x84013080    0x18    bltu a3,a5,ffffffff840130f0 <cancelIPC+0x88>
    0x84013084    0x1c    addi a5,a5,-3
    0x84013086    0x1e    li a3,1
    0x84013088    0x20    bltu a3,a5,ffffffff840130e6 <cancelIPC+0x7e>
    0x8401308c    0x24    lui a5,0xe0000
    0x84013090    0x28    srli a5,a5,0x19
    0x84013092    0x2a    and a5,a5,a4
    0x84013094    0x2c    srli a4,a4,0x26
    0x84013096    0x2e    andi a4,a4,1
    0x84013098    0x30    beqz a4,ffffffff840130a0 <cancelIPC+0x38>
    0x8401309a    0x32    li a4,-1
    0x8401309c    0x34    slli a4,a4,0x27
    0x8401309e    0x36    or a5,a5,a4
    0x840130a0    0x38    mv s1,a5
    0x840130a2    0x3a    ld a1,8(a5)
    0x840130a4    0x3c    ld a5,0(a5)
    0x840130a6    0x3e    lui a2,0xf8000
    0x840130aa    0x42    srli a2,a2,0x19
    0x840130ac    0x44    and a2,a2,a5
    0x840130ae    0x46    srli a5,a5,0x26
    0x840130b0    0x48    andi a5,a5,1
    0x840130b2    0x4a    beqz a5,ffffffff840130ba <cancelIPC+0x52>
    0x840130b4    0x4c    li a5,-1
    0x840130b6    0x4e    slli a5,a5,0x27
    0x840130b8    0x50    or a2,a2,a5
    0x840130ba    0x52    mv a0,s0
    0x840130bc    0x54    jal ra,ffffffff84012ec2 <tcbEPDequeue>
    0x840130c0    0x58    sd a0,0(sp)           ; stack access
    0x840130c2    0x5a    sd a1,8(sp)           ; stack access
    0x840130c4    0x5c    sd a0,8(s1)
    0x840130c6    0x5e    ld a5,0(s1)
    0x840130c8    0x60    li a4,-1
    0x840130ca    0x62    slli a4,a4,0x27
    0x840130cc    0x64    addi a4,a4,3
    0x840130ce    0x66    and a5,a5,a4
    0x840130d0    0x68    lui a4,0xf8000
    0x840130d4    0x6c    srli a4,a4,0x19
    0x840130d6    0x6e    and a1,a1,a4
    0x840130d8    0x70    or a1,a1,a5
    0x840130da    0x72    beqz a0,ffffffff84013112 <cancelIPC+0xaa>
    0x840130dc    0x74    sd a1,0(s1)
    0x840130de    0x76    li a1,0
    0x840130e0    0x78    mv a0,s0
    0x840130e2    0x7a    jal ra,ffffffff8401263a <setThreadState>
    0x840130e6    0x7e    ld ra,40(sp)          ; stack access
    0x840130e8    0x80    ld s0,32(sp)          ; stack access
    0x840130ea    0x82    ld s1,24(sp)          ; stack access
    0x840130ec    0x84    addi sp,sp,48
    0x840130ee    0x86    ret
    0x840130f0    0x88    li a3,6
    0x840130f2    0x8a    bne a5,a3,ffffffff840130e6 <cancelIPC+0x7e>
    0x840130f6    0x8e    lui a1,0xe0000
    0x840130fa    0x92    srli a1,a1,0x19
    0x840130fc    0x94    and a1,a1,a4
    0x840130fe    0x96    srli a4,a4,0x26
    0x84013100    0x98    andi a4,a4,1
    0x84013102    0x9a    beqz a4,ffffffff8401310a <cancelIPC+0xa2>
    0x84013104    0x9c    li a5,-1
    0x84013106    0x9e    slli a5,a5,0x27
    0x84013108    0xa0    or a1,a1,a5
    0x8401310a    0xa2    mv a0,s0
    0x8401310c    0xa4    jal ra,ffffffff84012ffa <cancelSignal>
    0x84013110    0xa8    j ffffffff840130e6 <cancelIPC+0x7e>
    0x84013112    0xaa    andi a1,a1,-4
    0x84013114    0xac    sd a1,0(s1)
    0x84013116    0xae    j ffffffff840130de <cancelIPC+0x76>
    0x84013118    0xb0    sd zero,312(a0)
    0x8401311c    0xb4    sd zero,320(a0)
    0x84013120    0xb8    andi s0,a0,-1024
    0x84013124    0xbc    ld a5,88(s0)
    0x84013126    0xbe    lui a0,0xf8000
    0x8401312a    0xc2    srli a0,a0,0x19
    0x8401312c    0xc4    and a0,a0,a5
    0x8401312e    0xc6    srli a5,a5,0x26
    0x84013130    0xc8    andi a5,a5,1
    0x84013132    0xca    beqz a5,ffffffff84013140 <cancelIPC+0xd8>
    0x84013134    0xcc    li a5,-1
    0x84013136    0xce    slli a5,a5,0x27
    0x84013138    0xd0    or a0,a0,a5
    0x8401313a    0xd2    jal ra,ffffffff84013a7c <cteDeleteOne>
    0x8401313e    0xd6    j ffffffff840130e6 <cancelIPC+0x7e>
    0x84013140    0xd8    beqz a0,ffffffff840130e6 <cancelIPC+0x7e>
    0x84013142    0xda    j ffffffff8401313a <cancelIPC+0xd2>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
92 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelIPC` has 135 nodes.

Section create_it_address_space (244 of 271)
============================================

Deriving specifications
-----------------------

Section `create_it_address_space` consists of 125 instructions.


Stack analysis
---------------

49 stack accesses found. Annotated code for `create_it_address_space`:

    0x840006e2      0x0    addi sp,sp,-240
    0x840006e4      0x2    sd ra,232(sp)         ; stack access
    0x840006e6      0x4    sd s0,224(sp)         ; stack access
    0x840006e8      0x6    sd s1,216(sp)         ; stack access
    0x840006ea      0x8    sd s2,208(sp)         ; stack access
    0x840006ec      0xa    sd s3,200(sp)         ; stack access
    0x840006ee      0xc    sd s4,192(sp)         ; stack access
    0x840006f0      0xe    sd s5,184(sp)         ; stack access
    0x840006f2     0x10    sd s6,176(sp)         ; stack access
    0x840006f4     0x12    sd s7,168(sp)         ; stack access
    0x840006f6     0x14    sd s8,160(sp)         ; stack access
    0x840006f8     0x16    sd s9,152(sp)         ; stack access
    0x840006fa     0x18    sd s10,144(sp)        ; stack access
    0x840006fc     0x1a    sd s11,136(sp)        ; stack access
    0x840006fe     0x1c    sd a0,48(sp)          ; stack access
    0x84000700     0x1e    sd a1,56(sp)          ; stack access
    0x84000702     0x20    sd a2,32(sp)          ; stack access
    0x84000704     0x22    mv s6,a3
    0x84000706     0x24    auipc s0,0x1
    0x8400070a     0x28    addi s0,s0,-478 # ffffffff84001528 <ndks_boot>
    0x8400070e     0x2c    ld a0,616(s0)
    0x84000712     0x30    jal ra,ffffffff840107c0 <copyGlobalMappings>
    0x84000716     0x34    ld a5,616(s0)
    0x8400071a     0x38    slli s4,a5,0x19
    0x8400071e     0x3c    srli s4,s4,0x19
    0x84000722     0x40    lui a4,0x300
    0x84000726     0x44    addi a4,a4,1
    0x84000728     0x46    slli a4,a4,0x27
    0x8400072a     0x48    or s4,s4,a4
    0x8400072e     0x4c    slli a5,a5,0x9
    0x84000730     0x4e    lui a4,0xfe000
    0x84000734     0x52    srli a4,a4,0x10
    0x84000736     0x54    and a5,a5,a4
    0x84000738     0x56    li a4,1
    0x8400073a     0x58    slli a4,a4,0x30
    0x8400073c     0x5a    or s1,a5,a4
    0x84000740     0x5e    sd s1,8(sp)           ; stack access
    0x84000742     0x60    ld a5,592(s0)
    0x84000746     0x64    sd a5,24(sp)          ; stack access
    0x84000748     0x66    ld a0,48(sp)          ; stack access
    0x8400074a     0x68    ld a1,56(sp)          ; stack access
    0x8400074c     0x6a    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x84000750     0x6e    sd s4,96(a0)
    0x84000754     0x72    sd s1,104(a0)
    0x84000756     0x74    sd zero,112(a0)
    0x8400075a     0x78    li a5,3
    0x8400075c     0x7a    sd a5,120(a0)
    0x8400075e     0x7c    li a5,30
    0x84000760     0x7e    sd a5,16(sp)          ; stack access
    0x84000762     0x80    mv s3,s0
    0x84000764     0x82    li s8,-1
    0x84000766     0x84    srli s8,s8,0x19
    0x8400076a     0x88    lui s5,0x300
    0x8400076e     0x8c    addi s5,s5,1
    0x84000770     0x8e    slli s5,s5,0x27
    0x84000772     0x90    lui s7,0xfe000
    0x84000776     0x94    srli s7,s7,0x10
    0x8400077a     0x98    ld a4,16(sp)          ; stack access
    0x8400077c     0x9a    sext.w a5,a4
    0x84000780     0x9e    ld s2,32(sp)          ; stack access
    0x84000782     0xa0    srl s2,s2,a4
    0x84000786     0xa4    sll s2,s2,a4
    0x8400078a     0xa8    bgeu s2,s6,ffffffff840007d8 <create_it_address_space+0xf6>
    0x8400078e     0xac    li s10,1
    0x84000790     0xae    sll s10,s10,a5
    0x84000794     0xb2    lui s11,0x1
    0x84000796     0xb4    li s9,1
    0x84000798     0xb6    slli s9,s9,0x30
    0x8400079a     0xb8    ld s0,664(s3) # ffffffff80000298 <KERNEL_OFFSET+0x80000298>
    0x8400079e     0xbc    add a5,s0,s11
    0x840007a2     0xc0    sd a5,664(s3)
    0x840007a6     0xc4    and s1,s2,s8
    0x840007aa     0xc8    or s1,s1,s5
    0x840007ae     0xcc    slli s0,s0,0x9
    0x840007b0     0xce    and s0,s0,s7
    0x840007b4     0xd2    or s0,s0,s9
    0x840007b8     0xd6    mv a2,s1
    0x840007ba     0xd8    mv a3,s0
    0x840007bc     0xda    mv a0,s4
    0x840007be     0xdc    ld a1,8(sp)           ; stack access
    0x840007c0     0xde    jal ra,ffffffff84000190 <map_it_pt_cap>
    0x840007c4     0xe2    mv a2,s1
    0x840007c6     0xe4    mv a3,s0
    0x840007c8     0xe6    ld a0,48(sp)          ; stack access
    0x840007ca     0xe8    ld a1,56(sp)          ; stack access
    0x840007cc     0xea    jal ra,ffffffff84000688 <provide_cap>
    0x840007d0     0xee    beqz a0,ffffffff84000824 <create_it_address_space+0x142>
    0x840007d2     0xf0    add s2,s2,s10
    0x840007d4     0xf2    bltu s2,s6,ffffffff8400079a <create_it_address_space+0xb8>
    0x840007d8     0xf6    ld a5,16(sp)          ; stack access
    0x840007da     0xf8    addiw a5,a5,-9
    0x840007dc     0xfa    mv a4,a5
    0x840007de     0xfc    sd a5,16(sp)          ; stack access
    0x840007e0     0xfe    li a5,12
    0x840007e2    0x100    bne a4,a5,ffffffff8400077a <create_it_address_space+0x98>
    0x840007e6    0x104    auipc a5,0x1
    0x840007ea    0x108    addi a5,a5,-702 # ffffffff84001528 <ndks_boot>
    0x840007ee    0x10c    ld a4,592(a5)
    0x840007f2    0x110    ld a5,584(a5)
    0x840007f6    0x114    ld a3,24(sp)          ; stack access
    0x840007f8    0x116    sd a3,88(a5)
    0x840007fa    0x118    sd a4,96(a5)
    0x840007fc    0x11a    sd s4,112(sp)         ; stack access
    0x840007fe    0x11c    ld a5,8(sp)           ; stack access
    0x84000800    0x11e    sd a5,120(sp)         ; stack access
    0x84000802    0x120    ld a0,112(sp)         ; stack access
    0x84000804    0x122    ld a1,120(sp)         ; stack access
    0x84000806    0x124    ld ra,232(sp)         ; stack access
    0x84000808    0x126    ld s0,224(sp)         ; stack access
    0x8400080a    0x128    ld s1,216(sp)         ; stack access
    0x8400080c    0x12a    ld s2,208(sp)         ; stack access
    0x8400080e    0x12c    ld s3,200(sp)         ; stack access
    0x84000810    0x12e    ld s4,192(sp)         ; stack access
    0x84000812    0x130    ld s5,184(sp)         ; stack access
    0x84000814    0x132    ld s6,176(sp)         ; stack access
    0x84000816    0x134    ld s7,168(sp)         ; stack access
    0x84000818    0x136    ld s8,160(sp)         ; stack access
    0x8400081a    0x138    ld s9,152(sp)         ; stack access
    0x8400081c    0x13a    ld s10,144(sp)        ; stack access
    0x8400081e    0x13c    ld s11,136(sp)        ; stack access
    0x84000820    0x13e    addi sp,sp,240
    0x84000822    0x140    ret
    0x84000824    0x142    sd zero,112(sp)       ; stack access
    0x84000826    0x144    sd zero,120(sp)       ; stack access
    0x84000828    0x146    j ffffffff84000802 <create_it_address_space+0x120>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
125 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_it_address_space` has 200 nodes.

Section decodeSetIPCBuffer (245 of 271)
=======================================

Deriving specifications
-----------------------

Section `decodeSetIPCBuffer` consists of 80 instructions.


Stack analysis
---------------

29 stack accesses found. Annotated code for `decodeSetIPCBuffer`:

    0x84015008     0x0    addi sp,sp,-176
    0x8401500a     0x2    sd ra,168(sp)         ; stack access
    0x8401500c     0x4    sd s0,160(sp)         ; stack access
    0x8401500e     0x6    sd s1,152(sp)         ; stack access
    0x84015010     0x8    sd s2,144(sp)         ; stack access
    0x84015012     0xa    sd a0,64(sp)          ; stack access
    0x84015014     0xc    sd a1,72(sp)          ; stack access
    0x84015016     0xe    beqz a2,ffffffff8401505a <decodeSetIPCBuffer+0x52>
    0x84015018    0x10    mv s1,a3
    0x8401501a    0x12    mv a1,a4
    0x8401501c    0x14    auipc s0,0x4
    0x84015020    0x18    ld s0,-1932(s0) # ffffffff84018890 <current_extra_caps>
    0x84015024    0x1c    beqz s0,ffffffff8401505a <decodeSetIPCBuffer+0x52>
    0x84015026    0x1e    li a0,0
    0x84015028    0x20    jal ra,ffffffff840100ea <getSyscallArg>
    0x8401502c    0x24    mv s2,a0
    0x8401502e    0x26    ld a5,0(s0)
    0x84015030    0x28    sd a5,112(sp)         ; stack access
    0x84015032    0x2a    ld a5,8(s0)
    0x84015034    0x2c    sd a5,120(sp)         ; stack access
    0x84015036    0x2e    beqz a0,ffffffff84015068 <decodeSetIPCBuffer+0x60>
    0x84015038    0x30    ld a2,112(sp)         ; stack access
    0x8401503a    0x32    mv a3,a5
    0x8401503c    0x34    mv a1,s0
    0x8401503e    0x36    addi a0,sp,88
    0x84015040    0x38    jal ra,ffffffff840120ec <deriveCap>
    0x84015044    0x3c    ld a0,88(sp)          ; stack access
    0x84015046    0x3e    bnez a0,ffffffff840150b4 <decodeSetIPCBuffer+0xac>
    0x84015048    0x40    ld a1,96(sp)          ; stack access
    0x8401504a    0x42    sd a1,112(sp)         ; stack access
    0x8401504c    0x44    ld a2,104(sp)         ; stack access
    0x8401504e    0x46    sd a2,120(sp)         ; stack access
    0x84015050    0x48    mv a0,s2
    0x84015052    0x4a    jal ra,ffffffff84010d60 <checkValidIPCBuffer>
    0x84015056    0x4e    beqz a0,ffffffff8401506a <decodeSetIPCBuffer+0x62>
    0x84015058    0x50    j ffffffff840150b4 <decodeSetIPCBuffer+0xac>
    0x8401505a    0x52    li a5,7
    0x8401505c    0x54    auipc a4,0x3
    0x84015060    0x58    sd a5,1652(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84015064    0x5c    li a0,3
    0x84015066    0x5e    j ffffffff840150b4 <decodeSetIPCBuffer+0xac>
    0x84015068    0x60    li s0,0
    0x8401506a    0x62    li a1,2
    0x8401506c    0x64    auipc a0,0x15
    0x84015070    0x68    ld a0,1996(a0) # ffffffff8402a838 <ksCurThread>
    0x84015074    0x6c    jal ra,ffffffff8401263a <setThreadState>
    0x84015078    0x70    ld a5,64(sp)          ; stack access
    0x8401507a    0x72    slli a0,a5,0x19
    0x8401507e    0x76    srli a0,a0,0x19
    0x84015080    0x78    srli a5,a5,0x26
    0x84015082    0x7a    andi a5,a5,1
    0x84015084    0x7c    beqz a5,ffffffff8401508c <decodeSetIPCBuffer+0x84>
    0x84015086    0x7e    li a5,-1
    0x84015088    0x80    slli a5,a5,0x27
    0x8401508a    0x82    or a0,a0,a5
    0x8401508c    0x84    li a5,2
    0x8401508e    0x86    sd a5,56(sp)          ; stack access
    0x84015090    0x88    sd s0,48(sp)          ; stack access
    0x84015092    0x8a    ld a5,112(sp)         ; stack access
    0x84015094    0x8c    sd a5,32(sp)          ; stack access
    0x84015096    0x8e    ld a5,120(sp)         ; stack access
    0x84015098    0x90    sd a5,40(sp)          ; stack access
    0x8401509a    0x92    sd s2,24(sp)          ; stack access
    0x8401509c    0x94    sd zero,16(sp)        ; stack access
    0x8401509e    0x96    sd zero,0(sp)         ; stack access
    0x840150a0    0x98    sd zero,8(sp)         ; stack access
    0x840150a2    0x9a    li a7,0
    0x840150a4    0x9c    li a5,0
    0x840150a6    0x9e    li a6,0
    0x840150a8    0xa0    li a4,0
    0x840150aa    0xa2    li a3,0
    0x840150ac    0xa4    li a2,0
    0x840150ae    0xa6    mv a1,s1
    0x840150b0    0xa8    jal ra,ffffffff84014a0a <invokeTCB_ThreadControl>
    0x840150b4    0xac    ld ra,168(sp)         ; stack access
    0x840150b6    0xae    ld s0,160(sp)         ; stack access
    0x840150b8    0xb0    ld s1,152(sp)         ; stack access
    0x840150ba    0xb2    ld s2,144(sp)         ; stack access
    0x840150bc    0xb4    addi sp,sp,176
    0x840150be    0xb6    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
80 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetIPCBuffer` has 132 nodes.

Section invokeTCB_ThreadControl (246 of 271)
============================================

Deriving specifications
-----------------------

Section `invokeTCB_ThreadControl` consists of 130 instructions.


Stack analysis
---------------

42 stack accesses found. Annotated code for `invokeTCB_ThreadControl`:

    0x84014a0a      0x0    addi sp,sp,-96
    0x84014a0c      0x2    sd ra,88(sp)          ; stack access
    0x84014a0e      0x4    sd s0,80(sp)          ; stack access
    0x84014a10      0x6    sd s1,72(sp)          ; stack access
    0x84014a12      0x8    sd s2,64(sp)          ; stack access
    0x84014a14      0xa    sd s3,56(sp)          ; stack access
    0x84014a16      0xc    sd s4,48(sp)          ; stack access
    0x84014a18      0xe    sd s5,40(sp)          ; stack access
    0x84014a1a     0x10    mv s0,a0
    0x84014a1c     0x12    mv s2,a1
    0x84014a1e     0x14    mv s3,a4
    0x84014a20     0x16    sd a5,0(sp)           ; stack access
    0x84014a22     0x18    sd a6,8(sp)           ; stack access
    0x84014a24     0x1a    mv s4,a7
    0x84014a26     0x1c    ld s1,152(sp)         ; stack access
    0x84014a28     0x1e    slli a5,a0,0x19
    0x84014a2c     0x22    srli a5,a5,0x19
    0x84014a2e     0x24    li a0,3
    0x84014a30     0x26    slli a0,a0,0x3d
    0x84014a32     0x28    or a5,a5,a0
    0x84014a34     0x2a    sd a5,16(sp)          ; stack access
    0x84014a36     0x2c    sd zero,24(sp)        ; stack access
    0x84014a38     0x2e    andi a5,s1,4
    0x84014a3c     0x32    beqz a5,ffffffff84014b3a <invokeTCB_ThreadControl+0x130>
    0x84014a40     0x36    sd a2,376(s0)
    0x84014a44     0x3a    andi a4,s1,8
    0x84014a48     0x3e    bnez a4,ffffffff84014abc <invokeTCB_ThreadControl+0xb2>
    0x84014a4a     0x40    andi s5,s0,-1024
    0x84014a4e     0x44    li a1,1
    0x84014a50     0x46    mv a0,s5
    0x84014a52     0x48    jal ra,ffffffff8401333c <cteDelete>
    0x84014a56     0x4c    bnez a0,ffffffff84014b4c <invokeTCB_ThreadControl+0x142>
    0x84014a5a     0x50    ld a2,0(s4)
    0x84014a5e     0x54    ld a3,8(s4)
    0x84014a62     0x58    ld a0,0(sp)           ; stack access
    0x84014a64     0x5a    ld a1,8(sp)           ; stack access
    0x84014a66     0x5c    jal ra,ffffffff84012166 <sameObjectAs>
    0x84014a6a     0x60    beqz a0,ffffffff84014a7e <invokeTCB_ThreadControl+0x74>
    0x84014a6c     0x62    ld a2,0(s2)
    0x84014a70     0x66    ld a3,8(s2)
    0x84014a74     0x6a    ld a0,16(sp)          ; stack access
    0x84014a76     0x6c    ld a1,24(sp)          ; stack access
    0x84014a78     0x6e    jal ra,ffffffff84012166 <sameObjectAs>
    0x84014a7c     0x72    bnez a0,ffffffff84014ac4 <invokeTCB_ThreadControl+0xba>
    0x84014a7e     0x74    addi s5,s5,32
    0x84014a82     0x78    li a1,1
    0x84014a84     0x7a    mv a0,s5
    0x84014a86     0x7c    jal ra,ffffffff8401333c <cteDelete>
    0x84014a8a     0x80    bnez a0,ffffffff84014b4c <invokeTCB_ThreadControl+0x142>
    0x84014a8c     0x82    ld a5,112(sp)         ; stack access
    0x84014a8e     0x84    ld a2,0(a5)
    0x84014a90     0x86    ld a3,8(a5)
    0x84014a92     0x88    ld a0,96(sp)          ; stack access
    0x84014a94     0x8a    ld a1,104(sp)         ; stack access
    0x84014a96     0x8c    jal ra,ffffffff84012166 <sameObjectAs>
    0x84014a9a     0x90    beqz a0,ffffffff84014b40 <invokeTCB_ThreadControl+0x136>
    0x84014a9c     0x92    ld a2,0(s2)
    0x84014aa0     0x96    ld a3,8(s2)
    0x84014aa4     0x9a    ld a0,16(sp)          ; stack access
    0x84014aa6     0x9c    ld a1,24(sp)          ; stack access
    0x84014aa8     0x9e    jal ra,ffffffff84012166 <sameObjectAs>
    0x84014aac     0xa2    beqz a0,ffffffff84014b40 <invokeTCB_ThreadControl+0x136>
    0x84014aae     0xa4    mv a3,s5
    0x84014ab0     0xa6    ld a2,112(sp)         ; stack access
    0x84014ab2     0xa8    ld a0,96(sp)          ; stack access
    0x84014ab4     0xaa    ld a1,104(sp)         ; stack access
    0x84014ab6     0xac    jal ra,ffffffff840116ba <cteInsert>
    0x84014aba     0xb0    j ffffffff84014b40 <invokeTCB_ThreadControl+0x136>
    0x84014abc     0xb2    sd a3,352(s0)
    0x84014ac0     0xb6    beqz a5,ffffffff84014b40 <invokeTCB_ThreadControl+0x136>
    0x84014ac2     0xb8    j ffffffff84014a4a <invokeTCB_ThreadControl+0x40>
    0x84014ac4     0xba    mv a3,s5
    0x84014ac6     0xbc    mv a2,s4
    0x84014ac8     0xbe    ld a0,0(sp)           ; stack access
    0x84014aca     0xc0    ld a1,8(sp)           ; stack access
    0x84014acc     0xc2    jal ra,ffffffff840116ba <cteInsert>
    0x84014ad0     0xc6    j ffffffff84014a7e <invokeTCB_ThreadControl+0x74>
    0x84014ad2     0xc8    andi s4,s0,-1024
    0x84014ad6     0xcc    addi s4,s4,128
    0x84014ada     0xd0    li a1,1
    0x84014adc     0xd2    mv a0,s4
    0x84014ade     0xd4    jal ra,ffffffff8401333c <cteDelete>
    0x84014ae2     0xd8    bnez a0,ffffffff84014b4c <invokeTCB_ThreadControl+0x142>
    0x84014ae4     0xda    ld a5,120(sp)         ; stack access
    0x84014ae6     0xdc    sd a5,384(s0)
    0x84014aea     0xe0    ld a5,144(sp)         ; stack access
    0x84014aec     0xe2    beqz a5,ffffffff84014b0e <invokeTCB_ThreadControl+0x104>
    0x84014aee     0xe4    ld a2,0(a5)
    0x84014af0     0xe6    ld a3,8(a5)
    0x84014af2     0xe8    ld a0,128(sp)         ; stack access
    0x84014af4     0xea    ld a1,136(sp)         ; stack access
    0x84014af6     0xec    jal ra,ffffffff84012166 <sameObjectAs>
    0x84014afa     0xf0    beqz a0,ffffffff84014b0e <invokeTCB_ThreadControl+0x104>
    0x84014afc     0xf2    ld a2,0(s2)
    0x84014b00     0xf6    ld a3,8(s2)
    0x84014b04     0xfa    ld a0,16(sp)          ; stack access
    0x84014b06     0xfc    ld a1,24(sp)          ; stack access
    0x84014b08     0xfe    jal ra,ffffffff84012166 <sameObjectAs>
    0x84014b0c    0x102    bnez a0,ffffffff84014b20 <invokeTCB_ThreadControl+0x116>
    0x84014b0e    0x104    auipc a5,0x16
    0x84014b12    0x108    ld a5,-726(a5) # ffffffff8402a838 <ksCurThread>
    0x84014b16    0x10c    bne a5,s0,ffffffff84014b46 <invokeTCB_ThreadControl+0x13c>
    0x84014b1a    0x110    jal ra,ffffffff840125d4 <rescheduleRequired>
    0x84014b1e    0x114    j ffffffff84014b46 <invokeTCB_ThreadControl+0x13c>
    0x84014b20    0x116    mv a3,s4
    0x84014b22    0x118    ld a2,144(sp)         ; stack access
    0x84014b24    0x11a    ld a0,128(sp)         ; stack access
    0x84014b26    0x11c    ld a1,136(sp)         ; stack access
    0x84014b28    0x11e    jal ra,ffffffff840116ba <cteInsert>
    0x84014b2c    0x122    j ffffffff84014b0e <invokeTCB_ThreadControl+0x104>
    0x84014b2e    0x124    mv a1,s3
    0x84014b30    0x126    mv a0,s0
    0x84014b32    0x128    jal ra,ffffffff84012e62 <setPriority>
    0x84014b36    0x12c    li a0,0
    0x84014b38    0x12e    j ffffffff84014b4c <invokeTCB_ThreadControl+0x142>
    0x84014b3a    0x130    andi a4,s1,8
    0x84014b3e    0x134    bnez a4,ffffffff84014abc <invokeTCB_ThreadControl+0xb2>
    0x84014b40    0x136    andi a5,s1,2
    0x84014b44    0x13a    bnez a5,ffffffff84014ad2 <invokeTCB_ThreadControl+0xc8>
    0x84014b46    0x13c    andi a0,s1,1
    0x84014b4a    0x140    bnez a0,ffffffff84014b2e <invokeTCB_ThreadControl+0x124>
    0x84014b4c    0x142    ld ra,88(sp)          ; stack access
    0x84014b4e    0x144    ld s0,80(sp)          ; stack access
    0x84014b50    0x146    ld s1,72(sp)          ; stack access
    0x84014b52    0x148    ld s2,64(sp)          ; stack access
    0x84014b54    0x14a    ld s3,56(sp)          ; stack access
    0x84014b56    0x14c    ld s4,48(sp)          ; stack access
    0x84014b58    0x14e    ld s5,40(sp)          ; stack access
    0x84014b5a    0x150    addi sp,sp,96
    0x84014b5c    0x152    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
130 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_ThreadControl` has 237 nodes.

Section handleRecv (247 of 271)
===============================

Deriving specifications
-----------------------

Section `handleRecv` consists of 124 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `handleRecv`:

    0x840147c8      0x0    addi sp,sp,-64
    0x840147ca      0x2    sd ra,56(sp)          ; stack access
    0x840147cc      0x4    sd s0,48(sp)          ; stack access
    0x840147ce      0x6    sd s1,40(sp)          ; stack access
    0x840147d0      0x8    mv s0,a0
    0x840147d2      0xa    auipc a1,0x16
    0x840147d6      0xe    ld a1,102(a1) # ffffffff8402a838 <ksCurThread>
    0x840147da     0x12    ld s1,72(a1)
    0x840147dc     0x14    mv a2,s1
    0x840147de     0x16    addi a0,sp,8
    0x840147e0     0x18    jal ra,ffffffff84011488 <lookupCap>
    0x840147e4     0x1c    ld a5,8(sp)           ; stack access
    0x840147e6     0x1e    bnez a5,ffffffff84014830 <handleRecv+0x68>
    0x840147e8     0x20    ld a5,16(sp)          ; stack access
    0x840147ea     0x22    srli a4,a5,0x3b
    0x840147ee     0x26    li a3,4
    0x840147f0     0x28    beq a4,a3,ffffffff84014854 <handleRecv+0x8c>
    0x840147f4     0x2c    li a3,6
    0x840147f6     0x2e    beq a4,a3,ffffffff840148a4 <handleRecv+0xdc>
    0x840147fa     0x32    auipc a4,0x4
    0x840147fe     0x36    addi a4,a4,-2042 # ffffffff84018000 <riscvKSASIDTable>
    0x84014802     0x3a    li a5,1
    0x84014804     0x3c    sd a5,1024(a4)
    0x84014808     0x40    sd zero,1032(a4)
    0x8401480c     0x44    li a5,-1
    0x8401480e     0x46    slli a5,a5,0x3f
    0x84014810     0x48    addi a5,a5,1
    0x84014812     0x4a    sd a5,1680(a4)
    0x84014816     0x4e    sd s1,1688(a4)
    0x8401481a     0x52    auipc a0,0x16
    0x8401481e     0x56    ld a0,30(a0) # ffffffff8402a838 <ksCurThread>
    0x84014822     0x5a    jal ra,ffffffff84014514 <handleFault>
    0x84014826     0x5e    ld ra,56(sp)          ; stack access
    0x84014828     0x60    ld s0,48(sp)          ; stack access
    0x8401482a     0x62    ld s1,40(sp)          ; stack access
    0x8401482c     0x64    addi sp,sp,64
    0x8401482e     0x66    ret
    0x84014830     0x68    auipc a4,0x3
    0x84014834     0x6c    addi a4,a4,2000 # ffffffff84018000 <riscvKSASIDTable>
    0x84014838     0x70    li a5,-1
    0x8401483a     0x72    slli a5,a5,0x3f
    0x8401483c     0x74    addi a5,a5,1
    0x8401483e     0x76    sd a5,1680(a4)
    0x84014842     0x7a    sd s1,1688(a4)
    0x84014846     0x7e    auipc a0,0x16
    0x8401484a     0x82    ld a0,-14(a0) # ffffffff8402a838 <ksCurThread>
    0x8401484e     0x86    jal ra,ffffffff84014514 <handleFault>
    0x84014852     0x8a    j ffffffff84014826 <handleRecv+0x5e>
    0x84014854     0x8c    srli a5,a5,0x38
    0x84014856     0x8e    andi a5,a5,1
    0x84014858     0x90    beqz a5,ffffffff84014876 <handleRecv+0xae>
    0x8401485a     0x92    auipc s1,0x16
    0x8401485e     0x96    addi s1,s1,-34 # ffffffff8402a838 <ksCurThread>
    0x84014862     0x9a    ld a0,0(s1)
    0x84014864     0x9c    jal ra,ffffffff84013ee4 <deleteCallerCap>
    0x84014868     0xa0    mv a3,s0
    0x8401486a     0xa2    ld a1,16(sp)          ; stack access
    0x8401486c     0xa4    ld a2,24(sp)          ; stack access
    0x8401486e     0xa6    ld a0,0(s1)
    0x84014870     0xa8    jal ra,ffffffff8401462c <receiveIPC>
    0x84014874     0xac    j ffffffff84014826 <handleRecv+0x5e>
    0x84014876     0xae    auipc a4,0x3
    0x8401487a     0xb2    addi a4,a4,1930 # ffffffff84018000 <riscvKSASIDTable>
    0x8401487e     0xb6    li a5,1
    0x84014880     0xb8    sd a5,1024(a4)
    0x84014884     0xbc    sd zero,1032(a4)
    0x84014888     0xc0    li a5,-1
    0x8401488a     0xc2    slli a5,a5,0x3f
    0x8401488c     0xc4    addi a5,a5,1
    0x8401488e     0xc6    sd a5,1680(a4)
    0x84014892     0xca    sd s1,1688(a4)
    0x84014896     0xce    auipc a0,0x16
    0x8401489a     0xd2    ld a0,-94(a0) # ffffffff8402a838 <ksCurThread>
    0x8401489e     0xd6    jal ra,ffffffff84014514 <handleFault>
    0x840148a2     0xda    j ffffffff84014826 <handleRecv+0x5e>
    0x840148a4     0xdc    slli a4,a5,0x19
    0x840148a8     0xe0    srli a4,a4,0x19
    0x840148aa     0xe2    srli a3,a5,0x26
    0x840148ae     0xe6    andi a3,a3,1
    0x840148b0     0xe8    beqz a3,ffffffff840148b8 <handleRecv+0xf0>
    0x840148b2     0xea    li a3,-1
    0x840148b4     0xec    slli a3,a3,0x27
    0x840148b6     0xee    or a4,a4,a3
    0x840148b8     0xf0    ld a4,24(a4)
    0x840148ba     0xf2    slli a3,a4,0x19
    0x840148be     0xf6    srli a3,a3,0x19
    0x840148c0     0xf8    srli a4,a4,0x26
    0x840148c2     0xfa    andi a4,a4,1
    0x840148c4     0xfc    beqz a4,ffffffff8401490e <handleRecv+0x146>
    0x840148c6     0xfe    srli a5,a5,0x3a
    0x840148c8    0x100    andi a5,a5,1
    0x840148ca    0x102    bnez a5,ffffffff840148fa <handleRecv+0x132>
    0x840148cc    0x104    auipc a4,0x3
    0x840148d0    0x108    addi a4,a4,1844 # ffffffff84018000 <riscvKSASIDTable>
    0x840148d4    0x10c    li a5,1
    0x840148d6    0x10e    sd a5,1024(a4)
    0x840148da    0x112    sd zero,1032(a4)
    0x840148de    0x116    li a5,-1
    0x840148e0    0x118    slli a5,a5,0x3f
    0x840148e2    0x11a    addi a5,a5,1
    0x840148e4    0x11c    sd a5,1680(a4)
    0x840148e8    0x120    sd s1,1688(a4)
    0x840148ec    0x124    auipc a0,0x16
    0x840148f0    0x128    ld a0,-180(a0) # ffffffff8402a838 <ksCurThread>
    0x840148f4    0x12c    jal ra,ffffffff84014514 <handleFault>
    0x840148f8    0x130    j ffffffff84014826 <handleRecv+0x5e>
    0x840148fa    0x132    li a5,-1
    0x840148fc    0x134    slli a5,a5,0x27
    0x840148fe    0x136    or a3,a3,a5
    0x84014900    0x138    auipc a5,0x16
    0x84014904    0x13c    ld a5,-200(a5) # ffffffff8402a838 <ksCurThread>
    0x84014908    0x140    beq a3,a5,ffffffff84014916 <handleRecv+0x14e>
    0x8401490c    0x144    j ffffffff840148cc <handleRecv+0x104>
    0x8401490e    0x146    srli a5,a5,0x3a
    0x84014910    0x148    andi a5,a5,1
    0x84014912    0x14a    beqz a5,ffffffff840148cc <handleRecv+0x104>
    0x84014914    0x14c    bnez a3,ffffffff84014900 <handleRecv+0x138>
    0x84014916    0x14e    mv a3,s0
    0x84014918    0x150    ld a1,16(sp)          ; stack access
    0x8401491a    0x152    ld a2,24(sp)          ; stack access
    0x8401491c    0x154    auipc a0,0x16
    0x84014920    0x158    ld a0,-228(a0) # ffffffff8402a838 <ksCurThread>
    0x84014924    0x15c    jal ra,ffffffff84012854 <receiveSignal>
    0x84014928    0x160    j ffffffff84014826 <handleRecv+0x5e>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
124 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleRecv` has 190 nodes.

Section doReplyTransfer (248 of 271)
====================================

Deriving specifications
-----------------------

Section `doReplyTransfer` consists of 46 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `doReplyTransfer`:

    0x840141e4     0x0    addi sp,sp,-32
    0x840141e6     0x2    sd ra,24(sp)          ; stack access
    0x840141e8     0x4    sd s0,16(sp)          ; stack access
    0x840141ea     0x6    sd s1,8(sp)           ; stack access
    0x840141ec     0x8    sd s2,0(sp)           ; stack access
    0x840141ee     0xa    mv s1,a0
    0x840141f0     0xc    mv s0,a1
    0x840141f2     0xe    mv s2,a2
    0x840141f4    0x10    ld a5,312(a1)
    0x840141f8    0x14    andi a5,a5,15
    0x840141fa    0x16    bnez a5,ffffffff84014226 <doReplyTransfer+0x42>
    0x840141fc    0x18    mv a4,a1
    0x840141fe    0x1a    li a2,0
    0x84014200    0x1c    li a1,0
    0x84014202    0x1e    jal ra,ffffffff8401417e <doIPCTransfer>
    0x84014206    0x22    mv a0,s2
    0x84014208    0x24    jal ra,ffffffff84013a7c <cteDeleteOne>
    0x8401420c    0x28    li a1,1
    0x8401420e    0x2a    mv a0,s0
    0x84014210    0x2c    jal ra,ffffffff8401263a <setThreadState>
    0x84014214    0x30    mv a0,s0
    0x84014216    0x32    jal ra,ffffffff84012934 <possibleSwitchTo>
    0x8401421a    0x36    ld ra,24(sp)          ; stack access
    0x8401421c    0x38    ld s0,16(sp)          ; stack access
    0x8401421e    0x3a    ld s1,8(sp)           ; stack access
    0x84014220    0x3c    ld s2,0(sp)           ; stack access
    0x84014222    0x3e    addi sp,sp,32
    0x84014224    0x40    ret
    0x84014226    0x42    mv a0,a2
    0x84014228    0x44    jal ra,ffffffff84013a7c <cteDeleteOne>
    0x8401422c    0x48    mv a1,s1
    0x8401422e    0x4a    mv a0,s0
    0x84014230    0x4c    jal ra,ffffffff84010876 <handleFaultReply>
    0x84014234    0x50    sd zero,312(s0)
    0x84014238    0x54    sd zero,320(s0)
    0x8401423c    0x58    beqz a0,ffffffff8401424e <doReplyTransfer+0x6a>
    0x8401423e    0x5a    li a1,2
    0x84014240    0x5c    mv a0,s0
    0x84014242    0x5e    jal ra,ffffffff8401263a <setThreadState>
    0x84014246    0x62    mv a0,s0
    0x84014248    0x64    jal ra,ffffffff84012934 <possibleSwitchTo>
    0x8401424c    0x68    j ffffffff8401421a <doReplyTransfer+0x36>
    0x8401424e    0x6a    li a1,0
    0x84014250    0x6c    mv a0,s0
    0x84014252    0x6e    jal ra,ffffffff8401263a <setThreadState>
    0x84014256    0x72    j ffffffff8401421a <doReplyTransfer+0x36>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
46 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doReplyTransfer` has 71 nodes.

Section doNormalTransfer (249 of 271)
=====================================

Deriving specifications
-----------------------

Section `doNormalTransfer` consists of 146 instructions.

SLLW.....

Stack analysis
---------------

40 stack accesses found. Annotated code for `doNormalTransfer`:

    0x84014000      0x0    addi sp,sp,-192
    0x84014002      0x2    sd ra,184(sp)         ; stack access
    0x84014004      0x4    sd s0,176(sp)         ; stack access
    0x84014006      0x6    sd s1,168(sp)         ; stack access
    0x84014008      0x8    sd s2,160(sp)         ; stack access
    0x8401400a      0xa    sd s3,152(sp)         ; stack access
    0x8401400c      0xc    sd s4,144(sp)         ; stack access
    0x8401400e      0xe    sd s5,136(sp)         ; stack access
    0x84014010     0x10    sd s6,128(sp)         ; stack access
    0x84014012     0x12    sd s7,120(sp)         ; stack access
    0x84014014     0x14    sd s8,112(sp)         ; stack access
    0x84014016     0x16    sd s9,104(sp)         ; stack access
    0x84014018     0x18    sd s10,96(sp)         ; stack access
    0x8401401a     0x1a    sd s11,88(sp)         ; stack access
    0x8401401c     0x1c    mv s2,a0
    0x8401401e     0x1e    mv s6,a1
    0x84014020     0x20    mv s5,a2
    0x84014022     0x22    mv s4,a3
    0x84014024     0x24    mv s1,a5
    0x84014026     0x26    mv s3,a6
    0x84014028     0x28    ld s0,80(a0)
    0x8401402a     0x2a    andi a3,s0,127
    0x8401402e     0x2e    li a5,120
    0x84014032     0x32    bgeu a5,a3,ffffffff8401403e <doNormalTransfer+0x3e>
    0x84014036     0x36    andi s0,s0,-128
    0x8401403a     0x3a    ori s0,s0,120
    0x8401403e     0x3e    bnez a4,ffffffff8401409c <doNormalTransfer+0x9c>
    0x84014040     0x40    auipc a5,0x5
    0x84014044     0x44    sd zero,-1968(a5) # ffffffff84018890 <current_extra_caps>
    0x84014048     0x48    andi a4,s0,127
    0x8401404c     0x4c    mv a3,s3
    0x8401404e     0x4e    mv a2,s1
    0x84014050     0x50    mv a1,s6
    0x84014052     0x52    mv a0,s2
    0x84014054     0x54    jal ra,ffffffff84013f90 <copyMRs>
    0x84014058     0x58    mv s2,a0
    0x8401405a     0x5a    lui a5,0xfffff
    0x8401405c     0x5c    addi a5,a5,127 # fffffffffffff07f <ki_end+0x7bfd007f>
    0x84014060     0x60    and s0,s0,a5
    0x84014062     0x62    auipc a5,0x5
    0x84014066     0x66    ld a5,-2002(a5) # ffffffff84018890 <current_extra_caps>
    0x8401406a     0x6a    bnez a5,ffffffff840140b2 <doNormalTransfer+0xb2>
    0x8401406c     0x6c    andi s0,s0,-128
    0x84014070     0x70    andi s2,s2,127
    0x84014074     0x74    or s0,s0,s2
    0x84014078     0x78    sd s0,80(s1)
    0x8401407a     0x7a    sd s4,72(s1)
    0x8401407e     0x7e    ld ra,184(sp)         ; stack access
    0x84014080     0x80    ld s0,176(sp)         ; stack access
    0x84014082     0x82    ld s1,168(sp)         ; stack access
    0x84014084     0x84    ld s2,160(sp)         ; stack access
    0x84014086     0x86    ld s3,152(sp)         ; stack access
    0x84014088     0x88    ld s4,144(sp)         ; stack access
    0x8401408a     0x8a    ld s5,136(sp)         ; stack access
    0x8401408c     0x8c    ld s6,128(sp)         ; stack access
    0x8401408e     0x8e    ld s7,120(sp)         ; stack access
    0x84014090     0x90    ld s8,112(sp)         ; stack access
    0x84014092     0x92    ld s9,104(sp)         ; stack access
    0x84014094     0x94    ld s10,96(sp)         ; stack access
    0x84014096     0x96    ld s11,88(sp)         ; stack access
    0x84014098     0x98    addi sp,sp,192
    0x8401409a     0x9a    ret
    0x8401409c     0x9c    mv a2,s0
    0x8401409e     0x9e    mv a1,s6
    0x840140a0     0xa0    mv a0,s2
    0x840140a2     0xa2    jal ra,ffffffff84013efa <lookupExtraCaps>
    0x840140a6     0xa6    beqz a0,ffffffff84014048 <doNormalTransfer+0x48>
    0x840140a8     0xa8    auipc a5,0x4
    0x840140ac     0xac    sd zero,2024(a5) # ffffffff84018890 <current_extra_caps>
    0x840140b0     0xb0    j ffffffff84014048 <doNormalTransfer+0x48>
    0x840140b2     0xb2    beqz s3,ffffffff8401406c <doNormalTransfer+0x6c>
    0x840140b6     0xb6    mv a1,s3
    0x840140b8     0xb8    mv a0,s1
    0x840140ba     0xba    jal ra,ffffffff84011a26 <getReceiveSlots>
    0x840140be     0xbe    mv s8,a0
    0x840140c0     0xc0    auipc s9,0x4
    0x840140c4     0xc4    addi s9,s9,2000 # ffffffff84018890 <current_extra_caps>
    0x840140c8     0xc8    addi s3,s3,976
    0x840140cc     0xcc    li s7,0
    0x840140ce     0xce    li s10,-1
    0x840140d0     0xd0    srli s11,s10,0x19
    0x840140d4     0xd4    li a5,1
    0x840140d6     0xd6    slli a5,a5,0x26
    0x840140d8     0xd8    sd a5,8(sp)           ; stack access
    0x840140da     0xda    lui a5,0x1
    0x840140dc     0xdc    addi a5,a5,-512 # e00 <KERNEL_OFFSET-0xfffffffefffff200>
    0x840140e0     0xe0    sd a5,16(sp)          ; stack access
    0x840140e2     0xe2    lui a5,0xfffff
    0x840140e4     0xe4    addi a5,a5,511 # fffffffffffff1ff <ki_end+0x7bfd01ff>
    0x840140e8     0xe8    sd a5,24(sp)          ; stack access
    0x840140ea     0xea    j ffffffff84014120 <doNormalTransfer+0x120>
    0x840140ec     0xec    beqz s8,ffffffff84014172 <doNormalTransfer+0x172>
    0x840140f0     0xf0    sd a2,40(sp)          ; stack access
    0x840140f2     0xf2    sd a3,48(sp)          ; stack access
    0x840140f4     0xf4    mv a1,s6
    0x840140f6     0xf6    addi a0,sp,56
    0x840140f8     0xf8    jal ra,ffffffff840120ec <deriveCap>
    0x840140fc     0xfc    ld a5,56(sp)          ; stack access
    0x840140fe     0xfe    bnez a5,ffffffff84014172 <doNormalTransfer+0x172>
    0x84014100    0x100    ld a5,64(sp)          ; stack access
    0x84014102    0x102    srli a5,a5,0x3b
    0x84014104    0x104    beqz a5,ffffffff84014172 <doNormalTransfer+0x172>
    0x84014106    0x106    mv a3,s8
    0x84014108    0x108    mv a2,s6
    0x8401410a    0x10a    ld a0,64(sp)          ; stack access
    0x8401410c    0x10c    ld a1,72(sp)          ; stack access
    0x8401410e    0x10e    jal ra,ffffffff840116ba <cteInsert>
    0x84014112    0x112    li s8,0
    0x84014114    0x114    addi s7,s7,1
    0x84014116    0x116    addi s9,s9,8
    0x84014118    0x118    addi s3,s3,8
    0x8401411a    0x11a    li a5,3
    0x8401411c    0x11c    beq s7,a5,ffffffff84014172 <doNormalTransfer+0x172>
    0x84014120    0x120    ld s6,0(s9)
    0x84014124    0x124    beqz s6,ffffffff84014172 <doNormalTransfer+0x172>
    0x84014128    0x128    ld a2,0(s6)
    0x8401412c    0x12c    sd a2,40(sp)          ; stack access
    0x8401412e    0x12e    ld a3,8(s6)
    0x84014132    0x132    sd a3,48(sp)          ; stack access
    0x84014134    0x134    srli a4,a2,0x3b
    0x84014138    0x138    li a5,4
    0x8401413a    0x13a    bne a4,a5,ffffffff840140ec <doNormalTransfer+0xec>
    0x8401413e    0x13e    and a5,a2,s11
    0x84014142    0x142    ld a4,8(sp)           ; stack access
    0x84014144    0x144    and a4,a4,a2
    0x84014146    0x146    beqz a4,ffffffff8401414e <doNormalTransfer+0x14e>
    0x84014148    0x148    slli a4,s10,0x27
    0x8401414c    0x14c    or a5,a5,a4
    0x8401414e    0x14e    bne s5,a5,ffffffff840140ec <doNormalTransfer+0xec>
    0x84014152    0x152    sd a3,0(s3)
    0x84014156    0x156    srli a5,s0,0x9
    0x8401415a    0x15a    andi a5,a5,7
    0x8401415c    0x15c    li a4,1
    0x8401415e    0x15e    sllw a4,a4,s7
    0x84014162    0x162    or a5,a5,a4
    0x84014164    0x164    slli a5,a5,0x9
    0x84014166    0x166    ld a4,16(sp)          ; stack access
    0x84014168    0x168    and a5,a5,a4
    0x8401416a    0x16a    ld a4,24(sp)          ; stack access
    0x8401416c    0x16c    and s0,s0,a4
    0x8401416e    0x16e    or s0,s0,a5
    0x84014170    0x170    j ffffffff84014114 <doNormalTransfer+0x114>
    0x84014172    0x172    slli a5,s7,0x7
    0x84014176    0x176    andi a5,a5,384
    0x8401417a    0x17a    or s0,s0,a5
    0x8401417c    0x17c    j ffffffff8401406c <doNormalTransfer+0x6c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
146 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doNormalTransfer` has 228 nodes.

Section restart (250 of 271)
============================

Deriving specifications
-----------------------

Section `restart` consists of 25 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `restart`:

    0x84013be4     0x0    addi sp,sp,-16
    0x84013be6     0x2    sd ra,8(sp)           ; stack access
    0x84013be8     0x4    sd s0,0(sp)           ; stack access
    0x84013bea     0x6    mv s0,a0
    0x84013bec     0x8    ld a5,280(a0)
    0x84013bf0     0xc    andi a5,a5,15
    0x84013bf2     0xe    beqz a5,ffffffff84013bfc <restart+0x18>
    0x84013bf4    0x10    addi a5,a5,-3
    0x84013bf6    0x12    li a4,3
    0x84013bf8    0x14    bltu a4,a5,ffffffff84013c1c <restart+0x38>
    0x84013bfc    0x18    mv a0,s0
    0x84013bfe    0x1a    jal ra,ffffffff84013068 <cancelIPC>
    0x84013c02    0x1e    mv a0,s0
    0x84013c04    0x20    jal ra,ffffffff840119f2 <setupReplyMaster>
    0x84013c08    0x24    li a1,2
    0x84013c0a    0x26    mv a0,s0
    0x84013c0c    0x28    jal ra,ffffffff8401263a <setThreadState>
    0x84013c10    0x2c    mv a0,s0
    0x84013c12    0x2e    jal ra,ffffffff8401253a <tcbSchedEnqueue>
    0x84013c16    0x32    mv a0,s0
    0x84013c18    0x34    jal ra,ffffffff84012934 <possibleSwitchTo>
    0x84013c1c    0x38    ld ra,8(sp)           ; stack access
    0x84013c1e    0x3a    ld s0,0(sp)           ; stack access
    0x84013c20    0x3c    addi sp,sp,16
    0x84013c22    0x3e    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
25 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `restart` has 40 nodes.

Section cancelBadgedSends (251 of 271)
======================================

Deriving specifications
-----------------------

Section `cancelBadgedSends` consists of 86 instructions.


Stack analysis
---------------

16 stack accesses found. Annotated code for `cancelBadgedSends`:

    0x84012ef8     0x0    addi sp,sp,-80
    0x84012efa     0x2    sd ra,72(sp)          ; stack access
    0x84012efc     0x4    sd s0,64(sp)          ; stack access
    0x84012efe     0x6    sd s1,56(sp)          ; stack access
    0x84012f00     0x8    sd s2,48(sp)          ; stack access
    0x84012f02     0xa    sd s3,40(sp)          ; stack access
    0x84012f04     0xc    sd s4,32(sp)          ; stack access
    0x84012f06     0xe    sd s5,24(sp)          ; stack access
    0x84012f08    0x10    ld a5,0(a0)
    0x84012f0a    0x12    andi a3,a5,3
    0x84012f0e    0x16    li a4,1
    0x84012f10    0x18    beq a3,a4,ffffffff84012f1c <cancelBadgedSends+0x24>
    0x84012f14    0x1c    andi a5,a5,1
    0x84012f16    0x1e    beqz a5,ffffffff84012fbc <cancelBadgedSends+0xc4>
    0x84012f18    0x20    jal ra,ffffffff8401041e <halt>
    0x84012f1c    0x24    mv s4,a0
    0x84012f1e    0x26    mv s3,a1
    0x84012f20    0x28    ld s0,8(a0)
    0x84012f22    0x2a    mv s2,s0
    0x84012f24    0x2c    lui a4,0xf8000
    0x84012f28    0x30    srli a4,a4,0x19
    0x84012f2a    0x32    and a4,a4,a5
    0x84012f2c    0x34    srli a3,a5,0x26
    0x84012f30    0x38    andi a3,a3,1
    0x84012f32    0x3a    beqz a3,ffffffff84012f3a <cancelBadgedSends+0x42>
    0x84012f34    0x3c    li a3,-1
    0x84012f36    0x3e    slli a3,a3,0x27
    0x84012f38    0x40    or a4,a4,a3
    0x84012f3a    0x42    mv s1,a4
    0x84012f3c    0x44    sd zero,8(s4)
    0x84012f40    0x48    srli a5,a5,0x27
    0x84012f42    0x4a    slli a5,a5,0x27
    0x84012f44    0x4c    sd a5,0(s4)
    0x84012f48    0x50    bnez s0,ffffffff84012f60 <cancelBadgedSends+0x68>
    0x84012f4a    0x52    sd zero,8(s4)
    0x84012f4e    0x56    lui a3,0xf8000
    0x84012f52    0x5a    srli a3,a3,0x19
    0x84012f54    0x5c    and a4,a4,a3
    0x84012f56    0x5e    or a5,a5,a4
    0x84012f58    0x60    sd a5,0(s4)
    0x84012f5c    0x64    j ffffffff84012fb8 <cancelBadgedSends+0xc0>
    0x84012f5e    0x66    beqz s0,ffffffff84012f90 <cancelBadgedSends+0x98>
    0x84012f60    0x68    ld a5,296(s0)
    0x84012f64    0x6c    mv s5,s0
    0x84012f66    0x6e    ld s0,408(s0)
    0x84012f6a    0x72    bne s3,a5,ffffffff84012f5e <cancelBadgedSends+0x66>
    0x84012f6e    0x76    li a1,2
    0x84012f70    0x78    mv a0,s5
    0x84012f72    0x7a    jal ra,ffffffff8401263a <setThreadState>
    0x84012f76    0x7e    mv a0,s5
    0x84012f78    0x80    jal ra,ffffffff8401253a <tcbSchedEnqueue>
    0x84012f7c    0x84    mv a1,s2
    0x84012f7e    0x86    mv a2,s1
    0x84012f80    0x88    mv a0,s5
    0x84012f82    0x8a    jal ra,ffffffff84012ec2 <tcbEPDequeue>
    0x84012f86    0x8e    mv s2,a0
    0x84012f88    0x90    mv s1,a1
    0x84012f8a    0x92    sd a0,0(sp)           ; stack access
    0x84012f8c    0x94    sd a1,8(sp)           ; stack access
    0x84012f8e    0x96    j ffffffff84012f5e <cancelBadgedSends+0x66>
    0x84012f90    0x98    sd s2,8(s4)
    0x84012f94    0x9c    ld a5,0(s4)
    0x84012f98    0xa0    li a4,-1
    0x84012f9a    0xa2    slli a4,a4,0x27
    0x84012f9c    0xa4    addi a4,a4,3
    0x84012f9e    0xa6    and a5,a5,a4
    0x84012fa0    0xa8    lui a4,0xf8000
    0x84012fa4    0xac    srli a4,a4,0x19
    0x84012fa6    0xae    and s1,s1,a4
    0x84012fa8    0xb0    or s1,s1,a5
    0x84012faa    0xb2    beqz s2,ffffffff84012fce <cancelBadgedSends+0xd6>
    0x84012fae    0xb6    andi s1,s1,-4
    0x84012fb0    0xb8    ori s1,s1,1
    0x84012fb4    0xbc    sd s1,0(s4)
    0x84012fb8    0xc0    jal ra,ffffffff840125d4 <rescheduleRequired>
    0x84012fbc    0xc4    ld ra,72(sp)          ; stack access
    0x84012fbe    0xc6    ld s0,64(sp)          ; stack access
    0x84012fc0    0xc8    ld s1,56(sp)          ; stack access
    0x84012fc2    0xca    ld s2,48(sp)          ; stack access
    0x84012fc4    0xcc    ld s3,40(sp)          ; stack access
    0x84012fc6    0xce    ld s4,32(sp)          ; stack access
    0x84012fc8    0xd0    ld s5,24(sp)          ; stack access
    0x84012fca    0xd2    addi sp,sp,80
    0x84012fcc    0xd4    ret
    0x84012fce    0xd6    sd s1,0(s4)
    0x84012fd2    0xda    j ffffffff84012fb8 <cancelBadgedSends+0xc0>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
86 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelBadgedSends` has 134 nodes.

Section schedule (252 of 271)
=============================

Deriving specifications
-----------------------

Section `schedule` consists of 94 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `schedule`:

    0x84012cf4      0x0    auipc a5,0x18
    0x84012cf8      0x4    ld a5,-1228(a5) # ffffffff8402a828 <ksSchedulerAction>
    0x84012cfc      0x8    beqz a5,ffffffff84012e12 <schedule+0x11e>
    0x84012d00      0xc    addi sp,sp,-48
    0x84012d02      0xe    sd ra,40(sp)          ; stack access
    0x84012d04     0x10    sd s0,32(sp)          ; stack access
    0x84012d06     0x12    sd s1,24(sp)          ; stack access
    0x84012d08     0x14    sd s2,16(sp)          ; stack access
    0x84012d0a     0x16    sd s3,8(sp)           ; stack access
    0x84012d0c     0x18    sd s4,0(sp)           ; stack access
    0x84012d0e     0x1a    auipc a0,0x18
    0x84012d12     0x1e    ld a0,-1238(a0) # ffffffff8402a838 <ksCurThread>
    0x84012d16     0x22    ld a5,280(a0)
    0x84012d1a     0x26    andi a5,a5,15
    0x84012d1c     0x28    addi a5,a5,-1
    0x84012d1e     0x2a    li a4,1
    0x84012d20     0x2c    li s3,0
    0x84012d22     0x2e    bgeu a4,a5,ffffffff84012dc0 <schedule+0xcc>
    0x84012d26     0x32    auipc s0,0x18
    0x84012d2a     0x36    ld s0,-1278(s0) # ffffffff8402a828 <ksSchedulerAction>
    0x84012d2e     0x3a    li a5,1
    0x84012d30     0x3c    beq s0,a5,ffffffff84012dc8 <schedule+0xd4>
    0x84012d34     0x40    auipc s4,0x18
    0x84012d38     0x44    ld s4,-1276(s4) # ffffffff8402a838 <ksCurThread>
    0x84012d3c     0x48    auipc a5,0x18
    0x84012d40     0x4c    ld a5,-1292(a5) # ffffffff8402a830 <ksIdleThread>
    0x84012d44     0x50    beq s4,a5,ffffffff84012d54 <schedule+0x60>
    0x84012d48     0x54    ld a4,360(s0)
    0x84012d4c     0x58    ld a5,360(s4)
    0x84012d50     0x5c    bgeu a4,a5,ffffffff84012dce <schedule+0xda>
    0x84012d54     0x60    auipc s1,0x18
    0x84012d58     0x64    ld s1,-1340(s1) # ffffffff8402a818 <ksCurDomain>
    0x84012d5c     0x68    slli a4,s1,0x3
    0x84012d60     0x6c    auipc a5,0x5
    0x84012d64     0x70    addi a5,a5,672 # ffffffff84018000 <riscvKSASIDTable>
    0x84012d68     0x74    add a5,a5,a4
    0x84012d6a     0x76    ld a0,1040(a5)
    0x84012d6e     0x7a    beqz a0,ffffffff84012dce <schedule+0xda>
    0x84012d70     0x7c    jal ra,ffffffff840100cc <clzl>
    0x84012d74     0x80    mv s2,a0
    0x84012d76     0x82    slli s1,s1,0x2
    0x84012d78     0x84    addi a5,a0,-60
    0x84012d7c     0x88    add s1,s1,a5
    0x84012d7e     0x8a    slli s1,s1,0x3
    0x84012d80     0x8c    auipc a5,0x5
    0x84012d84     0x90    addi a5,a5,640 # ffffffff84018000 <riscvKSASIDTable>
    0x84012d88     0x94    add s1,s1,a5
    0x84012d8a     0x96    ld a0,1168(s1)
    0x84012d8e     0x9a    jal ra,ffffffff840100cc <clzl>
    0x84012d92     0x9e    li a5,63
    0x84012d96     0xa2    sub s2,a5,s2
    0x84012d9a     0xa6    slli s2,s2,0x6
    0x84012d9c     0xa8    sub a5,a5,a0
    0x84012d9e     0xaa    or s2,s2,a5
    0x84012da2     0xae    ld a5,360(s0)
    0x84012da6     0xb2    bgeu a5,s2,ffffffff84012dce <schedule+0xda>
    0x84012daa     0xb6    mv a0,s0
    0x84012dac     0xb8    jal ra,ffffffff8401253a <tcbSchedEnqueue>
    0x84012db0     0xbc    li a5,1
    0x84012db2     0xbe    auipc a4,0x18
    0x84012db6     0xc2    sd a5,-1418(a4) # ffffffff8402a828 <ksSchedulerAction>
    0x84012dba     0xc6    jal ra,ffffffff84012c86 <scheduleChooseNewThread>
    0x84012dbe     0xca    j ffffffff84012de4 <schedule+0xf0>
    0x84012dc0     0xcc    jal ra,ffffffff8401253a <tcbSchedEnqueue>
    0x84012dc4     0xd0    li s3,1
    0x84012dc6     0xd2    j ffffffff84012d26 <schedule+0x32>
    0x84012dc8     0xd4    jal ra,ffffffff84012c86 <scheduleChooseNewThread>
    0x84012dcc     0xd8    j ffffffff84012de4 <schedule+0xf0>
    0x84012dce     0xda    beqz s3,ffffffff84012dde <schedule+0xea>
    0x84012dd2     0xde    ld a4,360(s0)
    0x84012dd6     0xe2    ld a5,360(s4)
    0x84012dda     0xe6    beq a4,a5,ffffffff84012dfc <schedule+0x108>
    0x84012dde     0xea    mv a0,s0
    0x84012de0     0xec    jal ra,ffffffff84012be8 <switchToThread>
    0x84012de4     0xf0    auipc a5,0x18
    0x84012de8     0xf4    sd zero,-1468(a5) # ffffffff8402a828 <ksSchedulerAction>
    0x84012dec     0xf8    ld ra,40(sp)          ; stack access
    0x84012dee     0xfa    ld s0,32(sp)          ; stack access
    0x84012df0     0xfc    ld s1,24(sp)          ; stack access
    0x84012df2     0xfe    ld s2,16(sp)          ; stack access
    0x84012df4    0x100    ld s3,8(sp)           ; stack access
    0x84012df6    0x102    ld s4,0(sp)           ; stack access
    0x84012df8    0x104    addi sp,sp,48
    0x84012dfa    0x106    ret
    0x84012dfc    0x108    mv a0,s0
    0x84012dfe    0x10a    jal ra,ffffffff84012a22 <tcbSchedAppend>
    0x84012e02    0x10e    li a5,1
    0x84012e04    0x110    auipc a4,0x18
    0x84012e08    0x114    sd a5,-1500(a4) # ffffffff8402a828 <ksSchedulerAction>
    0x84012e0c    0x118    jal ra,ffffffff84012c86 <scheduleChooseNewThread>
    0x84012e10    0x11c    j ffffffff84012de4 <schedule+0xf0>
    0x84012e12    0x11e    auipc a5,0x18
    0x84012e16    0x122    sd zero,-1514(a5) # ffffffff8402a828 <ksSchedulerAction>
    0x84012e1a    0x126    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
94 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `schedule` has 153 nodes.

Section Arch_finaliseCap (253 of 271)
=====================================

Deriving specifications
-----------------------

Section `Arch_finaliseCap` consists of 104 instructions.


Stack analysis
---------------

Section `Arch_finaliseCap` expects pointer to stack in a0.
18 stack accesses found. Annotated code for `Arch_finaliseCap`:

    0x84010f56      0x0    addi sp,sp,-80
    0x84010f58      0x2    sd ra,72(sp)          ; stack access
    0x84010f5a      0x4    sd s0,64(sp)          ; stack access
    0x84010f5c      0x6    sd s1,56(sp)          ; stack access
    0x84010f5e      0x8    sd s2,48(sp)          ; stack access
    0x84010f60      0xa    sd s3,40(sp)          ; stack access
    0x84010f62      0xc    mv s0,a0
    0x84010f64      0xe    mv s2,a2
    0x84010f66     0x10    mv s1,a1
    0x84010f68     0x12    srli a5,a1,0x3b
    0x84010f6c     0x16    li a4,3
    0x84010f6e     0x18    beq a5,a4,ffffffff84010fde <Arch_finaliseCap+0x88>
    0x84010f72     0x1c    li a4,13
    0x84010f74     0x1e    beq a5,a4,ffffffff84011040 <Arch_finaliseCap+0xea>
    0x84010f78     0x22    li a4,1
    0x84010f7a     0x24    beq a5,a4,ffffffff84010f9e <Arch_finaliseCap+0x48>
    0x84010f7e     0x28    sd zero,0(s0)         ; stack access
    0x84010f82     0x2c    sd zero,8(s0)         ; stack access
    0x84010f86     0x30    sd zero,16(s0)        ; stack access
    0x84010f8a     0x34    sd zero,24(s0)        ; stack access
    0x84010f8e     0x38    mv a0,s0
    0x84010f90     0x3a    ld ra,72(sp)          ; stack access
    0x84010f92     0x3c    ld s0,64(sp)          ; stack access
    0x84010f94     0x3e    ld s1,56(sp)          ; stack access
    0x84010f96     0x40    ld s2,48(sp)          ; stack access
    0x84010f98     0x42    ld s3,40(sp)          ; stack access
    0x84010f9a     0x44    addi sp,sp,80
    0x84010f9c     0x46    ret
    0x84010f9e     0x48    srli a1,a2,0x30
    0x84010fa2     0x4c    beqz a1,ffffffff84010f7e <Arch_finaliseCap+0x28>
    0x84010fa4     0x4e    srli a0,s1,0x39
    0x84010fa8     0x52    andi a0,a0,3
    0x84010faa     0x54    slli a2,s1,0x19
    0x84010fae     0x58    srli a2,a2,0x19
    0x84010fb0     0x5a    srli s1,s1,0x26
    0x84010fb2     0x5c    andi s1,s1,1
    0x84010fb4     0x5e    beqz s1,ffffffff84010fbc <Arch_finaliseCap+0x66>
    0x84010fb6     0x60    li a5,-1
    0x84010fb8     0x62    slli a5,a5,0x27
    0x84010fba     0x64    or a2,a2,a5
    0x84010fbc     0x66    srli s2,s2,0x9
    0x84010fc0     0x6a    slli a3,s2,0x19
    0x84010fc4     0x6e    srli a3,a3,0x19
    0x84010fc6     0x70    srli s2,s2,0x26
    0x84010fca     0x74    andi s2,s2,1
    0x84010fce     0x78    beqz s2,ffffffff84010fd8 <Arch_finaliseCap+0x82>
    0x84010fd2     0x7c    li a5,-1
    0x84010fd4     0x7e    slli a5,a5,0x27
    0x84010fd6     0x80    or a3,a3,a5
    0x84010fd8     0x82    jal ra,ffffffff84010b54 <unmapPage>
    0x84010fdc     0x86    j ffffffff84010f7e <Arch_finaliseCap+0x28>
    0x84010fde     0x88    beqz a3,ffffffff84010f7e <Arch_finaliseCap+0x28>
    0x84010fe0     0x8a    srli a5,a1,0x27
    0x84010fe4     0x8e    andi a5,a5,1
    0x84010fe6     0x90    beqz a5,ffffffff84010f7e <Arch_finaliseCap+0x28>
    0x84010fe8     0x92    srli s3,a2,0x30
    0x84010fec     0x96    mv a0,s3
    0x84010fee     0x98    jal ra,ffffffff84010144 <findVSpaceForASID>
    0x84010ff2     0x9c    sd a0,16(sp)          ; stack access
    0x84010ff4     0x9e    sd a1,24(sp)          ; stack access
    0x84010ff6     0xa0    srli s2,s2,0x9
    0x84010ffa     0xa4    slli a2,s2,0x19
    0x84010ffe     0xa8    srli a2,a2,0x19
    0x84011000     0xaa    srli s2,s2,0x26
    0x84011004     0xae    andi s2,s2,1
    0x84011008     0xb2    beqz s2,ffffffff84011012 <Arch_finaliseCap+0xbc>
    0x8401100c     0xb6    li a5,-1
    0x8401100e     0xb8    slli a5,a5,0x27
    0x84011010     0xba    or a2,a2,a5
    0x84011012     0xbc    ld a5,16(sp)          ; stack access
    0x84011014     0xbe    bnez a5,ffffffff8401101c <Arch_finaliseCap+0xc6>
    0x84011016     0xc0    ld a5,24(sp)          ; stack access
    0x84011018     0xc2    beq a5,a2,ffffffff84011036 <Arch_finaliseCap+0xe0>
    0x8401101c     0xc6    slli a1,s1,0x19
    0x84011020     0xca    srli a1,a1,0x19
    0x84011022     0xcc    srli s1,s1,0x26
    0x84011024     0xce    andi s1,s1,1
    0x84011026     0xd0    beqz s1,ffffffff8401102e <Arch_finaliseCap+0xd8>
    0x84011028     0xd2    li a5,-1
    0x8401102a     0xd4    slli a5,a5,0x27
    0x8401102c     0xd6    or a1,a1,a5
    0x8401102e     0xd8    mv a0,s3
    0x84011030     0xda    jal ra,ffffffff84010aaa <unmapPageTable>
    0x84011034     0xde    j ffffffff84010f7e <Arch_finaliseCap+0x28>
    0x84011036     0xe0    mv a1,a2
    0x84011038     0xe2    mv a0,s3
    0x8401103a     0xe4    jal ra,ffffffff84010d06 <deleteASID>
    0x8401103e     0xe8    j ffffffff84010f7e <Arch_finaliseCap+0x28>
    0x84011040     0xea    beqz a3,ffffffff84010f7e <Arch_finaliseCap+0x28>
    0x84011042     0xec    srli a0,a1,0x2b
    0x84011046     0xf0    slli a0,a0,0x30
    0x84011048     0xf2    srli a0,a0,0x30
    0x8401104a     0xf4    slli s1,a1,0x2
    0x8401104e     0xf8    lui a1,0xf8000
    0x84011052     0xfc    srli a1,a1,0x19
    0x84011054     0xfe    and a1,a1,s1
    0x84011056    0x100    srli s1,s1,0x26
    0x84011058    0x102    andi s1,s1,1
    0x8401105a    0x104    beqz s1,ffffffff84011062 <Arch_finaliseCap+0x10c>
    0x8401105c    0x106    li a5,-1
    0x8401105e    0x108    slli a5,a5,0x27
    0x84011060    0x10a    or a1,a1,a5
    0x84011062    0x10c    jal ra,ffffffff84010cc8 <deleteASIDPool>
    0x84011066    0x110    j ffffffff84010f7e <Arch_finaliseCap+0x28>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
104 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_finaliseCap` has 156 nodes.

Section init_freemem (254 of 271)
=================================

Deriving specifications
-----------------------

Section `init_freemem` consists of 299 instructions.


Stack analysis
---------------

42 stack accesses found. Annotated code for `init_freemem`:

    0x84000f66      0x0    addi sp,sp,-192
    0x84000f68      0x2    sd ra,184(sp)         ; stack access
    0x84000f6a      0x4    sd s0,176(sp)         ; stack access
    0x84000f6c      0x6    sd s1,168(sp)         ; stack access
    0x84000f6e      0x8    sd s2,160(sp)         ; stack access
    0x84000f70      0xa    sd s3,152(sp)         ; stack access
    0x84000f72      0xc    sd s4,144(sp)         ; stack access
    0x84000f74      0xe    sd s5,136(sp)         ; stack access
    0x84000f76     0x10    sd s6,128(sp)         ; stack access
    0x84000f78     0x12    sd s7,120(sp)         ; stack access
    0x84000f7a     0x14    sd s8,112(sp)         ; stack access
    0x84000f7c     0x16    sd s9,104(sp)         ; stack access
    0x84000f7e     0x18    mv s4,a0
    0x84000f80     0x1a    mv s5,a2
    0x84000f82     0x1c    mv s6,a3
    0x84000f84     0x1e    sd a4,0(sp)           ; stack access
    0x84000f86     0x20    sd a5,8(sp)           ; stack access
    0x84000f88     0x22    mv s3,a6
    0x84000f8a     0x24    li a5,1
    0x84000f8c     0x26    bgeu a5,a2,ffffffff84000f9c <init_freemem+0x36>
    0x84000f90     0x2a    addi a4,a2,-1
    0x84000f94     0x2e    li a5,0
    0x84000f96     0x30    addi a5,a5,1
    0x84000f98     0x32    bne a5,a4,ffffffff84000f96 <init_freemem+0x30>
    0x84000f9c     0x36    addi a4,s4,-1 # fff <KERNEL_OFFSET-0xfffffffefffff001>
    0x84000fa0     0x3a    beqz a4,ffffffff84000faa <init_freemem+0x44>
    0x84000fa2     0x3c    li a5,0
    0x84000fa4     0x3e    addi a5,a5,1
    0x84000fa6     0x40    bne a5,a4,ffffffff84000fa4 <init_freemem+0x3e>
    0x84000faa     0x44    auipc a5,0x0
    0x84000fae     0x48    addi a5,a5,1734 # ffffffff84001670 <ndks_boot+0x148>
    0x84000fb2     0x4c    auipc a4,0x0
    0x84000fb6     0x50    addi a4,a4,1982 # ffffffff84001770 <ndks_boot+0x248>
    0x84000fba     0x54    sd zero,0(a5)
    0x84000fbe     0x58    sd zero,8(a5)
    0x84000fc2     0x5c    addi a5,a5,16
    0x84000fc4     0x5e    bne a5,a4,ffffffff84000fba <init_freemem+0x54>
    0x84000fc8     0x62    beqz s4,ffffffff840011f6 <init_freemem+0x290>
    0x84000fcc     0x66    mv a6,a1
    0x84000fce     0x68    auipc a4,0x1
    0x84000fd2     0x6c    addi a4,a4,-2022 # ffffffff840017e8 <avail_reg+0x8>
    0x84000fd6     0x70    slli t1,s4,0x4
    0x84000fda     0x74    add t1,t1,a1
    0x84000fdc     0x76    li a7,-1
    0x84000fde     0x78    slli a7,a7,0x26
    0x84000fe0     0x7a    li a0,127
    0x84000fe4     0x7e    slli a0,a0,0x1f
    0x84000fe6     0x80    lui t4,0x80000
    0x84000fea     0x84    li t3,1
    0x84000fec     0x86    slli t3,t3,0x26
    0x84000fee     0x88    j ffffffff84001000 <init_freemem+0x9a>
    0x84000ff0     0x8a    mv a5,t4
    0x84000ff2     0x8c    j ffffffff8400101a <init_freemem+0xb4>
    0x84000ff4     0x8e    sd a5,-8(a3)
    0x84000ff8     0x92    addi a6,a6,16
    0x84000ffa     0x94    addi a4,a4,16
    0x84000ffc     0x96    beq a6,t1,ffffffff840012ae <init_freemem+0x348>
    0x84001000     0x9a    ld a1,8(a6)
    0x84001004     0x9e    add a5,a1,a7
    0x84001008     0xa2    mv a3,a4
    0x8400100a     0xa4    ld a2,0(a6)
    0x8400100e     0xa8    add a2,a2,a7
    0x84001010     0xaa    sd a2,-8(a4)
    0x84001014     0xae    sd a5,0(a4)
    0x84001016     0xb0    bltu a0,a1,ffffffff84000ff0 <init_freemem+0x8a>
    0x8400101a     0xb4    sd a5,0(a3)
    0x8400101c     0xb6    ld a5,-8(a3)
    0x84001020     0xba    add a2,a5,t3
    0x84001024     0xbe    bgeu a0,a2,ffffffff84000ff4 <init_freemem+0x8e>
    0x84001028     0xc2    mv a5,t4
    0x8400102a     0xc4    j ffffffff84000ff4 <init_freemem+0x8e>
    0x8400102c     0xc6    addi s1,s1,1
    0x8400102e     0xc8    bgeu s0,s4,ffffffff840011fa <init_freemem+0x294>
    0x84001032     0xcc    bgeu s1,s5,ffffffff8400111e <init_freemem+0x1b8>
    0x84001036     0xd0    slli s2,s1,0x4
    0x8400103a     0xd4    add s2,s2,s6
    0x8400103c     0xd6    ld a1,0(s2)
    0x84001040     0xda    ld a4,8(s2)
    0x84001044     0xde    beq a1,a4,ffffffff8400102c <init_freemem+0xc6>
    0x84001048     0xe2    slli a5,s0,0x4
    0x8400104c     0xe6    add a5,a5,s7
    0x8400104e     0xe8    ld a3,696(a5)
    0x84001052     0xec    ld a5,704(a5)
    0x84001056     0xf0    bltu a3,a5,ffffffff8400105e <init_freemem+0xf8>
    0x8400105a     0xf4    addi s0,s0,1
    0x8400105c     0xf6    j ffffffff8400102e <init_freemem+0xc8>
    0x8400105e     0xf8    bgeu a3,a4,ffffffff84001092 <init_freemem+0x12c>
    0x84001062     0xfc    bgeu a1,a5,ffffffff840010a6 <init_freemem+0x140>
    0x84001066    0x100    bltu a3,a1,ffffffff840010bc <init_freemem+0x156>
    0x8400106a    0x104    slli a3,s0,0x4
    0x8400106e    0x108    add a3,a3,s7
    0x84001070    0x10a    bgeu a5,a4,ffffffff84001076 <init_freemem+0x110>
    0x84001074    0x10e    mv a4,a5
    0x84001076    0x110    sd a4,696(a3)
    0x8400107a    0x114    ld a1,8(s2)
    0x8400107e    0x118    add a1,a1,s8
    0x84001080    0x11a    ld a0,0(s2)
    0x84001084    0x11e    add a0,a0,s8
    0x84001086    0x120    sd a0,48(sp)          ; stack access
    0x84001088    0x122    sd a1,56(sp)          ; stack access
    0x8400108a    0x124    jal ra,ffffffff84000366 <reserve_region>
    0x8400108e    0x128    addi s1,s1,1
    0x84001090    0x12a    j ffffffff8400102e <init_freemem+0xc8>
    0x84001092    0x12c    add a0,a1,s8
    0x84001096    0x130    sd a0,32(sp)          ; stack access
    0x84001098    0x132    add a1,a4,s8
    0x8400109c    0x136    sd a1,40(sp)          ; stack access
    0x8400109e    0x138    jal ra,ffffffff84000366 <reserve_region>
    0x840010a2    0x13c    addi s1,s1,1
    0x840010a4    0x13e    j ffffffff8400102e <init_freemem+0xc8>
    0x840010a6    0x140    slli a5,s0,0x4
    0x840010aa    0x144    add a5,a5,s7
    0x840010ac    0x146    ld a0,696(a5)
    0x840010b0    0x14a    ld a1,704(a5)
    0x840010b4    0x14e    jal ra,ffffffff84000532 <insert_region>
    0x840010b8    0x152    addi s0,s0,1
    0x840010ba    0x154    j ffffffff8400102e <init_freemem+0xc8>
    0x840010bc    0x156    slli s9,s0,0x4
    0x840010c0    0x15a    add s9,s9,s7
    0x840010c2    0x15c    ld a0,696(s9)
    0x840010c6    0x160    sd a0,16(sp)          ; stack access
    0x840010c8    0x162    sd a1,24(sp)          ; stack access
    0x840010ca    0x164    jal ra,ffffffff84000532 <insert_region>
    0x840010ce    0x168    ld a5,8(s2)
    0x840010d2    0x16c    ld a4,704(s9)
    0x840010d6    0x170    bltu a5,a4,ffffffff840010de <init_freemem+0x178>
    0x840010da    0x174    addi s0,s0,1
    0x840010dc    0x176    j ffffffff8400102e <init_freemem+0xc8>
    0x840010de    0x178    sd a5,696(s9)
    0x840010e2    0x17c    ld a0,0(s2)
    0x840010e6    0x180    add a0,a0,s8
    0x840010e8    0x182    sd a0,64(sp)          ; stack access
    0x840010ea    0x184    add a1,a5,s8
    0x840010ee    0x188    sd a1,72(sp)          ; stack access
    0x840010f0    0x18a    jal ra,ffffffff84000366 <reserve_region>
    0x840010f4    0x18e    addi s1,s1,1
    0x840010f6    0x190    j ffffffff8400102e <init_freemem+0xc8>
    0x840010f8    0x192    addi s1,s1,1
    0x840010fa    0x194    addi s2,s2,16
    0x840010fc    0x196    beq s5,s1,ffffffff8400111a <init_freemem+0x1b4>
    0x84001100    0x19a    ld a0,0(s2)
    0x84001104    0x19e    ld a1,8(s2)
    0x84001108    0x1a2    bgeu a0,a1,ffffffff840010f8 <init_freemem+0x192>
    0x8400110c    0x1a6    add a0,a0,s6
    0x8400110e    0x1a8    sd a0,80(sp)          ; stack access
    0x84001110    0x1aa    add a1,a1,s6
    0x84001112    0x1ac    sd a1,88(sp)          ; stack access
    0x84001114    0x1ae    jal ra,ffffffff84000366 <reserve_region>
    0x84001118    0x1b2    j ffffffff840010f8 <init_freemem+0x192>
    0x8400111a    0x1b4    bgeu s0,s4,ffffffff84001208 <init_freemem+0x2a2>
    0x8400111e    0x1b8    slli a5,s0,0x4
    0x84001122    0x1bc    auipc s1,0x0
    0x84001126    0x1c0    addi s1,s1,1726 # ffffffff840017e0 <avail_reg>
    0x8400112a    0x1c4    add s1,s1,a5
    0x8400112c    0x1c6    auipc s2,0x0
    0x84001130    0x1ca    addi s2,s2,1020 # ffffffff84001528 <ndks_boot>
    0x84001134    0x1ce    j ffffffff8400113e <init_freemem+0x1d8>
    0x84001136    0x1d0    addi s0,s0,1
    0x84001138    0x1d2    addi s1,s1,16
    0x8400113a    0x1d4    beq s4,s0,ffffffff84001208 <init_freemem+0x2a2>
    0x8400113e    0x1d8    ld a4,0(s1)
    0x84001140    0x1da    ld a5,8(s1)
    0x84001142    0x1dc    bgeu a4,a5,ffffffff84001136 <init_freemem+0x1d0>
    0x84001146    0x1e0    slli a5,s0,0x4
    0x8400114a    0x1e4    add a5,a5,s2
    0x8400114c    0x1e6    ld a0,696(a5)
    0x84001150    0x1ea    ld a1,704(a5)
    0x84001154    0x1ee    jal ra,ffffffff84000532 <insert_region>
    0x84001158    0x1f2    j ffffffff84001136 <init_freemem+0x1d0>
    0x8400115a    0x1f4    jal ra,ffffffff8401041e <halt>
    0x8400115e    0x1f8    mv s5,s1
    0x84001160    0x1fa    mv s1,s2
    0x84001162    0x1fc    mv a3,s3
    0x84001164    0x1fe    ld a1,0(sp)           ; stack access
    0x84001166    0x200    ld a2,8(sp)           ; stack access
    0x84001168    0x202    mv a0,s0
    0x8400116a    0x204    jal ra,ffffffff84000e7c <create_rootserver_objects>
    0x8400116e    0x208    li a5,15
    0x84001170    0x20a    bltu a5,s5,ffffffff84001194 <init_freemem+0x22e>
    0x84001174    0x20e    auipc a5,0x0
    0x84001178    0x212    addi a5,a5,948 # ffffffff84001528 <ndks_boot>
    0x8400117c    0x216    addi a4,s5,20 # 300014 <KERNEL_OFFSET-0xfffffffeffcfffec>
    0x84001180    0x21a    slli a4,a4,0x4
    0x84001182    0x21c    add a4,a4,a5
    0x84001184    0x21e    ld a4,16(a4)
    0x84001186    0x220    addi s1,s1,20
    0x84001188    0x222    slli s1,s1,0x4
    0x8400118a    0x224    add a5,a5,s1
    0x8400118c    0x226    sd a4,16(a5)
    0x8400118e    0x228    add s4,s4,s0
    0x84001190    0x22a    sd s4,8(a5)
    0x84001194    0x22e    addi s5,s5,20
    0x84001196    0x230    slli s5,s5,0x4
    0x84001198    0x232    auipc a5,0x0
    0x8400119c    0x236    addi a5,a5,912 # ffffffff84001528 <ndks_boot>
    0x840011a0    0x23a    add s5,s5,a5
    0x840011a2    0x23c    sd s0,16(s5)
    0x840011a6    0x240    ld ra,184(sp)         ; stack access
    0x840011a8    0x242    ld s0,176(sp)         ; stack access
    0x840011aa    0x244    ld s1,168(sp)         ; stack access
    0x840011ac    0x246    ld s2,160(sp)         ; stack access
    0x840011ae    0x248    ld s3,152(sp)         ; stack access
    0x840011b0    0x24a    ld s4,144(sp)         ; stack access
    0x840011b2    0x24c    ld s5,136(sp)         ; stack access
    0x840011b4    0x24e    ld s6,128(sp)         ; stack access
    0x840011b6    0x250    ld s7,120(sp)         ; stack access
    0x840011b8    0x252    ld s8,112(sp)         ; stack access
    0x840011ba    0x254    ld s9,104(sp)         ; stack access
    0x840011bc    0x256    addi sp,sp,192
    0x840011be    0x258    ret
    0x840011c0    0x25a    addi s5,s1,-1
    0x840011c4    0x25e    ld s0,8(a5)
    0x840011c6    0x260    sub s0,s0,s4
    0x840011ca    0x264    srl s0,s0,a4
    0x840011ce    0x268    sll s0,s0,a4
    0x840011d2    0x26c    addi a5,a5,-16
    0x840011d4    0x26e    mv s2,s1
    0x840011d6    0x270    ld a3,16(a5)
    0x840011d8    0x272    bgeu s0,a3,ffffffff84001162 <init_freemem+0x1fc>
    0x840011dc    0x276    mv s1,s5
    0x840011de    0x278    bltu a2,s1,ffffffff840011c0 <init_freemem+0x25a>
    0x840011e2    0x27c    addi s2,s2,20
    0x840011e4    0x27e    slli s2,s2,0x4
    0x840011e6    0x280    add s2,s2,a1
    0x840011e8    0x282    ld a3,16(a5)
    0x840011ea    0x284    sd a3,8(s2)
    0x840011ee    0x288    ld a3,24(a5)
    0x840011f0    0x28a    sd a3,16(s2)
    0x840011f4    0x28e    j ffffffff840011c0 <init_freemem+0x25a>
    0x840011f6    0x290    mv s0,s4
    0x840011f8    0x292    mv s1,s4
    0x840011fa    0x294    slli s2,s1,0x4
    0x840011fe    0x298    add s2,s2,s6
    0x84001200    0x29a    li s6,1
    0x84001202    0x29c    slli s6,s6,0x26
    0x84001204    0x29e    bltu s1,s5,ffffffff84001100 <init_freemem+0x19a>
    0x84001208    0x2a2    auipc a5,0x0
    0x8400120c    0x2a6    addi a5,a5,800 # ffffffff84001528 <ndks_boot>
    0x84001210    0x2aa    ld a3,568(a5)
    0x84001214    0x2ae    ld a4,576(a5)
    0x84001218    0x2b2    auipc a5,0x0
    0x8400121c    0x2b6    addi a5,a5,1336 # ffffffff84001750 <ndks_boot+0x228>
    0x84001220    0x2ba    li s1,15
    0x84001222    0x2bc    bne a3,a4,ffffffff8400115a <init_freemem+0x1f4>
    0x84001226    0x2c0    mv s2,s1
    0x84001228    0x2c2    addi s1,s1,-1
    0x8400122a    0x2c4    ld a3,0(a5)
    0x8400122c    0x2c6    addi a5,a5,-16
    0x8400122e    0x2c8    ld a4,24(a5)
    0x84001230    0x2ca    beq a3,a4,ffffffff84001226 <init_freemem+0x2c0>
    0x84001234    0x2ce    ld a5,0(sp)           ; stack access
    0x84001236    0x2d0    sd a5,16(sp)          ; stack access
    0x84001238    0x2d2    ld a5,8(sp)           ; stack access
    0x8400123a    0x2d4    sd a5,24(sp)          ; stack access
    0x8400123c    0x2d6    mv s0,s3
    0x8400123e    0x2d8    beqz s3,ffffffff84001248 <init_freemem+0x2e2>
    0x84001242    0x2dc    li s0,1
    0x84001244    0x2de    sll s0,s0,s3
    0x84001248    0x2e2    ld a0,16(sp)          ; stack access
    0x8400124a    0x2e4    ld a1,24(sp)          ; stack access
    0x8400124c    0x2e6    jal ra,ffffffff84000108 <arch_get_n_paging>
    0x84001250    0x2ea    lui s4,0x1004
    0x84001254    0x2ee    addi s4,s4,1024 # 1004400 <KERNEL_OFFSET-0xfffffffefeffbc00>
    0x84001258    0x2f2    add s0,s0,s4
    0x8400125a    0x2f4    slli s4,a0,0xc
    0x8400125e    0x2f8    add s4,s4,s0
    0x84001260    0x2fa    mv a3,s3
    0x84001262    0x2fc    li a5,24
    0x84001264    0x2fe    bgeu s3,a5,ffffffff8400126a <init_freemem+0x304>
    0x84001268    0x302    li a3,24
    0x8400126a    0x304    sext.w a4,a3
    0x8400126e    0x308    addi a5,s1,20
    0x84001272    0x30c    slli a2,a5,0x4
    0x84001276    0x310    auipc a5,0x0
    0x8400127a    0x314    addi a5,a5,690 # ffffffff84001528 <ndks_boot>
    0x8400127e    0x318    add a5,a5,a2
    0x84001280    0x31a    ld s0,16(a5)
    0x84001282    0x31c    sub s0,s0,s4
    0x84001286    0x320    srl s0,s0,a3
    0x8400128a    0x324    sll s0,s0,a3
    0x8400128e    0x328    ld a5,8(a5)
    0x84001290    0x32a    bgeu s0,a5,ffffffff8400115e <init_freemem+0x1f8>
    0x84001294    0x32e    slli a5,s1,0x4
    0x84001298    0x332    auipc a3,0x0
    0x8400129c    0x336    addi a3,a3,968 # ffffffff84001660 <ndks_boot+0x138>
    0x840012a0    0x33a    add a5,a5,a3
    0x840012a2    0x33c    li a2,15
    0x840012a4    0x33e    auipc a1,0x0
    0x840012a8    0x342    addi a1,a1,644 # ffffffff84001528 <ndks_boot>
    0x840012ac    0x346    j ffffffff840011de <init_freemem+0x278>
    0x840012ae    0x348    li s1,0
    0x840012b0    0x34a    li s0,0
    0x840012b2    0x34c    auipc s7,0x0
    0x840012b6    0x350    addi s7,s7,630 # ffffffff84001528 <ndks_boot>
    0x840012ba    0x354    li s8,1
    0x840012bc    0x356    slli s8,s8,0x26
    0x840012be    0x358    bnez s5,ffffffff84001036 <init_freemem+0xd0>
    0x840012c2    0x35c    mv s0,s5
    0x840012c4    0x35e    j ffffffff8400111e <init_freemem+0x1b8>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
299 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `init_freemem` has 463 nodes.

Section create_initial_thread (255 of 271)
==========================================

Deriving specifications
-----------------------

Section `create_initial_thread` consists of 107 instructions.


Stack analysis
---------------

35 stack accesses found. Annotated code for `create_initial_thread`:

    0x84000b9e      0x0    addi sp,sp,-144
    0x84000ba0      0x2    sd ra,120(sp)         ; stack access
    0x84000ba2      0x4    sd s0,112(sp)         ; stack access
    0x84000ba4      0x6    sd s1,104(sp)         ; stack access
    0x84000ba6      0x8    sd s2,96(sp)          ; stack access
    0x84000ba8      0xa    sd s3,88(sp)          ; stack access
    0x84000baa      0xc    sd s4,80(sp)          ; stack access
    0x84000bac      0xe    sd s5,72(sp)          ; stack access
    0x84000bae     0x10    sd a0,16(sp)          ; stack access
    0x84000bb0     0x12    sd a1,24(sp)          ; stack access
    0x84000bb2     0x14    sd a2,0(sp)           ; stack access
    0x84000bb4     0x16    sd a3,8(sp)           ; stack access
    0x84000bb6     0x18    mv s2,a4
    0x84000bb8     0x1a    mv s3,a5
    0x84000bba     0x1c    mv s4,a6
    0x84000bbc     0x1e    mv s1,a7
    0x84000bbe     0x20    sd a7,136(sp)         ; stack access
    0x84000bc0     0x22    auipc s0,0x1
    0x84000bc4     0x26    ld s0,-1032(s0) # ffffffff840017b8 <rootserver+0x30>
    0x84000bc8     0x2a    addi s0,s0,512
    0x84000bcc     0x2e    li a5,5
    0x84000bce     0x30    sd a5,368(s0)
    0x84000bd2     0x34    li a5,32
    0x84000bd6     0x38    sd a5,256(s0)
    0x84000bda     0x3c    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x84000bde     0x40    mv a2,s1
    0x84000be0     0x42    ld a3,144(sp)         ; stack access
    0x84000be2     0x44    addi a1,a0,320
    0x84000be6     0x48    addi a0,sp,40
    0x84000be8     0x4a    jal ra,ffffffff840120ec <deriveCap>
    0x84000bec     0x4e    ld a5,40(sp)          ; stack access
    0x84000bee     0x50    li s5,0
    0x84000bf0     0x52    bnez a5,ffffffff84000cbc <create_initial_thread+0x11e>
    0x84000bf2     0x54    mv s5,s0
    0x84000bf4     0x56    ld a0,16(sp)          ; stack access
    0x84000bf6     0x58    ld a1,24(sp)          ; stack access
    0x84000bf8     0x5a    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x84000bfc     0x5e    auipc s1,0x1
    0x84000c00     0x62    addi s1,s1,-1748 # ffffffff84001528 <ndks_boot>
    0x84000c04     0x66    ld a3,656(s1)
    0x84000c08     0x6a    addi a2,a0,64
    0x84000c0c     0x6e    ld a0,16(sp)          ; stack access
    0x84000c0e     0x70    ld a1,24(sp)          ; stack access
    0x84000c10     0x72    jal ra,ffffffff840116ba <cteInsert>
    0x84000c14     0x76    ld a0,16(sp)          ; stack access
    0x84000c16     0x78    ld a1,24(sp)          ; stack access
    0x84000c18     0x7a    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x84000c1c     0x7e    ld a3,656(s1)
    0x84000c20     0x82    addi a3,a3,32
    0x84000c24     0x86    addi a2,a0,96
    0x84000c28     0x8a    ld a0,0(sp)           ; stack access
    0x84000c2a     0x8c    ld a1,8(sp)           ; stack access
    0x84000c2c     0x8e    jal ra,ffffffff840116ba <cteInsert>
    0x84000c30     0x92    ld a0,16(sp)          ; stack access
    0x84000c32     0x94    ld a1,24(sp)          ; stack access
    0x84000c34     0x96    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x84000c38     0x9a    ld a3,656(s1)
    0x84000c3c     0x9e    addi a3,a3,128
    0x84000c40     0xa2    addi a2,a0,320
    0x84000c44     0xa6    ld a0,48(sp)          ; stack access
    0x84000c46     0xa8    ld a1,56(sp)          ; stack access
    0x84000c48     0xaa    jal ra,ffffffff840116ba <cteInsert>
    0x84000c4c     0xae    sd s4,384(s0)
    0x84000c50     0xb2    sd s3,72(s0)
    0x84000c54     0xb6    sd s2,272(s0)
    0x84000c58     0xba    li a5,255
    0x84000c5c     0xbe    sd a5,360(s0)
    0x84000c60     0xc2    sd a5,352(s0)
    0x84000c64     0xc6    mv a0,s0
    0x84000c66     0xc8    jal ra,ffffffff840119f2 <setupReplyMaster>
    0x84000c6a     0xcc    li a1,1
    0x84000c6c     0xce    mv a0,s0
    0x84000c6e     0xd0    jal ra,ffffffff8401263a <setThreadState>
    0x84000c72     0xd4    auipc a5,0x2a
    0x84000c76     0xd8    ld a5,-1130(a5) # ffffffff8402a808 <ksDomScheduleIdx>
    0x84000c7a     0xdc    slli a4,a5,0x4
    0x84000c7e     0xe0    auipc a5,0x17
    0x84000c82     0xe4    addi a5,a5,-1830 # ffffffff84017558 <msgRegisters>
    0x84000c86     0xe8    add a5,a5,a4
    0x84000c88     0xea    ld a4,192(a5)
    0x84000c8a     0xec    auipc a3,0x2a
    0x84000c8e     0xf0    sd a4,-1138(a3) # ffffffff8402a818 <ksCurDomain>
    0x84000c92     0xf4    ld a5,200(a5)
    0x84000c94     0xf6    auipc a4,0x2a
    0x84000c98     0xfa    sd a5,-1156(a4) # ffffffff8402a810 <ksDomainTime>
    0x84000c9c     0xfe    ld a0,16(sp)          ; stack access
    0x84000c9e    0x100    ld a1,24(sp)          ; stack access
    0x84000ca0    0x102    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x84000ca4    0x106    slli s0,s0,0x19
    0x84000ca6    0x108    srli s0,s0,0x19
    0x84000ca8    0x10a    li a5,3
    0x84000caa    0x10c    slli a4,a5,0x3d
    0x84000cae    0x110    or s0,s0,a4
    0x84000cb0    0x112    sd s0,32(a0)
    0x84000cb2    0x114    sd zero,40(a0)
    0x84000cb6    0x118    sd zero,48(a0)
    0x84000cba    0x11c    sd a5,56(a0)
    0x84000cbc    0x11e    mv a0,s5
    0x84000cbe    0x120    ld ra,120(sp)         ; stack access
    0x84000cc0    0x122    ld s0,112(sp)         ; stack access
    0x84000cc2    0x124    ld s1,104(sp)         ; stack access
    0x84000cc4    0x126    ld s2,96(sp)          ; stack access
    0x84000cc6    0x128    ld s3,88(sp)          ; stack access
    0x84000cc8    0x12a    ld s4,80(sp)          ; stack access
    0x84000cca    0x12c    ld s5,72(sp)          ; stack access
    0x84000ccc    0x12e    addi sp,sp,144
    0x84000cce    0x130    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
107 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_initial_thread` has 176 nodes.

Section sendIPC (256 of 271)
============================

Deriving specifications
-----------------------

Section `sendIPC` consists of 141 instructions.


Stack analysis
---------------

18 stack accesses found. Annotated code for `sendIPC`:

    0x840142b4      0x0    addi sp,sp,-80
    0x840142b6      0x2    sd ra,72(sp)          ; stack access
    0x840142b8      0x4    sd s0,64(sp)          ; stack access
    0x840142ba      0x6    sd s1,56(sp)          ; stack access
    0x840142bc      0x8    sd s2,48(sp)          ; stack access
    0x840142be      0xa    sd s3,40(sp)          ; stack access
    0x840142c0      0xc    sd s4,32(sp)          ; stack access
    0x840142c2      0xe    sd s5,24(sp)          ; stack access
    0x840142c4     0x10    sd s6,16(sp)          ; stack access
    0x840142c6     0x12    mv s3,a1
    0x840142c8     0x14    mv s5,a2
    0x840142ca     0x16    mv s2,a3
    0x840142cc     0x18    mv s4,a4
    0x840142ce     0x1a    mv s1,a5
    0x840142d0     0x1c    mv s0,a6
    0x840142d2     0x1e    ld a6,0(a6)
    0x840142d6     0x22    andi a5,a6,2
    0x840142da     0x26    beqz a5,ffffffff8401436a <sendIPC+0xb6>
    0x840142dc     0x28    andi a4,a6,3
    0x840142e0     0x2c    li a5,2
    0x840142e2     0x2e    bne a4,a5,ffffffff8401436c <sendIPC+0xb8>
    0x840142e6     0x32    ld s6,8(s0)
    0x840142ea     0x36    lui a2,0xf8000
    0x840142ee     0x3a    srli a2,a2,0x19
    0x840142f0     0x3c    and a2,a6,a2
    0x840142f4     0x40    srli a6,a6,0x26
    0x840142f8     0x44    andi a6,a6,1
    0x840142fc     0x48    beqz a6,ffffffff84014306 <sendIPC+0x52>
    0x84014300     0x4c    li a5,-1
    0x84014302     0x4e    slli a5,a5,0x27
    0x84014304     0x50    or a2,a2,a5
    0x84014306     0x52    mv a1,s6
    0x84014308     0x54    mv a0,s6
    0x8401430a     0x56    jal ra,ffffffff84012ec2 <tcbEPDequeue>
    0x8401430e     0x5a    sd a0,0(sp)           ; stack access
    0x84014310     0x5c    sd a1,8(sp)           ; stack access
    0x84014312     0x5e    sd a0,8(s0)
    0x84014314     0x60    ld a5,0(s0)
    0x84014316     0x62    li a4,-1
    0x84014318     0x64    slli a4,a4,0x27
    0x8401431a     0x66    addi a4,a4,3
    0x8401431c     0x68    and a5,a5,a4
    0x8401431e     0x6a    lui a4,0xf8000
    0x84014322     0x6e    srli a4,a4,0x19
    0x84014324     0x70    and a1,a1,a4
    0x84014326     0x72    or a1,a1,a5
    0x84014328     0x74    beqz a0,ffffffff8401441a <sendIPC+0x166>
    0x8401432c     0x78    sd a1,0(s0)
    0x8401432e     0x7a    mv a4,s6
    0x84014330     0x7c    mv a3,s2
    0x84014332     0x7e    mv a2,s5
    0x84014334     0x80    mv a1,s0
    0x84014336     0x82    mv a0,s1
    0x84014338     0x84    jal ra,ffffffff8401417e <doIPCTransfer>
    0x8401433c     0x88    ld s0,288(s6)
    0x84014340     0x8c    li a1,1
    0x84014342     0x8e    mv a0,s6
    0x84014344     0x90    jal ra,ffffffff8401263a <setThreadState>
    0x84014348     0x94    mv a0,s6
    0x8401434a     0x96    jal ra,ffffffff84012934 <possibleSwitchTo>
    0x8401434e     0x9a    beqz s3,ffffffff8401436c <sendIPC+0xb8>
    0x84014352     0x9e    or s2,s2,s4
    0x84014356     0xa2    beqz s2,ffffffff84014420 <sendIPC+0x16c>
    0x8401435a     0xa6    srli a2,s0,0x3
    0x8401435e     0xaa    andi a2,a2,1
    0x84014360     0xac    mv a1,s6
    0x84014362     0xae    mv a0,s1
    0x84014364     0xb0    jal ra,ffffffff84013ea2 <setupCallerCap>
    0x84014368     0xb4    j ffffffff8401436c <sendIPC+0xb8>
    0x8401436a     0xb6    bnez a0,ffffffff84014380 <sendIPC+0xcc>
    0x8401436c     0xb8    ld ra,72(sp)          ; stack access
    0x8401436e     0xba    ld s0,64(sp)          ; stack access
    0x84014370     0xbc    ld s1,56(sp)          ; stack access
    0x84014372     0xbe    ld s2,48(sp)          ; stack access
    0x84014374     0xc0    ld s3,40(sp)          ; stack access
    0x84014376     0xc2    ld s4,32(sp)          ; stack access
    0x84014378     0xc4    ld s5,24(sp)          ; stack access
    0x8401437a     0xc6    ld s6,16(sp)          ; stack access
    0x8401437c     0xc8    addi sp,sp,80
    0x8401437e     0xca    ret
    0x84014380     0xcc    ld a5,280(s1)
    0x84014384     0xd0    srli a5,a5,0x27
    0x84014386     0xd2    slli a5,a5,0x27
    0x84014388     0xd4    lui a4,0xe0000
    0x8401438c     0xd8    srli a4,a4,0x19
    0x8401438e     0xda    and a4,a4,s0
    0x84014390     0xdc    or a5,a5,a4
    0x84014392     0xde    ori a5,a5,4
    0x84014396     0xe2    sd a5,280(s1)
    0x8401439a     0xe6    sd a2,296(s1)
    0x8401439e     0xea    ld a5,288(s1)
    0x840143a2     0xee    slli s2,a3,0x3
    0x840143a6     0xf2    andi s2,s2,8
    0x840143aa     0xf6    andi a5,a5,-13
    0x840143ac     0xf8    or a5,a5,s2
    0x840143b0     0xfc    slli s4,s4,0x2
    0x840143b2     0xfe    andi s4,s4,4
    0x840143b6    0x102    or a5,a5,s4
    0x840143ba    0x106    andi a5,a5,-3
    0x840143bc    0x108    slli s3,a1,0x1
    0x840143c0    0x10c    andi s3,s3,2
    0x840143c4    0x110    or s3,a5,s3
    0x840143c8    0x114    sd s3,288(s1)
    0x840143cc    0x118    mv a0,s1
    0x840143ce    0x11a    jal ra,ffffffff84012606 <scheduleTCB>
    0x840143d2    0x11e    ld a2,8(s0)
    0x840143d4    0x120    ld a4,0(s0)
    0x840143d6    0x122    lui a5,0xf8000
    0x840143da    0x126    srli a5,a5,0x19
    0x840143dc    0x128    and a5,a5,a4
    0x840143de    0x12a    srli a4,a4,0x26
    0x840143e0    0x12c    andi a4,a4,1
    0x840143e2    0x12e    beqz a4,ffffffff840143ea <sendIPC+0x136>
    0x840143e4    0x130    li a4,-1
    0x840143e6    0x132    slli a4,a4,0x27
    0x840143e8    0x134    or a5,a5,a4
    0x840143ea    0x136    mv a4,a5
    0x840143ec    0x138    mv a3,s1
    0x840143ee    0x13a    beqz a2,ffffffff840143f6 <sendIPC+0x142>
    0x840143f0    0x13c    mv a3,a2
    0x840143f2    0x13e    sd s1,408(a5) # fffffffff8000198 <ki_end+0x73fd1198>
    0x840143f6    0x142    sd a4,416(s1)
    0x840143fa    0x146    sd zero,408(s1)
    0x840143fe    0x14a    ld a4,0(s0)
    0x84014400    0x14c    sd a3,8(s0)
    0x84014402    0x14e    lui a5,0xf8000
    0x84014406    0x152    srli a5,a5,0x19
    0x84014408    0x154    and s1,s1,a5
    0x8401440a    0x156    srli a5,a4,0x27
    0x8401440e    0x15a    slli a5,a5,0x27
    0x84014410    0x15c    or s1,s1,a5
    0x84014412    0x15e    ori s1,s1,1
    0x84014416    0x162    sd s1,0(s0)
    0x84014418    0x164    j ffffffff8401436c <sendIPC+0xb8>
    0x8401441a    0x166    andi a1,a1,-4
    0x8401441c    0x168    sd a1,0(s0)
    0x8401441e    0x16a    j ffffffff8401432e <sendIPC+0x7a>
    0x84014420    0x16c    li a1,0
    0x84014422    0x16e    mv a0,s1
    0x84014424    0x170    jal ra,ffffffff8401263a <setThreadState>
    0x84014428    0x174    j ffffffff8401436c <sendIPC+0xb8>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
141 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sendIPC` has 205 nodes.

Section cteDelete (257 of 271)
==============================

Deriving specifications
-----------------------

Section `cteDelete` consists of 162 instructions.


Stack analysis
---------------

34 stack accesses found. Annotated code for `cteDelete`:

    0x8401333c      0x0    addi sp,sp,-160
    0x8401333e      0x2    sd ra,152(sp)         ; stack access
    0x84013340      0x4    sd s0,144(sp)         ; stack access
    0x84013342      0x6    sd s1,136(sp)         ; stack access
    0x84013344      0x8    sd s2,128(sp)         ; stack access
    0x84013346      0xa    sd s3,120(sp)         ; stack access
    0x84013348      0xc    sd s4,112(sp)         ; stack access
    0x8401334a      0xe    sd s5,104(sp)         ; stack access
    0x8401334c     0x10    sd s6,96(sp)          ; stack access
    0x8401334e     0x12    sd s7,88(sp)          ; stack access
    0x84013350     0x14    sd s8,80(sp)          ; stack access
    0x84013352     0x16    sd s9,72(sp)          ; stack access
    0x84013354     0x18    mv s0,a0
    0x84013356     0x1a    mv s4,a1
    0x84013358     0x1c    li s2,18
    0x8401335a     0x1e    li s3,64
    0x8401335e     0x22    li s6,4
    0x84013360     0x24    li s5,-1
    0x84013362     0x26    li s1,1
    0x84013364     0x28    j ffffffff840133a4 <cteDelete+0x68>
    0x84013366     0x2a    mv a2,s6
    0x84013368     0x2c    j ffffffff840133dc <cteDelete+0xa0>
    0x8401336a     0x2e    bnez a1,ffffffff8401340a <cteDelete+0xce>
    0x8401336c     0x30    ld a3,0(sp)           ; stack access
    0x8401336e     0x32    sd a3,0(s0)
    0x84013370     0x34    ld a3,8(sp)           ; stack access
    0x84013372     0x36    sd a3,8(s0)
    0x84013374     0x38    bnez s4,ffffffff84013470 <cteDelete+0x134>
    0x84013378     0x3c    beq a4,s2,ffffffff84013410 <cteDelete+0xd4>
    0x8401337c     0x40    ld a5,0(s0)
    0x8401337e     0x42    ld a4,8(s0)
    0x84013380     0x44    andi a3,a5,127
    0x84013384     0x48    beq a3,s3,ffffffff840134f6 <cteDelete+0x1ba>
    0x84013388     0x4c    andi a0,a5,63
    0x8401338c     0x50    addiw a0,a0,1
    0x8401338e     0x52    sll a0,s1,a0
    0x84013392     0x56    neg a0,a0
    0x84013396     0x5a    and a0,a0,a4
    0x84013398     0x5c    mv a1,s0
    0x8401339a     0x5e    jal ra,ffffffff84011976 <capSwapForDelete>
    0x8401339e     0x62    jal ra,ffffffff84011684 <preemptionPoint>
    0x840133a2     0x66    bnez a0,ffffffff8401344c <cteDelete+0x110>
    0x840133a4     0x68    ld a5,0(s0)
    0x840133a6     0x6a    srli a5,a5,0x3b
    0x840133a8     0x6c    beqz a5,ffffffff8401343c <cteDelete+0x100>
    0x840133aa     0x6e    mv a0,s0
    0x840133ac     0x70    jal ra,ffffffff840121be <isFinalCapability>
    0x840133b0     0x74    mv a3,a0
    0x840133b2     0x76    li a4,0
    0x840133b4     0x78    ld a1,0(s0)
    0x840133b6     0x7a    ld a2,8(s0)
    0x840133b8     0x7c    mv a0,sp
    0x840133ba     0x7e    jal ra,ffffffff8401317c <finaliseCap>
    0x840133be     0x82    ld a7,16(sp)          ; stack access
    0x840133c0     0x84    ld a6,24(sp)          ; stack access
    0x840133c2     0x86    ld a5,0(sp)           ; stack access
    0x840133c4     0x88    ld a0,8(sp)           ; stack access
    0x840133c6     0x8a    srli a4,a5,0x3b
    0x840133ca     0x8e    beqz a4,ffffffff8401340a <cteDelete+0xce>
    0x840133cc     0x90    bne a4,s2,ffffffff84013406 <cteDelete+0xca>
    0x840133d0     0x94    andi a3,a5,127
    0x840133d4     0x98    beq a3,s3,ffffffff84013366 <cteDelete+0x2a>
    0x840133d8     0x9c    andi a2,a5,63
    0x840133dc     0xa0    addi a2,a2,1
    0x840133de     0xa2    sll a3,s5,a2
    0x840133e2     0xa6    not a3,a3
    0x840133e6     0xaa    and a3,a3,a0
    0x840133e8     0xac    mv a1,s1
    0x840133ea     0xae    beqz a3,ffffffff8401336a <cteDelete+0x2e>
    0x840133ec     0xb0    li a1,0
    0x840133ee     0xb2    bne a3,s1,ffffffff8401336a <cteDelete+0x2e>
    0x840133f2     0xb6    sll a3,s1,a2
    0x840133f6     0xba    neg a3,a3
    0x840133fa     0xbe    and a3,a3,a0
    0x840133fc     0xc0    sub a3,s0,a3
    0x84013400     0xc4    seqz a1,a3
    0x84013404     0xc8    j ffffffff8401336a <cteDelete+0x2e>
    0x84013406     0xca    jal ra,ffffffff8401041e <halt>
    0x8401340a     0xce    sd a7,48(sp)          ; stack access
    0x8401340c     0xd0    sd a6,56(sp)          ; stack access
    0x8401340e     0xd2    j ffffffff84013440 <cteDelete+0x104>
    0x84013410     0xd4    andi a4,a5,127
    0x84013414     0xd8    beq a4,s3,ffffffff84013430 <cteDelete+0xf4>
    0x84013418     0xdc    andi a5,a5,63
    0x8401341c     0xe0    addiw a5,a5,1
    0x8401341e     0xe2    sll a5,s1,a5
    0x84013422     0xe6    neg a5,a5
    0x84013426     0xea    and a5,a5,a0
    0x84013428     0xec    bne s0,a5,ffffffff8401337c <cteDelete+0x40>
    0x8401342c     0xf0    mv a0,s4
    0x8401342e     0xf2    j ffffffff8401344c <cteDelete+0x110>
    0x84013430     0xf4    mv a5,s6
    0x84013432     0xf6    j ffffffff8401341c <cteDelete+0xe0>
    0x84013434     0xf8    mv a5,s6
    0x84013436     0xfa    j ffffffff840134c8 <cteDelete+0x18c>
    0x84013438     0xfc    jal ra,ffffffff8401041e <halt>
    0x8401343c    0x100    sd zero,48(sp)        ; stack access
    0x8401343e    0x102    sd zero,56(sp)        ; stack access
    0x84013440    0x104    ld a1,48(sp)          ; stack access
    0x84013442    0x106    ld a2,56(sp)          ; stack access
    0x84013444    0x108    mv a0,s0
    0x84013446    0x10a    jal ra,ffffffff84011b74 <emptySlot>
    0x8401344a    0x10e    li a0,0
    0x8401344c    0x110    ld ra,152(sp)         ; stack access
    0x8401344e    0x112    ld s0,144(sp)         ; stack access
    0x84013450    0x114    ld s1,136(sp)         ; stack access
    0x84013452    0x116    ld s2,128(sp)         ; stack access
    0x84013454    0x118    ld s3,120(sp)         ; stack access
    0x84013456    0x11a    ld s4,112(sp)         ; stack access
    0x84013458    0x11c    ld s5,104(sp)         ; stack access
    0x8401345a    0x11e    ld s6,96(sp)          ; stack access
    0x8401345c    0x120    ld s7,88(sp)          ; stack access
    0x8401345e    0x122    ld s8,80(sp)          ; stack access
    0x84013460    0x124    ld s9,72(sp)          ; stack access
    0x84013462    0x126    addi sp,sp,160
    0x84013464    0x128    ret
    0x84013466    0x12a    andi s8,s9,-32
    0x8401346a    0x12e    andi s9,s9,31
    0x8401346e    0x132    j ffffffff8401349c <cteDelete+0x160>
    0x84013470    0x134    ld a5,0(s0)
    0x84013472    0x136    ld s9,8(s0)
    0x84013476    0x13a    andi s7,a5,127
    0x8401347a    0x13e    beq s7,s3,ffffffff84013466 <cteDelete+0x12a>
    0x8401347e    0x142    andi a5,a5,63
    0x84013482    0x146    addi a5,a5,1
    0x84013484    0x148    sll s8,s1,a5
    0x84013488    0x14c    neg s8,s8
    0x8401348c    0x150    and s8,s8,s9
    0x84013490    0x154    sll a5,s5,a5
    0x84013494    0x158    not a5,a5
    0x84013498    0x15c    and s9,a5,s9
    0x8401349c    0x160    slli a0,s9,0x5
    0x840134a0    0x164    addi a0,a0,-32
    0x840134a2    0x166    li a1,0
    0x840134a4    0x168    add a0,a0,s8
    0x840134a6    0x16a    jal ra,ffffffff8401333c <cteDelete>
    0x840134aa    0x16e    bnez a0,ffffffff8401344c <cteDelete+0x110>
    0x840134ac    0x170    ld a5,0(s0)
    0x840134ae    0x172    srli a4,a5,0x3b
    0x840134b2    0x176    beqz a4,ffffffff8401339e <cteDelete+0x62>
    0x840134b6    0x17a    bne a4,s2,ffffffff84013438 <cteDelete+0xfc>
    0x840134ba    0x17e    ld a3,8(s0)
    0x840134bc    0x180    andi a2,a5,127
    0x840134c0    0x184    beq a2,s3,ffffffff84013434 <cteDelete+0xf8>
    0x840134c4    0x188    andi a5,a5,63
    0x840134c8    0x18c    addi a5,a5,1
    0x840134ca    0x18e    sll a4,s1,a5
    0x840134ce    0x192    neg a4,a4
    0x840134d2    0x196    and a4,a4,a3
    0x840134d4    0x198    bne s8,a4,ffffffff8401339e <cteDelete+0x62>
    0x840134d8    0x19c    sll a5,s5,a5
    0x840134dc    0x1a0    not a5,a5
    0x840134e0    0x1a4    and a3,a3,a5
    0x840134e2    0x1a6    bne a3,s9,ffffffff8401339e <cteDelete+0x62>
    0x840134e6    0x1aa    bne a2,s7,ffffffff8401339e <cteDelete+0x62>
    0x840134ea    0x1ae    addi s9,s9,-1
    0x840134ec    0x1b0    and a5,s9,a5
    0x840134f0    0x1b4    or a4,a4,a5
    0x840134f2    0x1b6    sd a4,8(s0)
    0x840134f4    0x1b8    j ffffffff8401339e <cteDelete+0x62>
    0x840134f6    0x1ba    andi a0,a4,-32
    0x840134fa    0x1be    j ffffffff84013398 <cteDelete+0x5c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
162 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteDelete` has 258 nodes.

Section Arch_decodeIRQControlInvocation (258 of 271)
====================================================

Deriving specifications
-----------------------

Section `Arch_decodeIRQControlInvocation` consists of 83 instructions.


Stack analysis
---------------

17 stack accesses found. Annotated code for `Arch_decodeIRQControlInvocation`:

    0x84012656     0x0    li a5,37
    0x8401265a     0x4    bne a0,a5,ffffffff84012726 <Arch_decodeIRQControlInvocation+0xd0>
    0x8401265e     0x8    addi sp,sp,-80
    0x84012660     0xa    sd ra,72(sp)          ; stack access
    0x84012662     0xc    sd s0,64(sp)          ; stack access
    0x84012664     0xe    sd s1,56(sp)          ; stack access
    0x84012666    0x10    sd s2,48(sp)          ; stack access
    0x84012668    0x12    sd s3,40(sp)          ; stack access
    0x8401266a    0x14    sd s4,32(sp)          ; stack access
    0x8401266c    0x16    mv s1,a2
    0x8401266e    0x18    mv s0,a3
    0x84012670    0x1a    li a5,3
    0x84012672    0x1c    bgeu a5,a1,ffffffff840126d6 <Arch_decodeIRQControlInvocation+0x80>
    0x84012676    0x20    auipc s2,0x6
    0x8401267a    0x24    ld s2,538(s2) # ffffffff84018890 <current_extra_caps>
    0x8401267e    0x28    beqz s2,ffffffff840126d6 <Arch_decodeIRQControlInvocation+0x80>
    0x84012682    0x2c    mv a1,a3
    0x84012684    0x2e    li a0,0
    0x84012686    0x30    jal ra,ffffffff840100ea <getSyscallArg>
    0x8401268a    0x34    mv s3,a0
    0x8401268c    0x36    mv a1,s0
    0x8401268e    0x38    li a0,2
    0x84012690    0x3a    jal ra,ffffffff840100ea <getSyscallArg>
    0x84012694    0x3e    mv s4,a0
    0x84012696    0x40    mv a1,s0
    0x84012698    0x42    li a0,3
    0x8401269a    0x44    jal ra,ffffffff840100ea <getSyscallArg>
    0x8401269e    0x48    mv s0,a0
    0x840126a0    0x4a    ld a5,0(s2)
    0x840126a4    0x4e    sd a5,0(sp)           ; stack access
    0x840126a6    0x50    ld a5,8(s2)
    0x840126aa    0x54    sd a5,8(sp)           ; stack access
    0x840126ac    0x56    mv a0,s3
    0x840126ae    0x58    jal ra,ffffffff84010e70 <Arch_checkIRQ>
    0x840126b2    0x5c    bnez a0,ffffffff840126e2 <Arch_decodeIRQControlInvocation+0x8c>
    0x840126b4    0x5e    slli a4,s3,0x3
    0x840126b8    0x62    auipc a5,0x6
    0x840126bc    0x66    addi a5,a5,-1720 # ffffffff84018000 <riscvKSASIDTable>
    0x840126c0    0x6a    add a5,a5,a4
    0x840126c2    0x6c    ld a5,1752(a5)
    0x840126c6    0x70    beqz a5,ffffffff840126f2 <Arch_decodeIRQControlInvocation+0x9c>
    0x840126c8    0x72    li a5,9
    0x840126ca    0x74    auipc a4,0x6
    0x840126ce    0x78    sd a5,6(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840126d2    0x7c    li a0,3
    0x840126d4    0x7e    j ffffffff840126e2 <Arch_decodeIRQControlInvocation+0x8c>
    0x840126d6    0x80    li a5,7
    0x840126d8    0x82    auipc a4,0x6
    0x840126dc    0x86    sd a5,-8(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840126e0    0x8a    li a0,3
    0x840126e2    0x8c    ld ra,72(sp)          ; stack access
    0x840126e4    0x8e    ld s0,64(sp)          ; stack access
    0x840126e6    0x90    ld s1,56(sp)          ; stack access
    0x840126e8    0x92    ld s2,48(sp)          ; stack access
    0x840126ea    0x94    ld s3,40(sp)          ; stack access
    0x840126ec    0x96    ld s4,32(sp)          ; stack access
    0x840126ee    0x98    addi sp,sp,80
    0x840126f0    0x9a    ret
    0x840126f2    0x9c    mv a3,s0
    0x840126f4    0x9e    mv a2,s4
    0x840126f6    0xa0    ld a0,0(sp)           ; stack access
    0x840126f8    0xa2    ld a1,8(sp)           ; stack access
    0x840126fa    0xa4    jal ra,ffffffff840115ea <lookupTargetSlot>
    0x840126fe    0xa8    sd a1,24(sp)          ; stack access
    0x84012700    0xaa    bnez a0,ffffffff840126e2 <Arch_decodeIRQControlInvocation+0x8c>
    0x84012702    0xac    mv s0,a1
    0x84012704    0xae    mv a0,a1
    0x84012706    0xb0    jal ra,ffffffff84011a10 <ensureEmptySlot>
    0x8401270a    0xb4    bnez a0,ffffffff840126e2 <Arch_decodeIRQControlInvocation+0x8c>
    0x8401270c    0xb6    li a1,2
    0x8401270e    0xb8    auipc a0,0x18
    0x84012712    0xbc    ld a0,298(a0) # ffffffff8402a838 <ksCurThread>
    0x84012716    0xc0    jal ra,ffffffff8401263a <setThreadState>
    0x8401271a    0xc4    mv a2,s1
    0x8401271c    0xc6    mv a1,s0
    0x8401271e    0xc8    mv a0,s3
    0x84012720    0xca    jal ra,ffffffff84011b2a <invokeIRQControl>
    0x84012724    0xce    j ffffffff840126e2 <Arch_decodeIRQControlInvocation+0x8c>
    0x84012726    0xd0    li a5,3
    0x84012728    0xd2    auipc a4,0x6
    0x8401272c    0xd6    sd a5,-88(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84012730    0xda    li a0,3
    0x84012732    0xdc    ret

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
83 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_decodeIRQControlInvocation` has 132 nodes.

Section handleInvocation (259 of 271)
=====================================

Deriving specifications
-----------------------

Section `handleInvocation` consists of 105 instructions.


Stack analysis
---------------

23 stack accesses found. Annotated code for `handleInvocation`:

    0x84016afe      0x0    addi sp,sp,-128
    0x84016b00      0x2    sd ra,120(sp)         ; stack access
    0x84016b02      0x4    sd s0,112(sp)         ; stack access
    0x84016b04      0x6    sd s1,104(sp)         ; stack access
    0x84016b06      0x8    sd s2,96(sp)          ; stack access
    0x84016b08      0xa    sd s3,88(sp)          ; stack access
    0x84016b0a      0xc    sd s4,80(sp)          ; stack access
    0x84016b0c      0xe    sd s5,72(sp)          ; stack access
    0x84016b0e     0x10    sd s6,64(sp)          ; stack access
    0x84016b10     0x12    sd s7,56(sp)          ; stack access
    0x84016b12     0x14    mv s5,a0
    0x84016b14     0x16    mv s4,a1
    0x84016b16     0x18    auipc s0,0x14
    0x84016b1a     0x1c    ld s0,-734(s0) # ffffffff8402a838 <ksCurThread>
    0x84016b1e     0x20    ld s1,80(s0)
    0x84016b20     0x22    andi a4,s1,127
    0x84016b24     0x26    li a5,120
    0x84016b28     0x2a    bgeu a5,a4,ffffffff84016b34 <handleInvocation+0x36>
    0x84016b2c     0x2e    andi s1,s1,-128
    0x84016b30     0x32    ori s1,s1,120
    0x84016b34     0x36    ld s6,72(s0)
    0x84016b38     0x3a    mv a2,s6
    0x84016b3a     0x3c    mv a1,s0
    0x84016b3c     0x3e    addi a0,sp,16
    0x84016b3e     0x40    jal ra,ffffffff840114c2 <lookupCapAndSlot>
    0x84016b42     0x44    ld s7,16(sp)          ; stack access
    0x84016b44     0x46    bnez s7,ffffffff84016bb0 <handleInvocation+0xb2>
    0x84016b48     0x4a    mv a1,s0
    0x84016b4a     0x4c    li a0,0
    0x84016b4c     0x4e    jal ra,ffffffff840107e6 <lookupIPCBuffer>
    0x84016b50     0x52    mv s3,a0
    0x84016b52     0x54    mv a2,s1
    0x84016b54     0x56    mv a1,a0
    0x84016b56     0x58    mv a0,s0
    0x84016b58     0x5a    jal ra,ffffffff84013efa <lookupExtraCaps>
    0x84016b5c     0x5e    mv s2,a0
    0x84016b5e     0x60    bnez a0,ffffffff84016bd2 <handleInvocation+0xd4>
    0x84016b60     0x62    andi a1,s1,127
    0x84016b64     0x66    li a5,4
    0x84016b66     0x68    bltu a5,a1,ffffffff84016be2 <handleInvocation+0xe4>
    0x84016b6a     0x6c    sd s3,0(sp)           ; stack access
    0x84016b6c     0x6e    mv a7,s5
    0x84016b6e     0x70    mv a6,s4
    0x84016b70     0x72    ld a4,24(sp)          ; stack access
    0x84016b72     0x74    ld a5,32(sp)          ; stack access
    0x84016b74     0x76    ld a3,40(sp)          ; stack access
    0x84016b76     0x78    mv a2,s6
    0x84016b78     0x7a    srli a0,s1,0xc
    0x84016b7c     0x7e    jal ra,ffffffff8401690a <decodeInvocation>
    0x84016b80     0x82    li a5,4
    0x84016b82     0x84    beq a0,a5,ffffffff84016c12 <handleInvocation+0x114>
    0x84016b86     0x88    li a5,3
    0x84016b88     0x8a    beq a0,a5,ffffffff84016bea <handleInvocation+0xec>
    0x84016b8c     0x8e    ld a5,280(s0)
    0x84016b90     0x92    andi a5,a5,15
    0x84016b92     0x94    li a4,2
    0x84016b94     0x96    beq a5,a4,ffffffff84016bfa <handleInvocation+0xfc>
    0x84016b98     0x9a    mv a0,s2
    0x84016b9a     0x9c    ld ra,120(sp)         ; stack access
    0x84016b9c     0x9e    ld s0,112(sp)         ; stack access
    0x84016b9e     0xa0    ld s1,104(sp)         ; stack access
    0x84016ba0     0xa2    ld s2,96(sp)          ; stack access
    0x84016ba2     0xa4    ld s3,88(sp)          ; stack access
    0x84016ba4     0xa6    ld s4,80(sp)          ; stack access
    0x84016ba6     0xa8    ld s5,72(sp)          ; stack access
    0x84016ba8     0xaa    ld s6,64(sp)          ; stack access
    0x84016baa     0xac    ld s7,56(sp)          ; stack access
    0x84016bac     0xae    addi sp,sp,128
    0x84016bae     0xb0    ret
    0x84016bb0     0xb2    auipc a5,0x1
    0x84016bb4     0xb6    addi a5,a5,1104 # ffffffff84018000 <riscvKSASIDTable>
    0x84016bb8     0xba    li a4,1
    0x84016bba     0xbc    sd a4,1680(a5)
    0x84016bbe     0xc0    sd s6,1688(a5)
    0x84016bc2     0xc4    mv s2,s4
    0x84016bc4     0xc6    beqz s4,ffffffff84016b98 <handleInvocation+0x9a>
    0x84016bc8     0xca    mv a0,s0
    0x84016bca     0xcc    jal ra,ffffffff84014514 <handleFault>
    0x84016bce     0xd0    li s2,0
    0x84016bd0     0xd2    j ffffffff84016b98 <handleInvocation+0x9a>
    0x84016bd2     0xd4    mv s2,s4
    0x84016bd4     0xd6    beqz s4,ffffffff84016b98 <handleInvocation+0x9a>
    0x84016bd8     0xda    mv a0,s0
    0x84016bda     0xdc    jal ra,ffffffff84014514 <handleFault>
    0x84016bde     0xe0    mv s2,s7
    0x84016be0     0xe2    j ffffffff84016b98 <handleInvocation+0x9a>
    0x84016be2     0xe4    bnez s3,ffffffff84016b6a <handleInvocation+0x6c>
    0x84016be6     0xe8    li a1,4
    0x84016be8     0xea    j ffffffff84016b6a <handleInvocation+0x6c>
    0x84016bea     0xec    bnez s5,ffffffff84016bf2 <handleInvocation+0xf4>
    0x84016bee     0xf0    mv s2,s5
    0x84016bf0     0xf2    j ffffffff84016b98 <handleInvocation+0x9a>
    0x84016bf2     0xf4    mv a0,s0
    0x84016bf4     0xf6    jal ra,ffffffff84015aac <replyFromKernel_error>
    0x84016bf8     0xfa    j ffffffff84016b98 <handleInvocation+0x9a>
    0x84016bfa     0xfc    bnez s5,ffffffff84016c08 <handleInvocation+0x10a>
    0x84016bfe    0x100    li a1,1
    0x84016c00    0x102    mv a0,s0
    0x84016c02    0x104    jal ra,ffffffff8401263a <setThreadState>
    0x84016c06    0x108    j ffffffff84016b98 <handleInvocation+0x9a>
    0x84016c08    0x10a    sd zero,72(s0)
    0x84016c0c    0x10e    sd zero,80(s0)
    0x84016c10    0x112    j ffffffff84016bfe <handleInvocation+0x100>
    0x84016c12    0x114    mv s2,a0
    0x84016c14    0x116    j ffffffff84016b98 <handleInvocation+0x9a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
105 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleInvocation` has 169 nodes.

Section decodeUntypedInvocation (260 of 271)
============================================

Deriving specifications
-----------------------

Section `decodeUntypedInvocation` consists of 272 instructions.


Stack analysis
---------------

35 stack accesses found. Annotated code for `decodeUntypedInvocation`:

    0x840165f6      0x0    addi sp,sp,-176
    0x840165f8      0x2    sd ra,168(sp)         ; stack access
    0x840165fa      0x4    sd s0,160(sp)         ; stack access
    0x840165fc      0x6    sd s1,152(sp)         ; stack access
    0x840165fe      0x8    sd s2,144(sp)         ; stack access
    0x84016600      0xa    sd s3,136(sp)         ; stack access
    0x84016602      0xc    sd s4,128(sp)         ; stack access
    0x84016604      0xe    sd s5,120(sp)         ; stack access
    0x84016606     0x10    sd s6,112(sp)         ; stack access
    0x84016608     0x12    sd s7,104(sp)         ; stack access
    0x8401660a     0x14    sd s8,96(sp)          ; stack access
    0x8401660c     0x16    sd s9,88(sp)          ; stack access
    0x8401660e     0x18    sd s10,80(sp)         ; stack access
    0x84016610     0x1a    sd s11,72(sp)         ; stack access
    0x84016612     0x1c    sd a3,16(sp)          ; stack access
    0x84016614     0x1e    sd a4,24(sp)          ; stack access
    0x84016616     0x20    li a5,1
    0x84016618     0x22    bne a0,a5,ffffffff8401679c <decodeUntypedInvocation+0x1a6>
    0x8401661c     0x26    mv s1,a0
    0x8401661e     0x28    mv s2,a2
    0x84016620     0x2a    mv s0,a6
    0x84016622     0x2c    li a5,5
    0x84016624     0x2e    bgeu a5,a1,ffffffff840167c6 <decodeUntypedInvocation+0x1d0>
    0x84016628     0x32    auipc s9,0x2
    0x8401662c     0x36    ld s9,616(s9) # ffffffff84018890 <current_extra_caps>
    0x84016630     0x3a    beqz s9,ffffffff840167c6 <decodeUntypedInvocation+0x1d0>
    0x84016634     0x3e    mv a1,a6
    0x84016636     0x40    li a0,0
    0x84016638     0x42    jal ra,ffffffff840100ea <getSyscallArg>
    0x8401663c     0x46    mv s3,a0
    0x8401663e     0x48    li a5,8
    0x84016640     0x4a    bltu a5,a0,ffffffff840167d4 <decodeUntypedInvocation+0x1de>
    0x84016644     0x4e    mv a1,s0
    0x84016646     0x50    li a0,1
    0x84016648     0x52    jal ra,ffffffff840100ea <getSyscallArg>
    0x8401664c     0x56    mv s4,a0
    0x8401664e     0x58    mv a1,a0
    0x84016650     0x5a    mv a0,s3
    0x84016652     0x5c    jal ra,ffffffff84011c66 <getObjectSize>
    0x84016656     0x60    mv s5,a0
    0x84016658     0x62    li a5,63
    0x8401665c     0x66    bltu a5,s4,ffffffff840167ea <decodeUntypedInvocation+0x1f4>
    0x84016660     0x6a    li a5,38
    0x84016664     0x6e    bltu a5,a0,ffffffff840167ea <decodeUntypedInvocation+0x1f4>
    0x84016668     0x72    li a5,4
    0x8401666a     0x74    beq s3,a5,ffffffff84016808 <decodeUntypedInvocation+0x212>
    0x8401666e     0x78    bnez s3,ffffffff84016678 <decodeUntypedInvocation+0x82>
    0x84016672     0x7c    li a5,3
    0x84016674     0x7e    bgeu a5,s4,ffffffff84016822 <decodeUntypedInvocation+0x22c>
    0x84016678     0x82    ld s10,24(sp)         ; stack access
    0x8401667a     0x84    mv a1,s0
    0x8401667c     0x86    li a0,3
    0x8401667e     0x88    jal ra,ffffffff840100ea <getSyscallArg>
    0x84016682     0x8c    mv s6,a0
    0x84016684     0x8e    mv a1,s0
    0x84016686     0x90    li a0,4
    0x84016688     0x92    jal ra,ffffffff840100ea <getSyscallArg>
    0x8401668c     0x96    mv s7,a0
    0x8401668e     0x98    mv a1,s0
    0x84016690     0x9a    li a0,5
    0x84016692     0x9c    jal ra,ffffffff840100ea <getSyscallArg>
    0x84016696     0xa0    mv s8,a0
    0x84016698     0xa2    bnez s6,ffffffff84016838 <decodeUntypedInvocation+0x242>
    0x8401669c     0xa6    ld a5,0(s9)
    0x840166a0     0xaa    srli a4,a5,0x3b
    0x840166a4     0xae    li a3,10
    0x840166a6     0xb0    bne a4,a3,ffffffff8401685e <decodeUntypedInvocation+0x268>
    0x840166aa     0xb4    srli a4,a5,0x2f
    0x840166ae     0xb8    li a3,1
    0x840166b0     0xba    sll a4,a3,a4
    0x840166b4     0xbe    addi a3,a4,-1
    0x840166b8     0xc2    bltu a3,s7,ffffffff84016888 <decodeUntypedInvocation+0x292>
    0x840166bc     0xc6    addi a3,s8,-1
    0x840166c0     0xca    li a2,255
    0x840166c4     0xce    bltu a2,a3,ffffffff840168a2 <decodeUntypedInvocation+0x2ac>
    0x840166c8     0xd2    sub a4,a4,s7
    0x840166cc     0xd6    bltu a4,s8,ffffffff840168c2 <decodeUntypedInvocation+0x2cc>
    0x840166d0     0xda    slli a5,a5,0x1
    0x840166d2     0xdc    lui s0,0xfc000
    0x840166d6     0xe0    srli s0,s0,0x19
    0x840166d8     0xe2    and a4,a5,s0
    0x840166dc     0xe6    srli a5,a5,0x26
    0x840166de     0xe8    andi a5,a5,1
    0x840166e0     0xea    beqz a5,ffffffff840166e8 <decodeUntypedInvocation+0xf2>
    0x840166e2     0xec    li a5,-1
    0x840166e4     0xee    slli a5,a5,0x27
    0x840166e6     0xf0    or a4,a4,a5
    0x840166e8     0xf2    mv s11,a4
    0x840166ea     0xf4    add s9,s7,s8
    0x840166ee     0xf8    bgeu s7,s9,ffffffff8401670c <decodeUntypedInvocation+0x116>
    0x840166f2     0xfc    slli s0,s7,0x5
    0x840166f6    0x100    add s0,s0,a4
    0x840166f8    0x102    mv s6,s7
    0x840166fa    0x104    mv a0,s0
    0x840166fc    0x106    jal ra,ffffffff84011a10 <ensureEmptySlot>
    0x84016700    0x10a    bnez a0,ffffffff840167a8 <decodeUntypedInvocation+0x1b2>
    0x84016702    0x10c    addi s6,s6,1
    0x84016704    0x10e    addi s0,s0,32 # fffffffffc000020 <ki_end+0x77fd1020>
    0x84016708    0x112    bne s6,s9,ffffffff840166fa <decodeUntypedInvocation+0x104>
    0x8401670c    0x116    mv a0,s2
    0x8401670e    0x118    jal ra,ffffffff840120ae <ensureNoChildren>
    0x84016712    0x11c    beqz a0,ffffffff8401671a <decodeUntypedInvocation+0x124>
    0x84016714    0x11e    srli a0,s10,0x19
    0x84016718    0x122    li s1,0
    0x8401671a    0x124    ld a5,16(sp)          ; stack access
    0x8401671c    0x126    slli s0,a5,0x19
    0x84016720    0x12a    srli a4,s0,0x19
    0x84016724    0x12e    srli a5,a5,0x26
    0x84016726    0x130    andi a5,a5,1
    0x84016728    0x132    beqz a5,ffffffff84016730 <decodeUntypedInvocation+0x13a>
    0x8401672a    0x134    li a5,-1
    0x8401672c    0x136    slli a5,a5,0x27
    0x8401672e    0x138    or a4,a4,a5
    0x84016730    0x13a    slli a0,a0,0x4
    0x84016732    0x13c    li a5,1
    0x84016734    0x13e    sll a5,a5,s10
    0x84016738    0x142    sub a5,a5,a0
    0x8401673a    0x144    sext.w a3,s5
    0x8401673e    0x148    srl s5,a5,s5
    0x84016742    0x14c    bltu s5,s8,ffffffff840168de <decodeUntypedInvocation+0x2e8>
    0x84016746    0x150    srli s10,s10,0x6
    0x8401674a    0x154    andi s10,s10,1
    0x8401674e    0x158    beqz s10,ffffffff84016760 <decodeUntypedInvocation+0x16a>
    0x84016752    0x15c    addi a5,s3,-5
    0x84016756    0x160    li a2,2
    0x84016758    0x162    bgeu a2,a5,ffffffff84016760 <decodeUntypedInvocation+0x16a>
    0x8401675c    0x166    bnez s3,ffffffff840168f4 <decodeUntypedInvocation+0x2fe>
    0x84016760    0x16a    li a5,1
    0x84016762    0x16c    sll a5,a5,a3
    0x84016766    0x170    addi s0,a5,-1
    0x8401676a    0x174    add a0,a0,s0
    0x8401676c    0x176    add s0,a0,a4
    0x84016770    0x17a    neg a5,a5
    0x84016774    0x17e    and s0,s0,a5
    0x84016776    0x180    li a1,2
    0x84016778    0x182    auipc a0,0x14
    0x8401677c    0x186    ld a0,192(a0) # ffffffff8402a838 <ksCurThread>
    0x84016780    0x18a    jal ra,ffffffff8401263a <setThreadState>
    0x84016784    0x18e    sd s10,0(sp)          ; stack access
    0x84016786    0x190    mv a7,s8
    0x84016788    0x192    mv a6,s7
    0x8401678a    0x194    mv a5,s11
    0x8401678c    0x196    mv a4,s4
    0x8401678e    0x198    mv a3,s3
    0x84016790    0x19a    mv a2,s0
    0x84016792    0x19c    mv a1,s1
    0x84016794    0x19e    mv a0,s2
    0x84016796    0x1a0    jal ra,ffffffff840164e2 <invokeUntyped_Retype>
    0x8401679a    0x1a4    j ffffffff840167a8 <decodeUntypedInvocation+0x1b2>
    0x8401679c    0x1a6    li a5,3
    0x8401679e    0x1a8    auipc a4,0x2
    0x840167a2    0x1ac    sd a5,-206(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840167a6    0x1b0    li a0,3
    0x840167a8    0x1b2    ld ra,168(sp)         ; stack access
    0x840167aa    0x1b4    ld s0,160(sp)         ; stack access
    0x840167ac    0x1b6    ld s1,152(sp)         ; stack access
    0x840167ae    0x1b8    ld s2,144(sp)         ; stack access
    0x840167b0    0x1ba    ld s3,136(sp)         ; stack access
    0x840167b2    0x1bc    ld s4,128(sp)         ; stack access
    0x840167b4    0x1be    ld s5,120(sp)         ; stack access
    0x840167b6    0x1c0    ld s6,112(sp)         ; stack access
    0x840167b8    0x1c2    ld s7,104(sp)         ; stack access
    0x840167ba    0x1c4    ld s8,96(sp)          ; stack access
    0x840167bc    0x1c6    ld s9,88(sp)          ; stack access
    0x840167be    0x1c8    ld s10,80(sp)         ; stack access
    0x840167c0    0x1ca    ld s11,72(sp)         ; stack access
    0x840167c2    0x1cc    addi sp,sp,176
    0x840167c4    0x1ce    ret
    0x840167c6    0x1d0    li a5,7
    0x840167c8    0x1d2    auipc a4,0x2
    0x840167cc    0x1d6    sd a5,-248(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840167d0    0x1da    li a0,3
    0x840167d2    0x1dc    j ffffffff840167a8 <decodeUntypedInvocation+0x1b2>
    0x840167d4    0x1de    auipc a5,0x2
    0x840167d8    0x1e2    addi a5,a5,-2004 # ffffffff84018000 <riscvKSASIDTable>
    0x840167dc    0x1e6    li a4,1
    0x840167de    0x1e8    sd a4,1744(a5)
    0x840167e2    0x1ec    sd zero,1696(a5)
    0x840167e6    0x1f0    li a0,3
    0x840167e8    0x1f2    j ffffffff840167a8 <decodeUntypedInvocation+0x1b2>
    0x840167ea    0x1f4    auipc a5,0x2
    0x840167ee    0x1f8    addi a5,a5,-2026 # ffffffff84018000 <riscvKSASIDTable>
    0x840167f2    0x1fc    li a4,4
    0x840167f4    0x1fe    sd a4,1744(a5)
    0x840167f8    0x202    sd zero,1712(a5)
    0x840167fc    0x206    li a4,38
    0x84016800    0x20a    sd a4,1720(a5)
    0x84016804    0x20e    li a0,3
    0x84016806    0x210    j ffffffff840167a8 <decodeUntypedInvocation+0x1b2>
    0x84016808    0x212    bnez s4,ffffffff84016678 <decodeUntypedInvocation+0x82>
    0x8401680c    0x216    auipc a5,0x1
    0x84016810    0x21a    addi a5,a5,2036 # ffffffff84018000 <riscvKSASIDTable>
    0x84016814    0x21e    li a4,1
    0x84016816    0x220    sd a4,1744(a5)
    0x8401681a    0x224    sd a4,1696(a5)
    0x8401681e    0x228    li a0,3
    0x84016820    0x22a    j ffffffff840167a8 <decodeUntypedInvocation+0x1b2>
    0x84016822    0x22c    auipc a5,0x1
    0x84016826    0x230    addi a5,a5,2014 # ffffffff84018000 <riscvKSASIDTable>
    0x8401682a    0x234    li a4,1
    0x8401682c    0x236    sd a4,1744(a5)
    0x84016830    0x23a    sd a4,1696(a5)
    0x84016834    0x23e    li a0,3
    0x84016836    0x240    j ffffffff840167a8 <decodeUntypedInvocation+0x1b2>
    0x84016838    0x242    mv a1,s0
    0x8401683a    0x244    li a0,2
    0x8401683c    0x246    jal ra,ffffffff840100ea <getSyscallArg>
    0x84016840    0x24a    mv a2,a0
    0x84016842    0x24c    ld a0,0(s9)
    0x84016846    0x250    sd a0,32(sp)          ; stack access
    0x84016848    0x252    ld a1,8(s9)
    0x8401684c    0x256    sd a1,40(sp)          ; stack access
    0x8401684e    0x258    mv a3,s6
    0x84016850    0x25a    jal ra,ffffffff840115ea <lookupTargetSlot>
    0x84016854    0x25e    sd a0,48(sp)          ; stack access
    0x84016856    0x260    sd a1,56(sp)          ; stack access
    0x84016858    0x262    bnez a0,ffffffff840167a8 <decodeUntypedInvocation+0x1b2>
    0x8401685a    0x264    ld a5,0(a1)
    0x8401685c    0x266    j ffffffff840166a0 <decodeUntypedInvocation+0xaa>
    0x8401685e    0x268    auipc a4,0x1
    0x84016862    0x26c    addi a4,a4,1954 # ffffffff84018000 <riscvKSASIDTable>
    0x84016866    0x270    li a5,6
    0x84016868    0x272    sd a5,1744(a4)
    0x8401686c    0x276    sd zero,1736(a4)
    0x84016870    0x27a    slli a5,s6,0x2
    0x84016874    0x27e    andi a5,a5,508
    0x84016878    0x282    ori a5,a5,1
    0x8401687c    0x286    sd a5,1024(a4)
    0x84016880    0x28a    sd zero,1032(a4)
    0x84016884    0x28e    li a0,3
    0x84016886    0x290    j ffffffff840167a8 <decodeUntypedInvocation+0x1b2>
    0x84016888    0x292    auipc a5,0x1
    0x8401688c    0x296    addi a5,a5,1912 # ffffffff84018000 <riscvKSASIDTable>
    0x84016890    0x29a    li a4,4
    0x84016892    0x29c    sd a4,1744(a5)
    0x84016896    0x2a0    sd zero,1712(a5)
    0x8401689a    0x2a4    sd a3,1720(a5)
    0x8401689e    0x2a8    li a0,3
    0x840168a0    0x2aa    j ffffffff840167a8 <decodeUntypedInvocation+0x1b2>
    0x840168a2    0x2ac    auipc a5,0x1
    0x840168a6    0x2b0    addi a5,a5,1886 # ffffffff84018000 <riscvKSASIDTable>
    0x840168aa    0x2b4    li a4,4
    0x840168ac    0x2b6    sd a4,1744(a5)
    0x840168b0    0x2ba    li a4,1
    0x840168b2    0x2bc    sd a4,1712(a5)
    0x840168b6    0x2c0    li a4,256
    0x840168ba    0x2c4    sd a4,1720(a5)
    0x840168be    0x2c8    li a0,3
    0x840168c0    0x2ca    j ffffffff840167a8 <decodeUntypedInvocation+0x1b2>
    0x840168c2    0x2cc    auipc a5,0x1
    0x840168c6    0x2d0    addi a5,a5,1854 # ffffffff84018000 <riscvKSASIDTable>
    0x840168ca    0x2d4    li a3,4
    0x840168cc    0x2d6    sd a3,1744(a5)
    0x840168d0    0x2da    li a3,1
    0x840168d2    0x2dc    sd a3,1712(a5)
    0x840168d6    0x2e0    sd a4,1720(a5)
    0x840168da    0x2e4    li a0,3
    0x840168dc    0x2e6    j ffffffff840167a8 <decodeUntypedInvocation+0x1b2>
    0x840168de    0x2e8    auipc a4,0x1
    0x840168e2    0x2ec    addi a4,a4,1826 # ffffffff84018000 <riscvKSASIDTable>
    0x840168e6    0x2f0    li a3,10
    0x840168e8    0x2f2    sd a3,1744(a4)
    0x840168ec    0x2f6    sd a5,1728(a4)
    0x840168f0    0x2fa    li a0,3
    0x840168f2    0x2fc    j ffffffff840167a8 <decodeUntypedInvocation+0x1b2>
    0x840168f4    0x2fe    auipc a5,0x1
    0x840168f8    0x302    addi a5,a5,1804 # ffffffff84018000 <riscvKSASIDTable>
    0x840168fc    0x306    li a4,1
    0x840168fe    0x308    sd a4,1744(a5)
    0x84016902    0x30c    sd a4,1696(a5)
    0x84016906    0x310    li a0,3
    0x84016908    0x312    j ffffffff840167a8 <decodeUntypedInvocation+0x1b2>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
272 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeUntypedInvocation` has 406 nodes.

Section decodeSetSpace (261 of 271)
===================================

Deriving specifications
-----------------------

Section `decodeSetSpace` consists of 160 instructions.

RVC_FTTFFFFTFFFT__FT.

Stack analysis
---------------

58 stack accesses found. Annotated code for `decodeSetSpace`:

    0x840150c0      0x0    addi sp,sp,-256
    0x840150c2      0x2    sd ra,248(sp)         ; stack access
    0x840150c4      0x4    sd s0,240(sp)         ; stack access
    0x840150c6      0x6    sd s1,232(sp)         ; stack access
    0x840150c8      0x8    sd s2,224(sp)         ; stack access
    0x840150ca      0xa    sd s3,216(sp)         ; stack access
    0x840150cc      0xc    sd s4,208(sp)         ; stack access
    0x840150ce      0xe    sd s5,200(sp)         ; stack access
    0x840150d0     0x10    sd s6,192(sp)         ; stack access
    0x840150d2     0x12    sd s7,184(sp)         ; stack access
    0x840150d4     0x14    sd s8,176(sp)         ; stack access
    0x840150d6     0x16    sd s9,168(sp)         ; stack access
    0x840150d8     0x18    sd a0,64(sp)          ; stack access
    0x840150da     0x1a    sd a1,72(sp)          ; stack access
    0x840150dc     0x1c    li a5,2
    0x840150de     0x1e    bgeu a5,a2,ffffffff840151fe <decodeSetSpace+0x13e>
    0x840150e2     0x22    mv s2,a3
    0x840150e4     0x24    mv s0,a4
    0x840150e6     0x26    auipc s1,0x3
    0x840150ea     0x2a    ld s1,1962(s1) # ffffffff84018890 <current_extra_caps>
    0x840150ee     0x2e    beqz s1,ffffffff840151fe <decodeSetSpace+0x13e>
    0x840150f2     0x32    auipc s3,0x3
    0x840150f6     0x36    ld s3,1958(s3) # ffffffff84018898 <current_extra_caps+0x8>
    0x840150fa     0x3a    beqz s3,ffffffff840151fe <decodeSetSpace+0x13e>
    0x840150fe     0x3e    mv a1,a4
    0x84015100     0x40    li a0,0
    0x84015102     0x42    jal ra,ffffffff840100ea <getSyscallArg>
    0x84015106     0x46    mv s6,a0
    0x84015108     0x48    mv a1,s0
    0x8401510a     0x4a    li a0,1
    0x8401510c     0x4c    jal ra,ffffffff840100ea <getSyscallArg>
    0x84015110     0x50    mv s4,a0
    0x84015112     0x52    mv a1,s0
    0x84015114     0x54    li a0,2
    0x84015116     0x56    jal ra,ffffffff840100ea <getSyscallArg>
    0x8401511a     0x5a    mv s5,a0
    0x8401511c     0x5c    ld s7,0(s1)
    0x84015120     0x60    sd s7,128(sp)         ; stack access
    0x84015122     0x62    ld a5,8(s1)
    0x84015124     0x64    sd a5,136(sp)         ; stack access
    0x84015126     0x66    mv s8,s7
    0x84015128     0x68    ld a5,0(s3)
    0x8401512c     0x6c    sd a5,112(sp)         ; stack access
    0x8401512e     0x6e    ld a5,8(s3)
    0x84015132     0x72    sd a5,120(sp)         ; stack access
    0x84015134     0x74    ld a5,64(sp)          ; stack access
    0x84015136     0x76    slli s0,a5,0x19
    0x8401513a     0x7a    srli s0,s0,0x19
    0x8401513c     0x7c    srli a5,a5,0x26
    0x8401513e     0x7e    andi a5,a5,1
    0x84015140     0x80    beqz a5,ffffffff84015148 <decodeSetSpace+0x88>
    0x84015142     0x82    li a5,-1
    0x84015144     0x84    slli a5,a5,0x27
    0x84015146     0x86    or s0,s0,a5
    0x84015148     0x88    andi s9,s0,-1024
    0x8401514c     0x8c    mv a0,s9
    0x8401514e     0x8e    jal ra,ffffffff84012214 <slotCapLongRunningDelete>
    0x84015152     0x92    bnez a0,ffffffff84015224 <decodeSetSpace+0x164>
    0x84015154     0x94    addi a0,s9,32
    0x84015158     0x98    jal ra,ffffffff84012214 <slotCapLongRunningDelete>
    0x8401515c     0x9c    bnez a0,ffffffff84015224 <decodeSetSpace+0x164>
    0x8401515e     0x9e    beqz s4,ffffffff84015172 <decodeSetSpace+0xb2>
    0x84015162     0xa2    mv a2,s7
    0x84015164     0xa4    ld a3,136(sp)         ; stack access
    0x84015166     0xa6    mv a1,s4
    0x84015168     0xa8    li a0,0
    0x8401516a     0xaa    jal ra,ffffffff8401224e <updateCapData>
    0x8401516e     0xae    sd a1,136(sp)         ; stack access
    0x84015170     0xb0    mv s8,a0
    0x84015172     0xb2    mv a2,s8
    0x84015174     0xb4    ld a3,136(sp)         ; stack access
    0x84015176     0xb6    mv a1,s1
    0x84015178     0xb8    addi a0,sp,88
    0x8401517a     0xba    jal ra,ffffffff840120ec <deriveCap>
    0x8401517e     0xbe    ld a0,88(sp)          ; stack access
    0x84015180     0xc0    bnez a0,ffffffff8401520a <decodeSetSpace+0x14a>
    0x84015182     0xc2    ld s4,96(sp)          ; stack access
    0x84015184     0xc4    ld a5,104(sp)         ; stack access
    0x84015186     0xc6    sd a5,136(sp)         ; stack access
    0x84015188     0xc8    srli a4,s4,0x3b
    0x8401518c     0xcc    li a5,10
    0x8401518e     0xce    bne a4,a5,ffffffff84015232 <decodeSetSpace+0x172>
    0x84015192     0xd2    beqz s5,ffffffff840151a6 <decodeSetSpace+0xe6>
    0x84015196     0xd6    ld a2,112(sp)         ; stack access
    0x84015198     0xd8    ld a3,120(sp)         ; stack access
    0x8401519a     0xda    mv a1,s5
    0x8401519c     0xdc    li a0,0
    0x8401519e     0xde    jal ra,ffffffff8401224e <updateCapData>
    0x840151a2     0xe2    sd a0,112(sp)         ; stack access
    0x840151a4     0xe4    sd a1,120(sp)         ; stack access
    0x840151a6     0xe6    ld a2,112(sp)         ; stack access
    0x840151a8     0xe8    ld a3,120(sp)         ; stack access
    0x840151aa     0xea    mv a1,s3
    0x840151ac     0xec    addi a0,sp,88
    0x840151ae     0xee    jal ra,ffffffff840120ec <deriveCap>
    0x840151b2     0xf2    ld a0,88(sp)          ; stack access
    0x840151b4     0xf4    bnez a0,ffffffff8401520a <decodeSetSpace+0x14a>
    0x840151b6     0xf6    ld a0,96(sp)          ; stack access
    0x840151b8     0xf8    sd a0,112(sp)         ; stack access
    0x840151ba     0xfa    ld a1,104(sp)         ; stack access
    0x840151bc     0xfc    sd a1,120(sp)         ; stack access
    0x840151be     0xfe    jal ra,ffffffff84010d4a <isValidVTableRoot>
    0x840151c2    0x102    beqz a0,ffffffff84015240 <decodeSetSpace+0x180>
    0x840151c4    0x104    li a1,2
    0x840151c6    0x106    auipc a0,0x15
    0x840151ca    0x10a    ld a0,1650(a0) # ffffffff8402a838 <ksCurThread>
    0x840151ce    0x10e    jal ra,ffffffff8401263a <setThreadState>
    0x840151d2    0x112    li a5,4
    0x840151d4    0x114    sd a5,56(sp)          ; stack access
    0x840151d6    0x116    sd zero,48(sp)        ; stack access
    0x840151d8    0x118    sd zero,32(sp)        ; stack access
    0x840151da    0x11a    sd zero,40(sp)        ; stack access
    0x840151dc    0x11c    sd zero,24(sp)        ; stack access
    0x840151de    0x11e    sd s3,16(sp)          ; stack access
    0x840151e0    0x120    ld a5,112(sp)         ; stack access
    0x840151e2    0x122    sd a5,0(sp)           ; stack access
    0x840151e4    0x124    ld a5,120(sp)         ; stack access
    0x840151e6    0x126    sd a5,8(sp)           ; stack access
    0x840151e8    0x128    mv a7,s1
    0x840151ea    0x12a    mv a5,s4
    0x840151ec    0x12c    ld a6,136(sp)         ; stack access
    0x840151ee    0x12e    li a4,0
    0x840151f0    0x130    li a3,0
    0x840151f2    0x132    mv a2,s6
    0x840151f4    0x134    mv a1,s2
    0x840151f6    0x136    mv a0,s0
    0x840151f8    0x138    jal ra,ffffffff84014a0a <invokeTCB_ThreadControl>
    0x840151fc    0x13c    j ffffffff8401520a <decodeSetSpace+0x14a>
    0x840151fe    0x13e    li a5,7
    0x84015200    0x140    auipc a4,0x3
    0x84015204    0x144    sd a5,1232(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84015208    0x148    li a0,3
    0x8401520a    0x14a    ld ra,248(sp)         ; stack access
    0x8401520c    0x14c    ld s0,240(sp)         ; stack access
    0x8401520e    0x14e    ld s1,232(sp)         ; stack access
    0x84015210    0x150    ld s2,224(sp)         ; stack access
    0x84015212    0x152    ld s3,216(sp)         ; stack access
    0x84015214    0x154    ld s4,208(sp)         ; stack access
    0x84015216    0x156    ld s5,200(sp)         ; stack access
    0x84015218    0x158    ld s6,192(sp)         ; stack access
    0x8401521a    0x15a    ld s7,184(sp)         ; stack access
    0x8401521c    0x15c    ld s8,176(sp)         ; stack access
    0x8401521e    0x15e    ld s9,168(sp)         ; stack access
    0x84015220    0x160    addi sp,sp,256
    0x84015222    0x162    ret
    0x84015224    0x164    li a5,3
    0x84015226    0x166    auipc a4,0x3
    0x8401522a    0x16a    sd a5,1194(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x8401522e    0x16e    li a0,3
    0x84015230    0x170    j ffffffff8401520a <decodeSetSpace+0x14a>
    0x84015232    0x172    li a5,3
    0x84015234    0x174    auipc a4,0x3
    0x84015238    0x178    sd a5,1180(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x8401523c    0x17c    li a0,3
    0x8401523e    0x17e    j ffffffff8401520a <decodeSetSpace+0x14a>
    0x84015240    0x180    li a5,3
    0x84015242    0x182    auipc a4,0x3
    0x84015246    0x186    sd a5,1166(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x8401524a    0x18a    li a0,3
    0x8401524c    0x18c    j ffffffff8401520a <decodeSetSpace+0x14a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
160 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetSpace` has 266 nodes.

Section receiveIPC (262 of 271)
===============================

Deriving specifications
-----------------------

Section `receiveIPC` consists of 156 instructions.


Stack analysis
---------------

18 stack accesses found. Annotated code for `receiveIPC`:

    0x8401462c      0x0    addi sp,sp,-96
    0x8401462e      0x2    sd ra,88(sp)          ; stack access
    0x84014630      0x4    sd s0,80(sp)          ; stack access
    0x84014632      0x6    sd s1,72(sp)          ; stack access
    0x84014634      0x8    sd s2,64(sp)          ; stack access
    0x84014636      0xa    sd s3,56(sp)          ; stack access
    0x84014638      0xc    sd s4,48(sp)          ; stack access
    0x8401463a      0xe    sd s5,40(sp)          ; stack access
    0x8401463c     0x10    mv s1,a0
    0x8401463e     0x12    sd a1,0(sp)           ; stack access
    0x84014640     0x14    sd a2,8(sp)           ; stack access
    0x84014642     0x16    mv s0,a1
    0x84014644     0x18    slli a5,a1,0x19
    0x84014648     0x1c    srli a5,a5,0x19
    0x8401464a     0x1e    srli a4,a1,0x26
    0x8401464e     0x22    andi a4,a4,1
    0x84014650     0x24    beqz a4,ffffffff84014658 <receiveIPC+0x2c>
    0x84014652     0x26    li a4,-1
    0x84014654     0x28    slli a4,a4,0x27
    0x84014656     0x2a    or a5,a5,a4
    0x84014658     0x2c    mv s2,a5
    0x8401465a     0x2e    ld a0,304(s1)
    0x8401465e     0x32    beqz a0,ffffffff8401466a <receiveIPC+0x3e>
    0x84014660     0x34    ld a4,0(a0)
    0x84014662     0x36    andi a4,a4,3
    0x84014664     0x38    li a2,2
    0x84014666     0x3a    beq a4,a2,ffffffff8401468e <receiveIPC+0x62>
    0x8401466a     0x3e    ld a4,0(s2)
    0x8401466e     0x42    andi a1,a4,3
    0x84014672     0x46    li a2,1
    0x84014674     0x48    beq a1,a2,ffffffff8401471e <receiveIPC+0xf2>
    0x84014678     0x4c    andi a4,a4,1
    0x8401467a     0x4e    beqz a4,ffffffff84014696 <receiveIPC+0x6a>
    0x8401467c     0x50    ld ra,88(sp)          ; stack access
    0x8401467e     0x52    ld s0,80(sp)          ; stack access
    0x84014680     0x54    ld s1,72(sp)          ; stack access
    0x84014682     0x56    ld s2,64(sp)          ; stack access
    0x84014684     0x58    ld s3,56(sp)          ; stack access
    0x84014686     0x5a    ld s4,48(sp)          ; stack access
    0x84014688     0x5c    ld s5,40(sp)          ; stack access
    0x8401468a     0x5e    addi sp,sp,96
    0x8401468c     0x60    ret
    0x8401468e     0x62    mv a1,s1
    0x84014690     0x64    jal ra,ffffffff84011bf4 <completeSignal>
    0x84014694     0x68    j ffffffff8401467c <receiveIPC+0x50>
    0x84014696     0x6a    beqz a3,ffffffff84014718 <receiveIPC+0xec>
    0x84014698     0x6c    ld a4,280(s1)
    0x8401469c     0x70    srli a4,a4,0x27
    0x8401469e     0x72    slli a4,a4,0x27
    0x840146a0     0x74    lui a3,0xe0000
    0x840146a4     0x78    srli a3,a3,0x19
    0x840146a6     0x7a    and a5,a5,a3
    0x840146a8     0x7c    or a5,a5,a4
    0x840146aa     0x7e    ori a5,a5,3
    0x840146ae     0x82    sd a5,280(s1)
    0x840146b2     0x86    srli s0,s0,0x36
    0x840146b4     0x88    andi s0,s0,8
    0x840146b6     0x8a    ld a5,288(s1)
    0x840146ba     0x8e    andi a5,a5,-9
    0x840146bc     0x90    or s0,s0,a5
    0x840146be     0x92    sd s0,288(s1)
    0x840146c2     0x96    mv a0,s1
    0x840146c4     0x98    jal ra,ffffffff84012606 <scheduleTCB>
    0x840146c8     0x9c    ld a3,8(s2)
    0x840146cc     0xa0    ld a4,0(s2)
    0x840146d0     0xa4    lui a5,0xf8000
    0x840146d4     0xa8    srli a5,a5,0x19
    0x840146d6     0xaa    and a5,a5,a4
    0x840146d8     0xac    srli a4,a4,0x26
    0x840146da     0xae    andi a4,a4,1
    0x840146dc     0xb0    beqz a4,ffffffff840146e4 <receiveIPC+0xb8>
    0x840146de     0xb2    li a4,-1
    0x840146e0     0xb4    slli a4,a4,0x27
    0x840146e2     0xb6    or a5,a5,a4
    0x840146e4     0xb8    mv a2,a5
    0x840146e6     0xba    mv a4,s1
    0x840146e8     0xbc    beqz a3,ffffffff840146f0 <receiveIPC+0xc4>
    0x840146ea     0xbe    mv a4,a3
    0x840146ec     0xc0    sd s1,408(a5) # fffffffff8000198 <ki_end+0x73fd1198>
    0x840146f0     0xc4    sd a2,416(s1)
    0x840146f4     0xc8    sd zero,408(s1)
    0x840146f8     0xcc    ld a5,0(s2)
    0x840146fc     0xd0    sd a4,8(s2)
    0x84014700     0xd4    lui a0,0xf8000
    0x84014704     0xd8    srli a0,a0,0x19
    0x84014706     0xda    and s1,s1,a0
    0x84014708     0xdc    srli a5,a5,0x27
    0x8401470a     0xde    slli a5,a5,0x27
    0x8401470c     0xe0    or s1,s1,a5
    0x8401470e     0xe2    ori s1,s1,2
    0x84014712     0xe6    sd s1,0(s2)
    0x84014716     0xea    j ffffffff8401467c <receiveIPC+0x50>
    0x84014718     0xec    sd zero,72(s1)
    0x8401471c     0xf0    j ffffffff8401467c <receiveIPC+0x50>
    0x8401471e     0xf2    ld s3,8(s2)
    0x84014722     0xf6    lui a2,0xf8000
    0x84014726     0xfa    srli a2,a2,0x19
    0x84014728     0xfc    and a2,a2,a4
    0x8401472a     0xfe    srli a4,a4,0x26
    0x8401472c    0x100    andi a4,a4,1
    0x8401472e    0x102    beqz a4,ffffffff84014736 <receiveIPC+0x10a>
    0x84014730    0x104    li a5,-1
    0x84014732    0x106    slli a5,a5,0x27
    0x84014734    0x108    or a2,a2,a5
    0x84014736    0x10a    mv a1,s3
    0x84014738    0x10c    mv a0,s3
    0x8401473a    0x10e    jal ra,ffffffff84012ec2 <tcbEPDequeue>
    0x8401473e    0x112    sd a0,16(sp)          ; stack access
    0x84014740    0x114    sd a1,24(sp)          ; stack access
    0x84014742    0x116    sd a0,8(s2)
    0x84014746    0x11a    ld a5,0(s2)
    0x8401474a    0x11e    li a4,-1
    0x8401474c    0x120    slli a4,a4,0x27
    0x8401474e    0x122    addi a4,a4,3
    0x84014750    0x124    and a5,a5,a4
    0x84014752    0x126    lui a4,0xf8000
    0x84014756    0x12a    srli a4,a4,0x19
    0x84014758    0x12c    and a1,a1,a4
    0x8401475a    0x12e    or a1,a1,a5
    0x8401475c    0x130    beqz a0,ffffffff840147a6 <receiveIPC+0x17a>
    0x8401475e    0x132    sd a1,0(s2)
    0x84014762    0x136    ld s4,288(s3)
    0x84014766    0x13a    srli s5,s4,0x3
    0x8401476a    0x13e    mv a4,s1
    0x8401476c    0x140    andi a3,s5,1
    0x84014770    0x144    ld a2,296(s3)
    0x84014774    0x148    mv a1,s2
    0x84014776    0x14a    mv a0,s3
    0x84014778    0x14c    jal ra,ffffffff8401417e <doIPCTransfer>
    0x8401477c    0x150    ld a5,288(s3)
    0x84014780    0x154    srli a5,a5,0x1
    0x84014782    0x156    andi a5,a5,1
    0x84014784    0x158    beqz a5,ffffffff840147b8 <receiveIPC+0x18c>
    0x84014786    0x15a    srli s4,s4,0x2
    0x8401478a    0x15e    or s4,s4,s5
    0x8401478e    0x162    andi s4,s4,1
    0x84014792    0x166    beqz s4,ffffffff840147ae <receiveIPC+0x182>
    0x84014796    0x16a    srli a2,s0,0x39
    0x8401479a    0x16e    andi a2,a2,1
    0x8401479c    0x170    mv a1,s1
    0x8401479e    0x172    mv a0,s3
    0x840147a0    0x174    jal ra,ffffffff84013ea2 <setupCallerCap>
    0x840147a4    0x178    j ffffffff8401467c <receiveIPC+0x50>
    0x840147a6    0x17a    andi a1,a1,-4
    0x840147a8    0x17c    sd a1,0(s2)
    0x840147ac    0x180    j ffffffff84014762 <receiveIPC+0x136>
    0x840147ae    0x182    li a1,0
    0x840147b0    0x184    mv a0,s3
    0x840147b2    0x186    jal ra,ffffffff8401263a <setThreadState>
    0x840147b6    0x18a    j ffffffff8401467c <receiveIPC+0x50>
    0x840147b8    0x18c    li a1,1
    0x840147ba    0x18e    mv a0,s3
    0x840147bc    0x190    jal ra,ffffffff8401263a <setThreadState>
    0x840147c0    0x194    mv a0,s3
    0x840147c2    0x196    jal ra,ffffffff84012934 <possibleSwitchTo>
    0x840147c6    0x19a    j ffffffff8401467c <receiveIPC+0x50>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
156 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `receiveIPC` has 231 nodes.

Section decodeIRQControlInvocation (263 of 271)
===============================================

Deriving specifications
-----------------------

Section `decodeIRQControlInvocation` consists of 80 instructions.


Stack analysis
---------------

17 stack accesses found. Annotated code for `decodeIRQControlInvocation`:

    0x84012780     0x0    addi sp,sp,-80
    0x84012782     0x2    sd ra,72(sp)          ; stack access
    0x84012784     0x4    sd s0,64(sp)          ; stack access
    0x84012786     0x6    sd s1,56(sp)          ; stack access
    0x84012788     0x8    sd s2,48(sp)          ; stack access
    0x8401278a     0xa    sd s3,40(sp)          ; stack access
    0x8401278c     0xc    sd s4,32(sp)          ; stack access
    0x8401278e     0xe    mv s1,a2
    0x84012790    0x10    mv s0,a3
    0x84012792    0x12    li a5,25
    0x84012794    0x14    bne a0,a5,ffffffff8401284e <decodeIRQControlInvocation+0xce>
    0x84012798    0x18    li a5,2
    0x8401279a    0x1a    bgeu a5,a1,ffffffff840127fe <decodeIRQControlInvocation+0x7e>
    0x8401279e    0x1e    auipc s2,0x6
    0x840127a2    0x22    ld s2,242(s2) # ffffffff84018890 <current_extra_caps>
    0x840127a6    0x26    beqz s2,ffffffff840127fe <decodeIRQControlInvocation+0x7e>
    0x840127aa    0x2a    mv a1,a3
    0x840127ac    0x2c    li a0,0
    0x840127ae    0x2e    jal ra,ffffffff840100ea <getSyscallArg>
    0x840127b2    0x32    mv s3,a0
    0x840127b4    0x34    mv a1,s0
    0x840127b6    0x36    li a0,1
    0x840127b8    0x38    jal ra,ffffffff840100ea <getSyscallArg>
    0x840127bc    0x3c    mv s4,a0
    0x840127be    0x3e    mv a1,s0
    0x840127c0    0x40    li a0,2
    0x840127c2    0x42    jal ra,ffffffff840100ea <getSyscallArg>
    0x840127c6    0x46    mv s0,a0
    0x840127c8    0x48    ld a5,0(s2)
    0x840127cc    0x4c    sd a5,0(sp)           ; stack access
    0x840127ce    0x4e    ld a5,8(s2)
    0x840127d2    0x52    sd a5,8(sp)           ; stack access
    0x840127d4    0x54    mv a0,s3
    0x840127d6    0x56    jal ra,ffffffff84010e70 <Arch_checkIRQ>
    0x840127da    0x5a    bnez a0,ffffffff8401280a <decodeIRQControlInvocation+0x8a>
    0x840127dc    0x5c    slli a4,s3,0x3
    0x840127e0    0x60    auipc a5,0x6
    0x840127e4    0x64    addi a5,a5,-2016 # ffffffff84018000 <riscvKSASIDTable>
    0x840127e8    0x68    add a5,a5,a4
    0x840127ea    0x6a    ld a5,1752(a5)
    0x840127ee    0x6e    beqz a5,ffffffff8401281a <decodeIRQControlInvocation+0x9a>
    0x840127f0    0x70    li a5,9
    0x840127f2    0x72    auipc a4,0x6
    0x840127f6    0x76    sd a5,-290(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840127fa    0x7a    li a0,3
    0x840127fc    0x7c    j ffffffff8401280a <decodeIRQControlInvocation+0x8a>
    0x840127fe    0x7e    li a5,7
    0x84012800    0x80    auipc a4,0x6
    0x84012804    0x84    sd a5,-304(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84012808    0x88    li a0,3
    0x8401280a    0x8a    ld ra,72(sp)          ; stack access
    0x8401280c    0x8c    ld s0,64(sp)          ; stack access
    0x8401280e    0x8e    ld s1,56(sp)          ; stack access
    0x84012810    0x90    ld s2,48(sp)          ; stack access
    0x84012812    0x92    ld s3,40(sp)          ; stack access
    0x84012814    0x94    ld s4,32(sp)          ; stack access
    0x84012816    0x96    addi sp,sp,80
    0x84012818    0x98    ret
    0x8401281a    0x9a    mv a3,s0
    0x8401281c    0x9c    mv a2,s4
    0x8401281e    0x9e    ld a0,0(sp)           ; stack access
    0x84012820    0xa0    ld a1,8(sp)           ; stack access
    0x84012822    0xa2    jal ra,ffffffff840115ea <lookupTargetSlot>
    0x84012826    0xa6    sd a1,24(sp)          ; stack access
    0x84012828    0xa8    bnez a0,ffffffff8401280a <decodeIRQControlInvocation+0x8a>
    0x8401282a    0xaa    mv s0,a1
    0x8401282c    0xac    mv a0,a1
    0x8401282e    0xae    jal ra,ffffffff84011a10 <ensureEmptySlot>
    0x84012832    0xb2    bnez a0,ffffffff8401280a <decodeIRQControlInvocation+0x8a>
    0x84012834    0xb4    li a1,2
    0x84012836    0xb6    auipc a0,0x18
    0x8401283a    0xba    ld a0,2(a0) # ffffffff8402a838 <ksCurThread>
    0x8401283e    0xbe    jal ra,ffffffff8401263a <setThreadState>
    0x84012842    0xc2    mv a2,s1
    0x84012844    0xc4    mv a1,s0
    0x84012846    0xc6    mv a0,s3
    0x84012848    0xc8    jal ra,ffffffff84011b2a <invokeIRQControl>
    0x8401284c    0xcc    j ffffffff8401280a <decodeIRQControlInvocation+0x8a>
    0x8401284e    0xce    jal ra,ffffffff84012656 <Arch_decodeIRQControlInvocation>
    0x84012852    0xd2    j ffffffff8401280a <decodeIRQControlInvocation+0x8a>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
80 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeIRQControlInvocation` has 128 nodes.

Section decodeTCBConfigure (264 of 271)
=======================================

Deriving specifications
-----------------------

Section `decodeTCBConfigure` consists of 194 instructions.


Stack analysis
---------------

72 stack accesses found. Annotated code for `decodeTCBConfigure`:

    0x84014b5e      0x0    addi sp,sp,-272
    0x84014b60      0x2    sd ra,264(sp)         ; stack access
    0x84014b62      0x4    sd s0,256(sp)         ; stack access
    0x84014b64      0x6    sd s1,248(sp)         ; stack access
    0x84014b66      0x8    sd s2,240(sp)         ; stack access
    0x84014b68      0xa    sd s3,232(sp)         ; stack access
    0x84014b6a      0xc    sd s4,224(sp)         ; stack access
    0x84014b6c      0xe    sd s5,216(sp)         ; stack access
    0x84014b6e     0x10    sd s6,208(sp)         ; stack access
    0x84014b70     0x12    sd s7,200(sp)         ; stack access
    0x84014b72     0x14    sd s8,192(sp)         ; stack access
    0x84014b74     0x16    sd s9,184(sp)         ; stack access
    0x84014b76     0x18    sd s10,176(sp)        ; stack access
    0x84014b78     0x1a    sd s11,168(sp)        ; stack access
    0x84014b7a     0x1c    sd a0,64(sp)          ; stack access
    0x84014b7c     0x1e    sd a1,72(sp)          ; stack access
    0x84014b7e     0x20    li a5,3
    0x84014b80     0x22    bgeu a5,a2,ffffffff84014cd6 <decodeTCBConfigure+0x178>
    0x84014b84     0x26    mv s1,a3
    0x84014b86     0x28    mv s0,a4
    0x84014b88     0x2a    auipc s2,0x4
    0x84014b8c     0x2e    ld s2,-760(s2) # ffffffff84018890 <current_extra_caps>
    0x84014b90     0x32    beqz s2,ffffffff84014cd6 <decodeTCBConfigure+0x178>
    0x84014b94     0x36    auipc s4,0x4
    0x84014b98     0x3a    ld s4,-764(s4) # ffffffff84018898 <current_extra_caps+0x8>
    0x84014b9c     0x3e    beqz s4,ffffffff84014cd6 <decodeTCBConfigure+0x178>
    0x84014ba0     0x42    auipc s3,0x4
    0x84014ba4     0x46    ld s3,-768(s3) # ffffffff840188a0 <current_extra_caps+0x10>
    0x84014ba8     0x4a    beqz s3,ffffffff84014cd6 <decodeTCBConfigure+0x178>
    0x84014bac     0x4e    mv a1,a4
    0x84014bae     0x50    li a0,0
    0x84014bb0     0x52    jal ra,ffffffff840100ea <getSyscallArg>
    0x84014bb4     0x56    mv s8,a0
    0x84014bb6     0x58    mv a1,s0
    0x84014bb8     0x5a    li a0,1
    0x84014bba     0x5c    jal ra,ffffffff840100ea <getSyscallArg>
    0x84014bbe     0x60    mv s5,a0
    0x84014bc0     0x62    mv a1,s0
    0x84014bc2     0x64    li a0,2
    0x84014bc4     0x66    jal ra,ffffffff840100ea <getSyscallArg>
    0x84014bc8     0x6a    mv s6,a0
    0x84014bca     0x6c    mv a1,s0
    0x84014bcc     0x6e    li a0,3
    0x84014bce     0x70    jal ra,ffffffff840100ea <getSyscallArg>
    0x84014bd2     0x74    mv s0,a0
    0x84014bd4     0x76    ld s7,0(s2)
    0x84014bd8     0x7a    sd s7,128(sp)         ; stack access
    0x84014bda     0x7c    ld a5,8(s2)
    0x84014bde     0x80    sd a5,136(sp)         ; stack access
    0x84014be0     0x82    mv s9,s7
    0x84014be2     0x84    ld a5,0(s4)
    0x84014be6     0x88    sd a5,112(sp)         ; stack access
    0x84014be8     0x8a    ld a5,8(s4)
    0x84014bec     0x8e    sd a5,120(sp)         ; stack access
    0x84014bee     0x90    ld a5,0(s3)
    0x84014bf2     0x94    sd a5,144(sp)         ; stack access
    0x84014bf4     0x96    ld a5,8(s3)
    0x84014bf8     0x9a    sd a5,152(sp)         ; stack access
    0x84014bfa     0x9c    bnez a0,ffffffff84014d00 <decodeTCBConfigure+0x1a2>
    0x84014bfe     0xa0    li s3,0
    0x84014c00     0xa2    ld a5,64(sp)          ; stack access
    0x84014c02     0xa4    slli s10,a5,0x19
    0x84014c06     0xa8    srli s10,s10,0x19
    0x84014c0a     0xac    srli a5,a5,0x26
    0x84014c0c     0xae    andi a5,a5,1
    0x84014c0e     0xb0    beqz a5,ffffffff84014c18 <decodeTCBConfigure+0xba>
    0x84014c10     0xb2    li a5,-1
    0x84014c12     0xb4    slli a5,a5,0x27
    0x84014c14     0xb6    or s10,s10,a5
    0x84014c18     0xba    andi s11,s10,-1024
    0x84014c1c     0xbe    mv a0,s11
    0x84014c1e     0xc0    jal ra,ffffffff84012214 <slotCapLongRunningDelete>
    0x84014c22     0xc4    bnez a0,ffffffff84014d24 <decodeTCBConfigure+0x1c6>
    0x84014c26     0xc8    addi a0,s11,32 # 1020 <KERNEL_OFFSET-0xfffffffeffffefe0>
    0x84014c2a     0xcc    jal ra,ffffffff84012214 <slotCapLongRunningDelete>
    0x84014c2e     0xd0    bnez a0,ffffffff84014d24 <decodeTCBConfigure+0x1c6>
    0x84014c32     0xd4    beqz s5,ffffffff84014c46 <decodeTCBConfigure+0xe8>
    0x84014c36     0xd8    mv a2,s7
    0x84014c38     0xda    ld a3,136(sp)         ; stack access
    0x84014c3a     0xdc    mv a1,s5
    0x84014c3c     0xde    li a0,0
    0x84014c3e     0xe0    jal ra,ffffffff8401224e <updateCapData>
    0x84014c42     0xe4    sd a1,136(sp)         ; stack access
    0x84014c44     0xe6    mv s9,a0
    0x84014c46     0xe8    mv a2,s9
    0x84014c48     0xea    ld a3,136(sp)         ; stack access
    0x84014c4a     0xec    mv a1,s2
    0x84014c4c     0xee    addi a0,sp,88
    0x84014c4e     0xf0    jal ra,ffffffff840120ec <deriveCap>
    0x84014c52     0xf4    ld a0,88(sp)          ; stack access
    0x84014c54     0xf6    bnez a0,ffffffff84014ce2 <decodeTCBConfigure+0x184>
    0x84014c56     0xf8    ld s5,96(sp)          ; stack access
    0x84014c58     0xfa    ld a5,104(sp)         ; stack access
    0x84014c5a     0xfc    sd a5,136(sp)         ; stack access
    0x84014c5c     0xfe    srli a4,s5,0x3b
    0x84014c60    0x102    li a5,10
    0x84014c62    0x104    bne a4,a5,ffffffff84014d32 <decodeTCBConfigure+0x1d4>
    0x84014c66    0x108    beqz s6,ffffffff84014c7a <decodeTCBConfigure+0x11c>
    0x84014c6a    0x10c    ld a2,112(sp)         ; stack access
    0x84014c6c    0x10e    ld a3,120(sp)         ; stack access
    0x84014c6e    0x110    mv a1,s6
    0x84014c70    0x112    li a0,0
    0x84014c72    0x114    jal ra,ffffffff8401224e <updateCapData>
    0x84014c76    0x118    sd a0,112(sp)         ; stack access
    0x84014c78    0x11a    sd a1,120(sp)         ; stack access
    0x84014c7a    0x11c    ld a2,112(sp)         ; stack access
    0x84014c7c    0x11e    ld a3,120(sp)         ; stack access
    0x84014c7e    0x120    mv a1,s4
    0x84014c80    0x122    addi a0,sp,88
    0x84014c82    0x124    jal ra,ffffffff840120ec <deriveCap>
    0x84014c86    0x128    ld a0,88(sp)          ; stack access
    0x84014c88    0x12a    bnez a0,ffffffff84014ce2 <decodeTCBConfigure+0x184>
    0x84014c8a    0x12c    ld a0,96(sp)          ; stack access
    0x84014c8c    0x12e    sd a0,112(sp)         ; stack access
    0x84014c8e    0x130    ld a1,104(sp)         ; stack access
    0x84014c90    0x132    sd a1,120(sp)         ; stack access
    0x84014c92    0x134    jal ra,ffffffff84010d4a <isValidVTableRoot>
    0x84014c96    0x138    beqz a0,ffffffff84014d40 <decodeTCBConfigure+0x1e2>
    0x84014c98    0x13a    li a1,2
    0x84014c9a    0x13c    auipc a0,0x16
    0x84014c9e    0x140    ld a0,-1122(a0) # ffffffff8402a838 <ksCurThread>
    0x84014ca2    0x144    jal ra,ffffffff8401263a <setThreadState>
    0x84014ca6    0x148    li a5,6
    0x84014ca8    0x14a    sd a5,56(sp)          ; stack access
    0x84014caa    0x14c    sd s3,48(sp)          ; stack access
    0x84014cac    0x14e    ld a5,144(sp)         ; stack access
    0x84014cae    0x150    sd a5,32(sp)          ; stack access
    0x84014cb0    0x152    ld a5,152(sp)         ; stack access
    0x84014cb2    0x154    sd a5,40(sp)          ; stack access
    0x84014cb4    0x156    sd s0,24(sp)          ; stack access
    0x84014cb6    0x158    sd s4,16(sp)          ; stack access
    0x84014cb8    0x15a    ld a5,112(sp)         ; stack access
    0x84014cba    0x15c    sd a5,0(sp)           ; stack access
    0x84014cbc    0x15e    ld a5,120(sp)         ; stack access
    0x84014cbe    0x160    sd a5,8(sp)           ; stack access
    0x84014cc0    0x162    mv a7,s2
    0x84014cc2    0x164    mv a5,s5
    0x84014cc4    0x166    ld a6,136(sp)         ; stack access
    0x84014cc6    0x168    li a4,0
    0x84014cc8    0x16a    li a3,0
    0x84014cca    0x16c    mv a2,s8
    0x84014ccc    0x16e    mv a1,s1
    0x84014cce    0x170    mv a0,s10
    0x84014cd0    0x172    jal ra,ffffffff84014a0a <invokeTCB_ThreadControl>
    0x84014cd4    0x176    j ffffffff84014ce2 <decodeTCBConfigure+0x184>
    0x84014cd6    0x178    li a5,7
    0x84014cd8    0x17a    auipc a4,0x4
    0x84014cdc    0x17e    sd a5,-1544(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84014ce0    0x182    li a0,3
    0x84014ce2    0x184    ld ra,264(sp)         ; stack access
    0x84014ce4    0x186    ld s0,256(sp)         ; stack access
    0x84014ce6    0x188    ld s1,248(sp)         ; stack access
    0x84014ce8    0x18a    ld s2,240(sp)         ; stack access
    0x84014cea    0x18c    ld s3,232(sp)         ; stack access
    0x84014cec    0x18e    ld s4,224(sp)         ; stack access
    0x84014cee    0x190    ld s5,216(sp)         ; stack access
    0x84014cf0    0x192    ld s6,208(sp)         ; stack access
    0x84014cf2    0x194    ld s7,200(sp)         ; stack access
    0x84014cf4    0x196    ld s8,192(sp)         ; stack access
    0x84014cf6    0x198    ld s9,184(sp)         ; stack access
    0x84014cf8    0x19a    ld s10,176(sp)        ; stack access
    0x84014cfa    0x19c    ld s11,168(sp)        ; stack access
    0x84014cfc    0x19e    addi sp,sp,272
    0x84014cfe    0x1a0    ret
    0x84014d00    0x1a2    ld a2,144(sp)         ; stack access
    0x84014d02    0x1a4    mv a3,a5
    0x84014d04    0x1a6    mv a1,s3
    0x84014d06    0x1a8    addi a0,sp,88
    0x84014d08    0x1aa    jal ra,ffffffff840120ec <deriveCap>
    0x84014d0c    0x1ae    ld a0,88(sp)          ; stack access
    0x84014d0e    0x1b0    bnez a0,ffffffff84014ce2 <decodeTCBConfigure+0x184>
    0x84014d10    0x1b2    ld a1,96(sp)          ; stack access
    0x84014d12    0x1b4    sd a1,144(sp)         ; stack access
    0x84014d14    0x1b6    ld a2,104(sp)         ; stack access
    0x84014d16    0x1b8    sd a2,152(sp)         ; stack access
    0x84014d18    0x1ba    mv a0,s0
    0x84014d1a    0x1bc    jal ra,ffffffff84010d60 <checkValidIPCBuffer>
    0x84014d1e    0x1c0    beqz a0,ffffffff84014c00 <decodeTCBConfigure+0xa2>
    0x84014d22    0x1c4    j ffffffff84014ce2 <decodeTCBConfigure+0x184>
    0x84014d24    0x1c6    li a5,3
    0x84014d26    0x1c8    auipc a4,0x4
    0x84014d2a    0x1cc    sd a5,-1622(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84014d2e    0x1d0    li a0,3
    0x84014d30    0x1d2    j ffffffff84014ce2 <decodeTCBConfigure+0x184>
    0x84014d32    0x1d4    li a5,3
    0x84014d34    0x1d6    auipc a4,0x4
    0x84014d38    0x1da    sd a5,-1636(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84014d3c    0x1de    li a0,3
    0x84014d3e    0x1e0    j ffffffff84014ce2 <decodeTCBConfigure+0x184>
    0x84014d40    0x1e2    li a5,3
    0x84014d42    0x1e4    auipc a4,0x4
    0x84014d46    0x1e8    sd a5,-1650(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84014d4a    0x1ec    li a0,3
    0x84014d4c    0x1ee    j ffffffff84014ce2 <decodeTCBConfigure+0x184>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
194 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeTCBConfigure` has 328 nodes.

Section finaliseCap (265 of 271)
================================

Deriving specifications
-----------------------

Section `finaliseCap` consists of 155 instructions.

XOR.....
RVC_TFFFTT___FT___FT..

Stack analysis
---------------

Section `finaliseCap` expects pointer to stack in a0.
44 stack accesses found. Annotated code for `finaliseCap`:

    0x8401317c      0x0    addi sp,sp,-48
    0x8401317e      0x2    sd ra,40(sp)          ; stack access
    0x84013180      0x4    sd s0,32(sp)          ; stack access
    0x84013182      0x6    sd s1,24(sp)          ; stack access
    0x84013184      0x8    sd s2,16(sp)          ; stack access
    0x84013186      0xa    mv s0,a0
    0x84013188      0xc    sd a1,0(sp)           ; stack access
    0x8401318a      0xe    sd a2,8(sp)           ; stack access
    0x8401318c     0x10    mv s1,a1
    0x8401318e     0x12    srli a5,a1,0x3b
    0x84013192     0x16    andi a2,a5,1
    0x84013196     0x1a    bnez a2,ffffffff840131d6 <finaliseCap+0x5a>
    0x84013198     0x1c    li a2,6
    0x8401319a     0x1e    beq a5,a2,ffffffff84013208 <finaliseCap+0x8c>
    0x8401319e     0x22    bltu a2,a5,ffffffff840131ea <finaliseCap+0x6e>
    0x840131a2     0x26    beqz a5,ffffffff840131f6 <finaliseCap+0x7a>
    0x840131a4     0x28    li a2,4
    0x840131a6     0x2a    bne a5,a2,ffffffff84013336 <finaliseCap+0x1ba>
    0x840131aa     0x2e    beqz a3,ffffffff840131c4 <finaliseCap+0x48>
    0x840131ac     0x30    slli a0,a1,0x19
    0x840131b0     0x34    srli a0,a0,0x19
    0x840131b2     0x36    srli s1,a1,0x26
    0x840131b6     0x3a    andi s1,s1,1
    0x840131b8     0x3c    beqz s1,ffffffff840131c0 <finaliseCap+0x44>
    0x840131ba     0x3e    li a5,-1
    0x840131bc     0x40    slli a5,a5,0x27
    0x840131be     0x42    or a0,a0,a5
    0x840131c0     0x44    jal ra,ffffffff84012978 <cancelAllIPC>
    0x840131c4     0x48    sd zero,0(s0)         ; stack access
    0x840131c8     0x4c    sd zero,8(s0)         ; stack access
    0x840131cc     0x50    sd zero,16(s0)        ; stack access
    0x840131d0     0x54    sd zero,24(s0)        ; stack access
    0x840131d4     0x58    j ffffffff840131dc <finaliseCap+0x60>
    0x840131d6     0x5a    ld a2,8(sp)           ; stack access
    0x840131d8     0x5c    jal ra,ffffffff84010f56 <Arch_finaliseCap>
    0x840131dc     0x60    mv a0,s0
    0x840131de     0x62    ld ra,40(sp)          ; stack access
    0x840131e0     0x64    ld s0,32(sp)          ; stack access
    0x840131e2     0x66    ld s1,24(sp)          ; stack access
    0x840131e4     0x68    ld s2,16(sp)          ; stack access
    0x840131e6     0x6a    addi sp,sp,48
    0x840131e8     0x6c    ret
    0x840131ea     0x6e    li a2,8
    0x840131ec     0x70    beq a5,a2,ffffffff840131f6 <finaliseCap+0x7a>
    0x840131f0     0x74    li a2,20
    0x840131f2     0x76    bne a5,a2,ffffffff84013240 <finaliseCap+0xc4>
    0x840131f6     0x7a    sd zero,0(s0)         ; stack access
    0x840131fa     0x7e    sd zero,8(s0)         ; stack access
    0x840131fe     0x82    sd zero,16(s0)        ; stack access
    0x84013202     0x86    sd zero,24(s0)        ; stack access
    0x84013206     0x8a    j ffffffff840131dc <finaliseCap+0x60>
    0x84013208     0x8c    beqz a3,ffffffff8401322e <finaliseCap+0xb2>
    0x8401320a     0x8e    slli s2,a1,0x19
    0x8401320e     0x92    srli s2,s2,0x19
    0x84013212     0x96    srli s1,a1,0x26
    0x84013216     0x9a    andi s1,s1,1
    0x84013218     0x9c    beqz s1,ffffffff84013222 <finaliseCap+0xa6>
    0x8401321a     0x9e    li a5,-1
    0x8401321c     0xa0    slli a5,a5,0x27
    0x8401321e     0xa2    or s2,s2,a5
    0x84013222     0xa6    mv a0,s2
    0x84013224     0xa8    jal ra,ffffffff84011c14 <unbindMaybeNotification>
    0x84013228     0xac    mv a0,s2
    0x8401322a     0xae    jal ra,ffffffff840129b6 <cancelAllSignals>
    0x8401322e     0xb2    sd zero,0(s0)         ; stack access
    0x84013232     0xb6    sd zero,8(s0)         ; stack access
    0x84013236     0xba    sd zero,16(s0)        ; stack access
    0x8401323a     0xbe    sd zero,24(s0)        ; stack access
    0x8401323e     0xc2    j ffffffff840131dc <finaliseCap+0x60>
    0x84013240     0xc4    bnez a4,ffffffff84013338 <finaliseCap+0x1bc>
    0x84013244     0xc8    ld s2,8(sp)           ; stack access
    0x84013246     0xca    li a4,16
    0x84013248     0xcc    beq a5,a4,ffffffff84013308 <finaliseCap+0x18c>
    0x8401324c     0xd0    bltu a4,a5,ffffffff840132a0 <finaliseCap+0x124>
    0x84013250     0xd4    li a4,10
    0x84013252     0xd6    beq a5,a4,ffffffff840132b6 <finaliseCap+0x13a>
    0x84013256     0xda    li a4,12
    0x84013258     0xdc    bne a5,a4,ffffffff8401330a <finaliseCap+0x18e>
    0x8401325c     0xe0    beqz a3,ffffffff8401330a <finaliseCap+0x18e>
    0x8401325e     0xe2    slli s2,a1,0x19
    0x84013262     0xe6    srli s2,s2,0x19
    0x84013266     0xea    srli a5,a1,0x26
    0x8401326a     0xee    andi a5,a5,1
    0x8401326c     0xf0    beqz a5,ffffffff84013276 <finaliseCap+0xfa>
    0x8401326e     0xf2    li a5,-1
    0x84013270     0xf4    slli a5,a5,0x27
    0x84013272     0xf6    or s2,s2,a5
    0x84013276     0xfa    mv a0,s2
    0x84013278     0xfc    jal ra,ffffffff84011c3a <unbindNotification>
    0x8401327c    0x100    mv a0,s2
    0x8401327e    0x102    jal ra,ffffffff84013144 <suspend>
    0x84013282    0x106    li a5,-7
    0x84013284    0x108    slli a5,a5,0x3c
    0x84013286    0x10a    addi a5,a5,64 # ffffffffe0000040 <ki_end+0x5bfd1040>
    0x8401328a    0x10e    sd a5,0(s0)           ; stack access
    0x8401328c    0x110    andi a5,s2,-1024
    0x84013290    0x114    xori a5,a5,5
    0x84013294    0x118    sd a5,8(s0)           ; stack access
    0x84013296    0x11a    sd zero,16(s0)        ; stack access
    0x8401329a    0x11e    sd zero,24(s0)        ; stack access
    0x8401329e    0x122    j ffffffff840131dc <finaliseCap+0x60>
    0x840132a0    0x124    li a4,18
    0x840132a2    0x126    bne a5,a4,ffffffff8401330a <finaliseCap+0x18e>
    0x840132a6    0x12a    sd a1,0(s0)           ; stack access
    0x840132a8    0x12c    sd s2,8(a0) # fffffffff8000008 <ki_end+0x73fd1008>  ; stack access
    0x840132ac    0x130    sd zero,16(a0)        ; stack access
    0x840132b0    0x134    sd zero,24(a0)        ; stack access
    0x840132b4    0x138    j ffffffff840131dc <finaliseCap+0x60>
    0x840132b6    0x13a    beqz a3,ffffffff8401330a <finaliseCap+0x18e>
    0x840132b8    0x13c    srli a3,a1,0x2f
    0x840132bc    0x140    andi a0,a3,63
    0x840132c0    0x144    mv a3,a0
    0x840132c2    0x146    li a2,1
    0x840132c4    0x148    sll a1,a2,a0
    0x840132c8    0x14c    slli s1,s1,0x1
    0x840132ca    0x14e    lui a5,0xfc000
    0x840132ce    0x152    srli a5,a5,0x19
    0x840132d0    0x154    and a4,s1,a5
    0x840132d4    0x158    slli a2,a2,0x26
    0x840132d6    0x15a    and s1,s1,a2
    0x840132d8    0x15c    beqz s1,ffffffff840132e0 <finaliseCap+0x164>
    0x840132da    0x15e    li a5,-1
    0x840132dc    0x160    slli a5,a5,0x27
    0x840132de    0x162    or a4,a4,a5
    0x840132e0    0x164    li a5,-7
    0x840132e2    0x166    slli a5,a5,0x3c
    0x840132e4    0x168    or a5,a5,a0
    0x840132e6    0x16a    sd a5,0(s0)           ; stack access
    0x840132e8    0x16c    addiw a3,a3,1
    0x840132ea    0x16e    li a5,-1
    0x840132ec    0x170    sll a5,a5,a3
    0x840132f0    0x174    not a5,a5
    0x840132f4    0x178    xor a3,a1,a4
    0x840132f8    0x17c    and a5,a5,a3
    0x840132fa    0x17e    xor a5,a5,a4
    0x840132fc    0x180    sd a5,8(s0)           ; stack access
    0x840132fe    0x182    sd zero,16(s0)        ; stack access
    0x84013302    0x186    sd zero,24(s0)        ; stack access
    0x84013306    0x18a    j ffffffff840131dc <finaliseCap+0x60>
    0x84013308    0x18c    bnez a3,ffffffff8401331c <finaliseCap+0x1a0>
    0x8401330a    0x18e    sd zero,0(s0)         ; stack access
    0x8401330e    0x192    sd zero,8(s0)         ; stack access
    0x84013312    0x196    sd zero,16(s0)        ; stack access
    0x84013316    0x19a    sd zero,24(s0)        ; stack access
    0x8401331a    0x19e    j ffffffff840131dc <finaliseCap+0x60>
    0x8401331c    0x1a0    slli a0,s2,0x34
    0x84013320    0x1a4    srli a0,a0,0x34
    0x84013322    0x1a6    jal ra,ffffffff84013bca <deletingIRQHandler>
    0x84013326    0x1aa    sd zero,0(s0)         ; stack access
    0x8401332a    0x1ae    sd zero,8(s0)         ; stack access
    0x8401332e    0x1b2    sd s1,16(s0)          ; stack access
    0x84013330    0x1b4    sd s2,24(s0)          ; stack access
    0x84013334    0x1b8    j ffffffff840131dc <finaliseCap+0x60>
    0x84013336    0x1ba    beqz a4,ffffffff8401330a <finaliseCap+0x18e>
    0x84013338    0x1bc    jal ra,ffffffff8401041e <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
155 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `finaliseCap` has 254 nodes.

Section handleSyscall (266 of 271)
==================================

Deriving specifications
-----------------------

Section `handleSyscall` consists of 109 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `handleSyscall`:

    0x84016c16      0x0    addi sp,sp,-16
    0x84016c18      0x2    sd ra,8(sp)           ; stack access
    0x84016c1a      0x4    sd s0,0(sp)           ; stack access
    0x84016c1c      0x6    li a5,-4
    0x84016c1e      0x8    beq a0,a5,ffffffff84016cdc <handleSyscall+0xc6>
    0x84016c22      0xc    bltu a5,a0,ffffffff84016c56 <handleSyscall+0x40>
    0x84016c26     0x10    li a5,-6
    0x84016c28     0x12    beq a0,a5,ffffffff84016d5a <handleSyscall+0x144>
    0x84016c2c     0x16    bltu a5,a0,ffffffff84016d42 <handleSyscall+0x12c>
    0x84016c30     0x1a    li a5,-8
    0x84016c32     0x1c    beq a0,a5,ffffffff84016d6c <handleSyscall+0x156>
    0x84016c36     0x20    li a5,-7
    0x84016c38     0x22    bne a0,a5,ffffffff84016d74 <handleSyscall+0x15e>
    0x84016c3c     0x26    auipc s0,0x14
    0x84016c40     0x2a    addi s0,s0,-1028 # ffffffff8402a838 <ksCurThread>
    0x84016c44     0x2e    ld a0,0(s0)
    0x84016c46     0x30    jal ra,ffffffff84012b0c <tcbSchedDequeue>
    0x84016c4a     0x34    ld a0,0(s0)
    0x84016c4c     0x36    jal ra,ffffffff84012a22 <tcbSchedAppend>
    0x84016c50     0x3a    jal ra,ffffffff840125d4 <rescheduleRequired>
    0x84016c54     0x3e    j ffffffff84016d48 <handleSyscall+0x132>
    0x84016c56     0x40    li a5,-2
    0x84016c58     0x42    beq a0,a5,ffffffff84016d60 <handleSyscall+0x14a>
    0x84016c5c     0x46    li a5,-1
    0x84016c5e     0x48    bne a0,a5,ffffffff84016c8e <handleSyscall+0x78>
    0x84016c62     0x4c    li a1,1
    0x84016c64     0x4e    li a0,1
    0x84016c66     0x50    jal ra,ffffffff84016afe <handleInvocation>
    0x84016c6a     0x54    beqz a0,ffffffff84016d48 <handleSyscall+0x132>
    0x84016c6e     0x58    auipc a4,0x14
    0x84016c72     0x5c    lw a4,-1062(a4) # ffffffff8402a848 <active_irq>
    0x84016c76     0x60    addiw a3,a4,-1
    0x84016c7a     0x64    li a5,53
    0x84016c7e     0x68    bltu a5,a3,ffffffff84016d24 <handleSyscall+0x10e>
    0x84016c82     0x6c    slli a0,a4,0x20
    0x84016c86     0x70    srli a0,a0,0x20
    0x84016c88     0x72    jal ra,ffffffff84013d1c <handleInterrupt>
    0x84016c8c     0x76    j ffffffff84016d48 <handleSyscall+0x132>
    0x84016c8e     0x78    li a5,-3
    0x84016c90     0x7a    bne a0,a5,ffffffff84016d74 <handleSyscall+0x15e>
    0x84016c94     0x7e    li a1,1
    0x84016c96     0x80    li a0,0
    0x84016c98     0x82    jal ra,ffffffff84016afe <handleInvocation>
    0x84016c9c     0x86    beqz a0,ffffffff84016d48 <handleSyscall+0x132>
    0x84016c9e     0x88    auipc a4,0x14
    0x84016ca2     0x8c    lw a4,-1110(a4) # ffffffff8402a848 <active_irq>
    0x84016ca6     0x90    addiw a3,a4,-1
    0x84016caa     0x94    li a5,53
    0x84016cae     0x98    bltu a5,a3,ffffffff84016cbe <handleSyscall+0xa8>
    0x84016cb2     0x9c    slli a0,a4,0x20
    0x84016cb6     0xa0    srli a0,a0,0x20
    0x84016cb8     0xa2    jal ra,ffffffff84013d1c <handleInterrupt>
    0x84016cbc     0xa6    j ffffffff84016d48 <handleSyscall+0x132>
    0x84016cbe     0xa8    jal ra,ffffffff840101a4 <getNewActiveIRQ>
    0x84016cc2     0xac    sext.w a4,a0
    0x84016cc6     0xb0    auipc a5,0x14
    0x84016cca     0xb4    sw a0,-1150(a5) # ffffffff8402a848 <active_irq>
    0x84016cce     0xb8    addiw a5,a0,-1
    0x84016cd2     0xbc    li a3,53
    0x84016cd6     0xc0    bltu a3,a5,ffffffff84016d48 <handleSyscall+0x132>
    0x84016cda     0xc4    j ffffffff84016cb2 <handleSyscall+0x9c>
    0x84016cdc     0xc6    li a1,0
    0x84016cde     0xc8    li a0,0
    0x84016ce0     0xca    jal ra,ffffffff84016afe <handleInvocation>
    0x84016ce4     0xce    beqz a0,ffffffff84016d48 <handleSyscall+0x132>
    0x84016ce6     0xd0    auipc a4,0x14
    0x84016cea     0xd4    lw a4,-1182(a4) # ffffffff8402a848 <active_irq>
    0x84016cee     0xd8    addiw a3,a4,-1
    0x84016cf2     0xdc    li a5,53
    0x84016cf6     0xe0    bltu a5,a3,ffffffff84016d06 <handleSyscall+0xf0>
    0x84016cfa     0xe4    slli a0,a4,0x20
    0x84016cfe     0xe8    srli a0,a0,0x20
    0x84016d00     0xea    jal ra,ffffffff84013d1c <handleInterrupt>
    0x84016d04     0xee    j ffffffff84016d48 <handleSyscall+0x132>
    0x84016d06     0xf0    jal ra,ffffffff840101a4 <getNewActiveIRQ>
    0x84016d0a     0xf4    sext.w a4,a0
    0x84016d0e     0xf8    auipc a5,0x14
    0x84016d12     0xfc    sw a0,-1222(a5) # ffffffff8402a848 <active_irq>
    0x84016d16    0x100    addiw a5,a0,-1
    0x84016d1a    0x104    li a3,53
    0x84016d1e    0x108    bltu a3,a5,ffffffff84016d48 <handleSyscall+0x132>
    0x84016d22    0x10c    j ffffffff84016cfa <handleSyscall+0xe4>
    0x84016d24    0x10e    jal ra,ffffffff840101a4 <getNewActiveIRQ>
    0x84016d28    0x112    sext.w a4,a0
    0x84016d2c    0x116    auipc a5,0x14
    0x84016d30    0x11a    sw a0,-1252(a5) # ffffffff8402a848 <active_irq>
    0x84016d34    0x11e    addiw a5,a0,-1
    0x84016d38    0x122    li a3,53
    0x84016d3c    0x126    bltu a3,a5,ffffffff84016d48 <handleSyscall+0x132>
    0x84016d40    0x12a    j ffffffff84016c82 <handleSyscall+0x6c>
    0x84016d42    0x12c    li a0,1
    0x84016d44    0x12e    jal ra,ffffffff840147c8 <handleRecv>
    0x84016d48    0x132    jal ra,ffffffff84012cf4 <schedule>
    0x84016d4c    0x136    jal ra,ffffffff84012744 <activateThread>
    0x84016d50    0x13a    li a0,0
    0x84016d52    0x13c    ld ra,8(sp)           ; stack access
    0x84016d54    0x13e    ld s0,0(sp)           ; stack access
    0x84016d56    0x140    addi sp,sp,16
    0x84016d58    0x142    ret
    0x84016d5a    0x144    jal ra,ffffffff84014258 <handleReply>
    0x84016d5e    0x148    j ffffffff84016d48 <handleSyscall+0x132>
    0x84016d60    0x14a    jal ra,ffffffff84014258 <handleReply>
    0x84016d64    0x14e    li a0,1
    0x84016d66    0x150    jal ra,ffffffff840147c8 <handleRecv>
    0x84016d6a    0x154    j ffffffff84016d48 <handleSyscall+0x132>
    0x84016d6c    0x156    li a0,0
    0x84016d6e    0x158    jal ra,ffffffff840147c8 <handleRecv>
    0x84016d72    0x15c    j ffffffff84016d48 <handleSyscall+0x132>
    0x84016d74    0x15e    jal ra,ffffffff8401041e <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
109 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleSyscall` has 178 nodes.

Section decodeInvocation (267 of 271)
=====================================

Deriving specifications
-----------------------

Section `decodeInvocation` consists of 183 instructions.


Stack analysis
---------------

28 stack accesses found. Annotated code for `decodeInvocation`:

    0x8401690a      0x0    addi sp,sp,-96
    0x8401690c      0x2    sd ra,88(sp)          ; stack access
    0x8401690e      0x4    sd s0,80(sp)          ; stack access
    0x84016910      0x6    sd s1,72(sp)          ; stack access
    0x84016912      0x8    sd s2,64(sp)          ; stack access
    0x84016914      0xa    sd s3,56(sp)          ; stack access
    0x84016916      0xc    sd s4,48(sp)          ; stack access
    0x84016918      0xe    sd s5,40(sp)          ; stack access
    0x8401691a     0x10    mv s3,a3
    0x8401691c     0x12    sd a4,0(sp)           ; stack access
    0x8401691e     0x14    sd a5,8(sp)           ; stack access
    0x84016920     0x16    mv s1,a4
    0x84016922     0x18    mv s2,a5
    0x84016924     0x1a    srli t1,a4,0x3b
    0x84016928     0x1e    andi s0,t1,1
    0x8401692c     0x22    bnez s0,ffffffff8401697a <decodeInvocation+0x70>
    0x8401692e     0x24    mv s4,a6
    0x84016930     0x26    mv s5,a7
    0x84016932     0x28    li a5,10
    0x84016934     0x2a    beq t1,a5,ffffffff84016ade <decodeInvocation+0x1d4>
    0x84016938     0x2e    bltu a5,t1,ffffffff840169b2 <decodeInvocation+0xa8>
    0x8401693c     0x32    li a5,4
    0x8401693e     0x34    beq t1,a5,ffffffff84016a16 <decodeInvocation+0x10c>
    0x84016942     0x38    bgeu a5,t1,ffffffff84016996 <decodeInvocation+0x8c>
    0x84016946     0x3c    li a5,6
    0x84016948     0x3e    beq t1,a5,ffffffff84016a70 <decodeInvocation+0x166>
    0x8401694c     0x42    li a5,8
    0x8401694e     0x44    bne t1,a5,ffffffff84016afa <decodeInvocation+0x1f0>
    0x84016952     0x48    andi a5,a4,1
    0x84016956     0x4c    bnez a5,ffffffff84016ab6 <decodeInvocation+0x1ac>
    0x8401695a     0x50    li a1,2
    0x8401695c     0x52    auipc a0,0x14
    0x84016960     0x56    ld a0,-292(a0) # ffffffff8402a838 <ksCurThread>
    0x84016964     0x5a    jal ra,ffffffff8401263a <setThreadState>
    0x84016968     0x5e    srli s1,s1,0x1
    0x8401696a     0x60    andi a2,s1,1
    0x8401696e     0x64    mv a1,s3
    0x84016970     0x66    mv a0,s2
    0x84016972     0x68    jal ra,ffffffff84014296 <performInvocation_Reply>
    0x84016976     0x6c    mv s0,a0
    0x84016978     0x6e    j ffffffff84016982 <decodeInvocation+0x78>
    0x8401697a     0x70    ld a6,96(sp)          ; stack access
    0x8401697c     0x72    jal ra,ffffffff84015c08 <decodeRISCVMMUInvocation>
    0x84016980     0x76    mv s0,a0
    0x84016982     0x78    mv a0,s0
    0x84016984     0x7a    ld ra,88(sp)          ; stack access
    0x84016986     0x7c    ld s0,80(sp)          ; stack access
    0x84016988     0x7e    ld s1,72(sp)          ; stack access
    0x8401698a     0x80    ld s2,64(sp)          ; stack access
    0x8401698c     0x82    ld s3,56(sp)          ; stack access
    0x8401698e     0x84    ld s4,48(sp)          ; stack access
    0x84016990     0x86    ld s5,40(sp)          ; stack access
    0x84016992     0x88    addi sp,sp,96
    0x84016994     0x8a    ret
    0x84016996     0x8c    beqz t1,ffffffff840169ea <decodeInvocation+0xe0>
    0x8401699a     0x90    li a5,2
    0x8401699c     0x92    bne t1,a5,ffffffff84016afa <decodeInvocation+0x1f0>
    0x840169a0     0x96    ld a6,96(sp)          ; stack access
    0x840169a2     0x98    mv a5,a7
    0x840169a4     0x9a    ld a3,0(sp)           ; stack access
    0x840169a6     0x9c    ld a4,8(sp)           ; stack access
    0x840169a8     0x9e    mv a2,s3
    0x840169aa     0xa0    jal ra,ffffffff840165f6 <decodeUntypedInvocation>
    0x840169ae     0xa4    mv s0,a0
    0x840169b0     0xa6    j ffffffff84016982 <decodeInvocation+0x78>
    0x840169b2     0xa8    li a5,16
    0x840169b4     0xaa    beq t1,a5,ffffffff84016aec <decodeInvocation+0x1e2>
    0x840169b8     0xae    bgeu a5,t1,ffffffff840169d2 <decodeInvocation+0xc8>
    0x840169bc     0xb2    li a5,18
    0x840169be     0xb4    beq t1,a5,ffffffff84016a00 <decodeInvocation+0xf6>
    0x840169c2     0xb8    li a5,20
    0x840169c4     0xba    bne t1,a5,ffffffff84016afa <decodeInvocation+0x1f0>
    0x840169c8     0xbe    ld a2,96(sp)          ; stack access
    0x840169ca     0xc0    jal ra,ffffffff8401492a <decodeDomainInvocation>
    0x840169ce     0xc4    mv s0,a0
    0x840169d0     0xc6    j ffffffff84016982 <decodeInvocation+0x78>
    0x840169d2     0xc8    li a5,12
    0x840169d4     0xca    beq t1,a5,ffffffff84016acc <decodeInvocation+0x1c2>
    0x840169d8     0xce    li a5,14
    0x840169da     0xd0    bne t1,a5,ffffffff84016afa <decodeInvocation+0x1f0>
    0x840169de     0xd4    ld a3,96(sp)          ; stack access
    0x840169e0     0xd6    mv a2,s3
    0x840169e2     0xd8    jal ra,ffffffff84012780 <decodeIRQControlInvocation>
    0x840169e6     0xdc    mv s0,a0
    0x840169e8     0xde    j ffffffff84016982 <decodeInvocation+0x78>
    0x840169ea     0xe0    auipc a5,0x1
    0x840169ee     0xe4    addi a5,a5,1558 # ffffffff84018000 <riscvKSASIDTable>
    0x840169f2     0xe8    li a4,2
    0x840169f4     0xea    sd a4,1744(a5)
    0x840169f8     0xee    sd zero,1704(a5)
    0x840169fc     0xf2    li s0,3
    0x840169fe     0xf4    j ffffffff84016982 <decodeInvocation+0x78>
    0x84016a00     0xf6    auipc a5,0x1
    0x84016a04     0xfa    addi a5,a5,1536 # ffffffff84018000 <riscvKSASIDTable>
    0x84016a08     0xfe    li a4,2
    0x84016a0a    0x100    sd a4,1744(a5)
    0x84016a0e    0x104    sd zero,1704(a5)
    0x84016a12    0x108    li s0,3
    0x84016a14    0x10a    j ffffffff84016982 <decodeInvocation+0x78>
    0x84016a16    0x10c    srli a5,a4,0x37
    0x84016a1a    0x110    andi a5,a5,1
    0x84016a1c    0x112    beqz a5,ffffffff84016a5a <decodeInvocation+0x150>
    0x84016a1e    0x114    li a1,2
    0x84016a20    0x116    auipc a0,0x14
    0x84016a24    0x11a    ld a0,-488(a0) # ffffffff8402a838 <ksCurThread>
    0x84016a28    0x11e    jal ra,ffffffff8401263a <setThreadState>
    0x84016a2c    0x122    slli a0,s1,0x19
    0x84016a30    0x126    srli a0,a0,0x19
    0x84016a32    0x128    srli a5,s1,0x26
    0x84016a36    0x12c    andi a5,a5,1
    0x84016a38    0x12e    beqz a5,ffffffff84016a40 <decodeInvocation+0x136>
    0x84016a3a    0x130    li a5,-1
    0x84016a3c    0x132    slli a5,a5,0x27
    0x84016a3e    0x134    or a0,a0,a5
    0x84016a40    0x136    srli a3,s1,0x3a
    0x84016a44    0x13a    srli a2,s1,0x39
    0x84016a48    0x13e    mv a5,s5
    0x84016a4a    0x140    mv a4,s4
    0x84016a4c    0x142    andi a3,a3,1
    0x84016a4e    0x144    andi a2,a2,1
    0x84016a50    0x146    mv a1,s2
    0x84016a52    0x148    jal ra,ffffffff84014606 <performInvocation_Endpoint>
    0x84016a56    0x14c    mv s0,a0
    0x84016a58    0x14e    j ffffffff84016982 <decodeInvocation+0x78>
    0x84016a5a    0x150    auipc a5,0x1
    0x84016a5e    0x154    addi a5,a5,1446 # ffffffff84018000 <riscvKSASIDTable>
    0x84016a62    0x158    li a4,2
    0x84016a64    0x15a    sd a4,1744(a5)
    0x84016a68    0x15e    sd zero,1704(a5)
    0x84016a6c    0x162    li s0,3
    0x84016a6e    0x164    j ffffffff84016982 <decodeInvocation+0x78>
    0x84016a70    0x166    srli a5,a4,0x39
    0x84016a74    0x16a    andi a5,a5,1
    0x84016a76    0x16c    beqz a5,ffffffff84016aa0 <decodeInvocation+0x196>
    0x84016a78    0x16e    li a1,2
    0x84016a7a    0x170    auipc a0,0x14
    0x84016a7e    0x174    ld a0,-578(a0) # ffffffff8402a838 <ksCurThread>
    0x84016a82    0x178    jal ra,ffffffff8401263a <setThreadState>
    0x84016a86    0x17c    slli a0,s1,0x19
    0x84016a8a    0x180    srli a0,a0,0x19
    0x84016a8c    0x182    srli s1,s1,0x26
    0x84016a8e    0x184    andi s1,s1,1
    0x84016a90    0x186    beqz s1,ffffffff84016a98 <decodeInvocation+0x18e>
    0x84016a92    0x188    li a5,-1
    0x84016a94    0x18a    slli a5,a5,0x27
    0x84016a96    0x18c    or a0,a0,a5
    0x84016a98    0x18e    mv a1,s2
    0x84016a9a    0x190    jal ra,ffffffff84013c24 <sendSignal>
    0x84016a9e    0x194    j ffffffff84016982 <decodeInvocation+0x78>
    0x84016aa0    0x196    auipc a5,0x1
    0x84016aa4    0x19a    addi a5,a5,1376 # ffffffff84018000 <riscvKSASIDTable>
    0x84016aa8    0x19e    li a4,2
    0x84016aaa    0x1a0    sd a4,1744(a5)
    0x84016aae    0x1a4    sd zero,1704(a5)
    0x84016ab2    0x1a8    li s0,3
    0x84016ab4    0x1aa    j ffffffff84016982 <decodeInvocation+0x78>
    0x84016ab6    0x1ac    auipc a5,0x1
    0x84016aba    0x1b0    addi a5,a5,1354 # ffffffff84018000 <riscvKSASIDTable>
    0x84016abe    0x1b4    li a4,2
    0x84016ac0    0x1b6    sd a4,1744(a5)
    0x84016ac4    0x1ba    sd zero,1704(a5)
    0x84016ac8    0x1be    li s0,3
    0x84016aca    0x1c0    j ffffffff84016982 <decodeInvocation+0x78>
    0x84016acc    0x1c2    ld a6,96(sp)          ; stack access
    0x84016ace    0x1c4    mv a5,a7
    0x84016ad0    0x1c6    mv a4,a3
    0x84016ad2    0x1c8    ld a2,0(sp)           ; stack access
    0x84016ad4    0x1ca    ld a3,8(sp)           ; stack access
    0x84016ad6    0x1cc    jal ra,ffffffff84015830 <decodeTCBInvocation>
    0x84016ada    0x1d0    mv s0,a0
    0x84016adc    0x1d2    j ffffffff84016982 <decodeInvocation+0x78>
    0x84016ade    0x1d4    ld a4,96(sp)          ; stack access
    0x84016ae0    0x1d6    ld a2,0(sp)           ; stack access
    0x84016ae2    0x1d8    ld a3,8(sp)           ; stack access
    0x84016ae4    0x1da    jal ra,ffffffff8401359e <decodeCNodeInvocation>
    0x84016ae8    0x1de    mv s0,a0
    0x84016aea    0x1e0    j ffffffff84016982 <decodeInvocation+0x78>
    0x84016aec    0x1e2    slli a1,s2,0x34
    0x84016af0    0x1e6    srli a1,a1,0x34
    0x84016af2    0x1e8    jal ra,ffffffff84013b00 <decodeIRQHandlerInvocation>
    0x84016af6    0x1ec    mv s0,a0
    0x84016af8    0x1ee    j ffffffff84016982 <decodeInvocation+0x78>
    0x84016afa    0x1f0    jal ra,ffffffff8401041e <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
183 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeInvocation` has 279 nodes.

Section decodeRISCVMMUInvocation (268 of 271)
=============================================

Deriving specifications
-----------------------

Section `decodeRISCVMMUInvocation` consists of 768 instructions.

Skipping 12000073 sfence.vma

Skipping 12000073 sfence.vma


Stack analysis
---------------

56 stack accesses found. Annotated code for `decodeRISCVMMUInvocation`:

    0x84015c08      0x0    addi sp,sp,-208
    0x84015c0a      0x2    sd ra,200(sp)         ; stack access
    0x84015c0c      0x4    sd s0,192(sp)         ; stack access
    0x84015c0e      0x6    sd s1,184(sp)         ; stack access
    0x84015c10      0x8    sd s2,176(sp)         ; stack access
    0x84015c12      0xa    sd s3,168(sp)         ; stack access
    0x84015c14      0xc    sd s4,160(sp)         ; stack access
    0x84015c16      0xe    sd s5,152(sp)         ; stack access
    0x84015c18     0x10    sd s6,144(sp)         ; stack access
    0x84015c1a     0x12    sd s7,136(sp)         ; stack access
    0x84015c1c     0x14    sd s8,128(sp)         ; stack access
    0x84015c1e     0x16    sd s9,120(sp)         ; stack access
    0x84015c20     0x18    sd s10,112(sp)        ; stack access
    0x84015c22     0x1a    sd s11,104(sp)        ; stack access
    0x84015c24     0x1c    sd a4,0(sp)           ; stack access
    0x84015c26     0x1e    sd a5,8(sp)           ; stack access
    0x84015c28     0x20    mv s3,a6
    0x84015c2a     0x22    srli s0,a4,0x3b
    0x84015c2e     0x26    li a5,11
    0x84015c30     0x28    beq s0,a5,ffffffff8401623c <decodeRISCVMMUInvocation+0x634>
    0x84015c34     0x2c    mv s2,a3
    0x84015c36     0x2e    mv s1,a4
    0x84015c38     0x30    bltu a5,s0,ffffffff84015d70 <decodeRISCVMMUInvocation+0x168>
    0x84015c3c     0x34    li a5,1
    0x84015c3e     0x36    beq s0,a5,ffffffff84015eee <decodeRISCVMMUInvocation+0x2e6>
    0x84015c42     0x3a    li a5,3
    0x84015c44     0x3c    bne s0,a5,ffffffff840164ce <decodeRISCVMMUInvocation+0x8c6>
    0x84015c48     0x40    ld a5,0(sp)           ; stack access
    0x84015c4a     0x42    sd a5,16(sp)          ; stack access
    0x84015c4c     0x44    ld s4,8(sp)           ; stack access
    0x84015c4e     0x46    sd s4,24(sp)          ; stack access
    0x84015c50     0x48    li a5,31
    0x84015c52     0x4a    beq a0,a5,ffffffff84015dea <decodeRISCVMMUInvocation+0x1e2>
    0x84015c56     0x4e    li a5,30
    0x84015c58     0x50    bne a0,a5,ffffffff84015e5a <decodeRISCVMMUInvocation+0x252>
    0x84015c5c     0x54    li a5,1
    0x84015c5e     0x56    bgeu a5,a1,ffffffff84015e66 <decodeRISCVMMUInvocation+0x25e>
    0x84015c62     0x5a    auipc a4,0x3
    0x84015c66     0x5e    ld a4,-978(a4) # ffffffff84018890 <current_extra_caps>
    0x84015c6a     0x62    beqz a4,ffffffff84015e66 <decodeRISCVMMUInvocation+0x25e>
    0x84015c6e     0x66    srli a5,s1,0x27
    0x84015c72     0x6a    andi a5,a5,1
    0x84015c74     0x6c    bnez a5,ffffffff84015e72 <decodeRISCVMMUInvocation+0x26a>
    0x84015c78     0x70    ld a5,0(a4)
    0x84015c7a     0x72    srli s5,a5,0x3b
    0x84015c7e     0x76    li a3,3
    0x84015c80     0x78    bne s5,a3,ffffffff84015e86 <decodeRISCVMMUInvocation+0x27e>
    0x84015c84     0x7c    srli a5,a5,0x27
    0x84015c86     0x7e    andi a5,a5,1
    0x84015c88     0x80    beqz a5,ffffffff84015e86 <decodeRISCVMMUInvocation+0x27e>
    0x84015c8c     0x84    ld s8,8(a4)
    0x84015c90     0x88    srli a5,s8,0x9
    0x84015c94     0x8c    slli s0,a5,0x19
    0x84015c98     0x90    srli s0,s0,0x19
    0x84015c9a     0x92    srli a5,a5,0x26
    0x84015c9c     0x94    andi a5,a5,1
    0x84015c9e     0x96    beqz a5,ffffffff84015ca6 <decodeRISCVMMUInvocation+0x9e>
    0x84015ca0     0x98    li a5,-1
    0x84015ca2     0x9a    slli a5,a5,0x27
    0x84015ca4     0x9c    or s0,s0,a5
    0x84015ca6     0x9e    mv a1,s3
    0x84015ca8     0xa0    li a0,0
    0x84015caa     0xa2    jal ra,ffffffff840100ea <getSyscallArg>
    0x84015cae     0xa6    mv s6,a0
    0x84015cb0     0xa8    srli a0,s8,0x30
    0x84015cb4     0xac    lui a5,0xfefff
    0x84015cb8     0xb0    slli a5,a5,0xe
    0x84015cba     0xb2    srli a5,a5,0x1a
    0x84015cbc     0xb4    bltu a5,s6,ffffffff84015e9c <decodeRISCVMMUInvocation+0x294>
    0x84015cc0     0xb8    jal ra,ffffffff84010144 <findVSpaceForASID>
    0x84015cc4     0xbc    sd a0,64(sp)          ; stack access
    0x84015cc6     0xbe    sd a1,72(sp)          ; stack access
    0x84015cc8     0xc0    bnez a0,ffffffff84015eb2 <decodeRISCVMMUInvocation+0x2aa>
    0x84015ccc     0xc4    ld a5,72(sp)          ; stack access
    0x84015cce     0xc6    bne s0,a5,ffffffff84015ec8 <decodeRISCVMMUInvocation+0x2c0>
    0x84015cd2     0xca    mv a1,s6
    0x84015cd4     0xcc    mv a0,s0
    0x84015cd6     0xce    jal ra,ffffffff840109c6 <lookupPTSlot>
    0x84015cda     0xd2    mv s7,a0
    0x84015cdc     0xd4    mv s3,a1
    0x84015cde     0xd6    sd a0,48(sp)          ; stack access
    0x84015ce0     0xd8    sd a1,56(sp)          ; stack access
    0x84015ce2     0xda    li a5,12
    0x84015ce4     0xdc    beq a1,a5,ffffffff84015ee0 <decodeRISCVMMUInvocation+0x2d8>
    0x84015ce8     0xe0    ld s0,0(a0)
    0x84015cea     0xe2    andi s0,s0,1
    0x84015cec     0xe4    bnez s0,ffffffff84015ee0 <decodeRISCVMMUInvocation+0x2d8>
    0x84015cf0     0xe8    srli a5,s4,0x9
    0x84015cf4     0xec    slli s5,a5,0x19
    0x84015cf8     0xf0    srli s5,s5,0x19
    0x84015cfc     0xf4    srli a5,a5,0x26
    0x84015cfe     0xf6    andi a5,a5,1
    0x84015d00     0xf8    beqz a5,ffffffff84015d0a <decodeRISCVMMUInvocation+0x102>
    0x84015d02     0xfa    li a5,-1
    0x84015d04     0xfc    slli a5,a5,0x27
    0x84015d06     0xfe    or s5,s5,a5
    0x84015d0a    0x102    li s9,-1
    0x84015d0c    0x104    srli a5,s9,0x10
    0x84015d10    0x108    and s4,s4,a5
    0x84015d14    0x10c    slli a5,s9,0x30
    0x84015d18    0x110    and s8,s8,a5
    0x84015d1c    0x114    or s4,s4,s8
    0x84015d20    0x118    li a1,2
    0x84015d22    0x11a    auipc a0,0x15
    0x84015d26    0x11e    ld a0,-1258(a0) # ffffffff8402a838 <ksCurThread>
    0x84015d2a    0x122    jal ra,ffffffff8401263a <setThreadState>
    0x84015d2e    0x126    li a4,1
    0x84015d30    0x128    sll a5,a4,s3
    0x84015d34    0x12c    neg a5,a5
    0x84015d38    0x130    and a5,a5,s6
    0x84015d3c    0x134    slli s9,s9,0x28
    0x84015d3e    0x136    and s1,s1,s9
    0x84015d42    0x13a    or a5,a5,s1
    0x84015d44    0x13c    slli a3,a4,0x27
    0x84015d48    0x140    or a5,a5,a3
    0x84015d4a    0x142    sd a5,0(s2)
    0x84015d4e    0x146    sd s4,8(s2)
    0x84015d52    0x14a    slli a5,a4,0x26
    0x84015d56    0x14e    add a5,a5,s5
    0x84015d58    0x150    srli a5,a5,0x2
    0x84015d5a    0x152    lui a4,0xfff00
    0x84015d5e    0x156    srli a4,a4,0xa
    0x84015d60    0x158    and a5,a5,a4
    0x84015d62    0x15a    ori a5,a5,193
    0x84015d66    0x15e    sd a5,0(s7)
    0x84015d6a    0x162    sfence.vma
    0x84015d6e    0x166    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015d70    0x168    li a5,13
    0x84015d72    0x16a    bne s0,a5,ffffffff840164ce <decodeRISCVMMUInvocation+0x8c6>
    0x84015d76    0x16e    li a5,36
    0x84015d7a    0x172    bne a0,a5,ffffffff840163de <decodeRISCVMMUInvocation+0x7d6>
    0x84015d7e    0x176    auipc s3,0x3
    0x84015d82    0x17a    ld s3,-1262(s3) # ffffffff84018890 <current_extra_caps>
    0x84015d86    0x17e    beqz s3,ffffffff840163ec <decodeRISCVMMUInvocation+0x7e4>
    0x84015d8a    0x182    ld s2,0(s3)
    0x84015d8e    0x186    srli s0,s2,0x3b
    0x84015d92    0x18a    li a5,3
    0x84015d94    0x18c    bne s0,a5,ffffffff840163fa <decodeRISCVMMUInvocation+0x7f2>
    0x84015d98    0x190    srli s2,s2,0x27
    0x84015d9c    0x194    andi s2,s2,1
    0x84015da0    0x198    bnez s2,ffffffff840163fa <decodeRISCVMMUInvocation+0x7f2>
    0x84015da4    0x19c    srli a2,a4,0x2b
    0x84015da8    0x1a0    slli a2,a2,0x30
    0x84015daa    0x1a2    srli a2,a2,0x30
    0x84015dac    0x1a4    srli a5,a2,0x9
    0x84015db0    0x1a8    slli a4,a5,0x3
    0x84015db4    0x1ac    auipc a5,0x2
    0x84015db8    0x1b0    addi a5,a5,588 # ffffffff84018000 <riscvKSASIDTable>
    0x84015dbc    0x1b4    add a5,a5,a4
    0x84015dbe    0x1b6    ld s4,0(a5)
    0x84015dc2    0x1ba    beqz s4,ffffffff84016412 <decodeRISCVMMUInvocation+0x80a>
    0x84015dc6    0x1be    slli s1,s1,0x2
    0x84015dc8    0x1c0    lui a5,0xf8000
    0x84015dcc    0x1c4    srli a5,a5,0x19
    0x84015dce    0x1c6    and a5,a5,s1
    0x84015dd0    0x1c8    srli s1,s1,0x26
    0x84015dd2    0x1ca    andi s1,s1,1
    0x84015dd4    0x1cc    beqz s1,ffffffff84015ddc <decodeRISCVMMUInvocation+0x1d4>
    0x84015dd6    0x1ce    li a4,-1
    0x84015dd8    0x1d0    slli a4,a4,0x27
    0x84015dda    0x1d2    or a5,a5,a4
    0x84015ddc    0x1d4    bne s4,a5,ffffffff8401642e <decodeRISCVMMUInvocation+0x826>
    0x84015de0    0x1d8    mv a4,s4
    0x84015de2    0x1da    mv a5,s2
    0x84015de4    0x1dc    li a1,512
    0x84015de8    0x1e0    j ffffffff8401644a <decodeRISCVMMUInvocation+0x842>
    0x84015dea    0x1e2    mv a0,a3
    0x84015dec    0x1e4    jal ra,ffffffff840121be <isFinalCapability>
    0x84015df0    0x1e8    beqz a0,ffffffff84015e3c <decodeRISCVMMUInvocation+0x234>
    0x84015df2    0x1ea    srli a5,s1,0x27
    0x84015df6    0x1ee    andi a5,a5,1
    0x84015df8    0x1f0    beqz a5,ffffffff84015e20 <decodeRISCVMMUInvocation+0x218>
    0x84015dfa    0x1f2    srli a0,s4,0x30
    0x84015dfe    0x1f6    jal ra,ffffffff84010144 <findVSpaceForASID>
    0x84015e02    0x1fa    sd a0,64(sp)          ; stack access
    0x84015e04    0x1fc    sd a1,72(sp)          ; stack access
    0x84015e06    0x1fe    srli a5,s4,0x9
    0x84015e0a    0x202    slli a4,a5,0x19
    0x84015e0e    0x206    srli a4,a4,0x19
    0x84015e10    0x208    srli a5,a5,0x26
    0x84015e12    0x20a    andi a5,a5,1
    0x84015e14    0x20c    beqz a5,ffffffff84015e1c <decodeRISCVMMUInvocation+0x214>
    0x84015e16    0x20e    li a5,-1
    0x84015e18    0x210    slli a5,a5,0x27
    0x84015e1a    0x212    or a4,a4,a5
    0x84015e1c    0x214    ld a5,64(sp)          ; stack access
    0x84015e1e    0x216    beqz a5,ffffffff84015e48 <decodeRISCVMMUInvocation+0x240>
    0x84015e20    0x218    li a1,2
    0x84015e22    0x21a    auipc a0,0x15
    0x84015e26    0x21e    ld a0,-1514(a0) # ffffffff8402a838 <ksCurThread>
    0x84015e2a    0x222    jal ra,ffffffff8401263a <setThreadState>
    0x84015e2e    0x226    mv a2,s2
    0x84015e30    0x228    mv a0,s1
    0x84015e32    0x22a    mv a1,s4
    0x84015e34    0x22c    jal ra,ffffffff84015b9c <performPageTableInvocationUnmap>
    0x84015e38    0x230    mv s0,a0
    0x84015e3a    0x232    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015e3c    0x234    li a5,9
    0x84015e3e    0x236    auipc a4,0x3
    0x84015e42    0x23a    sd a5,-1902(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84015e46    0x23e    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015e48    0x240    ld a5,72(sp)          ; stack access
    0x84015e4a    0x242    bne a5,a4,ffffffff84015e20 <decodeRISCVMMUInvocation+0x218>
    0x84015e4e    0x246    li a5,9
    0x84015e50    0x248    auipc a4,0x3
    0x84015e54    0x24c    sd a5,-1920(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84015e58    0x250    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015e5a    0x252    li a5,3
    0x84015e5c    0x254    auipc a4,0x3
    0x84015e60    0x258    sd a5,-1932(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84015e64    0x25c    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015e66    0x25e    li a5,7
    0x84015e68    0x260    auipc a4,0x3
    0x84015e6c    0x264    sd a5,-1944(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84015e70    0x268    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015e72    0x26a    auipc a5,0x2
    0x84015e76    0x26e    addi a5,a5,398 # ffffffff84018000 <riscvKSASIDTable>
    0x84015e7a    0x272    li a4,2
    0x84015e7c    0x274    sd a4,1744(a5)
    0x84015e80    0x278    sd zero,1704(a5)
    0x84015e84    0x27c    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015e86    0x27e    auipc a5,0x2
    0x84015e8a    0x282    addi a5,a5,378 # ffffffff84018000 <riscvKSASIDTable>
    0x84015e8e    0x286    li a4,2
    0x84015e90    0x288    sd a4,1744(a5)
    0x84015e94    0x28c    li a4,1
    0x84015e96    0x28e    sd a4,1704(a5)
    0x84015e9a    0x292    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015e9c    0x294    auipc a5,0x2
    0x84015ea0    0x298    addi a5,a5,356 # ffffffff84018000 <riscvKSASIDTable>
    0x84015ea4    0x29c    li a4,1
    0x84015ea6    0x29e    sd a4,1744(a5)
    0x84015eaa    0x2a2    sd zero,1696(a5)
    0x84015eae    0x2a6    mv s0,s5
    0x84015eb0    0x2a8    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015eb2    0x2aa    auipc a5,0x2
    0x84015eb6    0x2ae    addi a5,a5,334 # ffffffff84018000 <riscvKSASIDTable>
    0x84015eba    0x2b2    li a4,6
    0x84015ebc    0x2b4    sd a4,1744(a5)
    0x84015ec0    0x2b8    sd zero,1736(a5)
    0x84015ec4    0x2bc    mv s0,s5
    0x84015ec6    0x2be    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015ec8    0x2c0    auipc a5,0x2
    0x84015ecc    0x2c4    addi a5,a5,312 # ffffffff84018000 <riscvKSASIDTable>
    0x84015ed0    0x2c8    li a4,2
    0x84015ed2    0x2ca    sd a4,1744(a5)
    0x84015ed6    0x2ce    li a4,1
    0x84015ed8    0x2d0    sd a4,1704(a5)
    0x84015edc    0x2d4    mv s0,s5
    0x84015ede    0x2d6    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015ee0    0x2d8    li a5,8
    0x84015ee2    0x2da    auipc a4,0x2
    0x84015ee6    0x2de    sd a5,2030(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84015eea    0x2e2    mv s0,s5
    0x84015eec    0x2e4    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015eee    0x2e6    ld a5,0(sp)           ; stack access
    0x84015ef0    0x2e8    sd a5,32(sp)          ; stack access
    0x84015ef2    0x2ea    ld s4,8(sp)           ; stack access
    0x84015ef4    0x2ec    sd s4,40(sp)          ; stack access
    0x84015ef6    0x2ee    li a5,33
    0x84015efa    0x2f2    beq a0,a5,ffffffff840161de <decodeRISCVMMUInvocation+0x5d6>
    0x84015efe    0x2f6    li a5,34
    0x84015f02    0x2fa    beq a0,a5,ffffffff840161fa <decodeRISCVMMUInvocation+0x5f2>
    0x84015f06    0x2fe    li a5,32
    0x84015f0a    0x302    beq a0,a5,ffffffff84015f1c <decodeRISCVMMUInvocation+0x314>
    0x84015f0e    0x306    li a5,3
    0x84015f10    0x308    auipc a4,0x2
    0x84015f14    0x30c    sd a5,1984(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84015f18    0x310    li s0,3
    0x84015f1a    0x312    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015f1c    0x314    li a5,2
    0x84015f1e    0x316    bgeu a5,a1,ffffffff84015fa8 <decodeRISCVMMUInvocation+0x3a0>
    0x84015f22    0x31a    auipc a4,0x3
    0x84015f26    0x31e    ld a4,-1682(a4) # ffffffff84018890 <current_extra_caps>
    0x84015f2a    0x322    beqz a4,ffffffff84015fa8 <decodeRISCVMMUInvocation+0x3a0>
    0x84015f2c    0x324    ld a5,0(a4)
    0x84015f2e    0x326    srli s8,a5,0x3b
    0x84015f32    0x32a    li a3,3
    0x84015f34    0x32c    bne s8,a3,ffffffff84015fb6 <decodeRISCVMMUInvocation+0x3ae>
    0x84015f38    0x330    srli a5,a5,0x27
    0x84015f3a    0x332    andi a5,a5,1
    0x84015f3c    0x334    beqz a5,ffffffff84015fb6 <decodeRISCVMMUInvocation+0x3ae>
    0x84015f3e    0x336    ld s7,8(a4)
    0x84015f42    0x33a    srli a5,s7,0x9
    0x84015f46    0x33e    slli s0,a5,0x19
    0x84015f4a    0x342    srli s0,s0,0x19
    0x84015f4c    0x344    srli a5,a5,0x26
    0x84015f4e    0x346    andi a5,a5,1
    0x84015f50    0x348    beqz a5,ffffffff84015f58 <decodeRISCVMMUInvocation+0x350>
    0x84015f52    0x34a    li a5,-1
    0x84015f54    0x34c    slli a5,a5,0x27
    0x84015f56    0x34e    or s0,s0,a5
    0x84015f58    0x350    mv a1,s3
    0x84015f5a    0x352    li a0,0
    0x84015f5c    0x354    jal ra,ffffffff840100ea <getSyscallArg>
    0x84015f60    0x358    mv s5,a0
    0x84015f62    0x35a    mv a1,s3
    0x84015f64    0x35c    li a0,1
    0x84015f66    0x35e    jal ra,ffffffff840100ea <getSyscallArg>
    0x84015f6a    0x362    mv s9,a0
    0x84015f6c    0x364    mv a1,s3
    0x84015f6e    0x366    li a0,2
    0x84015f70    0x368    jal ra,ffffffff840100ea <getSyscallArg>
    0x84015f74    0x36c    mv s6,a0
    0x84015f76    0x36e    mv s3,s0
    0x84015f78    0x370    srli s11,s7,0x30
    0x84015f7c    0x374    mv a0,s11
    0x84015f7e    0x376    jal ra,ffffffff84010144 <findVSpaceForASID>
    0x84015f82    0x37a    sd a0,48(sp)          ; stack access
    0x84015f84    0x37c    sd a1,56(sp)          ; stack access
    0x84015f86    0x37e    bnez a0,ffffffff84015fce <decodeRISCVMMUInvocation+0x3c6>
    0x84015f88    0x380    ld a5,56(sp)          ; stack access
    0x84015f8a    0x382    bne s0,a5,ffffffff84015fe4 <decodeRISCVMMUInvocation+0x3dc>
    0x84015f8e    0x386    srli a5,s1,0x39
    0x84015f92    0x38a    andi a5,a5,3
    0x84015f94    0x38c    li a4,1
    0x84015f96    0x38e    beq a5,a4,ffffffff84015ffc <decodeRISCVMMUInvocation+0x3f4>
    0x84015f9a    0x392    li a4,2
    0x84015f9c    0x394    beq a5,a4,ffffffff84016000 <decodeRISCVMMUInvocation+0x3f8>
    0x84015fa0    0x398    beqz a5,ffffffff840160fe <decodeRISCVMMUInvocation+0x4f6>
    0x84015fa4    0x39c    jal ra,ffffffff8401041e <halt>
    0x84015fa8    0x3a0    li a5,7
    0x84015faa    0x3a2    auipc a4,0x2
    0x84015fae    0x3a6    sd a5,1830(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84015fb2    0x3aa    li s0,3
    0x84015fb4    0x3ac    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015fb6    0x3ae    auipc a5,0x2
    0x84015fba    0x3b2    addi a5,a5,74 # ffffffff84018000 <riscvKSASIDTable>
    0x84015fbe    0x3b6    li a4,2
    0x84015fc0    0x3b8    sd a4,1744(a5)
    0x84015fc4    0x3bc    li a4,1
    0x84015fc6    0x3be    sd a4,1704(a5)
    0x84015fca    0x3c2    li s0,3
    0x84015fcc    0x3c4    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015fce    0x3c6    auipc a5,0x2
    0x84015fd2    0x3ca    addi a5,a5,50 # ffffffff84018000 <riscvKSASIDTable>
    0x84015fd6    0x3ce    li a4,6
    0x84015fd8    0x3d0    sd a4,1744(a5)
    0x84015fdc    0x3d4    sd zero,1736(a5)
    0x84015fe0    0x3d8    mv s0,s8
    0x84015fe2    0x3da    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015fe4    0x3dc    auipc a5,0x2
    0x84015fe8    0x3e0    addi a5,a5,28 # ffffffff84018000 <riscvKSASIDTable>
    0x84015fec    0x3e4    li a4,2
    0x84015fee    0x3e6    sd a4,1744(a5)
    0x84015ff2    0x3ea    li a4,1
    0x84015ff4    0x3ec    sd a4,1704(a5)
    0x84015ff8    0x3f0    mv s0,s8
    0x84015ffa    0x3f2    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84015ffc    0x3f4    li s10,21
    0x84015ffe    0x3f6    j ffffffff84016002 <decodeRISCVMMUInvocation+0x3fa>
    0x84016000    0x3f8    li s10,30
    0x84016002    0x3fa    sext.w a3,s10
    0x84016006    0x3fe    addi a4,s5,-1
    0x8401600a    0x402    li a5,1
    0x8401600c    0x404    sll a5,a5,s10
    0x84016010    0x408    add a4,a4,a5
    0x84016012    0x40a    lui a5,0xfefff
    0x84016016    0x40e    slli a5,a5,0xe
    0x84016018    0x410    srli a5,a5,0x1a
    0x8401601a    0x412    bltu a5,a4,ffffffff84016102 <decodeRISCVMMUInvocation+0x4fa>
    0x8401601e    0x416    li s0,-1
    0x84016020    0x418    sll s0,s0,a3
    0x84016024    0x41c    not s0,s0
    0x84016028    0x420    and s0,s0,s5
    0x8401602c    0x424    bnez s0,ffffffff84016118 <decodeRISCVMMUInvocation+0x510>
    0x8401602e    0x426    mv a1,s5
    0x84016030    0x428    mv a0,s3
    0x84016032    0x42a    jal ra,ffffffff840109c6 <lookupPTSlot>
    0x84016036    0x42e    mv s3,a0
    0x84016038    0x430    sd a0,64(sp)          ; stack access
    0x8401603a    0x432    sd a1,72(sp)          ; stack access
    0x8401603c    0x434    bne a1,s10,ffffffff84016126 <decodeRISCVMMUInvocation+0x51e>
    0x84016040    0x438    srli a5,s4,0x30
    0x84016044    0x43c    bnez a5,ffffffff84016150 <decodeRISCVMMUInvocation+0x548>
    0x84016048    0x440    ld a5,0(a0)
    0x8401604a    0x442    andi a5,a5,1
    0x8401604c    0x444    bnez a5,ffffffff840161c8 <decodeRISCVMMUInvocation+0x5c0>
    0x84016050    0x448    srli a0,s1,0x37
    0x84016054    0x44c    mv a1,s9
    0x84016056    0x44e    andi a0,a0,3
    0x84016058    0x450    jal ra,ffffffff84010da6 <maskVMRights>
    0x8401605c    0x454    srli a4,s4,0x9
    0x84016060    0x458    slli a5,a4,0x19
    0x84016064    0x45c    srli a5,a5,0x19
    0x84016066    0x45e    srli a4,a4,0x26
    0x84016068    0x460    andi a4,a4,1
    0x8401606a    0x462    beqz a4,ffffffff84016072 <decodeRISCVMMUInvocation+0x46a>
    0x8401606c    0x464    li a4,-1
    0x8401606e    0x466    slli a4,a4,0x27
    0x84016070    0x468    or a5,a5,a4
    0x84016072    0x46a    li a1,1
    0x84016074    0x46c    slli a4,a1,0x26
    0x84016078    0x470    add a5,a5,a4
    0x8401607a    0x472    li a4,-1
    0x8401607c    0x474    srli a3,a4,0x10
    0x84016080    0x478    and s4,s4,a3
    0x84016084    0x47c    slli a3,a4,0x30
    0x84016088    0x480    and s7,s7,a3
    0x8401608c    0x484    or s4,s4,s7
    0x84016090    0x488    slli a3,a4,0x27
    0x84016094    0x48c    and s1,s1,a3
    0x84016096    0x48e    srli a4,a4,0x19
    0x84016098    0x490    and s5,s5,a4
    0x8401609c    0x494    or s5,s1,s5
    0x840160a0    0x498    andi s6,s6,1
    0x840160a4    0x49c    xori a2,s6,1
    0x840160a8    0x4a0    addi a3,a0,-3
    0x840160ac    0x4a4    seqz a3,a3
    0x840160b0    0x4a8    addi a4,a0,-1
    0x840160b4    0x4ac    snez a4,a4
    0x840160b8    0x4b0    beq a0,a1,ffffffff840161d6 <decodeRISCVMMUInvocation+0x5ce>
    0x840160bc    0x4b4    srli s1,a5,0x2
    0x840160c0    0x4b8    lui a5,0xfff00
    0x840160c4    0x4bc    srli a5,a5,0xa
    0x840160c6    0x4be    and s1,s1,a5
    0x840160c8    0x4c0    slli a5,a2,0x3
    0x840160cc    0x4c4    or s1,s1,a5
    0x840160ce    0x4c6    slli a5,a3,0x2
    0x840160d2    0x4ca    or s1,s1,a5
    0x840160d4    0x4cc    slli a5,a4,0x1
    0x840160d8    0x4d0    or s1,s1,a5
    0x840160da    0x4d2    ori s1,s1,209
    0x840160de    0x4d6    li a1,2
    0x840160e0    0x4d8    auipc a0,0x14
    0x840160e4    0x4dc    ld a0,1880(a0) # ffffffff8402a838 <ksCurThread>
    0x840160e8    0x4e0    jal ra,ffffffff8401263a <setThreadState>
    0x840160ec    0x4e4    sd s5,0(s2)
    0x840160f0    0x4e8    sd s4,8(s2)
    0x840160f4    0x4ec    sd s1,0(s3)
    0x840160f8    0x4f0    sfence.vma
    0x840160fc    0x4f4    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x840160fe    0x4f6    li s10,12
    0x84016100    0x4f8    j ffffffff84016002 <decodeRISCVMMUInvocation+0x3fa>
    0x84016102    0x4fa    auipc a5,0x2
    0x84016106    0x4fe    addi a5,a5,-258 # ffffffff84018000 <riscvKSASIDTable>
    0x8401610a    0x502    li a4,1
    0x8401610c    0x504    sd a4,1744(a5)
    0x84016110    0x508    sd zero,1696(a5)
    0x84016114    0x50c    mv s0,s8
    0x84016116    0x50e    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84016118    0x510    li a5,5
    0x8401611a    0x512    auipc a4,0x2
    0x8401611e    0x516    sd a5,1462(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84016122    0x51a    mv s0,s8
    0x84016124    0x51c    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84016126    0x51e    auipc a4,0x2
    0x8401612a    0x522    addi a4,a4,-294 # ffffffff84018000 <riscvKSASIDTable>
    0x8401612e    0x526    slli a5,a1,0x2
    0x84016132    0x52a    andi a5,a5,508
    0x84016136    0x52e    ori a5,a5,1
    0x8401613a    0x532    sd a5,1024(a4)
    0x8401613e    0x536    sd zero,1032(a4)
    0x84016142    0x53a    li a5,6
    0x84016144    0x53c    sd a5,1744(a4)
    0x84016148    0x540    sd zero,1736(a4)
    0x8401614c    0x544    mv s0,s8
    0x8401614e    0x546    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84016150    0x548    beq s11,a5,ffffffff8401616c <decodeRISCVMMUInvocation+0x564>
    0x84016154    0x54c    auipc a5,0x2
    0x84016158    0x550    addi a5,a5,-340 # ffffffff84018000 <riscvKSASIDTable>
    0x8401615c    0x554    li a4,2
    0x8401615e    0x556    sd a4,1744(a5)
    0x84016162    0x55a    li a4,1
    0x84016164    0x55c    sd a4,1704(a5)
    0x84016168    0x560    mv s0,s8
    0x8401616a    0x562    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x8401616c    0x564    slli a5,s1,0x19
    0x84016170    0x568    srli a5,a5,0x19
    0x84016172    0x56a    srli a4,s1,0x26
    0x84016176    0x56e    andi a4,a4,1
    0x84016178    0x570    beqz a4,ffffffff84016180 <decodeRISCVMMUInvocation+0x578>
    0x8401617a    0x572    li a4,-1
    0x8401617c    0x574    slli a4,a4,0x27
    0x8401617e    0x576    or a5,a5,a4
    0x84016180    0x578    bne s5,a5,ffffffff840161b2 <decodeRISCVMMUInvocation+0x5aa>
    0x84016184    0x57c    ld a4,0(s3)
    0x84016188    0x580    andi a5,a4,1
    0x8401618c    0x584    beqz a5,ffffffff84016050 <decodeRISCVMMUInvocation+0x448>
    0x84016190    0x588    srli a5,a4,0x1
    0x84016194    0x58c    srli a3,a4,0x2
    0x84016198    0x590    or a5,a5,a3
    0x8401619a    0x592    srli a4,a4,0x3
    0x8401619c    0x594    or a5,a5,a4
    0x8401619e    0x596    andi a5,a5,1
    0x840161a0    0x598    bnez a5,ffffffff84016050 <decodeRISCVMMUInvocation+0x448>
    0x840161a4    0x59c    li a5,8
    0x840161a6    0x59e    auipc a4,0x2
    0x840161aa    0x5a2    sd a5,1322(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840161ae    0x5a6    mv s0,s8
    0x840161b0    0x5a8    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x840161b2    0x5aa    auipc a5,0x2
    0x840161b6    0x5ae    addi a5,a5,-434 # ffffffff84018000 <riscvKSASIDTable>
    0x840161ba    0x5b2    li a4,1
    0x840161bc    0x5b4    sd a4,1744(a5)
    0x840161c0    0x5b8    sd zero,1696(a5)
    0x840161c4    0x5bc    mv s0,s8
    0x840161c6    0x5be    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x840161c8    0x5c0    li a5,8
    0x840161ca    0x5c2    auipc a4,0x2
    0x840161ce    0x5c6    sd a5,1286(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840161d2    0x5ca    mv s0,s8
    0x840161d4    0x5cc    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x840161d6    0x5ce    beqz s6,ffffffff840160bc <decodeRISCVMMUInvocation+0x4b4>
    0x840161da    0x5d2    mv s1,s0
    0x840161dc    0x5d4    j ffffffff840160de <decodeRISCVMMUInvocation+0x4d6>
    0x840161de    0x5d6    li a1,2
    0x840161e0    0x5d8    auipc a0,0x14
    0x840161e4    0x5dc    ld a0,1624(a0) # ffffffff8402a838 <ksCurThread>
    0x840161e8    0x5e0    jal ra,ffffffff8401263a <setThreadState>
    0x840161ec    0x5e4    mv a2,s2
    0x840161ee    0x5e6    mv a0,s1
    0x840161f0    0x5e8    mv a1,s4
    0x840161f2    0x5ea    jal ra,ffffffff84010dfe <performPageInvocationUnmap>
    0x840161f6    0x5ee    mv s0,a0
    0x840161f8    0x5f0    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x840161fa    0x5f2    li a1,2
    0x840161fc    0x5f4    auipc a0,0x14
    0x84016200    0x5f8    ld a0,1596(a0) # ffffffff8402a838 <ksCurThread>
    0x84016204    0x5fc    jal ra,ffffffff8401263a <setThreadState>
    0x84016208    0x600    srli s4,s4,0x9
    0x8401620c    0x604    slli a5,s4,0x19
    0x84016210    0x608    srli a5,a5,0x19
    0x84016212    0x60a    srli s4,s4,0x26
    0x84016216    0x60e    andi s4,s4,1
    0x8401621a    0x612    beqz s4,ffffffff84016224 <decodeRISCVMMUInvocation+0x61c>
    0x8401621e    0x616    li a4,-1
    0x84016220    0x618    slli a4,a4,0x27
    0x84016222    0x61a    or a5,a5,a4
    0x84016224    0x61c    auipc a4,0x14
    0x84016228    0x620    ld a4,1556(a4) # ffffffff8402a838 <ksCurThread>
    0x8401622c    0x624    li a3,1
    0x8401622e    0x626    slli a2,a3,0x26
    0x84016232    0x62a    add a5,a5,a2
    0x84016234    0x62c    sd a5,88(a4)
    0x84016236    0x62e    sd a3,80(a4)
    0x84016238    0x630    li s0,0
    0x8401623a    0x632    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x8401623c    0x634    li a5,35
    0x84016240    0x638    beq a0,a5,ffffffff84016270 <decodeRISCVMMUInvocation+0x668>
    0x84016244    0x63c    li a5,3
    0x84016246    0x63e    auipc a4,0x2
    0x8401624a    0x642    sd a5,1162(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x8401624e    0x646    li s0,3
    0x84016250    0x648    mv a0,s0
    0x84016252    0x64a    ld ra,200(sp)         ; stack access
    0x84016254    0x64c    ld s0,192(sp)         ; stack access
    0x84016256    0x64e    ld s1,184(sp)         ; stack access
    0x84016258    0x650    ld s2,176(sp)         ; stack access
    0x8401625a    0x652    ld s3,168(sp)         ; stack access
    0x8401625c    0x654    ld s4,160(sp)         ; stack access
    0x8401625e    0x656    ld s5,152(sp)         ; stack access
    0x84016260    0x658    ld s6,144(sp)         ; stack access
    0x84016262    0x65a    ld s7,136(sp)         ; stack access
    0x84016264    0x65c    ld s8,128(sp)         ; stack access
    0x84016266    0x65e    ld s9,120(sp)         ; stack access
    0x84016268    0x660    ld s10,112(sp)        ; stack access
    0x8401626a    0x662    ld s11,104(sp)        ; stack access
    0x8401626c    0x664    addi sp,sp,208
    0x8401626e    0x666    ret
    0x84016270    0x668    li a5,1
    0x84016272    0x66a    bgeu a5,a1,ffffffff840162d8 <decodeRISCVMMUInvocation+0x6d0>
    0x84016276    0x66e    auipc s2,0x2
    0x8401627a    0x672    ld s2,1562(s2) # ffffffff84018890 <current_extra_caps>
    0x8401627e    0x676    beqz s2,ffffffff840162d8 <decodeRISCVMMUInvocation+0x6d0>
    0x84016282    0x67a    auipc s0,0x2
    0x84016286    0x67e    ld s0,1558(s0) # ffffffff84018898 <current_extra_caps+0x8>
    0x8401628a    0x682    beqz s0,ffffffff840162d8 <decodeRISCVMMUInvocation+0x6d0>
    0x8401628c    0x684    mv a1,a6
    0x8401628e    0x686    li a0,0
    0x84016290    0x688    jal ra,ffffffff840100ea <getSyscallArg>
    0x84016294    0x68c    mv s4,a0
    0x84016296    0x68e    mv a1,s3
    0x84016298    0x690    li a0,1
    0x8401629a    0x692    jal ra,ffffffff840100ea <getSyscallArg>
    0x8401629e    0x696    mv s3,a0
    0x840162a0    0x698    ld s5,0(s2)
    0x840162a4    0x69c    ld a2,8(s2)
    0x840162a8    0x6a0    ld a5,0(s0)
    0x840162aa    0x6a2    sd a5,48(sp)          ; stack access
    0x840162ac    0x6a4    ld a5,8(s0)
    0x840162ae    0x6a6    sd a5,56(sp)          ; stack access
    0x840162b0    0x6a8    auipc a5,0x2
    0x840162b4    0x6ac    addi a5,a5,-688 # ffffffff84018000 <riscvKSASIDTable>
    0x840162b8    0x6b0    li s1,0
    0x840162ba    0x6b2    li a3,128
    0x840162be    0x6b6    ld a4,0(a5)
    0x840162c0    0x6b8    beqz a4,ffffffff840162e6 <decodeRISCVMMUInvocation+0x6de>
    0x840162c2    0x6ba    addi s1,s1,1
    0x840162c4    0x6bc    addi a5,a5,8
    0x840162c6    0x6be    bne s1,a3,ffffffff840162be <decodeRISCVMMUInvocation+0x6b6>
    0x840162ca    0x6c2    li a5,8
    0x840162cc    0x6c4    auipc a4,0x2
    0x840162d0    0x6c8    sd a5,1028(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840162d4    0x6cc    li s0,3
    0x840162d6    0x6ce    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x840162d8    0x6d0    li a5,7
    0x840162da    0x6d2    auipc a4,0x2
    0x840162de    0x6d6    sd a5,1014(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840162e2    0x6da    li s0,3
    0x840162e4    0x6dc    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x840162e6    0x6de    li a5,128
    0x840162ea    0x6e2    beq s1,a5,ffffffff840162ca <decodeRISCVMMUInvocation+0x6c2>
    0x840162ee    0x6e6    srli a5,s5,0x3b
    0x840162f2    0x6ea    li a4,2
    0x840162f4    0x6ec    bne a5,a4,ffffffff8401630a <decodeRISCVMMUInvocation+0x702>
    0x840162f8    0x6f0    andi a5,a2,63
    0x840162fc    0x6f4    li a4,12
    0x840162fe    0x6f6    bne a5,a4,ffffffff8401630a <decodeRISCVMMUInvocation+0x702>
    0x84016302    0x6fa    srli a5,a2,0x6
    0x84016306    0x6fe    andi a5,a5,1
    0x84016308    0x700    beqz a5,ffffffff84016322 <decodeRISCVMMUInvocation+0x71a>
    0x8401630a    0x702    auipc a5,0x2
    0x8401630e    0x706    addi a5,a5,-778 # ffffffff84018000 <riscvKSASIDTable>
    0x84016312    0x70a    li a4,2
    0x84016314    0x70c    sd a4,1744(a5)
    0x84016318    0x710    li a4,1
    0x8401631a    0x712    sd a4,1704(a5)
    0x8401631e    0x716    li s0,3
    0x84016320    0x718    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84016322    0x71a    mv a0,s2
    0x84016324    0x71c    jal ra,ffffffff840120ae <ensureNoChildren>
    0x84016328    0x720    mv s0,a0
    0x8401632a    0x722    bnez a0,ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x8401632c    0x724    slli s6,s5,0x19
    0x84016330    0x728    srli s6,s6,0x19
    0x84016334    0x72c    srli a5,s5,0x26
    0x84016338    0x730    andi a5,a5,1
    0x8401633a    0x732    beqz a5,ffffffff84016344 <decodeRISCVMMUInvocation+0x73c>
    0x8401633c    0x734    li a5,-1
    0x8401633e    0x736    slli a5,a5,0x27
    0x84016340    0x738    or s6,s6,a5
    0x84016344    0x73c    mv a3,s3
    0x84016346    0x73e    mv a2,s4
    0x84016348    0x740    ld a0,48(sp)          ; stack access
    0x8401634a    0x742    ld a1,56(sp)          ; stack access
    0x8401634c    0x744    jal ra,ffffffff840115ea <lookupTargetSlot>
    0x84016350    0x748    sd a0,64(sp)          ; stack access
    0x84016352    0x74a    sd a1,72(sp)          ; stack access
    0x84016354    0x74c    mv s0,a0
    0x84016356    0x74e    bnez a0,ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x8401635a    0x752    mv s3,a1
    0x8401635c    0x754    mv a0,a1
    0x8401635e    0x756    jal ra,ffffffff84011a10 <ensureEmptySlot>
    0x84016362    0x75a    mv s0,a0
    0x84016364    0x75c    bnez a0,ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84016368    0x760    li a1,2
    0x8401636a    0x762    auipc a0,0x14
    0x8401636e    0x766    ld a0,1230(a0) # ffffffff8402a838 <ksCurThread>
    0x84016372    0x76a    jal ra,ffffffff8401263a <setThreadState>
    0x84016376    0x76e    ld a5,8(s2)
    0x8401637a    0x772    andi a4,a5,63
    0x8401637e    0x776    addiw a3,a4,-4
    0x84016382    0x77a    lui a4,0x2000
    0x84016386    0x77e    sll a4,a4,a3
    0x8401638a    0x782    slli a5,a5,0x27
    0x8401638c    0x784    srli a5,a5,0x27
    0x8401638e    0x786    or a5,a5,a4
    0x84016390    0x788    sd a5,8(s2)
    0x84016394    0x78c    lui a1,0x1
    0x84016396    0x78e    mv a0,s6
    0x84016398    0x790    jal ra,ffffffff84015b8a <memzero>
    0x8401639c    0x794    slli a5,s1,0x34
    0x840163a0    0x798    lui a4,0xffff
    0x840163a4    0x79c    slli a4,a4,0x1f
    0x840163a6    0x79e    and a5,a5,a4
    0x840163a8    0x7a0    srli a4,s6,0x2
    0x840163ac    0x7a4    li s4,-1
    0x840163ae    0x7a6    srli a3,s4,0x1b
    0x840163b2    0x7aa    and a4,a4,a3
    0x840163b4    0x7ac    or a5,a5,a4
    0x840163b6    0x7ae    mv a3,s3
    0x840163b8    0x7b0    mv a2,s2
    0x840163ba    0x7b2    li a0,13
    0x840163bc    0x7b4    slli a0,a0,0x3b
    0x840163be    0x7b6    or a0,a0,a5
    0x840163c0    0x7b8    li a1,0
    0x840163c2    0x7ba    jal ra,ffffffff840116ba <cteInsert>
    0x840163c6    0x7be    srli a5,s4,0x9
    0x840163ca    0x7c2    and a5,a5,s1
    0x840163cc    0x7c4    slli a5,a5,0x3
    0x840163ce    0x7c6    auipc a4,0x2
    0x840163d2    0x7ca    addi a4,a4,-974 # ffffffff84018000 <riscvKSASIDTable>
    0x840163d6    0x7ce    add a5,a5,a4
    0x840163d8    0x7d0    sd s6,0(a5)
    0x840163dc    0x7d4    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x840163de    0x7d6    li a5,3
    0x840163e0    0x7d8    auipc a4,0x2
    0x840163e4    0x7dc    sd a5,752(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840163e8    0x7e0    li s0,3
    0x840163ea    0x7e2    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x840163ec    0x7e4    li a5,7
    0x840163ee    0x7e6    auipc a4,0x2
    0x840163f2    0x7ea    sd a5,738(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840163f6    0x7ee    li s0,3
    0x840163f8    0x7f0    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x840163fa    0x7f2    auipc a5,0x2
    0x840163fe    0x7f6    addi a5,a5,-1018 # ffffffff84018000 <riscvKSASIDTable>
    0x84016402    0x7fa    li a4,2
    0x84016404    0x7fc    sd a4,1744(a5)
    0x84016408    0x800    li a4,1
    0x8401640a    0x802    sd a4,1704(a5)
    0x8401640e    0x806    li s0,3
    0x84016410    0x808    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84016412    0x80a    auipc a5,0x2
    0x84016416    0x80e    addi a5,a5,-1042 # ffffffff84018000 <riscvKSASIDTable>
    0x8401641a    0x812    li a4,6
    0x8401641c    0x814    sd a4,1744(a5)
    0x84016420    0x818    sd zero,1736(a5)
    0x84016424    0x81c    sd zero,1024(a5)
    0x84016428    0x820    sd zero,1032(a5)
    0x8401642c    0x824    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x8401642e    0x826    auipc a5,0x2
    0x84016432    0x82a    addi a5,a5,-1070 # ffffffff84018000 <riscvKSASIDTable>
    0x84016436    0x82e    li a4,2
    0x84016438    0x830    sd a4,1744(a5)
    0x8401643c    0x834    sd zero,1704(a5)
    0x84016440    0x838    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x84016442    0x83a    addi a5,a5,1
    0x84016444    0x83c    addi a4,a4,8
    0x84016446    0x83e    beq a5,a1,ffffffff840164c2 <decodeRISCVMMUInvocation+0x8ba>
    0x8401644a    0x842    add a3,a5,a2
    0x8401644e    0x846    beqz a3,ffffffff84016442 <decodeRISCVMMUInvocation+0x83a>
    0x84016450    0x848    ld a3,0(a4)
    0x84016452    0x84a    bnez a3,ffffffff84016442 <decodeRISCVMMUInvocation+0x83a>
    0x84016454    0x84c    li a4,512
    0x84016458    0x850    beq a5,a4,ffffffff840164c2 <decodeRISCVMMUInvocation+0x8ba>
    0x8401645c    0x854    add s0,a5,a2
    0x84016460    0x858    li a1,2
    0x84016462    0x85a    auipc a0,0x14
    0x84016466    0x85e    ld a0,982(a0) # ffffffff8402a838 <ksCurThread>
    0x8401646a    0x862    jal ra,ffffffff8401263a <setThreadState>
    0x8401646e    0x866    ld a3,0(s3)
    0x84016472    0x86a    ld a5,8(s3)
    0x84016476    0x86e    srli a4,a5,0x9
    0x8401647a    0x872    slli s1,a4,0x19
    0x8401647e    0x876    srli s1,s1,0x19
    0x84016480    0x878    srli a4,a4,0x26
    0x84016482    0x87a    andi a4,a4,1
    0x84016484    0x87c    beqz a4,ffffffff8401648c <decodeRISCVMMUInvocation+0x884>
    0x84016486    0x87e    li a4,-1
    0x84016488    0x880    slli a4,a4,0x27
    0x8401648a    0x882    or s1,s1,a4
    0x8401648c    0x884    li a2,-1
    0x8401648e    0x886    slli a4,a2,0x28
    0x84016492    0x88a    and a4,a4,a3
    0x84016494    0x88c    li a3,1
    0x84016496    0x88e    slli a3,a3,0x27
    0x84016498    0x890    or a4,a4,a3
    0x8401649a    0x892    sd a4,0(s3)
    0x8401649e    0x896    srli a2,a2,0x10
    0x840164a0    0x898    and a5,a5,a2
    0x840164a2    0x89a    slli a4,s0,0x30
    0x840164a6    0x89e    or a5,a5,a4
    0x840164a8    0x8a0    sd a5,8(s3)
    0x840164ac    0x8a4    mv a0,s1
    0x840164ae    0x8a6    jal ra,ffffffff840107c0 <copyGlobalMappings>
    0x840164b2    0x8aa    andi a5,s0,511
    0x840164b6    0x8ae    slli a5,a5,0x3
    0x840164b8    0x8b0    add s4,s4,a5
    0x840164ba    0x8b2    sd s1,0(s4)
    0x840164be    0x8b6    mv s0,s2
    0x840164c0    0x8b8    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x840164c2    0x8ba    li a5,8
    0x840164c4    0x8bc    auipc a4,0x2
    0x840164c8    0x8c0    sd a5,524(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840164cc    0x8c4    j ffffffff84016250 <decodeRISCVMMUInvocation+0x648>
    0x840164ce    0x8c6    jal ra,ffffffff8401041e <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
768 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeRISCVMMUInvocation` has 1107 nodes.

Section decodeTCBInvocation (269 of 271)
========================================

Deriving specifications
-----------------------

Section `decodeTCBInvocation` consists of 171 instructions.


Stack analysis
---------------

30 stack accesses found. Annotated code for `decodeTCBInvocation`:

    0x84015830      0x0    addi sp,sp,-48
    0x84015832      0x2    sd ra,40(sp)          ; stack access
    0x84015834      0x4    sd s0,32(sp)          ; stack access
    0x84015836      0x6    sd s1,24(sp)          ; stack access
    0x84015838      0x8    sd a2,0(sp)           ; stack access
    0x8401583a      0xa    sd a3,8(sp)           ; stack access
    0x8401583c      0xc    mv a3,a4
    0x8401583e      0xe    li a4,9
    0x84015840     0x10    beq a0,a4,ffffffff840159b0 <decodeTCBInvocation+0x180>
    0x84015844     0x14    mv s0,a2
    0x84015846     0x16    bltu a4,a0,ffffffff840158ba <decodeTCBInvocation+0x8a>
    0x8401584a     0x1a    li a4,5
    0x8401584c     0x1c    beq a0,a4,ffffffff84015994 <decodeTCBInvocation+0x164>
    0x84015850     0x20    bgeu a4,a0,ffffffff8401586e <decodeTCBInvocation+0x3e>
    0x84015854     0x24    li a5,7
    0x84015856     0x26    beq a0,a5,ffffffff840159a2 <decodeTCBInvocation+0x172>
    0x8401585a     0x2a    li a5,8
    0x8401585c     0x2c    bne a0,a5,ffffffff840158a6 <decodeTCBInvocation+0x76>
    0x84015860     0x30    mv a3,a6
    0x84015862     0x32    mv a2,a1
    0x84015864     0x34    ld a0,0(sp)           ; stack access
    0x84015866     0x36    ld a1,8(sp)           ; stack access
    0x84015868     0x38    jal ra,ffffffff84014efe <decodeSetSchedParams>
    0x8401586c     0x3c    j ffffffff8401589c <decodeTCBInvocation+0x6c>
    0x8401586e     0x3e    li a4,3
    0x84015870     0x40    beq a0,a4,ffffffff8401595e <decodeTCBInvocation+0x12e>
    0x84015874     0x44    li a4,4
    0x84015876     0x46    bne a0,a4,ffffffff84015888 <decodeTCBInvocation+0x58>
    0x8401587a     0x4a    mv a3,a6
    0x8401587c     0x4c    mv a2,a1
    0x8401587e     0x4e    ld a0,0(sp)           ; stack access
    0x84015880     0x50    ld a1,8(sp)           ; stack access
    0x84015882     0x52    jal ra,ffffffff840152f8 <decodeCopyRegisters>
    0x84015886     0x56    j ffffffff8401589c <decodeTCBInvocation+0x6c>
    0x84015888     0x58    li a4,2
    0x8401588a     0x5a    bne a0,a4,ffffffff840159e0 <decodeTCBInvocation+0x1b0>
    0x8401588e     0x5e    mv a4,a6
    0x84015890     0x60    mv a3,a5
    0x84015892     0x62    mv a2,a1
    0x84015894     0x64    ld a0,0(sp)           ; stack access
    0x84015896     0x66    ld a1,8(sp)           ; stack access
    0x84015898     0x68    jal ra,ffffffff840154b4 <decodeReadRegisters>
    0x8401589c     0x6c    ld ra,40(sp)          ; stack access
    0x8401589e     0x6e    ld s0,32(sp)          ; stack access
    0x840158a0     0x70    ld s1,24(sp)          ; stack access
    0x840158a2     0x72    addi sp,sp,48
    0x840158a4     0x74    ret
    0x840158a6     0x76    li a5,6
    0x840158a8     0x78    bne a0,a5,ffffffff840159e0 <decodeTCBInvocation+0x1b0>
    0x840158ac     0x7c    mv a3,a6
    0x840158ae     0x7e    mv a2,a1
    0x840158b0     0x80    ld a0,0(sp)           ; stack access
    0x840158b2     0x82    ld a1,8(sp)           ; stack access
    0x840158b4     0x84    jal ra,ffffffff84014d4e <decodeSetPriority>
    0x840158b8     0x88    j ffffffff8401589c <decodeTCBInvocation+0x6c>
    0x840158ba     0x8a    li a5,13
    0x840158bc     0x8c    beq a0,a5,ffffffff840159be <decodeTCBInvocation+0x18e>
    0x840158c0     0x90    bgeu a5,a0,ffffffff84015916 <decodeTCBInvocation+0xe6>
    0x840158c4     0x94    li a5,14
    0x840158c6     0x96    beq a0,a5,ffffffff840159c8 <decodeTCBInvocation+0x198>
    0x840158ca     0x9a    li a5,15
    0x840158cc     0x9c    bne a0,a5,ffffffff840159e0 <decodeTCBInvocation+0x1b0>
    0x840158d0     0xa0    beqz a1,ffffffff840159d2 <decodeTCBInvocation+0x1a2>
    0x840158d4     0xa4    mv a1,a6
    0x840158d6     0xa6    li a0,0
    0x840158d8     0xa8    jal ra,ffffffff840100ea <getSyscallArg>
    0x840158dc     0xac    mv s1,a0
    0x840158de     0xae    li a1,2
    0x840158e0     0xb0    auipc a0,0x15
    0x840158e4     0xb4    ld a0,-168(a0) # ffffffff8402a838 <ksCurThread>
    0x840158e8     0xb8    jal ra,ffffffff8401263a <setThreadState>
    0x840158ec     0xbc    slli a5,s0,0x19
    0x840158f0     0xc0    srli a5,a5,0x19
    0x840158f2     0xc2    srli s0,s0,0x26
    0x840158f4     0xc4    andi s0,s0,1
    0x840158f6     0xc6    beqz s0,ffffffff840158fe <decodeTCBInvocation+0xce>
    0x840158f8     0xc8    li a4,-1
    0x840158fa     0xca    slli a4,a4,0x27
    0x840158fc     0xcc    or a5,a5,a4
    0x840158fe     0xce    sd s1,24(a5)
    0x84015900     0xd0    auipc a4,0x15
    0x84015904     0xd4    ld a4,-200(a4) # ffffffff8402a838 <ksCurThread>
    0x84015908     0xd8    li a0,0
    0x8401590a     0xda    bne a5,a4,ffffffff8401589c <decodeTCBInvocation+0x6c>
    0x8401590e     0xde    jal ra,ffffffff840125d4 <rescheduleRequired>
    0x84015912     0xe2    li a0,0
    0x84015914     0xe4    j ffffffff8401589c <decodeTCBInvocation+0x6c>
    0x84015916     0xe6    li a5,11
    0x84015918     0xe8    beq a0,a5,ffffffff8401596c <decodeTCBInvocation+0x13c>
    0x8401591c     0xec    li a5,12
    0x8401591e     0xee    bne a0,a5,ffffffff8401594a <decodeTCBInvocation+0x11a>
    0x84015922     0xf2    li a1,2
    0x84015924     0xf4    auipc a0,0x15
    0x84015928     0xf8    ld a0,-236(a0) # ffffffff8402a838 <ksCurThread>
    0x8401592c     0xfc    jal ra,ffffffff8401263a <setThreadState>
    0x84015930    0x100    slli a0,s0,0x19
    0x84015934    0x104    srli a0,a0,0x19
    0x84015936    0x106    srli s0,s0,0x26
    0x84015938    0x108    andi s0,s0,1
    0x8401593a    0x10a    beqz s0,ffffffff84015942 <decodeTCBInvocation+0x112>
    0x8401593c    0x10c    li a5,-1
    0x8401593e    0x10e    slli a5,a5,0x27
    0x84015940    0x110    or a0,a0,a5
    0x84015942    0x112    jal ra,ffffffff84013be4 <restart>
    0x84015946    0x116    li a0,0
    0x84015948    0x118    j ffffffff8401589c <decodeTCBInvocation+0x6c>
    0x8401594a    0x11a    li a5,10
    0x8401594c    0x11c    bne a0,a5,ffffffff840159e0 <decodeTCBInvocation+0x1b0>
    0x84015950    0x120    mv a4,a6
    0x84015952    0x122    mv a2,a1
    0x84015954    0x124    ld a0,0(sp)           ; stack access
    0x84015956    0x126    ld a1,8(sp)           ; stack access
    0x84015958    0x128    jal ra,ffffffff840150c0 <decodeSetSpace>
    0x8401595c    0x12c    j ffffffff8401589c <decodeTCBInvocation+0x6c>
    0x8401595e    0x12e    mv a3,a6
    0x84015960    0x130    mv a2,a1
    0x84015962    0x132    ld a0,0(sp)           ; stack access
    0x84015964    0x134    ld a1,8(sp)           ; stack access
    0x84015966    0x136    jal ra,ffffffff84015658 <decodeWriteRegisters>
    0x8401596a    0x13a    j ffffffff8401589c <decodeTCBInvocation+0x6c>
    0x8401596c    0x13c    li a1,2
    0x8401596e    0x13e    auipc a0,0x15
    0x84015972    0x142    ld a0,-310(a0) # ffffffff8402a838 <ksCurThread>
    0x84015976    0x146    jal ra,ffffffff8401263a <setThreadState>
    0x8401597a    0x14a    slli a0,s0,0x19
    0x8401597e    0x14e    srli a0,a0,0x19
    0x84015980    0x150    srli s0,s0,0x26
    0x84015982    0x152    andi s0,s0,1
    0x84015984    0x154    beqz s0,ffffffff8401598c <decodeTCBInvocation+0x15c>
    0x84015986    0x156    li a5,-1
    0x84015988    0x158    slli a5,a5,0x27
    0x8401598a    0x15a    or a0,a0,a5
    0x8401598c    0x15c    jal ra,ffffffff84013144 <suspend>
    0x84015990    0x160    li a0,0
    0x84015992    0x162    j ffffffff8401589c <decodeTCBInvocation+0x6c>
    0x84015994    0x164    mv a4,a6
    0x84015996    0x166    mv a2,a1
    0x84015998    0x168    ld a0,0(sp)           ; stack access
    0x8401599a    0x16a    ld a1,8(sp)           ; stack access
    0x8401599c    0x16c    jal ra,ffffffff84014b5e <decodeTCBConfigure>
    0x840159a0    0x170    j ffffffff8401589c <decodeTCBInvocation+0x6c>
    0x840159a2    0x172    mv a3,a6
    0x840159a4    0x174    mv a2,a1
    0x840159a6    0x176    ld a0,0(sp)           ; stack access
    0x840159a8    0x178    ld a1,8(sp)           ; stack access
    0x840159aa    0x17a    jal ra,ffffffff84014e26 <decodeSetMCPriority>
    0x840159ae    0x17e    j ffffffff8401589c <decodeTCBInvocation+0x6c>
    0x840159b0    0x180    mv a4,a6
    0x840159b2    0x182    mv a2,a1
    0x840159b4    0x184    ld a0,0(sp)           ; stack access
    0x840159b6    0x186    ld a1,8(sp)           ; stack access
    0x840159b8    0x188    jal ra,ffffffff84015008 <decodeSetIPCBuffer>
    0x840159bc    0x18c    j ffffffff8401589c <decodeTCBInvocation+0x6c>
    0x840159be    0x18e    ld a0,0(sp)           ; stack access
    0x840159c0    0x190    ld a1,8(sp)           ; stack access
    0x840159c2    0x192    jal ra,ffffffff84015716 <decodeBindNotification>
    0x840159c6    0x196    j ffffffff8401589c <decodeTCBInvocation+0x6c>
    0x840159c8    0x198    ld a0,0(sp)           ; stack access
    0x840159ca    0x19a    ld a1,8(sp)           ; stack access
    0x840159cc    0x19c    jal ra,ffffffff840157e2 <decodeUnbindNotification>
    0x840159d0    0x1a0    j ffffffff8401589c <decodeTCBInvocation+0x6c>
    0x840159d2    0x1a2    li a5,7
    0x840159d4    0x1a4    auipc a4,0x3
    0x840159d8    0x1a8    sd a5,-772(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840159dc    0x1ac    li a0,3
    0x840159de    0x1ae    j ffffffff8401589c <decodeTCBInvocation+0x6c>
    0x840159e0    0x1b0    li a5,3
    0x840159e2    0x1b2    auipc a4,0x3
    0x840159e6    0x1b6    sd a5,-786(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840159ea    0x1ba    li a0,3
    0x840159ec    0x1bc    j ffffffff8401589c <decodeTCBInvocation+0x6c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
171 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeTCBInvocation` has 271 nodes.

Section decodeCNodeInvocation (270 of 271)
==========================================

Deriving specifications
-----------------------

Section `decodeCNodeInvocation` consists of 459 instructions.


Stack analysis
---------------

80 stack accesses found. Annotated code for `decodeCNodeInvocation`:

    0x8401359e      0x0    addi sp,sp,-224
    0x840135a0      0x2    sd ra,216(sp)         ; stack access
    0x840135a2      0x4    sd s0,208(sp)         ; stack access
    0x840135a4      0x6    sd s1,200(sp)         ; stack access
    0x840135a6      0x8    sd s2,192(sp)         ; stack access
    0x840135a8      0xa    sd s3,184(sp)         ; stack access
    0x840135aa      0xc    sd s4,176(sp)         ; stack access
    0x840135ac      0xe    sd s5,168(sp)         ; stack access
    0x840135ae     0x10    sd s6,160(sp)         ; stack access
    0x840135b0     0x12    sd s7,152(sp)         ; stack access
    0x840135b2     0x14    sd s8,144(sp)         ; stack access
    0x840135b4     0x16    sd a2,0(sp)           ; stack access
    0x840135b6     0x18    sd a3,8(sp)           ; stack access
    0x840135b8     0x1a    mv s2,a4
    0x840135ba     0x1c    addi a4,a0,-16
    0x840135be     0x20    li a5,8
    0x840135c0     0x22    bltu a5,a4,ffffffff84013680 <decodeCNodeInvocation+0xe2>
    0x840135c4     0x26    mv s1,a0
    0x840135c6     0x28    mv s3,a1
    0x840135c8     0x2a    li a5,1
    0x840135ca     0x2c    bgeu a5,a1,ffffffff8401368e <decodeCNodeInvocation+0xf0>
    0x840135ce     0x30    mv a1,s2
    0x840135d0     0x32    li a0,0
    0x840135d2     0x34    jal ra,ffffffff840100ea <getSyscallArg>
    0x840135d6     0x38    mv s0,a0
    0x840135d8     0x3a    mv a1,s2
    0x840135da     0x3c    li a0,1
    0x840135dc     0x3e    jal ra,ffffffff840100ea <getSyscallArg>
    0x840135e0     0x42    mv a3,a0
    0x840135e2     0x44    mv a2,s0
    0x840135e4     0x46    ld a0,0(sp)           ; stack access
    0x840135e6     0x48    ld a1,8(sp)           ; stack access
    0x840135e8     0x4a    jal ra,ffffffff840115ea <lookupTargetSlot>
    0x840135ec     0x4e    sd a0,112(sp)         ; stack access
    0x840135ee     0x50    sd a1,120(sp)         ; stack access
    0x840135f0     0x52    mv s0,a0
    0x840135f2     0x54    bnez a0,ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x840135f4     0x56    mv s4,a1
    0x840135f6     0x58    addi a5,s1,-19
    0x840135fa     0x5c    li a4,3
    0x840135fc     0x5e    bltu a4,a5,ffffffff84013820 <decodeCNodeInvocation+0x282>
    0x84013600     0x62    li a5,3
    0x84013602     0x64    bgeu a5,s3,ffffffff840136b4 <decodeCNodeInvocation+0x116>
    0x84013606     0x68    auipc s0,0x5
    0x8401360a     0x6c    ld s0,650(s0) # ffffffff84018890 <current_extra_caps>
    0x8401360e     0x70    beqz s0,ffffffff840136b4 <decodeCNodeInvocation+0x116>
    0x84013610     0x72    mv a1,s2
    0x84013612     0x74    li a0,2
    0x84013614     0x76    jal ra,ffffffff840100ea <getSyscallArg>
    0x84013618     0x7a    mv s6,a0
    0x8401361a     0x7c    mv a1,s2
    0x8401361c     0x7e    li a0,3
    0x8401361e     0x80    jal ra,ffffffff840100ea <getSyscallArg>
    0x84013622     0x84    mv s5,a0
    0x84013624     0x86    ld a5,0(s0)
    0x84013626     0x88    sd a5,24(sp)          ; stack access
    0x84013628     0x8a    ld a5,8(s0)
    0x8401362a     0x8c    sd a5,32(sp)          ; stack access
    0x8401362c     0x8e    mv a0,s4
    0x8401362e     0x90    jal ra,ffffffff84011a10 <ensureEmptySlot>
    0x84013632     0x94    mv s0,a0
    0x84013634     0x96    bnez a0,ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x84013636     0x98    mv a3,s5
    0x84013638     0x9a    mv a2,s6
    0x8401363a     0x9c    ld a0,24(sp)          ; stack access
    0x8401363c     0x9e    ld a1,32(sp)          ; stack access
    0x8401363e     0xa0    jal ra,ffffffff840115d0 <lookupSourceSlot>
    0x84013642     0xa4    sd a0,112(sp)         ; stack access
    0x84013644     0xa6    sd a1,120(sp)         ; stack access
    0x84013646     0xa8    mv s0,a0
    0x84013648     0xaa    bnez a0,ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x8401364a     0xac    mv s6,a1
    0x8401364c     0xae    ld s7,0(a1) # ffffffffe0000000 <ki_end+0x5bfd1000>
    0x84013650     0xb2    srli a5,s7,0x3b
    0x84013654     0xb6    beqz a5,ffffffff840136c2 <decodeCNodeInvocation+0x124>
    0x84013656     0xb8    li a5,21
    0x84013658     0xba    beq s1,a5,ffffffff840137a8 <decodeCNodeInvocation+0x20a>
    0x8401365c     0xbe    bltu a5,s1,ffffffff840137d2 <decodeCNodeInvocation+0x234>
    0x84013660     0xc2    li a5,19
    0x84013662     0xc4    beq s1,a5,ffffffff840136ee <decodeCNodeInvocation+0x150>
    0x84013666     0xc8    li a5,20
    0x84013668     0xca    bne s1,a5,ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x8401366c     0xce    li a5,5
    0x8401366e     0xd0    bltu a5,s3,ffffffff8401375c <decodeCNodeInvocation+0x1be>
    0x84013672     0xd4    li a5,7
    0x84013674     0xd6    auipc a4,0x5
    0x84013678     0xda    sd a5,92(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x8401367c     0xde    li s0,3
    0x8401367e     0xe0    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x84013680     0xe2    li a5,3
    0x84013682     0xe4    auipc a4,0x5
    0x84013686     0xe8    sd a5,78(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x8401368a     0xec    li s0,3
    0x8401368c     0xee    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x8401368e     0xf0    li a5,7
    0x84013690     0xf2    auipc a4,0x5
    0x84013694     0xf6    sd a5,64(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84013698     0xfa    li s0,3
    0x8401369a     0xfc    mv a0,s0
    0x8401369c     0xfe    ld ra,216(sp)         ; stack access
    0x8401369e    0x100    ld s0,208(sp)         ; stack access
    0x840136a0    0x102    ld s1,200(sp)         ; stack access
    0x840136a2    0x104    ld s2,192(sp)         ; stack access
    0x840136a4    0x106    ld s3,184(sp)         ; stack access
    0x840136a6    0x108    ld s4,176(sp)         ; stack access
    0x840136a8    0x10a    ld s5,168(sp)         ; stack access
    0x840136aa    0x10c    ld s6,160(sp)         ; stack access
    0x840136ac    0x10e    ld s7,152(sp)         ; stack access
    0x840136ae    0x110    ld s8,144(sp)         ; stack access
    0x840136b0    0x112    addi sp,sp,224
    0x840136b2    0x114    ret
    0x840136b4    0x116    li a5,7
    0x840136b6    0x118    auipc a4,0x5
    0x840136ba    0x11c    sd a5,26(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840136be    0x120    li s0,3
    0x840136c0    0x122    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x840136c2    0x124    auipc a4,0x5
    0x840136c6    0x128    addi a4,a4,-1730 # ffffffff84018000 <riscvKSASIDTable>
    0x840136ca    0x12c    li a5,6
    0x840136cc    0x12e    sd a5,1744(a4)
    0x840136d0    0x132    li a5,1
    0x840136d2    0x134    sd a5,1736(a4)
    0x840136d6    0x138    slli a5,s5,0x2
    0x840136da    0x13c    andi a5,a5,508
    0x840136de    0x140    ori a5,a5,1
    0x840136e2    0x144    sd a5,1024(a4)
    0x840136e6    0x148    sd zero,1032(a4)
    0x840136ea    0x14c    li s0,3
    0x840136ec    0x14e    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x840136ee    0x150    li a5,4
    0x840136f0    0x152    bltu a5,s3,ffffffff84013702 <decodeCNodeInvocation+0x164>
    0x840136f4    0x156    li a5,7
    0x840136f6    0x158    auipc a4,0x5
    0x840136fa    0x15c    sd a5,-38(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840136fe    0x160    li s0,3
    0x84013700    0x162    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x84013702    0x164    mv a1,s2
    0x84013704    0x166    li a0,4
    0x84013706    0x168    jal ra,ffffffff840100ea <getSyscallArg>
    0x8401370a    0x16c    ld a1,0(s6) # fffffffffe000000 <ki_end+0x79fd1000>
    0x8401370e    0x170    ld a2,8(s6)
    0x84013712    0x174    jal ra,ffffffff840122de <maskCapRights>
    0x84013716    0x178    mv a2,a0
    0x84013718    0x17a    mv a3,a1
    0x8401371a    0x17c    sd a0,56(sp)          ; stack access
    0x8401371c    0x17e    sd a1,64(sp)          ; stack access
    0x8401371e    0x180    mv a1,s6
    0x84013720    0x182    addi a0,sp,88
    0x84013722    0x184    jal ra,ffffffff840120ec <deriveCap>
    0x84013726    0x188    ld a5,88(sp)          ; stack access
    0x84013728    0x18a    bnez a5,ffffffff84013818 <decodeCNodeInvocation+0x27a>
    0x8401372c    0x18e    ld s1,96(sp)          ; stack access
    0x8401372e    0x190    sd s1,40(sp)          ; stack access
    0x84013730    0x192    ld a5,104(sp)         ; stack access
    0x84013732    0x194    sd a5,48(sp)          ; stack access
    0x84013734    0x196    srli a5,s1,0x3b
    0x84013738    0x19a    beqz a5,ffffffff840137fc <decodeCNodeInvocation+0x25e>
    0x8401373a    0x19c    li a1,2
    0x8401373c    0x19e    auipc a0,0x17
    0x84013740    0x1a2    ld a0,252(a0) # ffffffff8402a838 <ksCurThread>
    0x84013744    0x1a6    jal ra,ffffffff8401263a <setThreadState>
    0x84013748    0x1aa    sd s1,40(sp)          ; stack access
    0x8401374a    0x1ac    sd s1,72(sp)          ; stack access
    0x8401374c    0x1ae    ld a1,48(sp)          ; stack access
    0x8401374e    0x1b0    sd a1,80(sp)          ; stack access
    0x84013750    0x1b2    mv a3,s4
    0x84013752    0x1b4    mv a2,s6
    0x84013754    0x1b6    mv a0,s1
    0x84013756    0x1b8    jal ra,ffffffff840116ba <cteInsert>
    0x8401375a    0x1bc    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x8401375c    0x1be    mv a1,s2
    0x8401375e    0x1c0    li a0,4
    0x84013760    0x1c2    jal ra,ffffffff840100ea <getSyscallArg>
    0x84013764    0x1c6    mv s3,a0
    0x84013766    0x1c8    mv a1,s2
    0x84013768    0x1ca    li a0,5
    0x8401376a    0x1cc    jal ra,ffffffff840100ea <getSyscallArg>
    0x8401376e    0x1d0    mv s1,a0
    0x84013770    0x1d2    ld a1,0(s6)
    0x84013774    0x1d6    ld a2,8(s6)
    0x84013778    0x1da    mv a0,s3
    0x8401377a    0x1dc    jal ra,ffffffff840122de <maskCapRights>
    0x8401377e    0x1e0    mv a2,a0
    0x84013780    0x1e2    mv a3,a1
    0x84013782    0x1e4    sd a0,56(sp)          ; stack access
    0x84013784    0x1e6    sd a1,64(sp)          ; stack access
    0x84013786    0x1e8    mv a1,s1
    0x84013788    0x1ea    li a0,0
    0x8401378a    0x1ec    jal ra,ffffffff8401224e <updateCapData>
    0x8401378e    0x1f0    mv a2,a0
    0x84013790    0x1f2    mv a3,a1
    0x84013792    0x1f4    mv a1,s6
    0x84013794    0x1f6    addi a0,sp,88
    0x84013796    0x1f8    jal ra,ffffffff840120ec <deriveCap>
    0x8401379a    0x1fc    ld a5,88(sp)          ; stack access
    0x8401379c    0x1fe    bnez a5,ffffffff8401381c <decodeCNodeInvocation+0x27e>
    0x8401379e    0x200    ld s1,96(sp)          ; stack access
    0x840137a0    0x202    sd s1,40(sp)          ; stack access
    0x840137a2    0x204    ld a5,104(sp)         ; stack access
    0x840137a4    0x206    sd a5,48(sp)          ; stack access
    0x840137a6    0x208    j ffffffff84013734 <decodeCNodeInvocation+0x196>
    0x840137a8    0x20a    ld a5,0(a1)
    0x840137aa    0x20c    sd a5,40(sp)          ; stack access
    0x840137ac    0x20e    ld a5,8(a1)
    0x840137ae    0x210    sd a5,48(sp)          ; stack access
    0x840137b0    0x212    li a1,2
    0x840137b2    0x214    auipc a0,0x17
    0x840137b6    0x218    ld a0,134(a0) # ffffffff8402a838 <ksCurThread>
    0x840137ba    0x21c    jal ra,ffffffff8401263a <setThreadState>
    0x840137be    0x220    sd s7,40(sp)          ; stack access
    0x840137c0    0x222    sd s7,88(sp)          ; stack access
    0x840137c2    0x224    ld a1,48(sp)          ; stack access
    0x840137c4    0x226    sd a1,96(sp)          ; stack access
    0x840137c6    0x228    mv a3,s4
    0x840137c8    0x22a    mv a2,s6
    0x840137ca    0x22c    mv a0,s7
    0x840137cc    0x22e    jal ra,ffffffff840117f6 <cteMove>
    0x840137d0    0x232    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x840137d2    0x234    li a5,4
    0x840137d4    0x236    bgeu a5,s3,ffffffff8401380a <decodeCNodeInvocation+0x26c>
    0x840137d8    0x23a    mv a1,s2
    0x840137da    0x23c    li a0,4
    0x840137dc    0x23e    jal ra,ffffffff840100ea <getSyscallArg>
    0x840137e0    0x242    mv a1,a0
    0x840137e2    0x244    ld a2,0(s6)
    0x840137e6    0x248    ld a3,8(s6)
    0x840137ea    0x24c    li a0,1
    0x840137ec    0x24e    jal ra,ffffffff8401224e <updateCapData>
    0x840137f0    0x252    sd a0,40(sp)          ; stack access
    0x840137f2    0x254    sd a1,48(sp)          ; stack access
    0x840137f4    0x256    mv s7,a0
    0x840137f6    0x258    srli a0,a0,0x3b
    0x840137f8    0x25a    bnez a0,ffffffff84013a6c <decodeCNodeInvocation+0x4ce>
    0x840137fc    0x25e    li a5,3
    0x840137fe    0x260    auipc a4,0x5
    0x84013802    0x264    sd a5,-302(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84013806    0x268    li s0,3
    0x84013808    0x26a    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x8401380a    0x26c    li a5,7
    0x8401380c    0x26e    auipc a4,0x5
    0x84013810    0x272    sd a5,-316(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84013814    0x276    li s0,3
    0x84013816    0x278    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x84013818    0x27a    mv s0,a5
    0x8401381a    0x27c    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x8401381c    0x27e    mv s0,a5
    0x8401381e    0x280    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x84013820    0x282    li a5,16
    0x84013822    0x284    beq s1,a5,ffffffff8401393e <decodeCNodeInvocation+0x3a0>
    0x84013826    0x288    li a5,17
    0x84013828    0x28a    beq s1,a5,ffffffff84013956 <decodeCNodeInvocation+0x3b8>
    0x8401382c    0x28e    li a5,24
    0x8401382e    0x290    beq s1,a5,ffffffff8401396e <decodeCNodeInvocation+0x3d0>
    0x84013832    0x294    li a5,18
    0x84013834    0x296    beq s1,a5,ffffffff84013992 <decodeCNodeInvocation+0x3f4>
    0x84013838    0x29a    li a5,23
    0x8401383a    0x29c    bne s1,a5,ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x8401383e    0x2a0    li a5,7
    0x84013840    0x2a2    bgeu a5,s3,ffffffff840139c8 <decodeCNodeInvocation+0x42a>
    0x84013844    0x2a6    auipc s0,0x5
    0x84013848    0x2aa    ld s0,76(s0) # ffffffff84018890 <current_extra_caps>
    0x8401384c    0x2ae    beqz s0,ffffffff840139c8 <decodeCNodeInvocation+0x42a>
    0x84013850    0x2b2    auipc s1,0x5
    0x84013854    0x2b6    ld s1,72(s1) # ffffffff84018898 <current_extra_caps+0x8>
    0x84013858    0x2ba    beqz s1,ffffffff840139c8 <decodeCNodeInvocation+0x42a>
    0x8401385c    0x2be    mv a1,s2
    0x8401385e    0x2c0    li a0,2
    0x84013860    0x2c2    jal ra,ffffffff840100ea <getSyscallArg>
    0x84013864    0x2c6    mv s7,a0
    0x84013866    0x2c8    mv a1,s2
    0x84013868    0x2ca    li a0,3
    0x8401386a    0x2cc    jal ra,ffffffff840100ea <getSyscallArg>
    0x8401386e    0x2d0    mv s6,a0
    0x84013870    0x2d2    mv a1,s2
    0x84013872    0x2d4    li a0,4
    0x84013874    0x2d6    jal ra,ffffffff840100ea <getSyscallArg>
    0x84013878    0x2da    mv s3,a0
    0x8401387a    0x2dc    mv a1,s2
    0x8401387c    0x2de    li a0,5
    0x8401387e    0x2e0    jal ra,ffffffff840100ea <getSyscallArg>
    0x84013882    0x2e4    mv s8,a0
    0x84013884    0x2e6    mv a1,s2
    0x84013886    0x2e8    li a0,6
    0x84013888    0x2ea    jal ra,ffffffff840100ea <getSyscallArg>
    0x8401388c    0x2ee    mv s5,a0
    0x8401388e    0x2f0    mv a1,s2
    0x84013890    0x2f2    li a0,7
    0x84013892    0x2f4    jal ra,ffffffff840100ea <getSyscallArg>
    0x84013896    0x2f8    mv s2,a0
    0x84013898    0x2fa    ld a5,0(s0)
    0x8401389a    0x2fc    sd a5,40(sp)          ; stack access
    0x8401389c    0x2fe    ld a5,8(s0)
    0x8401389e    0x300    sd a5,48(sp)          ; stack access
    0x840138a0    0x302    ld a0,0(s1)
    0x840138a2    0x304    sd a0,56(sp)          ; stack access
    0x840138a4    0x306    ld a1,8(s1)
    0x840138a6    0x308    sd a1,64(sp)          ; stack access
    0x840138a8    0x30a    mv a3,s2
    0x840138aa    0x30c    mv a2,s5
    0x840138ac    0x30e    jal ra,ffffffff840115d0 <lookupSourceSlot>
    0x840138b0    0x312    sd a1,120(sp)         ; stack access
    0x840138b2    0x314    mv s0,a0
    0x840138b4    0x316    bnez a0,ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x840138b8    0x31a    mv s1,a1
    0x840138ba    0x31c    mv a3,s3
    0x840138bc    0x31e    mv a2,s6
    0x840138be    0x320    ld a0,40(sp)          ; stack access
    0x840138c0    0x322    ld a1,48(sp)          ; stack access
    0x840138c2    0x324    jal ra,ffffffff84011604 <lookupPivotSlot>
    0x840138c6    0x328    sd a0,112(sp)         ; stack access
    0x840138c8    0x32a    sd a1,120(sp)         ; stack access
    0x840138ca    0x32c    mv s0,a0
    0x840138cc    0x32e    bnez a0,ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x840138d0    0x332    mv s5,a1
    0x840138d2    0x334    beq s1,a1,ffffffff840139d6 <decodeCNodeInvocation+0x438>
    0x840138d6    0x338    beq s4,a1,ffffffff840139d6 <decodeCNodeInvocation+0x438>
    0x840138da    0x33c    beq s4,s1,ffffffff840138ea <decodeCNodeInvocation+0x34c>
    0x840138de    0x340    mv a0,s4
    0x840138e0    0x342    jal ra,ffffffff84011a10 <ensureEmptySlot>
    0x840138e4    0x346    mv s0,a0
    0x840138e6    0x348    bnez a0,ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x840138ea    0x34c    ld a5,0(s1)
    0x840138ec    0x34e    srli a5,a5,0x3b
    0x840138ee    0x350    beqz a5,ffffffff840139e4 <decodeCNodeInvocation+0x446>
    0x840138f2    0x354    ld a5,0(s5) # 2000 <KERNEL_OFFSET-0xfffffffeffffe000>
    0x840138f6    0x358    srli a5,a5,0x3b
    0x840138f8    0x35a    beqz a5,ffffffff84013a10 <decodeCNodeInvocation+0x472>
    0x840138fc    0x35e    ld a2,0(s1)
    0x840138fe    0x360    ld a3,8(s1)
    0x84013900    0x362    mv a1,s8
    0x84013902    0x364    li a0,1
    0x84013904    0x366    jal ra,ffffffff8401224e <updateCapData>
    0x84013908    0x36a    mv s0,a0
    0x8401390a    0x36c    sd a0,72(sp)          ; stack access
    0x8401390c    0x36e    sd a1,80(sp)          ; stack access
    0x8401390e    0x370    ld a2,0(s5)
    0x84013912    0x374    ld a3,8(s5)
    0x84013916    0x378    mv a1,s7
    0x84013918    0x37a    li a0,1
    0x8401391a    0x37c    jal ra,ffffffff8401224e <updateCapData>
    0x8401391e    0x380    sd a0,88(sp)          ; stack access
    0x84013920    0x382    sd a1,96(sp)          ; stack access
    0x84013922    0x384    srli s0,s0,0x3b
    0x84013924    0x386    beqz s0,ffffffff84013a3a <decodeCNodeInvocation+0x49c>
    0x84013928    0x38a    ld a5,88(sp)          ; stack access
    0x8401392a    0x38c    srli a5,a5,0x3b
    0x8401392c    0x38e    bnez a5,ffffffff84013a48 <decodeCNodeInvocation+0x4aa>
    0x84013930    0x392    li a5,3
    0x84013932    0x394    auipc a4,0x5
    0x84013936    0x398    sd a5,-610(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x8401393a    0x39c    li s0,3
    0x8401393c    0x39e    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x8401393e    0x3a0    li a1,2
    0x84013940    0x3a2    auipc a0,0x17
    0x84013944    0x3a6    ld a0,-264(a0) # ffffffff8402a838 <ksCurThread>
    0x84013948    0x3aa    jal ra,ffffffff8401263a <setThreadState>
    0x8401394c    0x3ae    mv a0,s4
    0x8401394e    0x3b0    jal ra,ffffffff8401350c <cteRevoke>
    0x84013952    0x3b4    mv s0,a0
    0x84013954    0x3b6    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x84013956    0x3b8    li a1,2
    0x84013958    0x3ba    auipc a0,0x17
    0x8401395c    0x3be    ld a0,-288(a0) # ffffffff8402a838 <ksCurThread>
    0x84013960    0x3c2    jal ra,ffffffff8401263a <setThreadState>
    0x84013964    0x3c6    mv a0,s4
    0x84013966    0x3c8    jal ra,ffffffff840134fc <invokeCNodeDelete>
    0x8401396a    0x3cc    mv s0,a0
    0x8401396c    0x3ce    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x8401396e    0x3d0    mv a0,a1
    0x84013970    0x3d2    jal ra,ffffffff84011a10 <ensureEmptySlot>
    0x84013974    0x3d6    mv s0,a0
    0x84013976    0x3d8    bnez a0,ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x8401397a    0x3dc    li a1,2
    0x8401397c    0x3de    auipc a0,0x17
    0x84013980    0x3e2    ld a0,-324(a0) # ffffffff8402a838 <ksCurThread>
    0x84013984    0x3e6    jal ra,ffffffff8401263a <setThreadState>
    0x84013988    0x3ea    mv a0,s4
    0x8401398a    0x3ec    jal ra,ffffffff8401185e <invokeCNodeSaveCaller>
    0x8401398e    0x3f0    mv s0,a0
    0x84013990    0x3f2    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x84013992    0x3f4    ld a0,0(a1)
    0x84013994    0x3f6    sd a0,88(sp)          ; stack access
    0x84013996    0x3f8    ld a1,8(a1)
    0x84013998    0x3fa    sd a1,96(sp)          ; stack access
    0x8401399a    0x3fc    jal ra,ffffffff84011cac <hasCancelSendRights>
    0x8401399e    0x400    bnez a0,ffffffff840139ae <decodeCNodeInvocation+0x410>
    0x840139a0    0x402    li a5,3
    0x840139a2    0x404    auipc a4,0x5
    0x840139a6    0x408    sd a5,-722(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840139aa    0x40c    li s0,3
    0x840139ac    0x40e    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x840139ae    0x410    li a1,2
    0x840139b0    0x412    auipc a0,0x17
    0x840139b4    0x416    ld a0,-376(a0) # ffffffff8402a838 <ksCurThread>
    0x840139b8    0x41a    jal ra,ffffffff8401263a <setThreadState>
    0x840139bc    0x41e    ld a0,88(sp)          ; stack access
    0x840139be    0x420    ld a1,96(sp)          ; stack access
    0x840139c0    0x422    jal ra,ffffffff84012fd4 <invokeCNodeCancelBadgedSends>
    0x840139c4    0x426    mv s0,a0
    0x840139c6    0x428    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x840139c8    0x42a    li a5,7
    0x840139ca    0x42c    auipc a4,0x5
    0x840139ce    0x430    sd a5,-762(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840139d2    0x434    li s0,3
    0x840139d4    0x436    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x840139d6    0x438    li a5,3
    0x840139d8    0x43a    auipc a4,0x5
    0x840139dc    0x43e    sd a5,-776(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x840139e0    0x442    li s0,3
    0x840139e2    0x444    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x840139e4    0x446    auipc a4,0x4
    0x840139e8    0x44a    addi a4,a4,1564 # ffffffff84018000 <riscvKSASIDTable>
    0x840139ec    0x44e    li a5,6
    0x840139ee    0x450    sd a5,1744(a4)
    0x840139f2    0x454    li a5,1
    0x840139f4    0x456    sd a5,1736(a4)
    0x840139f8    0x45a    slli a5,s2,0x2
    0x840139fc    0x45e    andi a5,a5,508
    0x84013a00    0x462    ori a5,a5,1
    0x84013a04    0x466    sd a5,1024(a4)
    0x84013a08    0x46a    sd zero,1032(a4)
    0x84013a0c    0x46e    li s0,3
    0x84013a0e    0x470    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x84013a10    0x472    auipc a4,0x4
    0x84013a14    0x476    addi a4,a4,1520 # ffffffff84018000 <riscvKSASIDTable>
    0x84013a18    0x47a    li a5,6
    0x84013a1a    0x47c    sd a5,1744(a4)
    0x84013a1e    0x480    sd zero,1736(a4)
    0x84013a22    0x484    slli a5,s3,0x2
    0x84013a26    0x488    andi a5,a5,508
    0x84013a2a    0x48c    ori a5,a5,1
    0x84013a2e    0x490    sd a5,1024(a4)
    0x84013a32    0x494    sd zero,1032(a4)
    0x84013a36    0x498    li s0,3
    0x84013a38    0x49a    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x84013a3a    0x49c    li a5,3
    0x84013a3c    0x49e    auipc a4,0x5
    0x84013a40    0x4a2    sd a5,-876(a4) # ffffffff840186d0 <current_syscall_error+0x30>
    0x84013a44    0x4a6    li s0,3
    0x84013a46    0x4a8    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x84013a48    0x4aa    li a1,2
    0x84013a4a    0x4ac    auipc a0,0x17
    0x84013a4e    0x4b0    ld a0,-530(a0) # ffffffff8402a838 <ksCurThread>
    0x84013a52    0x4b4    jal ra,ffffffff8401263a <setThreadState>
    0x84013a56    0x4b8    mv a6,s4
    0x84013a58    0x4ba    mv a5,s5
    0x84013a5a    0x4bc    mv a4,s1
    0x84013a5c    0x4be    ld a2,88(sp)          ; stack access
    0x84013a5e    0x4c0    ld a3,96(sp)          ; stack access
    0x84013a60    0x4c2    ld a0,72(sp)          ; stack access
    0x84013a62    0x4c4    ld a1,80(sp)          ; stack access
    0x84013a64    0x4c6    jal ra,ffffffff8401192e <invokeCNodeRotate>
    0x84013a68    0x4ca    mv s0,a0
    0x84013a6a    0x4cc    j ffffffff8401369a <decodeCNodeInvocation+0xfc>
    0x84013a6c    0x4ce    li a1,2
    0x84013a6e    0x4d0    auipc a0,0x17
    0x84013a72    0x4d4    ld a0,-566(a0) # ffffffff8402a838 <ksCurThread>
    0x84013a76    0x4d8    jal ra,ffffffff8401263a <setThreadState>
    0x84013a7a    0x4dc    j ffffffff840137be <decodeCNodeInvocation+0x220>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
459 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeCNodeInvocation` has 723 nodes.

Section init_kernel (271 of 271)
================================

Deriving specifications
-----------------------

Section `init_kernel` consists of 222 instructions.

RVC_FTTFT____FFFT_FT.
Skipping 10579073 csrw stvec,a5

RVC_FTTFFT___FFT__FT.
Skipping 1007b073 csrc sstatus,a5

RVC_FFFFFFFFFFF___FFdfn'UnknownInstruction (s with c_Skip := s.c_Skip(|s.procID |-> 2w|))

Skipping 0000 unimp

RVC_FFFFFFFFFFF___FFdfn'UnknownInstruction (s with c_Skip := s.c_Skip(|s.procID |-> 2w|))

Skipping 0000 unimp


Stack analysis
---------------

78 stack accesses found. Annotated code for `init_kernel`:

    0x840012c6      0x0    addi sp,sp,-256
    0x840012c8      0x2    sd ra,248(sp)         ; stack access
    0x840012ca      0x4    sd s0,240(sp)         ; stack access
    0x840012cc      0x6    sd s1,232(sp)         ; stack access
    0x840012ce      0x8    sd s2,224(sp)         ; stack access
    0x840012d0      0xa    sd s3,216(sp)         ; stack access
    0x840012d2      0xc    sd s4,208(sp)         ; stack access
    0x840012d4      0xe    sd s5,200(sp)         ; stack access
    0x840012d6     0x10    sd s6,192(sp)         ; stack access
    0x840012d8     0x12    sd s7,184(sp)         ; stack access
    0x840012da     0x14    mv s7,a3
    0x840012dc     0x16    li s0,-1
    0x840012de     0x18    slli s0,s0,0x26
    0x840012e0     0x1a    add s1,a0,s0
    0x840012e4     0x1e    add s0,s0,a1
    0x840012e6     0x20    sd s1,88(sp)          ; stack access
    0x840012e8     0x22    sd s0,96(sp)          ; stack access
    0x840012ea     0x24    slli s6,a2,0x20
    0x840012ee     0x28    srli s6,s6,0x20
    0x840012f2     0x2c    sub s3,a0,s6
    0x840012f6     0x30    sub s4,a1,s6
    0x840012fa     0x34    lui s5,0x2
    0x840012fc     0x36    add s5,s5,s4
    0x840012fe     0x38    jal ra,ffffffff84000474 <map_kernel_window>
    0x84001302     0x3c    jal ra,ffffffff84000138 <activate_kernel_vspace>
    0x84001306     0x40    auipc a5,0xf
    0x8400130a     0x44    addi a5,a5,-774 # ffffffff84010000 <ki_boot_end>
    0x8400130e     0x48    csrw stvec,a5
    0x84001312     0x4c    jal ra,ffffffff840002ca <initLocalIRQController>
    0x84001316     0x50    jal ra,ffffffff840002b4 <initTimer>
    0x8400131a     0x54    lui a5,0x6
    0x8400131c     0x56    csrc sstatus,a5
    0x84001320     0x5a    jal ra,ffffffff8400030e <initIRQController>
    0x84001324     0x5e    sd s3,152(sp)         ; stack access
    0x84001326     0x60    sd s5,160(sp)         ; stack access
    0x84001328     0x62    auipc a5,0x0
    0x8400132c     0x66    addi a5,a5,512 # ffffffff84001528 <ndks_boot>
    0x84001330     0x6a    lui a4,0xff021
    0x84001334     0x6e    slli a4,a4,0xe
    0x84001336     0x70    sd a4,952(a5)
    0x8400133a     0x74    auipc a4,0x2e
    0x8400133e     0x78    addi a4,a4,-826 # ffffffff8402f000 <ki_end>
    0x84001342     0x7c    li a3,-63
    0x84001346     0x80    slli a3,a3,0x20
    0x84001348     0x82    add a4,a4,a3
    0x8400134a     0x84    sd a4,960(a5)
    0x8400134e     0x88    sd s1,968(a5)
    0x84001352     0x8c    sd s0,976(a5)
    0x84001356     0x90    li a6,0
    0x84001358     0x92    mv a4,s3
    0x8400135a     0x94    mv a5,s5
    0x8400135c     0x96    auipc a3,0x0
    0x84001360     0x9a    addi a3,a3,1412 # ffffffff840018e0 <res_reg>
    0x84001364     0x9e    li a2,2
    0x84001366     0xa0    auipc a1,0x0
    0x8400136a     0xa4    addi a1,a1,434 # ffffffff84001518 <avail_p_regs>
    0x8400136e     0xa8    li a0,1
    0x84001370     0xaa    jal ra,ffffffff84000f66 <init_freemem>
    0x84001374     0xae    jal ra,ffffffff840005a2 <create_root_cnode>
    0x84001378     0xb2    sd a0,24(sp)          ; stack access
    0x8400137a     0xb4    sd a1,32(sp)          ; stack access
    0x8400137c     0xb6    srli a0,a0,0x3b
    0x8400137e     0xb8    bnez a0,ffffffff84001384 <init_kernel+0xbe>
    0x84001380     0xba    jal ra,ffffffff8401041e <halt>
    0x84001384     0xbe    ld a0,24(sp)          ; stack access
    0x84001386     0xc0    jal ra,ffffffff840005de <create_domain_cap>
    0x8400138a     0xc4    ld a5,24(sp)          ; stack access
    0x8400138c     0xc6    sd a5,152(sp)         ; stack access
    0x8400138e     0xc8    ld a5,32(sp)          ; stack access
    0x84001390     0xca    sd a5,160(sp)         ; stack access
    0x84001392     0xcc    li s1,1
    0x84001394     0xce    li s0,0
    0x84001396     0xd0    li s2,54
    0x8400139a     0xd4    j ffffffff840013a0 <init_kernel+0xda>
    0x8400139c     0xd6    addi s0,s0,1
    0x8400139e     0xd8    addi s1,s1,1
    0x840013a0     0xda    beqz s0,ffffffff8400139c <init_kernel+0xd6>
    0x840013a2     0xdc    mv a1,s0
    0x840013a4     0xde    li a0,0
    0x840013a6     0xe0    jal ra,ffffffff84011ac2 <setIRQState>
    0x840013aa     0xe4    bgeu s2,s1,ffffffff8400139c <init_kernel+0xd6>
    0x840013ae     0xe8    li a1,54
    0x840013b2     0xec    li a0,2
    0x840013b4     0xee    jal ra,ffffffff84011ac2 <setIRQState>
    0x840013b8     0xf2    ld a0,152(sp)         ; stack access
    0x840013ba     0xf4    ld a1,160(sp)         ; stack access
    0x840013bc     0xf6    jal ra,ffffffff840101c8 <cap_get_capPtr>
    0x840013c0     0xfa    li a5,7
    0x840013c2     0xfc    slli a5,a5,0x3c
    0x840013c4     0xfe    sd a5,128(a0)
    0x840013c6    0x100    sd zero,136(a0)
    0x840013ca    0x104    sd zero,144(a0)
    0x840013ce    0x108    li a5,3
    0x840013d0    0x10a    sd a5,152(a0)
    0x840013d2    0x10c    li a3,0
    0x840013d4    0x10e    mv a2,s4
    0x840013d6    0x110    li a1,1
    0x840013d8    0x112    li a0,0
    0x840013da    0x114    jal ra,ffffffff84000d82 <populate_bi_frame>
    0x840013de    0x118    mv a2,s3
    0x840013e0    0x11a    mv a3,s5
    0x840013e2    0x11c    ld a0,24(sp)          ; stack access
    0x840013e4    0x11e    ld a1,32(sp)          ; stack access
    0x840013e6    0x120    jal ra,ffffffff840006e2 <create_it_address_space>
    0x840013ea    0x124    sd a0,40(sp)          ; stack access
    0x840013ec    0x126    sd a1,48(sp)          ; stack access
    0x840013ee    0x128    srli a0,a0,0x3b
    0x840013f0    0x12a    beqz a0,ffffffff84001380 <init_kernel+0xba>
    0x840013f2    0x12c    lui s0,0x1
    0x840013f4    0x12e    add s0,s0,s4
    0x840013f6    0x130    mv a4,s0
    0x840013f8    0x132    ld a2,40(sp)          ; stack access
    0x840013fa    0x134    mv a3,a1
    0x840013fc    0x136    ld a0,24(sp)          ; stack access
    0x840013fe    0x138    ld a1,32(sp)          ; stack access
    0x84001400    0x13a    jal ra,ffffffff84000602 <create_bi_frame_cap>
    0x84001404    0x13e    mv a4,s4
    0x84001406    0x140    ld a2,40(sp)          ; stack access
    0x84001408    0x142    ld a3,48(sp)          ; stack access
    0x8400140a    0x144    ld a0,24(sp)          ; stack access
    0x8400140c    0x146    ld a1,32(sp)          ; stack access
    0x8400140e    0x148    jal ra,ffffffff84000d1e <create_ipcbuf_frame_cap>
    0x84001412    0x14c    sd a0,72(sp)          ; stack access
    0x84001414    0x14e    sd a1,80(sp)          ; stack access
    0x84001416    0x150    srli a0,a0,0x3b
    0x84001418    0x152    beqz a0,ffffffff84001380 <init_kernel+0xba>
    0x8400141a    0x154    sd s6,0(sp)           ; stack access
    0x8400141c    0x156    li a7,1
    0x8400141e    0x158    ld a5,88(sp)          ; stack access
    0x84001420    0x15a    ld a6,96(sp)          ; stack access
    0x84001422    0x15c    ld a3,40(sp)          ; stack access
    0x84001424    0x15e    ld a4,48(sp)          ; stack access
    0x84001426    0x160    ld a1,24(sp)          ; stack access
    0x84001428    0x162    ld a2,32(sp)          ; stack access
    0x8400142a    0x164    addi a0,sp,152
    0x8400142c    0x166    jal ra,ffffffff8400082a <create_frames_of_region>
    0x84001430    0x16a    ld a5,168(sp)         ; stack access
    0x84001432    0x16c    beqz a5,ffffffff84001380 <init_kernel+0xba>
    0x84001434    0x16e    auipc a5,0x0
    0x84001438    0x172    ld a5,828(a5) # ffffffff84001770 <ndks_boot+0x248>
    0x8400143c    0x176    ld a4,152(sp)         ; stack access
    0x8400143e    0x178    sd a4,72(a5)
    0x84001440    0x17a    ld a4,160(sp)         ; stack access
    0x84001442    0x17c    sd a4,80(a5)
    0x84001444    0x17e    ld a0,24(sp)          ; stack access
    0x84001446    0x180    ld a1,32(sp)          ; stack access
    0x84001448    0x182    jal ra,ffffffff840008f8 <create_it_asid_pool>
    0x8400144c    0x186    sd a0,56(sp)          ; stack access
    0x8400144e    0x188    sd a1,64(sp)          ; stack access
    0x84001450    0x18a    srli a0,a0,0x3b
    0x84001452    0x18c    beqz a0,ffffffff84001380 <init_kernel+0xba>
    0x84001454    0x18e    ld a2,40(sp)          ; stack access
    0x84001456    0x190    ld a3,48(sp)          ; stack access
    0x84001458    0x192    ld a0,56(sp)          ; stack access
    0x8400145a    0x194    jal ra,ffffffff8400015e <write_it_asid_pool>
    0x8400145e    0x198    jal ra,ffffffff84000cfe <create_idle_thread>
    0x84001462    0x19c    beqz a0,ffffffff84001380 <init_kernel+0xba>
    0x84001466    0x1a0    ld a5,80(sp)          ; stack access
    0x84001468    0x1a2    sd a5,0(sp)           ; stack access
    0x8400146a    0x1a4    ld a7,72(sp)          ; stack access
    0x8400146c    0x1a6    mv a6,s4
    0x8400146e    0x1a8    mv a5,s0
    0x84001470    0x1aa    mv a4,s7
    0x84001472    0x1ac    ld a2,40(sp)          ; stack access
    0x84001474    0x1ae    ld a3,48(sp)          ; stack access
    0x84001476    0x1b0    ld a0,24(sp)          ; stack access
    0x84001478    0x1b2    ld a1,32(sp)          ; stack access
    0x8400147a    0x1b4    jal ra,ffffffff84000b9e <create_initial_thread>
    0x8400147e    0x1b8    beqz a0,ffffffff84001380 <init_kernel+0xba>
    0x84001482    0x1bc    jal ra,ffffffff8400095a <init_core_state>
    0x84001486    0x1c0    ld a0,24(sp)          ; stack access
    0x84001488    0x1c2    sd a0,120(sp)         ; stack access
    0x8400148a    0x1c4    ld a1,32(sp)          ; stack access
    0x8400148c    0x1c6    sd a1,128(sp)         ; stack access
    0x8400148e    0x1c8    lui a5,0xff021
    0x84001492    0x1cc    slli a5,a5,0xe
    0x84001494    0x1ce    sd a5,136(sp)         ; stack access
    0x84001496    0x1d0    auipc a5,0xf
    0x8400149a    0x1d4    addi a5,a5,-1174 # ffffffff84010000 <ki_boot_end>
    0x8400149e    0x1d8    li a4,-63
    0x840014a2    0x1dc    slli a4,a4,0x20
    0x840014a4    0x1de    add a5,a5,a4
    0x840014a6    0x1e0    sd a5,144(sp)         ; stack access
    0x840014a8    0x1e2    auipc s1,0x0
    0x840014ac    0x1e6    addi s1,s1,128 # ffffffff84001528 <ndks_boot>
    0x840014b0    0x1ea    ld s0,592(s1)
    0x840014b4    0x1ee    mv a2,s0
    0x840014b6    0x1f0    jal ra,ffffffff84000a84 <create_device_untypeds>
    0x840014ba    0x1f4    mv a4,s0
    0x840014bc    0x1f6    ld a2,136(sp)         ; stack access
    0x840014be    0x1f8    ld a3,144(sp)         ; stack access
    0x840014c0    0x1fa    ld a0,120(sp)         ; stack access
    0x840014c2    0x1fc    ld a1,128(sp)         ; stack access
    0x840014c4    0x1fe    jal ra,ffffffff84000b26 <create_kernel_untypeds>
    0x840014c8    0x202    ld a4,592(s1)
    0x840014cc    0x206    ld a5,584(s1)
    0x840014d0    0x20a    sd s0,152(a5)
    0x840014d2    0x20c    sd a4,160(a5)
    0x840014d4    0x20e    beqz a0,ffffffff84001380 <init_kernel+0xba>
    0x840014d8    0x212    auipc a5,0x0
    0x840014dc    0x216    ld a5,664(a5) # ffffffff84001770 <ndks_boot+0x248>
    0x840014e0    0x21a    sd zero,56(a5)
    0x840014e4    0x21e    sd zero,64(a5)
    0x840014e8    0x222    jal ra,ffffffff84000b84 <bi_finalise>
    0x840014ec    0x226    li a5,1
    0x840014ee    0x228    auipc a4,0x29
    0x840014f2    0x22c    sd a5,850(a4) # ffffffff8402a840 <ksNumCPUs>
    0x840014f6    0x230    jal ra,ffffffff84012cf4 <schedule>
    0x840014fa    0x234    jal ra,ffffffff84012744 <activateThread>
    0x840014fe    0x238    ld ra,248(sp)         ; stack access
    0x84001500    0x23a    ld s0,240(sp)         ; stack access
    0x84001502    0x23c    ld s1,232(sp)         ; stack access
    0x84001504    0x23e    ld s2,224(sp)         ; stack access
    0x84001506    0x240    ld s3,216(sp)         ; stack access
    0x84001508    0x242    ld s4,208(sp)         ; stack access
    0x8400150a    0x244    ld s5,200(sp)         ; stack access
    0x8400150c    0x246    ld s6,192(sp)         ; stack access
    0x8400150e    0x248    ld s7,184(sp)         ; stack access
    0x84001510    0x24a    addi sp,sp,256
    0x84001512    0x24c    ret
    0x84001514    0x24e    unimp
    0x84001516    0x250    unimp

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
222 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `init_kernel` has 372 nodes.

Completing graph
-----------------

Evaluating graph
----------------

The graph for `instruction'csrrc_a5_sie_a5_84011AE2` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrrs_a5_sie_a5_84011AEC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrr_a0_sip_840116AA` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_84010DF4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_84010DDE` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ecall_84010426` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sscratch_t0_84010406` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sstatus_t1_8401040E` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sepc_t1_84010402` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sret_8401041A` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrr_a0_sip_840101A4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'wfi_8401011A` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrrs_a5_sie_a5_84000308` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ecall_840002C2` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'rdtime_a0_840002B4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_satp_a5_84000154` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_84000158` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_zero_a0_84010D30` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_satp_a5_84010C9A` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_satp_a5_84010C0C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_satp_a5_84010C6A` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_84010C10` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_84010C9E` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_84010C6E` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_84010B4E` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrr_a4_stval_84010A2C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sscratch_zero_84000014` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'fence_i_84000000` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sscratch_t0_8401736C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sstatus_t1_84017374` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_satp_s6_840172D8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sepc_t1_84017368` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sret_84017380` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_840172DC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sscratch_t0_84017026` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sstatus_t1_8401702E` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_satp_a5_84016F90` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_sepc_t1_84017022` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sret_8401703A` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_84016F94` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrr_s0_scause_8401008C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrr_ra_sscratch_8401007C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrr_ra_sstatus_84010084` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrr_ra_sepc_840100A0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrrw_t0_sscratch_t0_84010000` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_84000256` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_840001EA` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrr_a0_scause_840145DC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrrc_a5_sie_a5_84013DF0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ecall_84013DD6` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'rdtime_a5_84013DC6` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'rdtime_a4_84013DDA` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_84010BD8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_84015D6A` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'sfence_vma_840160F8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrw_stvec_a5_8400130E` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'csrc_sstatus_a5_8400131C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'unimp_84001514` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'unimp_84001516` has 0 nodes.

Proving correctness of call offsets
===================================

Offsets proved correct.

Summary
=======

No stack intro failures.
No graph spec failures.
No export failures.
No call offset failures.
> 